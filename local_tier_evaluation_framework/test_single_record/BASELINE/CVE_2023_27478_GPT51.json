[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "memcached_purge",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/purge.cc",
      "52-131"
    ],
    "function_name": "memcached_purge",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"libmemcached/common.h\"\n\nbool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: memcached_result_free\nvoid memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}\n\nCallee: memcached_read_one_response\nmemcached_return_t memcached_read_one_response(memcached_instance_st *instance,\n                                               memcached_result_st *result) {\n  char buffer[SMALL_STRING_LEN];\n\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  return _read_one_response(instance, buffer, sizeof(buffer), result);\n}\n\nCallee: memcached_result_reset\nvoid memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}\n\nCallee: memcached_server_response_count\nuint32_t memcached_server_response_count(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->cursor_active_;\n}\n\nCallee: memcached_set_error\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}\n\nCallee: memcached_io_reset\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}\n\nCallee: memcached_io_write\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}\n",
    "Vulnerable": false,
    "Description": "The memcached_purge function does not itself expose or return any sensitive information. It only returns a boolean success flag and internally processes server responses using memcached_read_one_response and callbacks. Errors are handled via memcached_set_error, but any potential details are stored in internal structures, not emitted to external callers by this function. There is no direct logging or output of internal data, file paths, memory contents, or detailed error messages to an untrusted sink. Therefore, based solely on the provided code, it does not implement a CWE-200 information exposure vulnerability."
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "_read_one_response",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
      "745-769"
    ],
    "function_name": "_read_one_response",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: memcached_io_reset\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}\n\nCallee: textual_read_one_response\nstatic memcached_return_t textual_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                    const size_t buffer_length,\n                                                    memcached_result_st *result) {\n  size_t total_read;\n  memcached_return_t rc = memcached_io_readline(instance, buffer, buffer_length, total_read);\n\n  if (memcached_failed(rc)) {\n    return rc;\n  }\n  assert(total_read);\n\n  switch (buffer[0]) {\n  case 'V': {\n    // VALUE\n    if (buffer[1] == 'A' and buffer[2] == 'L' and buffer[3] == 'U' and buffer[4] == 'E') /* VALUE */\n    {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return textual_value_fetch(instance, buffer, result);\n    }\n    // VERSION\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'S' and buffer[4] == 'I'\n             and buffer[5] == 'O' and buffer[6] == 'N') /* VERSION */\n    {\n      /* Find the space, and then move one past it to copy version */\n      char *response_ptr = strchr(buffer, ' ');\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(response_ptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'O': {\n    // OK\n    if (buffer[1] == 'K') {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'S': {\n    // STAT\n    if (buffer[1] == 'T' and buffer[2] == 'A' and buffer[3] == 'T') /* STORED STATS */ {\n      memcached_server_response_increment(instance);\n      return MEMCACHED_STAT;\n    }\n    // SERVER_ERROR\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'V' and buffer[4] == 'E'\n             and buffer[5] == 'R' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n             and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      if (total_read == memcached_literal_param_size(\"SERVER_ERROR\")) {\n        return MEMCACHED_SERVER_ERROR;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR object too large for cache\")\n          and (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR object too large for cache\"))\n               == 0))\n      {\n        return MEMCACHED_E2BIG;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR out of memory\")\n          and ((memcmp(buffer, memcached_literal_param(\"SERVER_ERROR out of memory\")) == 0)\n               or (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR Out of memory\")) == 0)))\n      {\n        return MEMCACHED_SERVER_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"SERVER_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_SERVER_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n    // STORED\n    else if (buffer[1] == 'T' and buffer[2] == 'O'\n             and buffer[3] == 'R') //  and buffer[4] == 'E' and buffer[5] == 'D')\n    {\n      return MEMCACHED_STORED;\n    }\n  } break;\n\n  case 'D': {\n    // DELETED\n    if (buffer[1] == 'E' and buffer[2] == 'L' and buffer[3] == 'E' and buffer[4] == 'T'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_DELETED;\n    }\n  } break;\n\n  case 'N': {\n    // NOT_FOUND\n    if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'F'\n        and buffer[5] == 'O' and buffer[6] == 'U' and buffer[7] == 'N' and buffer[8] == 'D')\n    {\n      return MEMCACHED_NOTFOUND;\n    }\n    // NOT_STORED\n    else if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'S'\n             and buffer[5] == 'T' and buffer[6] == 'O' and buffer[7] == 'R' and buffer[8] == 'E'\n             and buffer[9] == 'D')\n    {\n      return MEMCACHED_NOTSTORED;\n    }\n  } break;\n\n  case 'E': /* PROTOCOL ERROR or END */\n  {\n    // END\n    if (buffer[1] == 'N' and buffer[2] == 'D') {\n      return MEMCACHED_END;\n    }\n#if 0\n      // PROTOCOL_ERROR\n      else if (buffer[1] == 'R' and buffer[2] == 'O' and buffer[3] == 'T' and buffer[4] == 'O' and buffer[5] == 'C' and buffer[6] == 'O' and buffer[7] == 'L'\n               and buffer[8] == '_'\n               and buffer[9] == 'E' and buffer[10] == 'R' and buffer[11] == 'R' and buffer[12] == 'O' and buffer[13] == 'R')\n      {\n        return MEMCACHED_PROTOCOL_ERROR;\n      }\n#endif\n    // ERROR\n    else if (buffer[1] == 'R' and buffer[2] == 'R' and buffer[3] == 'O' and buffer[4] == 'R')\n    {\n      return MEMCACHED_ERROR;\n    }\n    // EXISTS\n    else if (buffer[1] == 'X' and buffer[2] == 'I' and buffer[3] == 'S' and buffer[4] == 'T'\n             and buffer[5] == 'S')\n    {\n      return MEMCACHED_DATA_EXISTS;\n    }\n  } break;\n\n  case 'T': /* TOUCHED */\n  {\n    // TOUCHED\n    if (buffer[1] == 'O' and buffer[2] == 'U' and buffer[3] == 'C' and buffer[4] == 'H'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'I': /* ITEM */\n  {\n    // ITEM\n    if (buffer[1] == 'T' and buffer[2] == 'E' and buffer[3] == 'M') {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return MEMCACHED_ITEM;\n    }\n  } break;\n\n  case 'C': /* CLIENT ERROR */\n  {\n    // CLIENT_ERROR\n    if (buffer[1] == 'L' and buffer[2] == 'I' and buffer[3] == 'E' and buffer[4] == 'N'\n        and buffer[5] == 'T' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n        and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"CLIENT_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_CLIENT_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n  } break;\n\n  case '0': /* INCR/DECR response */\n  case '1': /* INCR/DECR response */\n  case '2': /* INCR/DECR response */\n  case '3': /* INCR/DECR response */\n  case '4': /* INCR/DECR response */\n  case '5': /* INCR/DECR response */\n  case '6': /* INCR/DECR response */\n  case '7': /* INCR/DECR response */\n  case '8': /* INCR/DECR response */\n  case '9': /* INCR/DECR response */\n  {\n    errno = 0;\n    unsigned long long int auto_return_value = strtoull(buffer, (char **) NULL, 10);\n\n    if (auto_return_value == ULLONG_MAX and errno == ERANGE) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno == EINVAL) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    }\n\n    result->numeric_value = uint64_t(auto_return_value);\n\n    WATCHPOINT_STRING(buffer);\n    return MEMCACHED_SUCCESS;\n  }\n\n  default:\n    break;\n  }\n\n  buffer[total_read] = 0;\n#if 0\n  if (total_read >= sizeof(\"STORSTORED\") -1)\n  {\n    fprintf(stderr, \"%s:%d '%s', %.*s\\n\", __FILE__, __LINE__,\n            buffer, MEMCACHED_MAX_BUFFER, instance->read_buffer);\n    assert(memcmp(buffer,\"STORSTORED\", sizeof(\"STORSTORED\") -1));\n  }\n#endif\n  return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT, buffer,\n                             total_read);\n}\n\nCallee: binary_read_one_response\nstatic memcached_return_t binary_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                   const size_t buffer_length,\n                                                   memcached_result_st *result) {\n  memcached_return_t rc;\n  protocol_binary_response_header header;\n\n  assert(memcached_is_binary(instance->root));\n\n  if ((rc = memcached_safe_read(instance, &header.bytes, sizeof(header.bytes)))\n      != MEMCACHED_SUCCESS) {\n    WATCHPOINT_ERROR(rc);\n    return rc;\n  }\n\n  if (header.response.magic != PROTOCOL_BINARY_RES) {\n    return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n  }\n\n  /*\n   ** Convert the header to host local endian!\n   */\n  header.response.keylen = ntohs(header.response.keylen);\n  header.response.status = ntohs(header.response.status);\n  header.response.bodylen = ntohl(header.response.bodylen);\n  header.response.cas = memcached_ntohll(header.response.cas);\n  uint32_t bodylen = header.response.bodylen;\n\n  if (header.response.status == PROTOCOL_BINARY_RESPONSE_SUCCESS\n      or header.response.status == PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE)\n  {\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      /*\n       * We didn't increment the response counter for the GETKQ packet\n       * (only the final NOOP), so we need to increment the counter again.\n       */\n      memcached_server_response_increment(instance);\n      /* fall through */\n    case PROTOCOL_BINARY_CMD_GETK: {\n      uint16_t keylen = header.response.keylen;\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if ((rc = memcached_safe_read(instance, &result->item_flags, sizeof(result->item_flags)))\n          != MEMCACHED_SUCCESS)\n      {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->item_flags = ntohl(result->item_flags);\n      bodylen -= header.response.extlen;\n\n      result->key_length = keylen;\n      if (memcached_failed(rc = memcached_safe_read(instance, result->item_key, keylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      // Only bother with doing this if key_length > 0\n      if (result->key_length) {\n        if (memcached_array_size(instance->root->_namespace)\n            and memcached_array_size(instance->root->_namespace) >= result->key_length)\n        {\n          return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n        }\n\n        if (memcached_array_size(instance->root->_namespace)) {\n          result->key_length -= memcached_array_size(instance->root->_namespace);\n          memmove(result->item_key,\n                  result->item_key + memcached_array_size(instance->root->_namespace),\n                  result->key_length);\n        }\n      }\n\n      bodylen -= keylen;\n      if (memcached_failed(memcached_string_check(&result->value, bodylen))) {\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if (memcached_failed(rc = memcached_safe_read(instance, vptr, bodylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n    case PROTOCOL_BINARY_CMD_DECREMENT: {\n      if (bodylen != sizeof(uint64_t)) {\n        result->numeric_value = UINT64_MAX;\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n\n      uint64_t val;\n      if ((rc = memcached_safe_read(instance, &val, sizeof(val))) != MEMCACHED_SUCCESS) {\n        result->numeric_value = UINT64_MAX;\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->numeric_value = memcached_ntohll(val);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: {\n      if (header.response.keylen || bodylen + 1 > buffer_length) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        if ((rc = memcached_safe_read(instance, buffer, bodylen)) != MEMCACHED_SUCCESS) {\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_VERSION: {\n      char version_buffer[32]; // @todo document this number\n      memset(version_buffer, 0, sizeof(version_buffer));\n\n      if (memcached_safe_read(instance, version_buffer, bodylen) != MEMCACHED_SUCCESS) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(version_buffer, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_TOUCH: {\n      rc = MEMCACHED_SUCCESS;\n      if (bodylen == 4) // The four byte read is a bug?\n      {\n        char touch_buffer[4]; // @todo document this number\n        rc = memcached_safe_read(instance, touch_buffer, sizeof(touch_buffer));\n#if 0\n          fprintf(stderr, \"%s:%d %d %d %d %d %.*s(%d)\\n\", __FILE__, __LINE__,\n                  int(touch_buffer[0]),\n                  int(touch_buffer[1]),\n                  int(touch_buffer[2]),\n                  int(touch_buffer[3]),\n                  int(bodylen), touch_buffer, int(bodylen));\n#endif\n      }\n      return memcached_set_error(*instance, rc, MEMCACHED_AT);\n    }\n\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n    case PROTOCOL_BINARY_CMD_DELETE: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_SUCCESS;\n    }\n\n    case PROTOCOL_BINARY_CMD_NOOP: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_END;\n    }\n\n    case PROTOCOL_BINARY_CMD_STAT: {\n      if (bodylen == 0) {\n        return MEMCACHED_END;\n      } else if (bodylen + 1 > buffer_length) {\n        /* not enough space in buffer.. should not happen... */\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        size_t keylen = header.response.keylen;\n        memset(buffer, 0, buffer_length);\n        if ((rc = memcached_safe_read(instance, buffer, keylen)) != MEMCACHED_SUCCESS\n            || (rc = memcached_safe_read(instance, buffer + keylen + 1, bodylen - keylen))\n                != MEMCACHED_SUCCESS)\n        {\n          WATCHPOINT_ERROR(rc);\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n    case PROTOCOL_BINARY_CMD_SASL_STEP: {\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if (memcached_string_check(&result->value, bodylen) != MEMCACHED_SUCCESS)\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if ((rc = memcached_safe_read(instance, vptr, bodylen)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n    default: {\n      /* Command not implemented yet! */\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n    }\n    }\n  } else if (header.response.bodylen) {\n    /* What should I do with the error message??? just discard it for now */\n    char hole[SMALL_STRING_LEN];\n    while (bodylen > 0) {\n      size_t nr = (bodylen > SMALL_STRING_LEN) ? SMALL_STRING_LEN : bodylen;\n      if ((rc = memcached_safe_read(instance, hole, nr)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n      bodylen -= (uint32_t) nr;\n    }\n\n    /* This might be an error from one of the quiet commands.. if\n     * so, just throw it away and get the next one. What about creating\n     * a callback to the user with the error information?\n     */\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n      return MEMCACHED_FETCH_NOTFINISHED;\n\n    default:\n      break;\n    }\n  }\n\n  rc = MEMCACHED_SUCCESS;\n  if (header.response.status) {\n    switch (header.response.status) {\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n      rc = MEMCACHED_NOTFOUND;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n      rc = MEMCACHED_DATA_EXISTS;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n      rc = MEMCACHED_NOTSTORED;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n      rc = MEMCACHED_E2BIG;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE:\n      rc = MEMCACHED_AUTH_CONTINUE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n      rc = MEMCACHED_AUTH_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n    default:\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      break;\n    }\n  }\n\n  return rc;\n}\n",
    "Vulnerable": true,
    "Description": "The main function _read_one_response itself only routes responses and resets the connection on fatal errors, but its callees reveal the issue. Both textual_read_one_response and binary_read_one_response pass server-provided error strings and protocol responses directly into memcached_set_error and sometimes into user-visible result structures. For textual protocol, arbitrary text following SERVER_ERROR or CLIENT_ERROR is extracted from the server reply buffer and used as the error message; the default case also forwards the full unexpected line back via memcached_set_error. For binary protocol, unknown-read failures are signaled without including the raw body, but textual errors can still leak detailed internal messages from the memcached server (e.g., configuration, internal state, or debug info) to the client code. If client applications log or display these error strings to untrusted users, this becomes an information exposure (CWE-200). The code does not sanitize or restrict what part of the serverâ€™s message is exposed, so any sensitive details the server includes in error text will be propagated to higher layers."
  }
]