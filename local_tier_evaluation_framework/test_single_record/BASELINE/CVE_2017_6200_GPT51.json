[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "run",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6200/repo/src/sandstorm/backup.c++",
      "108-244"
    ],
    "function_name": "run",
    "contextual_snippet": "MAIN FUNCTION:\n#include <sys/capability.h>\n#include <sys/prctl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/syscall.h>\n#include <sys/mount.h>\n#include <sched.h>\n#include <kj/debug.h>\n#include \"version.h\"\n#include \"util.h\"\n#include \"backup.h\"\n\n#define PR_SET_NO_NEW_PRIVS 38\n\nBackupMain {\n  bool BackupMain::run(kj::StringPtr grainDir) {\n    // Enable no_new_privs so that once we drop privileges we can never regain them through e.g.\n    // execing a suid-root binary, as a backup measure. This is a backup measure in case someone\n    // finds an arbitrary code execution exploit in zip/unzip; it's not needed otherwise.\n    KJ_SYSCALL(prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0));\n  \n    // Create files / directories before we potentially change the UID, so that they are created\n    // with the right owner.\n    if (restore) {\n      KJ_SYSCALL(mkdir(kj::str(grainDir, \"/sandbox\").cStr(), 0770));\n    } else if (filename != \"-\") {\n      // Instead of binding into mount tree later, just open the file and we'll compress to stdout.\n      KJ_SYSCALL(dup2(raiiOpen(filename, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC), STDOUT_FILENO));\n    }\n  \n    if (sandboxUid == nullptr) {\n      uid_t uid = getuid();\n      gid_t gid = getgid();\n  \n      KJ_SYSCALL(unshare(CLONE_NEWUSER | CLONE_NEWNS |\n          // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n          // arbitrary code execution bugs in zip/unzip.\n          CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n      writeSetgroupsIfPresent(\"deny\\n\");\n      writeUserNSMap(\"uid\", kj::str(\"1000 \", uid, \" 1\\n\"));\n      writeUserNSMap(\"gid\", kj::str(\"1000 \", gid, \" 1\\n\"));\n    } else {\n      KJ_SYSCALL(seteuid(0));\n      KJ_SYSCALL(unshare(CLONE_NEWNS |\n          // Unshare other stuff; like no_new_privs, this is only to defend against hypothetical\n          // arbitrary code execution bugs in zip/unzip.\n          CLONE_NEWNET | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUTS));\n    }\n  \n    // To really unshare the mount namespace, we also have to make sure all mounts are private.\n    // The parameters here were derived by strace'ing `mount --make-rprivate /`.  AFAICT the flags\n    // are undocumented.  :(\n    KJ_SYSCALL(mount(\"none\", \"/\", nullptr, MS_REC | MS_PRIVATE, nullptr));\n  \n    // Mount root read-only.\n    bind(kj::str(root, \"/\"), \"/tmp\", MS_BIND | MS_NOSUID | MS_RDONLY);\n  \n    if (access(\"/tmp/dev/null\", F_OK) != 0) {\n      // Looks like we need to bind in /dev.\n      KJ_SYSCALL(mount(\"/dev\", \"/tmp/dev\", nullptr, MS_BIND, nullptr));\n    }\n  \n    // Hide sensitive directories.\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/proc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/var\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/etc\", \"tmpfs\", 0, \"size=32k,nr_inodes=8,mode=000\"));\n  \n    // Mount inner tmpfs.\n    KJ_SYSCALL(mount(\"tmpfs\", \"/tmp/tmp\", \"tmpfs\", 0, \"size=8m,nr_inodes=128,mode=777\"));\n  \n    // Bind in the grain's `data` (=`sandbox`).\n    KJ_SYSCALL(mkdir(\"/tmp/tmp/data\", 0777));\n    bind(kj::str(grainDir, \"/sandbox\"), \"/tmp/tmp/data\",\n         MS_NODEV | MS_NOSUID | MS_NOEXEC | (restore ? 0 : MS_RDONLY));\n  \n    // Bind in the grain's `log`. When restoring, we discard the log.\n    if (!restore) {\n      KJ_SYSCALL(mknod(\"/tmp/tmp/log\", S_IFREG | 0666, 0));\n      bind(kj::str(grainDir, \"/log\"), \"/tmp/tmp/log\", MS_RDONLY | MS_NOEXEC | MS_NOSUID | MS_NODEV);\n    }\n  \n    // Bind in the file.\n    if (restore) {\n      KJ_SYSCALL(mknod(\"/tmp/tmp/file.zip\", S_IFREG | 0666, 0));\n      KJ_SYSCALL(mount(filename.cStr(), \"/tmp/tmp/file.zip\", nullptr, MS_BIND, nullptr));\n    }\n  \n    // Use Andy's ridiculous pivot_root trick to place ourselves into the sandbox.\n    // See supervisor-main.c++ for more discussion.\n    {\n      auto oldRootDir = raiiOpen(\"/\", O_RDONLY | O_DIRECTORY | O_CLOEXEC);\n      KJ_SYSCALL(syscall(SYS_pivot_root, \"/tmp\", \"/tmp\"));\n      KJ_SYSCALL(fchdir(oldRootDir));\n      KJ_SYSCALL(umount2(\".\", MNT_DETACH));\n      KJ_SYSCALL(chdir(\"/tmp\"));\n    }\n  \n    KJ_IF_MAYBE(u, sandboxUid) {\n      KJ_SYSCALL(setresuid(*u, *u, *u));\n    }\n  \n    // TODO(security): We could seccomp this pretty tightly, but that would only be necessary to\n    //   defend against *both* zip/unzip *and* the Linux kernel having bugs at the same time. It's\n    //   fairly involved to set up, so maybe not worthwhile, unless we could factor the code out of\n    //   supervisor.c++...\n  \n    if (!restore) {\n      // Read stdin to metadata file.\n      kj::FdInputStream in(STDIN_FILENO);\n      kj::FdOutputStream out(raiiOpen(\"metadata\", O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC));\n      pump(in, out);\n    }\n  \n    {\n      // Drop crapabilities.\n      struct __user_cap_header_struct hdr;\n      struct __user_cap_data_struct data[2];\n      hdr.version = _LINUX_CAPABILITY_VERSION_3;\n      hdr.pid = 0;\n      memset(data, 0, sizeof(data));  // All capabilities disabled!\n      KJ_SYSCALL(capset(&hdr, data));\n      umask(0007);\n    }\n  \n    // TODO(someday): Find a zip library that doesn't suck and use it instead of shelling out\n    //   to zip/unzip.\n    if (restore) {\n      Subprocess({\"unzip\", \"-q\", \"file.zip\", \"data/*\", \"metadata\"}).waitForSuccess();\n  \n      // Read metadata file to stdout.\n      kj::FdInputStream in(raiiOpen(\"metadata\", O_RDONLY | O_CLOEXEC));\n      kj::FdOutputStream out(STDOUT_FILENO);\n      pump(in, out);\n    } else {\n      Subprocess::Options zipOptions({\"zip\", \"-qy@\", \"-\"});\n      auto inPipe = Pipe::make();\n      zipOptions.stdin = inPipe.readEnd;\n      Subprocess zip(kj::mv(zipOptions));\n      inPipe.readEnd = nullptr;\n  \n      {\n        kj::FdOutputStream out(kj::mv(inPipe.writeEnd));\n        for (auto& entry: listDirectory(\".\")) {\n          findFilesToZip(entry, out);\n        }\n      }\n  \n      zip.waitForSuccess();\n    }\n  \n    return true;\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: zip.waitForSuccess\nvoid Subprocess::waitForSuccess() {\n  int exitCode = waitForExit();\n  KJ_ASSERT(exitCode == 0, \"child process failed\", name, exitCode);\n}\n\nCallee: findFilesToZip\nbool BackupMain::findFilesToZip(kj::StringPtr path, kj::OutputStream& out) {\n  struct stat stats;\n  KJ_SYSCALL(lstat(path.cStr(), &stats));\n  if (S_ISREG(stats.st_mode) || S_ISLNK(stats.st_mode)) {\n    // Regular file or link can be zipped; write to file stream.\n    // If the path contains a newline, we cannot correctly pass it to `zip` since `zip` expects\n    // one file per line. For security reasons, we must detect and filter out these files.\n    // Hopefully this never happens legitimately?\n    if (path.findFirst('\\n') == nullptr) {\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n      return true;\n    } else {\n      KJ_LOG(ERROR, \"tried to backup file containing newlines\", path);\n      return false;\n    }\n  } else if (S_ISDIR(stats.st_mode)) {\n    // Subdirectory; enumerate contents.\n    bool packedAny = false;\n    for (auto& entry: listDirectory(path)) {\n      if (findFilesToZip(kj::str(path, '/', entry), out)) {\n        packedAny = true;\n      }\n    }\n\n    if (!packedAny) {\n      // Empty directory. Need to make sure it gets into the zip.\n      kj::ArrayPtr<const byte> pieces[2];\n      pieces[0] = path.asBytes();\n      pieces[1] = kj::StringPtr(\"\\n\").asBytes();\n      out.write(pieces);\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n\nCallee: listDirectory\nkj::Array<kj::String> listDirectoryFd(int dirfd) {\n  // We can't actually use `dirfd` directly because we'd mess up the seek state and because\n  // closedir() unfortunately always closes the FD even if opened with fdopendir(). So instead\n  // we delegate to listDirectoryAt() which will open a new FD.\n  return listDirectoryAt(dirfd, \".\");\n}\n\nCallee: Pipe::make\nPipe Pipe::makeTwoWayAsync() {\n  int fds[2];\n  KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, fds));\n  return { kj::AutoCloseFd(fds[0]), kj::AutoCloseFd(fds[1]) };\n}\n\nCallee: pump\nvoid BackupMain::pump(kj::InputStream& in, kj::OutputStream& out) {\n  byte buffer[4096];\n  while (size_t n = in.tryRead(buffer, 1, sizeof(buffer))) {\n    out.write(buffer, n);\n  }\n}\n\nCallee: Subprocess\nvoid detach() {\n    // Indicates that you don't intend to wait for this process to complete and do not want it to\n    // be killed when the Subprocess object is destroyed. The parent process needs a wait loop\n    // somewhere to clean up zombies.\n\n    pid = 0;\n  }\n\nCallee: Subprocess\nvoid notifyExited(int status) {\n    // Call if you receive exit notification from elsewhere, e.g. calling wait() yourself. It is\n    // NECESSARY to call this immediately upon receiving an exit notification, otherwise the\n    // destructor will try to SIGKILL the pid which might have been re-assigned by then.\n    //\n    // TODO(cleanup): Build a safer API to allow waiting on a group of subprocesses, or using\n    //   async I/O.\n\n    pid = 0;\n  }\n\nCallee: bind\nvoid BackupMain::bind(kj::StringPtr src, kj::StringPtr dst, unsigned long flags) {\n  // Contrary to the documentation of MS_BIND claiming this is no longer the case after 2.6.26,\n  // mountflags are ignored on the initial bind.  We have to issue a subsequent remount to set\n  // them.\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr, MS_BIND | MS_REC, nullptr), src, dst);\n  KJ_SYSCALL(mount(src.cStr(), dst.cStr(), nullptr,\n                   MS_BIND | MS_REC | MS_REMOUNT | flags, nullptr),\n      src, dst);\n}\n\nCallee: writeUserNSMap\nvoid BackupMain::writeUserNSMap(const char *type, kj::StringPtr contents) {\n  kj::FdOutputStream(raiiOpen(kj::str(\"/proc/self/\", type, \"_map\").cStr(), O_WRONLY | O_CLOEXEC))\n      .write(contents.begin(), contents.size());\n}\n\nCallee: writeSetgroupsIfPresent\nvoid BackupMain::writeSetgroupsIfPresent(const char *contents) {\n  KJ_IF_MAYBE(fd, raiiOpenIfExists(\"/proc/self/setgroups\", O_WRONLY | O_CLOEXEC)) {\n    kj::FdOutputStream(kj::mv(*fd)).write(contents, strlen(contents));\n  }\n}\n",
    "Vulnerable": false,
    "Description": "The function performs sandboxing and backup/restore operations but does not return or log internal system details, user data, or metadata beyond what the caller explicitly passes via stdin/stdout or configured file paths. All sensitive filesystem areas are hidden with tmpfs mounts before running zip/unzip. Logging in helpers only reports the name of a problematic path inside the already‑selected directory tree. Errors are handled via KJ_SYSCALL/KJ_ASSERT, which, based solely on the provided code, do not expose detailed system internals to an unprivileged actor. Therefore, there is no clear CWE‑200 (information exposure) issue evident in this snippet."
  }
]