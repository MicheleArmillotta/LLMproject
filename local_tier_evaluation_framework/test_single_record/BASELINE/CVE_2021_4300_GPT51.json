[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "CheckBlock",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
      "2101-2190"
    ],
    "function_name": "CheckBlock",
    "contextual_snippet": "MAIN FUNCTION:\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::CheckBlock() const {\n  \n      // These are checks that are independent of context\n      // that can be verified before saving an orphan block.\n  \n      // Size limits\n      if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CheckBlock() : size limits failed\"));\n  \n      if(IsProofOfWork()) {\n  \n          /* Proof-of-work verification against target */\n          if(!CheckProofOfWork(GetHashPoW(), nBits))\n            return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n  \n          /* Proof-of-work block signature verification */\n          if(!CheckBlockSignature())\n            return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n      }\n  \n      // Check timestamp\n      if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n          return error(\"CheckBlock() : block timestamp too far in the future\");\n  \n      // First transaction must be coinbase, the rest must not be\n      if (vtx.empty() || !vtx[0].IsCoinBase())\n          return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n      for (unsigned int i = 1; i < vtx.size(); i++)\n          if (vtx[i].IsCoinBase())\n              return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n  \n      // Check coinbase timestamp\n      if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n          return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n  \n      if (IsProofOfStake())\n      {\n          // Coinbase output should be empty if proof-of-stake block\n          if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n              return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n  \n          // Second transaction must be coinstake, the rest must not be\n          if (vtx.empty() || !vtx[1].IsCoinStake())\n              return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n          for (unsigned int i = 2; i < vtx.size(); i++)\n              if (vtx[i].IsCoinStake())\n                  return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n  \n          // Check coinstake timestamp\n          if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n              return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n  \n          // NovaCoin: check proof-of-stake block signature\n          if(!CheckBlockSignature())\n              return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n      }\n  \n      // Check transactions\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          if (!tx.CheckTransaction())\n              return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n  \n          // ppcoin: check transaction timestamp\n          if (GetBlockTime() < (int64_t)tx.nTime)\n              return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n      }\n  \n      /* Merkle root verification */\n      if(hashMerkleRoot != BuildMerkleTree())\n        return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n  \n      /* Check for duplicate transactions */\n      set<uint256> uniqueTx;\n      BOOST_FOREACH(const CTransaction& tx, vtx) {\n          uniqueTx.insert(tx.GetHash());\n      }\n      if(uniqueTx.size() != vtx.size())\n        return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n  \n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          nSigOps += tx.GetLegacySigOpCount();\n      }\n      if (nSigOps > MAX_BLOCK_SIGOPS)\n          return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n  \n      return(true);\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: DoS\nbool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n\nCallee: error\nexplicit key_error(const std::string& str) : std::runtime_error(str) {}\n\nCallee: tx.GetLegacySigOpCount\nunsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}\n\nCallee: vtx.size\nunsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }\n\nCallee: uniqueTx.insert\nvoid CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}\n\nCallee: tx.GetHash\nuint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }\n\nCallee: BuildMerkleTree\nuint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }\n\nCallee: GetBlockTime\nint64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }\n\nCallee: tx.CheckTransaction\nbool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}\n\nCallee: CheckBlockSignature\nbool CBlock::CheckBlockSignature() const\n{\n    if (IsProofOfWork())\n        return vchBlockSig.empty();\n\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n\n    const CTxOut& txout = vtx[1].vout[1];\n\n    if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        valtype& vchPubKey = vSolutions[0];\n        CKey key;\n        if (!key.SetPubKey(vchPubKey))\n            return false;\n        if (vchBlockSig.empty())\n            return false;\n        return key.Verify(GetHash(), vchBlockSig);\n    }\n\n    return false;\n}\n\nCallee: error\nvoid BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}\n\nCallee: CheckCoinStakeTimestamp\nbool CheckCoinStakeTimestamp(int64_t nTimeBlock, int64_t nTimeTx)\n{\n    // v0.3 protocol\n    return (nTimeBlock == nTimeTx);\n}\n\nCallee: vtx[i].IsCoinStake\nbool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }\n\nCallee: vtx.empty\nbool empty() const { return map.empty(); }\n\nCallee: vtx[0].vout[0].IsEmpty\nbool IsEmpty() const\n    {\n        return (nValue == 0 && scriptPubKey.empty());\n    }\n\nCallee: IsProofOfStake\nbool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }\n\nCallee: FutureDrift\ninline int64_t FutureDrift(int64_t nTime) { return(nTime + 10 * 60); }\n\nCallee: vtx[i].IsCoinBase\nbool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }\n\nCallee: GetAdjustedTime\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}\n\nCallee: CheckProofOfWork\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}\n\nCallee: GetHashPoW\nuint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }\n\nCallee: IsProofOfWork\nbool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }\n\nCallee: ::GetSerializeSize\nunsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}\n",
    "Vulnerable": true,
    "Description": "The function CBlock::CheckBlock uses the error(...) helper repeatedly with detailed, internal diagnostic strings (e.g., \"CheckBlock() : proof-of-work verification failed\", size limit failures, timestamp violations, duplicate transaction detection, bad signatures, etc.). If these error messages are propagated to logs, UI, or network peers without appropriate access control or sanitization, they can reveal internal validation logic, thresholds, and processing states. This constitutes an information exposure risk (CWE-200), especially in a consensus/validation component of a cryptocurrency node, because a remote actor submitting crafted blocks or transactions can infer precise validation rules, timing constraints, and DoS scoring behavior from the distinct error texts and thereby fine-tune attacks or enumerate edge conditions. The code shows no restriction or redaction around these messages, so it may expose sensitive internal details under error conditions."
  }
]