[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "state_fieldbody_crlf",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2013-7299/repo/framework/common/messageheaderparser.cpp",
      "190-235"
    ],
    "function_name": "state_fieldbody_crlf",
    "contextual_snippet": "MAIN FUNCTION:\n#include <cxxtools/log.h>\n#include <cctype>\n#include <tnt/http.h>\n#include <tnt/httperror.h>\n#include <tnt/messageheaderparser.h>\n\nMessageheader {\n  Parser {\n    bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n      {\n        if (ch == '\\r')\n          SET_STATE(state_end_cr);\n        else if (ch == '\\n')\n        {\n          log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n          switch (header.onField(fieldnamePtr, fieldbodyPtr))\n          {\n            case OK:\n            case END:  return true;\n                       break;\n            case FAIL: failedFlag = true;\n                       log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                       break;\n          }\n    \n          return true;\n        }\n        else if (std::isspace(ch))\n        {\n          // continuation line\n          checkHeaderspace(1);\n          *(headerdataPtr - 1) = '\\n';\n          *headerdataPtr++ = ch;\n          SET_STATE(state_fieldbody);\n        }\n        else if (ch >= 33 && ch <= 126)\n        {\n          switch (header.onField(fieldnamePtr, fieldbodyPtr))\n          {\n            case OK:   SET_STATE(state_fieldname);\n                       break;\n            case FAIL: failedFlag = true;\n                       log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                       break;\n            case END:  return true;\n                       break;\n          }\n    \n          fieldnamePtr = headerdataPtr;\n          checkHeaderspace(1);\n          *headerdataPtr++ = ch;\n        }\n        return false;\n      }\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: checkHeaderspace\nvoid Messageheader::Parser::checkHeaderspace(unsigned chars) const\n  {\n    if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))\n      throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, \"header too large\");\n  }\n\nCallee: chartoprint\nstd::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }\n\nCallee: header.onField\nPartheader::return_type Partheader::onField(const char* name,\n    const char* value)\n  {\n    if (tnt::StringCompareIgnoreCase<const char*>(name, \"Content-Disposition:\") == 0)\n    {\n      std::istringstream in(value);\n      in >> cd;\n      if (!in)\n        return FAIL;\n    }\n\n    return Messageheader::onField(name, value);\n  }\n",
    "Vulnerable": true,
    "Description": "The function logs full HTTP header field names and values (`log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);`) at debug level whenever a header line ends. Header fields can contain sensitive data (such as authentication tokens, cookies, or user identifiers). If debug logs are accessible to unauthorized actors, this constitutes an information exposure (CWE-200). Additionally, when parsing fails, it logs the specific invalid character via `log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\")`, revealing exact parsing behavior and character-level input details, which can aid an attacker in probing the parser. There is no indication of masking, filtering, or access control for these logs in the provided code, so the function may expose sensitive information through logging."
  }
]