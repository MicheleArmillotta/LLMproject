[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "write",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
      "928-1017"
    ],
    "function_name": "write",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write()\n  {\n      int bugs = 0;\n      if (!inifile.isDirty())\n      {\n          y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      if (read_only)\n      {\n          y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      UpdateIfModif ();\n  \n      if (multiple_files)\n      {\n  \tIniIterator\n  \t    ci = inifile.getContainerBegin (),\n  \t    ce = inifile.getContainerEnd ();\n  \n  \tfor (;ci != ce; ++ci)\n  \t    {\n  \t\tif (ci->t () == SECTION)\n  \t\t    {\n  \t\t\tIniSection&s = ci->s ();\n  \t\t\tint wb = s.getRewriteBy (); // bug #19066 \n  \t\t\tstring filename = getFileName (s.getName (), wb);\n  \n  \t\t\t// This is the only place where we unmark a\n  \t\t\t// section for deletion - when it is a file\n  \t\t\t// that got some data again. We can do it\n  \t\t\t// because we only erase the files afterwards.\n  \t\t\tdeleted_sections.erase (filename);\n  \n  \t\t\tif (!s.isDirty ()) {\n  \t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\ts.initReadBy ();\n  \t\t\t// ensure that the directories exist\n  \t\t\tPathname pn (filename);\n  \t\t\tPathInfo::assert_dir (pn.dirname ());\n  \t\t\tofstream of(filename.c_str());\n  \t\t\tif (!of.good())\n  \t\t\t{\n  \t\t\t    bugs++;\n  \t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\twrite_helper (s, of, 0);\n  \t\t\ts.clean();\n  \t\t\tof.close ();\n  \t\t    }\n  \t\telse\n  \t\t    {\n  \t\t\ty2error (\"Value %s encountered at multifile top level\",\n  \t\t\t\t ci->e ().getName ());\n  \t\t    }\n  \t    }\n  \n  \t// FIXME: update time stamps of files...\n  \n  \t// erase removed files...\n  \tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n  \t    if (multi_files.find (*i) != multi_files.end ()) {\n  \t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n  \t\tunlink ((*i).c_str());\n  \t    }\n      }\n      else\n      {\n  \t// ensure that the directories exist\n  \tPathname pn (file);\n  \tPathInfo::assert_dir (pn.dirname ());\n  \tofstream of(file.c_str());\n  \tif (!of.good())\n  \t{\n  \t    y2error (\"Can not open file %s for write\", file.c_str());\n  \t    return -1;\n  \t}\n  \n  \twrite_helper (inifile, of, 0);\n  \n  \tof.close();\n  \ttimestamp = getTimeStamp ();\n      }\n      inifile.clean ();\n      return bugs ? -1 : 0;\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: inifile.clean\nvirtual void clean() { dirty = false; }\n\nCallee: getTimeStamp\ntime_t IniParser::getTimeStamp()\n{\n    struct stat st;\n    if (multiple_files)\n    {\n\tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n\tabort ();\n    }\n    if (stat(file.c_str(), &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}\n\nCallee: of.close\nint\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}\n\nCallee: write_helper\nint IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}\n\nCallee: pn.dirname\nPathname    dirname()       const { return dirname( *this ); }\n\nCallee: unlink\nint PathInfo::unlink( const Pathname & path )\n{\n  DBG << \"unlink \" << path;\n  if ( ::unlink( path.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}\n\nCallee: multi_files.end\nYCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}\n\nCallee: deleted_sections.begin\nYCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}\n\nCallee: s.initReadBy\nvoid initReadBy () { read_by = -1; }\n\nCallee: s.isDirty\nbool IniSection::isDirty ()\n{\n    if (dirty)\n\treturn true;\n    // every write dirtyfies not only value but section too\n    // so it is enough for us to find the first dirty section\n    IniSectionIdxIterator xi = isections.begin (), xe = isections. end ();\n    for (; xi != xe; ++xi)\n    {\n\tif (xi->second->s ().isDirty ())\n\t  return true;\n    }\n    return false;\n}\n\nCallee: deleted_sections.erase\nint PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}\n\nCallee: getFileName\nstring IniParser::getFileName (const string&sec, int rb) const\n{\n    string file = sec;\n    if (-1 != rb && (int) rewrites.size () > rb)\n    {\n\tint max = rewrites[rb].out.length () + sec.length () + 1;\n\tchar*buf = new char[max + 1];\n\tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n\ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n\tfile = buf;\n\tdelete [] buf;\n    }\n    return file;\n}\n\nCallee: s.getRewriteBy\nint getRewriteBy() { return rewrite_by; }\n\nCallee: ci->t\nIniType t () const { return _t; }\n\nCallee: inifile.getContainerEnd\nIniIterator IniSection::getContainerEnd ()\n{\n    return container.end ();\n}\n\nCallee: inifile.getContainerBegin\nIniIterator IniSection::getContainerBegin ()\n{\n    return container.begin ();\n}\n\nCallee: UpdateIfModif\nvoid IniParser::UpdateIfModif ()\n{\n    if (read_only)\n        return;\n    // #42297: parsing a file with repeat_names cannot remove duplicates\n    // so reparsing it would duplicate the whole file.\n    // Therefore we do not reparse.\n    if (repeat_names)\n    {\n\ty2debug (\"Skipping possible reparse due to repeat_names\");\n\treturn;\n    }\n    if (multiple_files)\n\tparse ();\n    else\n    {\n\tif (timestamp != getTimeStamp())\n\t{\n\t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n\t    parse ();\n\t}\n    }\n    return ;\n}\n",
    "Vulnerable": true,
    "Description": "The function uses y2debug and y2error logging calls that include full file paths and section-derived filenames. These logs may reveal configuration file locations, internal directory structures, section names, and rewritten filenames (via getFileName), which can encode application logic or user-specific data. Additionally, getTimeStampâ€™s error path logs strerror(errno), exposing specific filesystem error details. If logs are accessible to unauthorized users (no access control is shown), this constitutes an information exposure issue (CWE-200)."
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "Write",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
      "655-864"
    ],
    "function_name": "Write",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nSystemAgent {\n  YCPBoolean\n  SystemAgent::Write (const YCPPath& path, const YCPValue& value,\n  \t\t    const YCPValue& arg)\n  {\n      y2debug (\"Write (%s)\", path->toString().c_str());\n  \n      if (path->isRoot())\n      {\n  \tycp2error (\"Write () called without sub-path\");\n  \treturn YCPBoolean (false);\n      }\n  \n      const string cmd = path->component_str (0); // just a shortcut\n  \n      if (cmd == \"passwd\")\n      {\n  \t/**\n  \t * @builtin Write (.target.passwd.&lt;name&gt;, string cryptval) -> bool\n  \t * .passwd can be used to set or modify the encrypted password\n  \t * of an already existing user in /etc/passwd and /etc/shadow.\n  \t *\n  \t * This call returns true on success and false, if it fails.\n  \t *\n  \t * @example Write (.target.passwd.root, crypt (a_passwd))\n  \t */\n  \n  \tif (path->length() != 2)\n  \t{\n  \t    ycp2error (\"Bad path argument in call to Write (.passwd.name)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    ycp2error (\"Bad password argument in call to Write (.passwd)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring passwd = value->asString()->value();\n  \n  \tstring bashcommand =\n  \t    string (\"/bin/echo '\") +\n  \t    path->component_str (1).c_str () + \":\" + passwd +\n  \t    \"' |/usr/sbin/chpasswd -e >/dev/null 2>&1\";\n  \n  \t// Don't write the password into the log - even though it's crypted\n  \t// y2debug(\"Executing: '%s'\", bashcommand.c_str());\n  \n  \tint exitcode = system(bashcommand.c_str());\n  \n  \treturn YCPBoolean (WIFEXITED (exitcode) && WEXITSTATUS (exitcode) == 0);\n      }\n  \n      else if (cmd == \"string\")\n      {\n  \t/**\n  \t * @builtin Write (.target.string, string filename, string value) -> boolean\n  \t * Writes the string <tt>value</tt> into a file. If the file already\n  \t * exists, the existing file is overwritten. The return value is\n  \t * true, if the file has been written successfully.\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    ycp2error (\"Bad filename arg for Write (.string ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (arg.isNull() || !arg->isString())\n  \t{\n  \t    ycp2error (\"Bad string value for Write (.string ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename = value->asString()->value();\n  \tint fd = open(filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  \tif (fd >= 0)\n  \t{\n  \t    string cont = arg->asString()->value();\n  \t    const char *buffer = cont.c_str();\n  \t    size_t length = cont.length();\n  \t    size_t written = write(fd, buffer, length);\n  \t    close(fd);\n  \t    return YCPBoolean (written == length);\n  \t}\n  \tycp2error (\"Write (.string, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n  \treturn YCPBoolean(false);\n      }\n  \n      else if (cmd == \"byte\")\n      {\n  \t/**\n  \t * @builtin Write (.target.byte, string filename, byteblock) -> boolean\n  \t * Write a byteblock into a file.\n  \t */\n  \n  \tif (value.isNull () || !value->isString ())\n  \t{\n  \t    ycp2error (\"Bad filename arg for Write (.byte, ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (arg.isNull () || !arg->isByteblock ())\n  \t{\n  \t    ycp2error (\"Bad value for Write (.byte, filename, byteblock)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename = value->asString ()->value ();\n  \tYCPByteblock byteblock = arg->asByteblock ();\n  \n  \tint fd = open (filename.c_str (), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  \tif (fd >= 0)\n  \t{\n  \t    size_t size = byteblock->size ();\n  \t    size_t write_size = write (fd, byteblock->value (), size);\n  \t    close (fd);\n  \t    return YCPBoolean (write_size == size);\n  \t}\n  \n  \tycp2error (\"Write (.byte, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n  \treturn YCPBoolean (false);\n      }\n  \n      else if (cmd == \"ycp\" || cmd == \"yast2\")\n      {\n  \t/**\n  \t * @builtin Write (.target.ycp, string filename, any value) -> boolean\n  \t * Opens a file for writing and prints the value <tt>value</tt> in\n  \t * YCP syntax to that file. Returns true, if the file has\n  \t * been written, false otherwise. The newly created file gets\n  \t * the mode 0644 minus umask. Furthermore any missing directory in the\n  \t * pathname <tt>filename</tt> is created automatically.\n  \t */\n  \n  \t/**\n  \t * @builtin Write (.target.ycp, [ string filename, integer mode], any value) -> boolean\n  \t * Opens a file for writing and prints the value <tt>value</tt> in\n  \t * YCP syntax to that file. Returns true, if the file has\n  \t * been written, false otherwise. The newly created file gets\n  \t * the mode mode minus umask. Furthermore any missing directory in the\n  \t * pathname <tt>filename</tt> is created automatically.\n  \t */\n  \n  \t// either string or list\n  \n  \tif (value.isNull() || !(value->isString() || value->isList()))\n  \t{\n  \t    ycp2error (\"Bad arguments to Write (%s, string filename ...)\", cmd.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename;\n  \tmode_t filemode = 0644;\n  \n  \tif (value->isString())\n  \t{\n  \t    filename = value->asString()->value();\n  \t}\n  \telse\n  \t{\t\t\t// value is list\n  \t    YCPList flist = value->asList();\n  \t    if ((flist->size() != 2)\n  \t\t|| (!flist->value(0)->isString())\n  \t\t|| (!flist->value(1)->isInteger()))\n  \t    {\n  \t\tycp2error (\"Bad [filename, mode] list in call to Write (%s, [ string filename, integer mode ], ...)\",\n  \t\t    cmd.c_str ());\n  \t\treturn YCPBoolean (false);\n  \t    }\n  \t    filename = flist->value(0)->asString()->value();\n  \t    filemode = (int)(flist->value(1)->asInteger()->value());\n  \t}\n  \n  \tif (filename.length() == 0)\n  \t{\n  \t    ycp2error (\"Invalid empty filename in Write (%s, ...)\", cmd.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// Create directory, if missing\n  \tsize_t pos = 0;\n  \twhile (pos = filename.find('/', pos + 1), pos != string::npos)\n  \t    mkdir (filename.substr(0, pos).c_str(), 0775);\n  \n  \t// Remove file, if existing\n  \tremove (filename.c_str());\n  \n  \tint fd = open (filename.c_str(), O_WRONLY | O_CREAT |  O_TRUNC , filemode);\n  \tbool success = false;\n  \tif (fd < 0)\n  \t{\n  \t    ycp2error (\"Error opening '%s': %s\", filename.c_str (), strerror (errno));\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// string contents = (arg.isNull() ? \"\" : arg->toString());\n  \tstring contents = (arg.isNull() ? \"\" : dump_value(0, arg));\n  \tssize_t size = contents.length();\n  \tif (size == write(fd, contents.c_str(), size)\n  \t    && write(fd, \"\\n\", 1) == 1)\n  \t    success = true;\n  \tclose(fd);\n  \n  \treturn YCPBoolean(success);\n      }\n  \n      ycp2error (\"Undefined subpath for Write (%s)\", path->toString ().c_str ());\n      return YCPBoolean (false);\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: YCPBoolean\nYCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}\n\nCallee: path->toString\nstring\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}\n\nCallee: write\nint IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}\n\nCallee: contents.length\nlong\nYCPPathRep::length() const\n{\n    return components.size();\n}\n\nCallee: dump_value\nstring\ndump_value (int level, const YCPValue& value)\n{\n    string ret = \"\";\n\n    if (value.isNull())\n\treturn \"\";\n\n    y2debug ( \"%s\\n\", value->toString ().c_str ());\n\n    switch (value->valuetype()) {\n\tcase YT_LIST:\n\t    {\n\t    YCPList list = value->asList ();\n\t    ret += \"[\";\n\t    for (int i = 0; i < list->size (); i++) {\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, list->value (i));\n\t\tif ( i != list->size()-1)\n\t\t    ret += \",\";\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tcase YT_MAP:\n\t    {\n\t    YCPMap map = value->asMap ();\n\t    ret += \"$[\";\n\t    for (YCPMap::const_iterator i = map->begin(); i != map->end(); i++) {\n\t\tif ( i != map->begin () )\n\t\t    ret += \",\";\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, i->first);\n\t\tret += \" : \";\n\t\tret += dump_value (level+1, i->second);\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tdefault:\n\t    ret = value->toString ().c_str ();\n\t    break;\n    }\n\n    return ret;\n}\n\nCallee: remove\nvoid YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}\n\nCallee: mkdir\nint PathInfo::mkdir( const Pathname & path, unsigned mode )\n{\n  DBG << \"mkdir \" << path << ' ' << stringutil::octstring( mode );\n  if ( ::mkdir( path.asString().c_str(), mode ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}\n\nCallee: filename.find\nstring\nYCPPathSearch::find (Kind kind, const string& name)\n{\n    if (name[0] == '.'\n\t&& name[1] == '/')\n    {\n\tif (access (name.c_str(), R_OK) == 0)\n\t{\n\t    return name;\n\t}\n\treturn \"\";\n    }\n\n    initialize ();\n\n    std::list<string>& kindList = searchList[kind];\n    std::list<string>::iterator i = kindList.begin (), e = kindList.end ();\n    while (i != e)\n    {\n\tstring pathname = completeFilename (*i + '/' + name);\n\ty2debug (\"trying %s\", pathname.c_str ());\n\tif (access (pathname.c_str(), R_OK) == 0)\n\t{\n\t    y2debug (\"... success\");\n\t    // FIXME: this check is different for clients and for modules - see findy2\n\t    if( searchPrefixWarn && *i != kindList.back () ) {\n\t\ty2warning( \"Using special search prefix '%s' for '%s'\", i->c_str(), pathname.c_str() );\n\t    }\n\t    return pathname;\n\t}\n\n\t++i;\n    }\n    return \"\";\n}\n\nCallee: flist->value\nstring\nYCPStringRep::value() const\n{\n    return v;\n}\n\nCallee: flist->value\nYCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}\n\nCallee: flist->size\nint\nYCPTermRep::size() const\n{\n    return l->size();\n}\n\nCallee: value->asList\nYCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}\n\nCallee: value->asString\nYCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}\n\nCallee: value->isString\nbool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n\nCallee: value->isList\nbool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n\nCallee: arg->asByteblock\nYCPByteblock\nYCPValueRep::asByteblock() const\n{\n    if (!isByteblock())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Byteblock!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPByteblock (static_cast<const YCPByteblockRep *>(this));\n}\n\nCallee: arg->isByteblock\nbool YCPValueRep::isByteblock()   const { return valuetype() == YT_BYTEBLOCK; }\n\nCallee: path->component_str\nstring\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}\n\nCallee: string\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}\n\nCallee: path->isRoot\nbool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}\n",
    "Vulnerable": true,
    "Description": "The Write() method can leak sensitive information via error and debug logging. It logs full YCP paths and filenames (including arbitrary paths provided by callers) using y2debug/ycp2error, which can disclose internal file system layout, configuration locations, and path-based context to any actor with access to the logs. Additionally, in the .ycp/.yast2 branch, dump_value() logs the full string representation of the value being written; if those values contain secrets (configuration content, credentials, personal data), they will be exposed in logs even though they were only meant to go into files. While the passwd-handling branch avoids logging the password itself, the generic logging behavior for other branches can still expose sensitive data, constituting an information disclosure risk (CWE-200)."
  }
]