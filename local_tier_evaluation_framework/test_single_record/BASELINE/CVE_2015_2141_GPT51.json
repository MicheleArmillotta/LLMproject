[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "CalculateInverse",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-2141/repo/rw.cpp",
      "124-158"
    ],
    "function_name": "CalculateInverse",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"asn.h\"\n#include \"nbtheory.h\"\n#include \"rw.h\"\n#include \"pch.h\"\n\nInvertibleRWFunction {\n  Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n  {\n  \tDoQuickSanityCheck();\n  \tModularArithmetic modn(m_n);\n  \tInteger r, rInv;\n  \tdo {\t// do this in a loop for people using small numbers for testing\n  \t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n  \t\trInv = modn.MultiplicativeInverse(r);\n  \t} while (rInv.IsZero());\n  \tInteger re = modn.Square(r);\n  \tre = modn.Multiply(re, x);\t\t\t// blind\n  \n  \tInteger cp=re%m_p, cq=re%m_q;\n  \tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n  \t{\n  \t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n  \t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n  \t}\n  \n  \t#pragma omp parallel\n  \t\t#pragma omp sections\n  \t\t{\n  \t\t\t#pragma omp section\n  \t\t\t\tcp = ModularSquareRoot(cp, m_p);\n  \t\t\t#pragma omp section\n  \t\t\t\tcq = ModularSquareRoot(cq, m_q);\n  \t\t}\n  \n  \tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n  \ty = modn.Multiply(y, rInv);\t\t\t\t// unblind\n  \ty = STDMIN(y, m_n-y);\n  \tif (ApplyFunction(y) != x)\t\t\t\t// check\n  \t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n  \treturn y;\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: ApplyFunction\nInteger RWFunction::ApplyFunction(const Integer &in) const\n{\n\tDoQuickSanityCheck();\n\n\tInteger out = in.Squared()%m_n;\n\tconst word r = 12;\n\t// this code was written to handle both r = 6 and r = 12,\n\t// but now only r = 12 is used in P1363\n\tconst word r2 = r/2;\n\tconst word r3a = (16 + 5 - r) % 16;\t// n%16 could be 5 or 13\n\tconst word r3b = (16 + 13 - r) % 16;\n\tconst word r4 = (8 + 5 - r/2) % 8;\t// n%8 == 5\n\tswitch (out % 16)\n\t{\n\tcase r:\n\t\tbreak;\n\tcase r2:\n\tcase r2+8:\n\t\tout <<= 1;\n\t\tbreak;\n\tcase r3a:\n\tcase r3b:\n\t\tout.Negate();\n\t\tout += m_n;\n\t\tbreak;\n\tcase r4:\n\tcase r4+8:\n\t\tout.Negate();\n\t\tout += m_n;\n\t\tout <<= 1;\n\t\tbreak;\n\tdefault:\n\t\tout = Integer::Zero();\n\t}\n\treturn out;\n}\n\nCallee: modn.Multiply\nstatic Word Multiply(hword a, hword b)\n\t{\n\t\tWord r;\n\t\tr.m_whole = (word)a * b;\n\t\treturn r;\n\t}\n\nCallee: CRT\nInteger CRT(const Integer &xp, const Integer &p, const Integer &xq, const Integer &q, const Integer &u)\n{\n\t// isn't operator overloading great?\n\treturn p * (u * (xq-xp) % q) + xp;\n/*\n\tInteger t1 = xq-xp;\n\tcout << hex << t1 << endl;\n\tInteger t2 = u * t1;\n\tcout << hex << t2 << endl;\n\tInteger t3 = t2 % q;\n\tcout << hex << t3 << endl;\n\tInteger t4 = p * t3;\n\tcout << hex << t4 << endl;\n\tInteger t5 = t4 + xp;\n\tcout << hex << t5 << endl;\n\treturn t5;\n*/\n}\n\nCallee: ModularSquareRoot\nInteger ModularSquareRoot(const Integer &a, const Integer &p)\n{\n\tif (p%4 == 3)\n\t\treturn a_exp_b_mod_c(a, (p+1)/4, p);\n\n\tInteger q=p-1;\n\tunsigned int r=0;\n\twhile (q.IsEven())\n\t{\n\t\tr++;\n\t\tq >>= 1;\n\t}\n\n\tInteger n=2;\n\twhile (Jacobi(n, p) != -1)\n\t\t++n;\n\n\tInteger y = a_exp_b_mod_c(n, q, p);\n\tInteger x = a_exp_b_mod_c(a, (q-1)/2, p);\n\tInteger b = (x.Squared()%p)*a%p;\n\tx = a*x%p;\n\tInteger tempb, t;\n\n\twhile (b != 1)\n\t{\n\t\tunsigned m=0;\n\t\ttempb = b;\n\t\tdo\n\t\t{\n\t\t\tm++;\n\t\t\tb = b.Squared()%p;\n\t\t\tif (m==r)\n\t\t\t\treturn Integer::Zero();\n\t\t}\n\t\twhile (b != 1);\n\n\t\tt = y;\n\t\tfor (unsigned i=0; i<r-m-1; i++)\n\t\t\tt = t.Squared()%p;\n\t\ty = t.Squared()%p;\n\t\tr = m;\n\t\tx = x*t%p;\n\t\tb = tempb*y%p;\n\t}\n\n\tassert(x.Squared()%p == a);\n\treturn x;\n}\n\nCallee: cq.IsOdd\nbool IsOdd() const\t{return GetBit(0) == 1;}\n\nCallee: Jacobi\nint Jacobi(const Integer &aIn, const Integer &bIn)\n{\n\tassert(bIn.IsOdd());\n\n\tInteger b = bIn, a = aIn%bIn;\n\tint result = 1;\n\n\twhile (!!a)\n\t{\n\t\tunsigned i=0;\n\t\twhile (a.GetBit(i)==0)\n\t\t\ti++;\n\t\ta>>=i;\n\n\t\tif (i%2==1 && (b%8==3 || b%8==5))\n\t\t\tresult = -result;\n\n\t\tif (a%4==3 && b%4==3)\n\t\t\tresult = -result;\n\n\t\tstd::swap(a, b);\n\t\ta %= b;\n\t}\n\n\treturn (b==1) ? result : 0;\n}\n\nCallee: modn.Square\nElement Square(Element a) const\n\t\t{return Multiply(a, a);}\n\nCallee: rInv.IsZero\nbool IsZero() const {return !*this;}\n\nCallee: modn.MultiplicativeInverse\nPolynomialOver<T> PolynomialOver<T>::MultiplicativeInverse(const Ring &ring) const\n{\n\treturn Degree(ring)==0 ? ring.MultiplicativeInverse(m_coefficients[0]) : ring.Identity();\n}\n\nCallee: r.Randomize\nvoid Integer::Randomize(RandomNumberGenerator &rng, const Integer &min, const Integer &max)\n{\n\tif (min > max)\n\t\tthrow InvalidArgument(\"Integer: Min must be no greater than Max\");\n\n\tInteger range = max - min;\n\tconst unsigned int nbits = range.BitCount();\n\n\tdo\n\t{\n\t\tRandomize(rng, nbits);\n\t}\n\twhile (*this > range);\n\n\t*this += min;\n}\n\nCallee: Integer::One\nElement One() const\n\t\t{return 1;}\n",
    "Vulnerable": false,
    "Description": "The function InvertibleRWFunction::CalculateInverse performs private-key computations (modular arithmetic, CRT, square roots) and returns only the resulting decrypted value y. It does not log, print, or otherwise expose internal state (such as p, q, u, n, intermediate cp/cq, or errors with detailed context) to any external channel. The only error it throws is a generic exception message without sensitive parameters. Based strictly on the provided code, there is no observable side channel, debug output, or leakage of internal configuration or secrets via outputs or errors, so there is no direct CWE-200 information exposure in this snippet."
  }
]