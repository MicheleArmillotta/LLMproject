[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "cgroup_release_agent_write",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-v1.c",
      "545-561"
    ],
    "function_name": "cgroup_release_agent_write",
    "contextual_snippet": "MAIN FUNCTION:\n#include <trace/events/cgroup.h>\n#include <linux/fs_parser.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(release_agent_path_lock);\n\nstatic ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: cgroup_kn_unlock\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}\n\nCallee: cgroup_kn_lock_live\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}\n",
    "sinks": [
      {
        "sink_id": "strlcpy(cgrp->root->release_agent_path, strstrip(buf), ...)",
        "sink_description": "Writes a new cgroup release_agent_path, controlling which helper binary is executed when cgroups in this hierarchy are released.",
        "required_conditions": [
          {
            "id": "cgroup_object_must_be_live",
            "description": "The target cgroup associated with of->kn must be live (not dead) before updating its root->release_agent_path.",
            "locally_satisfied": true,
            "justification": "cgroup_kn_lock_live(of->kn, false) is called; if it returns NULL (dead or inaccessible cgroup), the function returns -ENODEV and does not perform the write."
          },
          {
            "id": "caller_must_be_authorized_to_modify_cgroup_release_agent",
            "description": "Only appropriately privileged callers may change the cgroup release_agent_path for this hierarchy.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "release_agent_path_write_must_be_properly_synchronized",
            "description": "Concurrent updates to root->release_agent_path must be serialized to avoid races and inconsistent configuration.",
            "locally_satisfied": true,
            "justification": "A global spinlock release_agent_path_lock is taken before and released after the strlcpy into root->release_agent_path."
          },
          {
            "id": "release_agent_path_string_must_be_sanitized_or_bounded",
            "description": "The configured release_agent_path must be bounded to the destination buffer to avoid overflow and must be stored as a properly terminated string.",
            "locally_satisfied": true,
            "justification": "The code uses strlcpy with sizeof(cgrp->root->release_agent_path) as the bound; BUILD_BUG_ON verifies the buffer is at least PATH_MAX in size, and strlcpy ensures NUL termination."
          }
        ]
      },
      {
        "sink_id": "cgroup_kn_unlock(of->kn)",
        "sink_description": "Releases cgroup-wide mutex and lifetime references after having updated a cgroup configuration field.",
        "required_conditions": [
          {
            "id": "must_release_cgroup_lock_after_modification",
            "description": "The cgroup lock and references obtained via cgroup_kn_lock_live must be released after the configuration change to avoid deadlocks and resource leaks.",
            "locally_satisfied": true,
            "justification": "cgroup_kn_unlock(of->kn) is unconditionally called on the success path after the critical section; error path returns before acquiring locks that need unlocking."
          }
        ]
      }
    ]
  }
]