[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "write",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-ini/src/IniParser.cc",
      "928-1017"
    ],
    "function_name": "write",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"IniFile.h\"\n#include \"IniParser.h\"\n#include <cassert>\n#include <glob.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <errno.h>\n#include <set>\n#include <vector>\n#include <ycp/y2log.h>\n#include <y2util/PathInfo.h>\n#include \"config.h\"\n\nIniParser {\n  int IniParser::write()\n  {\n      int bugs = 0;\n      if (!inifile.isDirty())\n      {\n          y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      if (read_only)\n      {\n          y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n  \treturn 0;\n      }\n      UpdateIfModif ();\n  \n      if (multiple_files)\n      {\n  \tIniIterator\n  \t    ci = inifile.getContainerBegin (),\n  \t    ce = inifile.getContainerEnd ();\n  \n  \tfor (;ci != ce; ++ci)\n  \t    {\n  \t\tif (ci->t () == SECTION)\n  \t\t    {\n  \t\t\tIniSection&s = ci->s ();\n  \t\t\tint wb = s.getRewriteBy (); // bug #19066 \n  \t\t\tstring filename = getFileName (s.getName (), wb);\n  \n  \t\t\t// This is the only place where we unmark a\n  \t\t\t// section for deletion - when it is a file\n  \t\t\t// that got some data again. We can do it\n  \t\t\t// because we only erase the files afterwards.\n  \t\t\tdeleted_sections.erase (filename);\n  \n  \t\t\tif (!s.isDirty ()) {\n  \t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\ts.initReadBy ();\n  \t\t\t// ensure that the directories exist\n  \t\t\tPathname pn (filename);\n  \t\t\tPathInfo::assert_dir (pn.dirname ());\n  \t\t\tofstream of(filename.c_str());\n  \t\t\tif (!of.good())\n  \t\t\t{\n  \t\t\t    bugs++;\n  \t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n  \t\t\t    continue;\n  \t\t\t}\n  \t\t\twrite_helper (s, of, 0);\n  \t\t\ts.clean();\n  \t\t\tof.close ();\n  \t\t    }\n  \t\telse\n  \t\t    {\n  \t\t\ty2error (\"Value %s encountered at multifile top level\",\n  \t\t\t\t ci->e ().getName ());\n  \t\t    }\n  \t    }\n  \n  \t// FIXME: update time stamps of files...\n  \n  \t// erase removed files...\n  \tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n  \t    if (multi_files.find (*i) != multi_files.end ()) {\n  \t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n  \t\tunlink ((*i).c_str());\n  \t    }\n      }\n      else\n      {\n  \t// ensure that the directories exist\n  \tPathname pn (file);\n  \tPathInfo::assert_dir (pn.dirname ());\n  \tofstream of(file.c_str());\n  \tif (!of.good())\n  \t{\n  \t    y2error (\"Can not open file %s for write\", file.c_str());\n  \t    return -1;\n  \t}\n  \n  \twrite_helper (inifile, of, 0);\n  \n  \tof.close();\n  \ttimestamp = getTimeStamp ();\n      }\n      inifile.clean ();\n      return bugs ? -1 : 0;\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: inifile.clean\nvirtual void clean() { dirty = false; }\n\nCallee: getTimeStamp\ntime_t IniParser::getTimeStamp()\n{\n    struct stat st;\n    if (multiple_files)\n    {\n\tprintf (\"bad call of getTimeStamp aborting. FIXME\\n\");//FIXME\n\tabort ();\n    }\n    if (stat(file.c_str(), &st))\n    {\n\ty2error(\"Unable to stat '%s': %s\", file.c_str(), strerror(errno));\n\treturn 0;\n    }\n    return st.st_mtime;\n}\n\nCallee: of.close\nint\nExternalProgram::close()\n{\n    if (pid > 0)\n    {\n\tExternalDataSource::close();\n\t// Wait for child to exit\n\tint ret;\n        int status = 0;\n\tdo\n\t{\n\t    ret = waitpid(pid, &status, 0);\n\t}\n\twhile (ret == -1 && errno == EINTR);\n\n\tif (ret != -1)\n\t{\n\t    status = checkStatus( status );\n\t}\n        pid = -1;\n        return status;\n    }\n    else\n    {\n        return _exitStatus;\n    }\n}\n\nCallee: write_helper\nint IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}\n\nCallee: pn.dirname\nPathname    dirname()       const { return dirname( *this ); }\n\nCallee: unlink\nint PathInfo::unlink( const Pathname & path )\n{\n  DBG << \"unlink \" << path;\n  if ( ::unlink( path.asString().c_str() ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}\n\nCallee: multi_files.end\nYCPMapIterator\nYCPMapRep::end() const\n{\n    return stl_map.end();\n}\n\nCallee: deleted_sections.begin\nYCPMapIterator\nYCPMapRep::begin() const\n{\n    return stl_map.begin();\n}\n\nCallee: s.initReadBy\nvoid initReadBy () { read_by = -1; }\n\nCallee: s.isDirty\nbool IniSection::isDirty ()\n{\n    if (dirty)\n\treturn true;\n    // every write dirtyfies not only value but section too\n    // so it is enough for us to find the first dirty section\n    IniSectionIdxIterator xi = isections.begin (), xe = isections. end ();\n    for (; xi != xe; ++xi)\n    {\n\tif (xi->second->s ().isDirty ())\n\t  return true;\n    }\n    return false;\n}\n\nCallee: deleted_sections.erase\nint PathInfo::erase( const Pathname & path )\n{\n  int res = 0;\n  PathInfo p( path, LSTAT );\n  if ( p.isExist() )\n    {\n      if ( p.isDir() )\n        res = PathInfo::recursive_rmdir( path );\n      else\n        res = PathInfo::unlink( path );\n    }\n  return res;\n}\n\nCallee: getFileName\nstring IniParser::getFileName (const string&sec, int rb) const\n{\n    string file = sec;\n    if (-1 != rb && (int) rewrites.size () > rb)\n    {\n\tint max = rewrites[rb].out.length () + sec.length () + 1;\n\tchar*buf = new char[max + 1];\n\tsnprintf (buf, max, rewrites[rb].out.c_str (), sec.c_str());\n\ty2debug (\"Rewriting %s to %s\", sec.c_str(), buf);\n\tfile = buf;\n\tdelete [] buf;\n    }\n    return file;\n}\n\nCallee: s.getRewriteBy\nint getRewriteBy() { return rewrite_by; }\n\nCallee: ci->t\nIniType t () const { return _t; }\n\nCallee: inifile.getContainerEnd\nIniIterator IniSection::getContainerEnd ()\n{\n    return container.end ();\n}\n\nCallee: inifile.getContainerBegin\nIniIterator IniSection::getContainerBegin ()\n{\n    return container.begin ();\n}\n\nCallee: UpdateIfModif\nvoid IniParser::UpdateIfModif ()\n{\n    if (read_only)\n        return;\n    // #42297: parsing a file with repeat_names cannot remove duplicates\n    // so reparsing it would duplicate the whole file.\n    // Therefore we do not reparse.\n    if (repeat_names)\n    {\n\ty2debug (\"Skipping possible reparse due to repeat_names\");\n\treturn;\n    }\n    if (multiple_files)\n\tparse ();\n    else\n    {\n\tif (timestamp != getTimeStamp())\n\t{\n\t    y2warning(\"Data file '%s' was changed externaly!\", file.c_str());\n\t    parse ();\n\t}\n    }\n    return ;\n}\n",
    "sinks": [
      {
        "sink_id": "y2debug / y2error logging with file paths",
        "sink_description": "Logging operations y2debug and y2error output full INI file paths (file or files[0] or per-section filename) and error details such as inability to open or stat files. These paths and error messages may reveal system configuration layout or existence of particular configuration files to external observers that see the logs.",
        "required_conditions": [
          {
            "id": "logs_not_exposed_to_untrusted_actors",
            "description": "Debug and error logs containing file paths and filesystem error messages must not be exposed to unauthorized users or remote clients.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "paths_not_sensitive",
            "description": "The logged file paths (configuration file locations and section-derived filenames) must not themselves be considered sensitive information in the deployment context.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "filesystem metadata exposure via getTimeStamp / stat errors",
        "sink_description": "getTimeStamp uses stat() on the configuration file and logs detailed error messages (including strerror(errno)) if stat fails, exposing whether the file exists and certain error conditions.",
        "required_conditions": [
          {
            "id": "stat_error_messages_not_visible_to_untrusted",
            "description": "Error messages from failed stat() calls, including errno-derived strings, must not be shown to untrusted parties.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "file_existence_not_sensitive",
            "description": "The mere existence or non-existence of the configuration file must not be sensitive information in this application context.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "unlinking configuration-related files (deleted_sections loop)",
        "sink_description": "The code iterates over deleted_sections and unlinks corresponding files from the filesystem, logging each removal with the full path. The presence or absence of specific per-section files, plus their removal, may reveal application structure or data layout via logs.",
        "required_conditions": [
          {
            "id": "delete_operations_and_paths_not_exposed",
            "description": "Information about which configuration-related files are being deleted (names and paths) must not be exposed to unauthorized observers, typically via logs or external error reporting.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "writing full INI contents to disk via write_helper",
        "sink_description": "write() and write_helper() serialize all sections, entries, names, values, and associated comments into INI files on disk. If configuration values or comments contain secrets (passwords, tokens, internal endpoints), their persistence may constitute exposure if file permissions or storage location are not adequately protected.",
        "required_conditions": [
          {
            "id": "sensitive_values_not_stored_in_plaintext_or_properly_protected",
            "description": "Any sensitive configuration values (e.g., credentials, keys) written by write_helper must either not be present in plaintext or must be stored on disk with appropriate protections (file permissions, encryption).",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "output_files_permissions_secure",
            "description": "The created or overwritten INI files must have secure filesystem permissions restricting access to authorized users only.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "comments_not_leaking_secrets",
            "description": "Comments attached to sections and entries must be free of sensitive information that should not be written to persistent storage.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      }
    ]
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "Write",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2011-3177/repo/agent-system/src/SystemAgent.cc",
      "655-864"
    ],
    "function_name": "Write",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"ShellCommand.h\"\n#include \"SystemAgent.h\"\n#include <ycp/y2log.h>\n#include <ycp/Parser.h>\n#include <ycp/pathsearch.h>\n#include <YCP.h>\n#include <stdexcept>\n#include <sstream>\n#include <string>\n#include <linux/lp.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include \"config.h\"\n\nSystemAgent {\n  YCPBoolean\n  SystemAgent::Write (const YCPPath& path, const YCPValue& value,\n  \t\t    const YCPValue& arg)\n  {\n      y2debug (\"Write (%s)\", path->toString().c_str());\n  \n      if (path->isRoot())\n      {\n  \tycp2error (\"Write () called without sub-path\");\n  \treturn YCPBoolean (false);\n      }\n  \n      const string cmd = path->component_str (0); // just a shortcut\n  \n      if (cmd == \"passwd\")\n      {\n  \t/**\n  \t * @builtin Write (.target.passwd.&lt;name&gt;, string cryptval) -> bool\n  \t * .passwd can be used to set or modify the encrypted password\n  \t * of an already existing user in /etc/passwd and /etc/shadow.\n  \t *\n  \t * This call returns true on success and false, if it fails.\n  \t *\n  \t * @example Write (.target.passwd.root, crypt (a_passwd))\n  \t */\n  \n  \tif (path->length() != 2)\n  \t{\n  \t    ycp2error (\"Bad path argument in call to Write (.passwd.name)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    ycp2error (\"Bad password argument in call to Write (.passwd)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring passwd = value->asString()->value();\n  \n  \tstring bashcommand =\n  \t    string (\"/bin/echo '\") +\n  \t    path->component_str (1).c_str () + \":\" + passwd +\n  \t    \"' |/usr/sbin/chpasswd -e >/dev/null 2>&1\";\n  \n  \t// Don't write the password into the log - even though it's crypted\n  \t// y2debug(\"Executing: '%s'\", bashcommand.c_str());\n  \n  \tint exitcode = system(bashcommand.c_str());\n  \n  \treturn YCPBoolean (WIFEXITED (exitcode) && WEXITSTATUS (exitcode) == 0);\n      }\n  \n      else if (cmd == \"string\")\n      {\n  \t/**\n  \t * @builtin Write (.target.string, string filename, string value) -> boolean\n  \t * Writes the string <tt>value</tt> into a file. If the file already\n  \t * exists, the existing file is overwritten. The return value is\n  \t * true, if the file has been written successfully.\n  \t */\n  \n  \tif (value.isNull() || !value->isString())\n  \t{\n  \t    ycp2error (\"Bad filename arg for Write (.string ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (arg.isNull() || !arg->isString())\n  \t{\n  \t    ycp2error (\"Bad string value for Write (.string ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename = value->asString()->value();\n  \tint fd = open(filename.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  \tif (fd >= 0)\n  \t{\n  \t    string cont = arg->asString()->value();\n  \t    const char *buffer = cont.c_str();\n  \t    size_t length = cont.length();\n  \t    size_t written = write(fd, buffer, length);\n  \t    close(fd);\n  \t    return YCPBoolean (written == length);\n  \t}\n  \tycp2error (\"Write (.string, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n  \treturn YCPBoolean(false);\n      }\n  \n      else if (cmd == \"byte\")\n      {\n  \t/**\n  \t * @builtin Write (.target.byte, string filename, byteblock) -> boolean\n  \t * Write a byteblock into a file.\n  \t */\n  \n  \tif (value.isNull () || !value->isString ())\n  \t{\n  \t    ycp2error (\"Bad filename arg for Write (.byte, ...)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tif (arg.isNull () || !arg->isByteblock ())\n  \t{\n  \t    ycp2error (\"Bad value for Write (.byte, filename, byteblock)\");\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename = value->asString ()->value ();\n  \tYCPByteblock byteblock = arg->asByteblock ();\n  \n  \tint fd = open (filename.c_str (), O_WRONLY | O_CREAT | O_TRUNC, 0644);\n  \tif (fd >= 0)\n  \t{\n  \t    size_t size = byteblock->size ();\n  \t    size_t write_size = write (fd, byteblock->value (), size);\n  \t    close (fd);\n  \t    return YCPBoolean (write_size == size);\n  \t}\n  \n  \tycp2error (\"Write (.byte, \\\"%s\\\") failed: %s\", filename.c_str (), strerror (errno));\n  \treturn YCPBoolean (false);\n      }\n  \n      else if (cmd == \"ycp\" || cmd == \"yast2\")\n      {\n  \t/**\n  \t * @builtin Write (.target.ycp, string filename, any value) -> boolean\n  \t * Opens a file for writing and prints the value <tt>value</tt> in\n  \t * YCP syntax to that file. Returns true, if the file has\n  \t * been written, false otherwise. The newly created file gets\n  \t * the mode 0644 minus umask. Furthermore any missing directory in the\n  \t * pathname <tt>filename</tt> is created automatically.\n  \t */\n  \n  \t/**\n  \t * @builtin Write (.target.ycp, [ string filename, integer mode], any value) -> boolean\n  \t * Opens a file for writing and prints the value <tt>value</tt> in\n  \t * YCP syntax to that file. Returns true, if the file has\n  \t * been written, false otherwise. The newly created file gets\n  \t * the mode mode minus umask. Furthermore any missing directory in the\n  \t * pathname <tt>filename</tt> is created automatically.\n  \t */\n  \n  \t// either string or list\n  \n  \tif (value.isNull() || !(value->isString() || value->isList()))\n  \t{\n  \t    ycp2error (\"Bad arguments to Write (%s, string filename ...)\", cmd.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \tstring filename;\n  \tmode_t filemode = 0644;\n  \n  \tif (value->isString())\n  \t{\n  \t    filename = value->asString()->value();\n  \t}\n  \telse\n  \t{\t\t\t// value is list\n  \t    YCPList flist = value->asList();\n  \t    if ((flist->size() != 2)\n  \t\t|| (!flist->value(0)->isString())\n  \t\t|| (!flist->value(1)->isInteger()))\n  \t    {\n  \t\tycp2error (\"Bad [filename, mode] list in call to Write (%s, [ string filename, integer mode ], ...)\",\n  \t\t    cmd.c_str ());\n  \t\treturn YCPBoolean (false);\n  \t    }\n  \t    filename = flist->value(0)->asString()->value();\n  \t    filemode = (int)(flist->value(1)->asInteger()->value());\n  \t}\n  \n  \tif (filename.length() == 0)\n  \t{\n  \t    ycp2error (\"Invalid empty filename in Write (%s, ...)\", cmd.c_str ());\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// Create directory, if missing\n  \tsize_t pos = 0;\n  \twhile (pos = filename.find('/', pos + 1), pos != string::npos)\n  \t    mkdir (filename.substr(0, pos).c_str(), 0775);\n  \n  \t// Remove file, if existing\n  \tremove (filename.c_str());\n  \n  \tint fd = open (filename.c_str(), O_WRONLY | O_CREAT |  O_TRUNC , filemode);\n  \tbool success = false;\n  \tif (fd < 0)\n  \t{\n  \t    ycp2error (\"Error opening '%s': %s\", filename.c_str (), strerror (errno));\n  \t    return YCPBoolean (false);\n  \t}\n  \n  \t// string contents = (arg.isNull() ? \"\" : arg->toString());\n  \tstring contents = (arg.isNull() ? \"\" : dump_value(0, arg));\n  \tssize_t size = contents.length();\n  \tif (size == write(fd, contents.c_str(), size)\n  \t    && write(fd, \"\\n\", 1) == 1)\n  \t    success = true;\n  \tclose(fd);\n  \n  \treturn YCPBoolean(success);\n      }\n  \n      ycp2error (\"Undefined subpath for Write (%s)\", path->toString ().c_str ());\n      return YCPBoolean (false);\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: YCPBoolean\nYCPBoolean::YCPBoolean (bytecodeistream & str)\n    : YCPValue (*(\n\tBytecode::readBool (str) ? \n\ttrueboolean ? trueboolean : (trueboolean = new YCPBoolean (new YCPBooleanRep (true)) )\n\t:\n\tfalseboolean ? falseboolean : (falseboolean = new YCPBoolean (new YCPBooleanRep (false)) )\n    ))\n{\n}\n\nCallee: path->toString\nstring\nYBreakpoint::toString() const\n{\n    return m_code->toString ();\n}\n\nCallee: write\nint IniParser::write_helper(IniSection&ini, ofstream&of, int depth)\n{\n    char * out_buffer;\n    string indent;\n    string indent2;\n    int readby = ini.getReadBy ();\n    if (!subindent.empty ())\n    {\n\tfor (int ii = 0; ii<depth - 1;ii++)\n\t    indent = indent + subindent;\n\tif (depth)\n\t    indent2 = indent + subindent;\n    }\n\n    if (ini.getComment ()[0])\n        of << ini.getComment();\n    if (readby>=0 && readby < (int)sections.size ())\n\t{\n\t    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free (out_buffer);\n\t}\n    \n    IniIterator\n\tci = ini.getContainerBegin (),\n\tce = ini.getContainerEnd ();\n\n    for (;ci != ce; ++ci)\n\t{\n\t    if (ci->t () == SECTION)\n\t\t{\n\t\t    write_helper (ci->s (), of, depth + 1);\n\t\t    ci->s ().clean();\n\t\t}\n\t    else\n\t\t{\n\t\t    IniEntry&e = ci->e ();\n\t\t    if (e.getComment ()[0])\n\t\t\tof << e.getComment();\n\t\t    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {\n\t\t\t// bnc#492859, a fixed buffer is too small\n\t\t\tasprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());\n\t\t\tof << indent2 << out_buffer << \"\\n\";\n\t\t\tfree(out_buffer);\n\t\t    }\n\t\t    e.clean();\n\t\t}\n\t}\n\n    if (ini.getEndComment ()[0])\n        of << indent << ini.getEndComment();\n    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)\n\t{\n\t    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());\n\t    of << indent << out_buffer << \"\\n\";\n\t    free(out_buffer);\n\t}\n    ini.clean();\n    return 0;\n}\n\nCallee: contents.length\nlong\nYCPPathRep::length() const\n{\n    return components.size();\n}\n\nCallee: dump_value\nstring\ndump_value (int level, const YCPValue& value)\n{\n    string ret = \"\";\n\n    if (value.isNull())\n\treturn \"\";\n\n    y2debug ( \"%s\\n\", value->toString ().c_str ());\n\n    switch (value->valuetype()) {\n\tcase YT_LIST:\n\t    {\n\t    YCPList list = value->asList ();\n\t    ret += \"[\";\n\t    for (int i = 0; i < list->size (); i++) {\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, list->value (i));\n\t\tif ( i != list->size()-1)\n\t\t    ret += \",\";\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tcase YT_MAP:\n\t    {\n\t    YCPMap map = value->asMap ();\n\t    ret += \"$[\";\n\t    for (YCPMap::const_iterator i = map->begin(); i != map->end(); i++) {\n\t\tif ( i != map->begin () )\n\t\t    ret += \",\";\n\t\tret += \"\\n\";\n\t\tret += indent_output (level+1);\n\t\tret += dump_value (level+1, i->first);\n\t\tret += \" : \";\n\t\tret += dump_value (level+1, i->second);\n\t    }\n\t    ret += \"\\n\";\n\t    ret += indent_output (level);\n\t    ret += \"]\";\n\t    }\n\t    break;\n\tdefault:\n\t    ret = value->toString ().c_str ();\n\t    break;\n    }\n\n    return ret;\n}\n\nCallee: remove\nvoid YCPMapRep::remove(const YCPValue& key)\n{\n    if (!key->isString() && !key->isInteger() && !key->isSymbol())\n    {\n        ycp2error (\"Only integer, string, or symbol constant allowed as key in map\");\n        return;\n    }\n\n    stl_map.erase (key);\n}\n\nCallee: mkdir\nint PathInfo::mkdir( const Pathname & path, unsigned mode )\n{\n  DBG << \"mkdir \" << path << ' ' << stringutil::octstring( mode );\n  if ( ::mkdir( path.asString().c_str(), mode ) == -1 ) {\n    return _Log_Result( errno );\n  }\n  return _Log_Result( 0 );\n}\n\nCallee: filename.find\nstring\nYCPPathSearch::find (Kind kind, const string& name)\n{\n    if (name[0] == '.'\n\t&& name[1] == '/')\n    {\n\tif (access (name.c_str(), R_OK) == 0)\n\t{\n\t    return name;\n\t}\n\treturn \"\";\n    }\n\n    initialize ();\n\n    std::list<string>& kindList = searchList[kind];\n    std::list<string>::iterator i = kindList.begin (), e = kindList.end ();\n    while (i != e)\n    {\n\tstring pathname = completeFilename (*i + '/' + name);\n\ty2debug (\"trying %s\", pathname.c_str ());\n\tif (access (pathname.c_str(), R_OK) == 0)\n\t{\n\t    y2debug (\"... success\");\n\t    // FIXME: this check is different for clients and for modules - see findy2\n\t    if( searchPrefixWarn && *i != kindList.back () ) {\n\t\ty2warning( \"Using special search prefix '%s' for '%s'\", i->c_str(), pathname.c_str() );\n\t    }\n\t    return pathname;\n\t}\n\n\t++i;\n    }\n    return \"\";\n}\n\nCallee: flist->value\nstring\nYCPStringRep::value() const\n{\n    return v;\n}\n\nCallee: flist->value\nYCPValue\nYCPTermRep::value (int n) const\n{\n    return l->value(n);\n}\n\nCallee: flist->size\nint\nYCPTermRep::size() const\n{\n    return l->size();\n}\n\nCallee: value->asList\nYCPList\nYCPValueRep::asList() const\n{\n    if (!isList())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not List!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPList (static_cast<const YCPListRep *>(this));\n}\n\nCallee: value->asString\nYCPString\nYCPValueRep::asString() const\n{\n    if (!isString())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not String!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPString (static_cast<const YCPStringRep *>(this));\n}\n\nCallee: value->isString\nbool YCPValueRep::isString()      const { return valuetype() == YT_STRING; }\n\nCallee: value->isList\nbool YCPValueRep::isList()        const { return valuetype() == YT_LIST; }\n\nCallee: arg->asByteblock\nYCPByteblock\nYCPValueRep::asByteblock() const\n{\n    if (!isByteblock())\n    {\n\tycp2error(\"Invalid cast of YCP value '%s'! Should be but is not Byteblock!\",\n\t      toString().c_str());\n\tabort();\n    }\n    return YCPByteblock (static_cast<const YCPByteblockRep *>(this));\n}\n\nCallee: arg->isByteblock\nbool YCPValueRep::isByteblock()   const { return valuetype() == YT_BYTEBLOCK; }\n\nCallee: path->component_str\nstring\nYCPPathRep::component_str(long index) const\n{\n    return components[index].component.asString();\n}\n\nCallee: string\nstring to_string (const YCPValue&v)\n{\n    string s;\n    if (v->isString ())\n\ts = v->asString ()->value ();\n    else\n\ts = v->toString ();\n    return s;\n}\n\nCallee: path->isRoot\nbool\nYCPPathRep::isRoot() const\n{\n    return components.empty();\n}\n",
    "sinks": [
      {
        "sink_id": "passwd branch: system(bashcommand.c_str())",
        "sink_description": "Executes /usr/sbin/chpasswd with a constructed shell command that embeds the (encrypted) password and username, potentially exposing credentials via the process environment, command line, or shell interpretation context.",
        "required_conditions": [
          {
            "id": "no_sensitive_logging_or_echo",
            "description": "The constructed command string containing the password must not be logged, printed, or otherwise exposed beyond the immediate system() call.",
            "locally_satisfied": true,
            "justification": "The code explicitly comments that the password must not be written to the log and the y2debug call that would log the full command is commented out."
          },
          {
            "id": "avoid_shell_injection_and_argument_leakage",
            "description": "User-controllable parts of the command (username and password) should be passed as process arguments (e.g., via fork/exec) rather than embedded in a shell command line to avoid shell injection and command-line exposure.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "authorized_caller_for_password_change",
            "description": "The caller must be authorized to change the specified user’s password according to system policy.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "password_is_already_encrypted",
            "description": "The password value provided to .target.passwd must already be in encrypted form as expected by chpasswd -e, so that raw passwords are not exposed in system-level views.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "string branch: write(fd, buffer, length) to arbitrary filename",
        "sink_description": "Writes a caller-specified string into a caller-specified file path, potentially overwriting or creating system files and exposing the string contents to any process with read access to that path.",
        "required_conditions": [
          {
            "id": "filename_must_be_valid_and_intended",
            "description": "The filename argument must be validated to ensure it refers only to intended locations and cannot be used to overwrite sensitive or privileged files.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "content_must_be_non_sensitive_or_access_controlled",
            "description": "Either the written value must not contain sensitive information, or file permissions and environment must ensure that only authorized actors can read the created/overwritten file.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "error_messages_sanitize_filename_only",
            "description": "Error logging should not include the file contents being written.",
            "locally_satisfied": true,
            "justification": "On failure, the function logs only the filename and strerror(errno); it does not log or dump the contents being written."
          }
        ]
      },
      {
        "sink_id": "byte branch: write(fd, byteblock->value(), size) to arbitrary filename",
        "sink_description": "Writes an arbitrary byte block to a caller-specified file path, potentially persisting sensitive binary data where unauthorized actors can read it.",
        "required_conditions": [
          {
            "id": "byte_filename_must_be_valid_and_intended",
            "description": "The target filename must be constrained so it cannot overwrite sensitive or security-critical files unintentionally.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "byte_content_must_be_properly_protected",
            "description": "The caller must ensure that the byteblock does not contain sensitive information unless the chosen path and permissions adequately protect it.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "no_logging_of_binary_content",
            "description": "Binary content must not be logged or emitted in error paths.",
            "locally_satisfied": true,
            "justification": "On failure, only the filename and strerror(errno) are logged; the byteblock content is never printed."
          }
        ]
      },
      {
        "sink_id": "ycp/yast2 branch: dump_value to string and write(fd, contents.c_str(), size)",
        "sink_description": "Serializes an arbitrary YCP value into a textual representation and writes it to a file whose name (and optionally mode) are provided by the caller; this can persist complex internal data structures, configuration, or credentials to disk.",
        "required_conditions": [
          {
            "id": "ycp_filename_must_be_valid_and_intended",
            "description": "The output filename must be validated to prevent writing YCP dumps into unintended or sensitive filesystem locations.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "value_must_be_safe_to_serialize",
            "description": "The YCP value passed for serialization must either exclude sensitive fields or the caller must ensure that the output file is only accessible to authorized actors.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "directories_and_permissions_must_be_secure",
            "description": "Automatically created directories and the file’s mode must not allow unauthorized read access to any serialized sensitive information.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "no_sensitive_data_in_logs_from_dump_value",
            "description": "Debug logging when dumping values must not expose sensitive data to logs if those logs are accessible to unauthorized users.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      }
    ]
  }
]