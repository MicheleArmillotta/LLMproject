[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "memcached_purge",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/purge.cc",
      "52-131"
    ],
    "function_name": "memcached_purge",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"libmemcached/common.h\"\n\nbool memcached_purge(memcached_instance_st *ptr) {\n  Memcached *root = (Memcached *) ptr->root;\n\n  if (memcached_is_purging(ptr->root) || /* already purging */\n      (memcached_server_response_count(ptr) < ptr->root->io_msg_watermark\n       && ptr->io_bytes_sent < ptr->root->io_bytes_watermark)\n      || (ptr->io_bytes_sent >= ptr->root->io_bytes_watermark\n          && memcached_server_response_count(ptr) < 2))\n  {\n    return true;\n  }\n\n  /*\n    memcached_io_write and memcached_response may call memcached_purge\n    so we need to be able stop any recursion..\n  */\n  Purge set_purge(root);\n\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n  /*\n    Force a flush of the buffer to ensure that we don't have the n-1 pending\n    requests buffered up..\n  */\n  if (memcached_io_write(ptr) == false) {\n    memcached_io_reset(ptr);\n    memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT);\n    return false;\n  }\n  WATCHPOINT_ASSERT(ptr->fd != INVALID_SOCKET);\n\n  bool is_successful = true;\n  uint32_t no_msg = memcached_server_response_count(ptr);\n  if (no_msg > 1) {\n    memcached_result_st result;\n\n    /*\n     * We need to increase the timeout, because we might be waiting for\n     * data to be sent from the server (the commands was in the output buffer\n     * and just flushed\n     */\n    PollTimeout poll_timeout(ptr->root);\n\n    memcached_result_st *result_ptr = memcached_result_create(root, &result);\n    assert(result_ptr);\n\n    for (uint32_t x = 0; x < no_msg - 1; x++) {\n      memcached_result_reset(result_ptr);\n      memcached_return_t rc = memcached_read_one_response(ptr, result_ptr);\n      /*\n       * Purge doesn't care for what kind of command results that is received.\n       * The only kind of errors I care about if is I'm out of sync with the\n       * protocol or have problems reading data from the network..\n       */\n      if (rc == MEMCACHED_PROTOCOL_ERROR or rc == MEMCACHED_UNKNOWN_READ_FAILURE\n          or rc == MEMCACHED_READ_FAILURE)\n      {\n        WATCHPOINT_ERROR(rc);\n        is_successful = false;\n      }\n      if (rc == MEMCACHED_TIMEOUT) {\n        break;\n      }\n\n      if (ptr->root->callbacks) {\n        memcached_callback_st cb = *ptr->root->callbacks;\n        if (memcached_success(rc)) {\n          for (uint32_t y = 0; y < cb.number_of_callback; y++) {\n            if (memcached_fatal((*cb.callback[y])(ptr->root, result_ptr, cb.context))) {\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    memcached_result_free(result_ptr);\n  }\n\n  return is_successful;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: memcached_result_free\nvoid memcached_result_free(memcached_result_st *ptr) {\n  if (ptr == NULL) {\n    return;\n  }\n\n  memcached_string_free(&ptr->value);\n  ptr->numeric_value = UINT64_MAX;\n\n  if (memcached_is_allocated(ptr)) {\n    WATCHPOINT_ASSERT(\n        ptr->root); // Without a root, that means that result was not properly initialized.\n    libmemcached_free(ptr->root, ptr);\n  } else {\n    ptr->count = 0;\n    ptr->options.is_initialized = false;\n  }\n}\n\nCallee: memcached_read_one_response\nmemcached_return_t memcached_read_one_response(memcached_instance_st *instance,\n                                               memcached_result_st *result) {\n  char buffer[SMALL_STRING_LEN];\n\n  if (memcached_is_udp(instance->root)) {\n    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);\n  }\n\n  return _read_one_response(instance, buffer, sizeof(buffer), result);\n}\n\nCallee: memcached_result_reset\nvoid memcached_result_reset_value(memcached_result_st *ptr) {\n  memcached_string_reset(&ptr->value);\n}\n\nCallee: memcached_server_response_count\nuint32_t memcached_server_response_count(const memcached_instance_st *self) {\n  WATCHPOINT_ASSERT(self);\n  if (self == NULL) {\n    return 0;\n  }\n\n  return self->cursor_active_;\n}\n\nCallee: memcached_set_error\nmemcached_return_t memcached_set_error(Memcached &self, memcached_return_t rc, const char *at) {\n  assert_msg(rc != MEMCACHED_ERRNO,\n             \"Programmer error, MEMCACHED_ERRNO was set to be returned to client\");\n  if (memcached_fatal(rc) == false) {\n    return rc;\n  }\n\n  _set(self, NULL, rc, at);\n\n  return rc;\n}\n\nCallee: memcached_io_reset\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}\n\nCallee: memcached_io_write\nbool memcached_io_write(memcached_instance_st *instance) {\n  size_t written;\n  return _io_write(instance, NULL, 0, true, written);\n}\n",
    "sinks": [
      {
        "sink_id": "memcached_read_one_response(ptr, result_ptr) loop with callbacks",
        "sink_description": "Reads and discards up to no_msg-1 pending responses from the memcached server, optionally invoking user-registered callbacks with each parsed result, thereby exposing any queued response data to the application layer.",
        "required_conditions": [
          {
            "id": "authorized_callback_context",
            "description": "Callbacks invoked for purged responses must only be installed by authorized code and must treat the data they receive according to the callerâ€™s access control and privacy policy.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "no_unintended_callback_leakage",
            "description": "Purged responses delivered to callbacks must not be forwarded or logged in ways that expose potentially sensitive values (keys/values) to unauthorized actors.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "protocol_sync_before_exposure",
            "description": "Responses must be successfully parsed and the protocol state must remain in sync before passing result_ptr to callbacks, so that callbacks do not act on corrupted or attacker-injected data wrongly attributed to other operations.",
            "locally_satisfied": true,
            "justification": "The code checks rc from memcached_read_one_response and only invokes callbacks when memcached_success(rc) is true; protocol/read failures (MEMCACHED_PROTOCOL_ERROR, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_READ_FAILURE) are detected and prevent callback execution."
          }
        ]
      },
      {
        "sink_id": "memcached_set_error(*ptr, MEMCACHED_WRITE_FAILURE, MEMCACHED_AT)",
        "sink_description": "Stores a fatal I/O error condition in the Memcached root structure, potentially propagating error information to callers or logs.",
        "required_conditions": [
          {
            "id": "no_sensitive_data_in_error",
            "description": "Error recording for write failures must not embed sensitive application data (keys, values, or user identifiers) into error messages that may be exposed outside the trusted boundary.",
            "locally_satisfied": true,
            "justification": "In this call site a fixed error code MEMCACHED_WRITE_FAILURE and macro MEMCACHED_AT are passed; no user data, keys, or values from ptr are included."
          }
        ]
      }
    ]
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "_read_one_response",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2023-27478/repo/src/libmemcached/response.cc",
      "745-769"
    ],
    "function_name": "_read_one_response",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"libmemcached/string.hpp\"\n#include \"libmemcached/common.h\"\n\nstatic memcached_return_t _read_one_response(memcached_instance_st *instance, char *buffer,\n                                             const size_t buffer_length,\n                                             memcached_result_st *result) {\n  memcached_server_response_decrement(instance);\n\n  if (result == NULL) {\n    Memcached *root = (Memcached *) instance->root;\n    result = &root->result;\n  }\n\n  memcached_return_t rc;\n  if (memcached_is_binary(instance->root)) {\n    do {\n      rc = binary_read_one_response(instance, buffer, buffer_length, result);\n    } while (rc == MEMCACHED_FETCH_NOTFINISHED);\n  } else {\n    rc = textual_read_one_response(instance, buffer, buffer_length, result);\n  }\n\n  if (memcached_fatal(rc) && rc != MEMCACHED_TIMEOUT) {\n    memcached_io_reset(instance);\n  }\n\n  return rc;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: memcached_io_reset\nvoid memcached_io_reset(memcached_instance_st *instance) {\n  memcached_quit_server(instance, true);\n}\n\nCallee: textual_read_one_response\nstatic memcached_return_t textual_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                    const size_t buffer_length,\n                                                    memcached_result_st *result) {\n  size_t total_read;\n  memcached_return_t rc = memcached_io_readline(instance, buffer, buffer_length, total_read);\n\n  if (memcached_failed(rc)) {\n    return rc;\n  }\n  assert(total_read);\n\n  switch (buffer[0]) {\n  case 'V': {\n    // VALUE\n    if (buffer[1] == 'A' and buffer[2] == 'L' and buffer[3] == 'U' and buffer[4] == 'E') /* VALUE */\n    {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return textual_value_fetch(instance, buffer, result);\n    }\n    // VERSION\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'S' and buffer[4] == 'I'\n             and buffer[5] == 'O' and buffer[6] == 'N') /* VERSION */\n    {\n      /* Find the space, and then move one past it to copy version */\n      char *response_ptr = strchr(buffer, ' ');\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(response_ptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'O': {\n    // OK\n    if (buffer[1] == 'K') {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'S': {\n    // STAT\n    if (buffer[1] == 'T' and buffer[2] == 'A' and buffer[3] == 'T') /* STORED STATS */ {\n      memcached_server_response_increment(instance);\n      return MEMCACHED_STAT;\n    }\n    // SERVER_ERROR\n    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'V' and buffer[4] == 'E'\n             and buffer[5] == 'R' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n             and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      if (total_read == memcached_literal_param_size(\"SERVER_ERROR\")) {\n        return MEMCACHED_SERVER_ERROR;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR object too large for cache\")\n          and (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR object too large for cache\"))\n               == 0))\n      {\n        return MEMCACHED_E2BIG;\n      }\n\n      if (total_read >= memcached_literal_param_size(\"SERVER_ERROR out of memory\")\n          and ((memcmp(buffer, memcached_literal_param(\"SERVER_ERROR out of memory\")) == 0)\n               or (memcmp(buffer, memcached_literal_param(\"SERVER_ERROR Out of memory\")) == 0)))\n      {\n        return MEMCACHED_SERVER_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"SERVER_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_SERVER_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n    // STORED\n    else if (buffer[1] == 'T' and buffer[2] == 'O'\n             and buffer[3] == 'R') //  and buffer[4] == 'E' and buffer[5] == 'D')\n    {\n      return MEMCACHED_STORED;\n    }\n  } break;\n\n  case 'D': {\n    // DELETED\n    if (buffer[1] == 'E' and buffer[2] == 'L' and buffer[3] == 'E' and buffer[4] == 'T'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_DELETED;\n    }\n  } break;\n\n  case 'N': {\n    // NOT_FOUND\n    if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'F'\n        and buffer[5] == 'O' and buffer[6] == 'U' and buffer[7] == 'N' and buffer[8] == 'D')\n    {\n      return MEMCACHED_NOTFOUND;\n    }\n    // NOT_STORED\n    else if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'S'\n             and buffer[5] == 'T' and buffer[6] == 'O' and buffer[7] == 'R' and buffer[8] == 'E'\n             and buffer[9] == 'D')\n    {\n      return MEMCACHED_NOTSTORED;\n    }\n  } break;\n\n  case 'E': /* PROTOCOL ERROR or END */\n  {\n    // END\n    if (buffer[1] == 'N' and buffer[2] == 'D') {\n      return MEMCACHED_END;\n    }\n#if 0\n      // PROTOCOL_ERROR\n      else if (buffer[1] == 'R' and buffer[2] == 'O' and buffer[3] == 'T' and buffer[4] == 'O' and buffer[5] == 'C' and buffer[6] == 'O' and buffer[7] == 'L'\n               and buffer[8] == '_'\n               and buffer[9] == 'E' and buffer[10] == 'R' and buffer[11] == 'R' and buffer[12] == 'O' and buffer[13] == 'R')\n      {\n        return MEMCACHED_PROTOCOL_ERROR;\n      }\n#endif\n    // ERROR\n    else if (buffer[1] == 'R' and buffer[2] == 'R' and buffer[3] == 'O' and buffer[4] == 'R')\n    {\n      return MEMCACHED_ERROR;\n    }\n    // EXISTS\n    else if (buffer[1] == 'X' and buffer[2] == 'I' and buffer[3] == 'S' and buffer[4] == 'T'\n             and buffer[5] == 'S')\n    {\n      return MEMCACHED_DATA_EXISTS;\n    }\n  } break;\n\n  case 'T': /* TOUCHED */\n  {\n    // TOUCHED\n    if (buffer[1] == 'O' and buffer[2] == 'U' and buffer[3] == 'C' and buffer[4] == 'H'\n        and buffer[5] == 'E' and buffer[6] == 'D')\n    {\n      return MEMCACHED_SUCCESS;\n    }\n  } break;\n\n  case 'I': /* ITEM */\n  {\n    // ITEM\n    if (buffer[1] == 'T' and buffer[2] == 'E' and buffer[3] == 'M') {\n      /* We add back in one because we will need to search for END */\n      memcached_server_response_increment(instance);\n      return MEMCACHED_ITEM;\n    }\n  } break;\n\n  case 'C': /* CLIENT ERROR */\n  {\n    // CLIENT_ERROR\n    if (buffer[1] == 'L' and buffer[2] == 'I' and buffer[3] == 'E' and buffer[4] == 'N'\n        and buffer[5] == 'T' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'\n        and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')\n    {\n      // Move past the basic error message and whitespace\n      char *startptr = buffer + memcached_literal_param_size(\"CLIENT_ERROR\");\n      if (startptr[0] == ' ') {\n        startptr++;\n      }\n\n      char *endptr = startptr;\n      while (*endptr != '\\r' && *endptr != '\\n') endptr++;\n\n      return memcached_set_error(*instance, MEMCACHED_CLIENT_ERROR, MEMCACHED_AT, startptr,\n                                 size_t(endptr - startptr));\n    }\n  } break;\n\n  case '0': /* INCR/DECR response */\n  case '1': /* INCR/DECR response */\n  case '2': /* INCR/DECR response */\n  case '3': /* INCR/DECR response */\n  case '4': /* INCR/DECR response */\n  case '5': /* INCR/DECR response */\n  case '6': /* INCR/DECR response */\n  case '7': /* INCR/DECR response */\n  case '8': /* INCR/DECR response */\n  case '9': /* INCR/DECR response */\n  {\n    errno = 0;\n    unsigned long long int auto_return_value = strtoull(buffer, (char **) NULL, 10);\n\n    if (auto_return_value == ULLONG_MAX and errno == ERANGE) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno == EINVAL) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    } else if (errno) {\n      result->numeric_value = UINT64_MAX;\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n                                 memcached_literal_param(\"Numeric response was out of range\"));\n    }\n\n    result->numeric_value = uint64_t(auto_return_value);\n\n    WATCHPOINT_STRING(buffer);\n    return MEMCACHED_SUCCESS;\n  }\n\n  default:\n    break;\n  }\n\n  buffer[total_read] = 0;\n#if 0\n  if (total_read >= sizeof(\"STORSTORED\") -1)\n  {\n    fprintf(stderr, \"%s:%d '%s', %.*s\\n\", __FILE__, __LINE__,\n            buffer, MEMCACHED_MAX_BUFFER, instance->read_buffer);\n    assert(memcmp(buffer,\"STORSTORED\", sizeof(\"STORSTORED\") -1));\n  }\n#endif\n  return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT, buffer,\n                             total_read);\n}\n\nCallee: binary_read_one_response\nstatic memcached_return_t binary_read_one_response(memcached_instance_st *instance, char *buffer,\n                                                   const size_t buffer_length,\n                                                   memcached_result_st *result) {\n  memcached_return_t rc;\n  protocol_binary_response_header header;\n\n  assert(memcached_is_binary(instance->root));\n\n  if ((rc = memcached_safe_read(instance, &header.bytes, sizeof(header.bytes)))\n      != MEMCACHED_SUCCESS) {\n    WATCHPOINT_ERROR(rc);\n    return rc;\n  }\n\n  if (header.response.magic != PROTOCOL_BINARY_RES) {\n    return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n  }\n\n  /*\n   ** Convert the header to host local endian!\n   */\n  header.response.keylen = ntohs(header.response.keylen);\n  header.response.status = ntohs(header.response.status);\n  header.response.bodylen = ntohl(header.response.bodylen);\n  header.response.cas = memcached_ntohll(header.response.cas);\n  uint32_t bodylen = header.response.bodylen;\n\n  if (header.response.status == PROTOCOL_BINARY_RESPONSE_SUCCESS\n      or header.response.status == PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE)\n  {\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_GETKQ:\n      /*\n       * We didn't increment the response counter for the GETKQ packet\n       * (only the final NOOP), so we need to increment the counter again.\n       */\n      memcached_server_response_increment(instance);\n      /* fall through */\n    case PROTOCOL_BINARY_CMD_GETK: {\n      uint16_t keylen = header.response.keylen;\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if ((rc = memcached_safe_read(instance, &result->item_flags, sizeof(result->item_flags)))\n          != MEMCACHED_SUCCESS)\n      {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->item_flags = ntohl(result->item_flags);\n      bodylen -= header.response.extlen;\n\n      result->key_length = keylen;\n      if (memcached_failed(rc = memcached_safe_read(instance, result->item_key, keylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      // Only bother with doing this if key_length > 0\n      if (result->key_length) {\n        if (memcached_array_size(instance->root->_namespace)\n            and memcached_array_size(instance->root->_namespace) >= result->key_length)\n        {\n          return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n        }\n\n        if (memcached_array_size(instance->root->_namespace)) {\n          result->key_length -= memcached_array_size(instance->root->_namespace);\n          memmove(result->item_key,\n                  result->item_key + memcached_array_size(instance->root->_namespace),\n                  result->key_length);\n        }\n      }\n\n      bodylen -= keylen;\n      if (memcached_failed(memcached_string_check(&result->value, bodylen))) {\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      }\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if (memcached_failed(rc = memcached_safe_read(instance, vptr, bodylen))) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_INCREMENT:\n    case PROTOCOL_BINARY_CMD_DECREMENT: {\n      if (bodylen != sizeof(uint64_t)) {\n        result->numeric_value = UINT64_MAX;\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n\n      uint64_t val;\n      if ((rc = memcached_safe_read(instance, &val, sizeof(val))) != MEMCACHED_SUCCESS) {\n        result->numeric_value = UINT64_MAX;\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      result->numeric_value = memcached_ntohll(val);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: {\n      if (header.response.keylen || bodylen + 1 > buffer_length) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        if ((rc = memcached_safe_read(instance, buffer, bodylen)) != MEMCACHED_SUCCESS) {\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_VERSION: {\n      char version_buffer[32]; // @todo document this number\n      memset(version_buffer, 0, sizeof(version_buffer));\n\n      if (memcached_safe_read(instance, version_buffer, bodylen) != MEMCACHED_SUCCESS) {\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      char *endptr;\n      errno = 0;\n      long int version = strtol(version_buffer, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX\n          or version == 0) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse major version\"));\n      }\n      instance->major_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse minor version\"));\n      }\n      instance->minor_version = uint8_t(version);\n\n      endptr++;\n      errno = 0;\n      version = strtol(endptr, &endptr, 10);\n      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {\n        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;\n        return memcached_set_error(\n            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,\n            memcached_literal_param(\"strtol() failed to parse micro version\"));\n      }\n      instance->micro_version = uint8_t(version);\n    } break;\n\n    case PROTOCOL_BINARY_CMD_TOUCH: {\n      rc = MEMCACHED_SUCCESS;\n      if (bodylen == 4) // The four byte read is a bug?\n      {\n        char touch_buffer[4]; // @todo document this number\n        rc = memcached_safe_read(instance, touch_buffer, sizeof(touch_buffer));\n#if 0\n          fprintf(stderr, \"%s:%d %d %d %d %d %.*s(%d)\\n\", __FILE__, __LINE__,\n                  int(touch_buffer[0]),\n                  int(touch_buffer[1]),\n                  int(touch_buffer[2]),\n                  int(touch_buffer[3]),\n                  int(bodylen), touch_buffer, int(bodylen));\n#endif\n      }\n      return memcached_set_error(*instance, rc, MEMCACHED_AT);\n    }\n\n    case PROTOCOL_BINARY_CMD_FLUSH:\n    case PROTOCOL_BINARY_CMD_QUIT:\n    case PROTOCOL_BINARY_CMD_SET:\n    case PROTOCOL_BINARY_CMD_ADD:\n    case PROTOCOL_BINARY_CMD_REPLACE:\n    case PROTOCOL_BINARY_CMD_APPEND:\n    case PROTOCOL_BINARY_CMD_PREPEND:\n    case PROTOCOL_BINARY_CMD_DELETE: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_SUCCESS;\n    }\n\n    case PROTOCOL_BINARY_CMD_NOOP: {\n      WATCHPOINT_ASSERT(bodylen == 0);\n      return MEMCACHED_END;\n    }\n\n    case PROTOCOL_BINARY_CMD_STAT: {\n      if (bodylen == 0) {\n        return MEMCACHED_END;\n      } else if (bodylen + 1 > buffer_length) {\n        /* not enough space in buffer.. should not happen... */\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      } else {\n        size_t keylen = header.response.keylen;\n        memset(buffer, 0, buffer_length);\n        if ((rc = memcached_safe_read(instance, buffer, keylen)) != MEMCACHED_SUCCESS\n            || (rc = memcached_safe_read(instance, buffer + keylen + 1, bodylen - keylen))\n                != MEMCACHED_SUCCESS)\n        {\n          WATCHPOINT_ERROR(rc);\n          return MEMCACHED_UNKNOWN_READ_FAILURE;\n        }\n      }\n    } break;\n\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n    case PROTOCOL_BINARY_CMD_SASL_STEP: {\n      memcached_result_reset(result);\n      result->item_cas = header.response.cas;\n\n      if (memcached_string_check(&result->value, bodylen) != MEMCACHED_SUCCESS)\n        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n\n      char *vptr = memcached_string_value_mutable(&result->value);\n      if ((rc = memcached_safe_read(instance, vptr, bodylen)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return MEMCACHED_UNKNOWN_READ_FAILURE;\n      }\n\n      memcached_string_set_length(&result->value, bodylen);\n    } break;\n    default: {\n      /* Command not implemented yet! */\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n    }\n    }\n  } else if (header.response.bodylen) {\n    /* What should I do with the error message??? just discard it for now */\n    char hole[SMALL_STRING_LEN];\n    while (bodylen > 0) {\n      size_t nr = (bodylen > SMALL_STRING_LEN) ? SMALL_STRING_LEN : bodylen;\n      if ((rc = memcached_safe_read(instance, hole, nr)) != MEMCACHED_SUCCESS) {\n        WATCHPOINT_ERROR(rc);\n        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      }\n      bodylen -= (uint32_t) nr;\n    }\n\n    /* This might be an error from one of the quiet commands.. if\n     * so, just throw it away and get the next one. What about creating\n     * a callback to the user with the error information?\n     */\n    switch (header.response.opcode) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n    case PROTOCOL_BINARY_CMD_ADDQ:\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n      return MEMCACHED_FETCH_NOTFINISHED;\n\n    default:\n      break;\n    }\n  }\n\n  rc = MEMCACHED_SUCCESS;\n  if (header.response.status) {\n    switch (header.response.status) {\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n      rc = MEMCACHED_NOTFOUND;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n      rc = MEMCACHED_DATA_EXISTS;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n      rc = MEMCACHED_NOTSTORED;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n      rc = MEMCACHED_E2BIG;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE:\n      rc = MEMCACHED_AUTH_CONTINUE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n      rc = MEMCACHED_AUTH_FAILURE;\n      break;\n\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n    default:\n      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);\n      break;\n    }\n  }\n\n  return rc;\n}\n",
    "sinks": [
      {
        "sink_id": "return rc; (result points to internal root->result if caller passed NULL)",
        "sink_description": "If the caller passes result == NULL, the function substitutes instance->root->result and allows the callee binary_read_one_response/textual_read_one_response to populate it, then returns only a status code while the shared internal result object remains externally accessible through the instance/root structures.",
        "required_conditions": [
          {
            "id": "shared_result_not_exposed_to_untrusted_callers",
            "description": "Callers who can indirectly access instance->root->result must be trusted to see whatever data previous responses left in that shared result object.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "result_cleared_or_reset_between_uses",
            "description": "The shared result object (root->result) should be reset or cleared between logically separate operations so that stale or sensitive data from prior uses is not observable via later API calls.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "no_aliasing_between_concurrent_users",
            "description": "The same root->result object must not be shared concurrently between independent or multi-threaded callers that should not see each other's data.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "delegation to binary_read_one_response/textual_read_one_response",
        "sink_description": "The function reads a response from a memcached server and forwards it into the provided result structure (or root->result) by calling binary_read_one_response or textual_read_one_response, potentially filling it with key/value data originating from the server or backing store.",
        "required_conditions": [
          {
            "id": "caller_authorized_for_cached_data",
            "description": "The caller of _read_one_response must be authorized to receive the data associated with the requested key(s) that binary_read_one_response/textual_read_one_response place into result.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "result_structure_not_reused_for_other_tenants",
            "description": "The memcached_result_st structure used here must not be reused across security domains or tenants without appropriate scrubbing, to avoid cross-tenant leakage of cached values or keys.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      }
    ]
  }
]