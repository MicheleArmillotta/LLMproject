[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "settings_changed",
      "/home/michele/Desktop/ricerca/output_repos_c_ICV/CVE-2021-3658/repo/src/adapter.c",
      "508-557"
    ],
    "function_name": "settings_changed",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"eir.h\"\n#include \"advertising.h\"\n#include \"gatt-database.h\"\n#include \"attrib-server.h\"\n#include \"attrib/gatt.h\"\n#include \"attrib/att.h\"\n#include \"attrib/gattrib.h\"\n#include \"storage.h\"\n#include \"agent.h\"\n#include \"uuid-helper.h\"\n#include \"error.h\"\n#include \"dbus-common.h\"\n#include \"profile.h\"\n#include \"device.h\"\n#include \"adapter.h\"\n#include \"sdpd.h\"\n#include \"hcid.h\"\n#include \"btio/btio.h\"\n#include \"src/shared/gatt-db.h\"\n#include \"src/shared/att.h\"\n#include \"src/shared/queue.h\"\n#include \"src/shared/util.h\"\n#include \"src/shared/mgmt.h\"\n#include \"textfile.h\"\n#include \"log.h\"\n#include \"gdbus/gdbus.h\"\n#include \"lib/mgmt.h\"\n#include \"lib/uuid.h\"\n#include \"bluetooth/sdp_lib.h\"\n#include \"bluetooth/sdp.h\"\n#include \"bluetooth/hci_lib.h\"\n#include \"bluetooth/hci.h\"\n#include \"bluetooth/bluetooth.h\"\n#include <dbus/dbus.h>\n#include <glib.h>\n#include <dirent.h>\n#include <sys/stat.h>\n#include <sys/file.h>\n#include <sys/ioctl.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <errno.h>\n#include <inttypes.h>\n#include <stdio.h>\n#include <config.h>\n\n#define ADAPTER_INTERFACE\t\"org.bluez.Adapter1\"\n\nstatic DBusConnection *dbus_conn = NULL;\nstatic unsigned int adapter_remaining = 0;\nstatic bool powering_down = false;\nstatic void trigger_pairable_timeout(struct btd_adapter *adapter);\nstatic void adapter_start(struct btd_adapter *adapter);\nstatic void adapter_stop(struct btd_adapter *adapter);\nstatic void trigger_passive_scanning(struct btd_adapter *adapter);\n\nstatic void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\n\tchanged_mask = adapter->current_settings ^ settings;\n\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\n\tif (changed_mask & MGMT_SETTING_LE) {\n\t\tif ((adapter->current_settings & MGMT_SETTING_POWERED) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\t\ttrigger_passive_scanning(adapter);\n\t}\n\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: trigger_pairable_timeout\nstatic void trigger_pairable_timeout(struct btd_adapter *adapter)\n{\n\tif (adapter->pairable_timeout_id > 0) {\n\t\tg_source_remove(adapter->pairable_timeout_id);\n\t\tadapter->pairable_timeout_id = 0;\n\t}\n\n\tif (!(adapter->current_settings & MGMT_SETTING_BONDABLE))\n\t\treturn;\n\n\tif (adapter->pairable_timeout > 0)\n\t\tadapter->pairable_timeout_id =\n\t\t\tg_timeout_add_seconds(adapter->pairable_timeout,\n\t\t\t\t\tpairable_timeout_handler, adapter);\n}\n\nCallee: btd_adv_manager_refresh\nvoid btd_adv_manager_refresh(struct btd_adv_manager *manager)\n{\n\tif (!manager)\n\t\treturn;\n\n\tqueue_foreach(manager->clients, manager_refresh, NULL);\n}\n\nCallee: store_adapter_info\nstatic void store_adapter_info(struct btd_adapter *adapter)\n{\n\tGKeyFile *key_file;\n\tchar filename[PATH_MAX];\n\tchar *str;\n\tgsize length = 0;\n\tgboolean discoverable;\n\n\tkey_file = g_key_file_new();\n\n\tif (adapter->pairable_timeout != main_opts.pairto)\n\t\tg_key_file_set_integer(key_file, \"General\", \"PairableTimeout\",\n\t\t\t\t\tadapter->pairable_timeout);\n\n\tif ((adapter->current_settings & MGMT_SETTING_DISCOVERABLE) &&\n\t\t\t\t\t\t!adapter->discoverable_timeout)\n\t\tdiscoverable = TRUE;\n\telse\n\t\tdiscoverable = FALSE;\n\n\tg_key_file_set_boolean(key_file, \"General\", \"Discoverable\",\n\t\t\t\t\t\t\tdiscoverable);\n\n\tif (adapter->discoverable_timeout != main_opts.discovto)\n\t\tg_key_file_set_integer(key_file, \"General\",\n\t\t\t\t\t\"DiscoverableTimeout\",\n\t\t\t\t\tadapter->discoverable_timeout);\n\n\tif (adapter->stored_alias)\n\t\tg_key_file_set_string(key_file, \"General\", \"Alias\",\n\t\t\t\t\t\t\tadapter->stored_alias);\n\n\tsnprintf(filename, PATH_MAX, STORAGEDIR \"/%s/settings\",\n\t\t\t\t\tbtd_adapter_get_storage_dir(adapter));\n\n\tcreate_file(filename, S_IRUSR | S_IWUSR);\n\n\tstr = g_key_file_to_data(key_file, &length, NULL);\n\tg_file_set_contents(filename, str, length, NULL);\n\tg_free(str);\n\n\tg_key_file_free(key_file);\n}\n\nCallee: trigger_passive_scanning\nstatic void trigger_passive_scanning(struct btd_adapter *adapter)\n{\n\tif (!(adapter->current_settings & MGMT_SETTING_LE))\n\t\treturn;\n\n\tDBG(\"\");\n\n\tif (adapter->passive_scan_timeout > 0) {\n\t\tg_source_remove(adapter->passive_scan_timeout);\n\t\tadapter->passive_scan_timeout = 0;\n\t}\n\n\t/*\n\t * When the kernel background scanning is available, there is\n\t * no need to start any discovery. The kernel will keep scanning\n\t * as long as devices are in its auto-connection list.\n\t */\n\tif (kernel_conn_control)\n\t\treturn;\n\n\t/*\n\t * If any client is running a discovery right now, then do not\n\t * even try to start passive scanning.\n\t *\n\t * The discovery procedure is using interleaved scanning and\n\t * thus will discover Low Energy devices as well.\n\t */\n\tif (adapter->discovery_list)\n\t\treturn;\n\n\tif (adapter->discovery_enable == 0x01)\n\t\treturn;\n\n\t/*\n\t * In case the discovery is suspended (for example for an ongoing\n\t * pairing attempt), then also do not start passive scanning.\n\t */\n\tif (adapter->discovery_suspended)\n\t\treturn;\n\n\t/*\n\t * If the list of connectable Low Energy devices is empty,\n\t * then do not start passive scanning.\n\t */\n\tif (!adapter->connect_list)\n\t\treturn;\n\n\tadapter->passive_scan_timeout = g_timeout_add_seconds(CONN_SCAN_TIMEOUT,\n\t\t\t\t\tpassive_scanning_timeout, adapter);\n}\n\nCallee: btd_exit\nvoid btd_exit(void)\n{\n\tg_main_loop_quit(event_loop);\n}\n\nCallee: adapter_stop\nstatic void adapter_stop(struct btd_adapter *adapter)\n{\n\t/* check pending requests */\n\treply_pending_requests(adapter);\n\n\tcancel_passive_scanning(adapter);\n\n\tg_slist_free_full(adapter->set_filter_list, discovery_free);\n\tadapter->set_filter_list = NULL;\n\n\tg_slist_free_full(adapter->discovery_list, discovery_free);\n\tadapter->discovery_list = NULL;\n\n\tdiscovery_cleanup(adapter);\n\n\tadapter->filtered_discovery = false;\n\tadapter->no_scan_restart_delay = false;\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = NULL;\n\n\tadapter->discovering = false;\n\n\twhile (adapter->connections) {\n\t\tstruct btd_device *device = adapter->connections->data;\n\t\tuint8_t addr_type = btd_device_get_bdaddr_type(device);\n\n\t\tadapter_remove_connection(adapter, device, BDADDR_BREDR);\n\t\tif (addr_type != BDADDR_BREDR)\n\t\t\tadapter_remove_connection(adapter, device, addr_type);\n\t}\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\n\tif (adapter->dev_class) {\n\t\t/* the kernel should reset the class of device when powering\n\t\t * down, but it does not. So force it here ... */\n\t\tadapter->dev_class = 0;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Class\");\n\t}\n\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\tDBG(\"adapter %s has been disabled\", adapter->path);\n}\n\nCallee: adapter_start\nstatic void adapter_start(struct btd_adapter *adapter)\n{\n\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\n\tDBG(\"adapter %s has been enabled\", adapter->path);\n\n\ttrigger_passive_scanning(adapter);\n}\n",
    "sinks": [
      {
        "sink_id": "settings_changed",
        "sink_description": "Handles changes to Bluetooth adapter settings, including powering the adapter on/off, toggling discoverability and bondability, and starting/stopping passive scanning. These operations affect system-wide Bluetooth behavior and are security/privilege relevant.",
        "required_conditions": [
          {
            "id": "authorized_caller_for_settings_change",
            "description": "Only authorized entities should be able to change adapter settings that lead to power state transitions, discoverability, bondability, or scanning behavior.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "valid_adapter_pointer",
            "description": "The adapter pointer must refer to a valid, initialized adapter object before mutating its current_settings and using its fields.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "dbus_connection_initialized",
            "description": "The global DBus connection (dbus_conn) must be initialized and associated with the correct bus so that property change signals are only sent on behalf of the intended service.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "controlled_power_state_transitions",
            "description": "Powering the adapter on or off (and potentially exiting the daemon via btd_exit) must only occur as a result of legitimate management commands or policy decisions, not arbitrary untrusted input.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "controlled_discoverability_and_bondability",
            "description": "Changes to discoverable and bondable (pairable) state, which affect who can find and pair with the device, must be restricted to permitted callers or policy.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "controlled_scanning_behavior",
            "description": "Starting passive scanning for LE devices must be allowed only under appropriate conditions and policy, to avoid unintended tracking or resource use.",
            "locally_satisfied": true,
            "justification": "The function and its callees check multiple internal adapter state flags (MGMT_SETTING_POWERED, MGMT_SETTING_LE, discovery_list, discovery_suspended, connect_list, etc.) before initiating passive scanning, enforcing internal preconditions for when scanning can start. This is state-based control, though not an explicit authorization check on the caller."
          },
          {
            "id": "persistent_storage_write_policy",
            "description": "Writing adapter settings to persistent storage (via store_adapter_info) must only occur for legitimate configuration changes originating from authorized callers.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      }
    ]
  }
]