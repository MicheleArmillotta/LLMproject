{
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "ndp_sock_recv",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-3698/repo/libndp/libndp.c",
      "1687-1740"
    ],
    "function_name": "ndp_sock_recv",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"list.h\"\n#include \"ndp_private.h\"\n#include <ndp.h>\n#include <assert.h>\n#include <net/ethernet.h>\n#include <arpa/inet.h>\n#include <netinet/icmp6.h>\n#include <netinet/in.h>\n#include <sys/select.h>\n#include <sys/socket.h>\n#include <ctype.h>\n#include <errno.h>\n#include <string.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void ndp_msg_type_set(struct ndp_msg *msg, enum ndp_msg_type msg_type);\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nenum;\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nenum;\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nstruct;\nNDP_EXPORT\nenum;\nNDP_EXPORT\nstruct;\nstatic int ndp_call_handlers(struct ndp *ndp, struct ndp_msg *msg);\n\nstatic int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\terr = ndp_call_handlers(ndp, msg);;\n\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: ndp_msg_destroy\nNDP_EXPORT\nvoid ndp_msg_destroy(struct ndp_msg *msg)\n{\n\tfree(msg);\n}\n\nCallee: ndp_call_handlers\nstatic int ndp_call_handlers(struct ndp *ndp, struct ndp_msg *msg)\n{\n\tstruct ndp_msgrcv_handler_item *handler_item;\n\tint err;\n\n\tlist_for_each_node_entry(handler_item,\n\t\t\t\t &ndp->msgrcv_handler_list, list) {\n\t\tif (handler_item->msg_type != NDP_MSG_ALL &&\n\t\t    handler_item->msg_type != ndp_msg_type(msg))\n\t\t\tcontinue;\n\t\tif (handler_item->ifindex &&\n\t\t    handler_item->ifindex != msg->ifindex)\n\t\t\tcontinue;\n\t\terr = handler_item->func(ndp, msg, handler_item->priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nCallee: ndp_msg_check_opts\nstatic bool ndp_msg_check_opts(struct ndp_msg *msg)\n{\n\tunsigned char *ptr = ndp_msg_payload_opts(msg);\n\tsize_t len = ndp_msg_payload_opts_len(msg);\n\tstruct ndp_msg_opt_type_info *info;\n\n\twhile (len > 0) {\n\t\tuint8_t cur_opt_raw_type = ptr[0];\n\t\tunsigned int cur_opt_len = ptr[1] << 3; /* convert to bytes */\n\n\t\tif (!cur_opt_len)\n\t\t\treturn false;\n\t\tif (len < cur_opt_len)\n\t\t\tbreak;\n\t\tinfo = ndp_msg_opt_type_info_by_raw_type(cur_opt_raw_type);\n\t\tif (info) {\n\t\t\tif (cur_opt_len < info->raw_struct_size ||\n\t\t\t    (info->check_valid && !info->check_valid(ptr)))\n\t\t\t\tptr[0] = __INVALID_OPT_TYPE_MAGIC;\n\t\t}\n\t\tptr += cur_opt_len;\n\t\tlen -= cur_opt_len;\n\t}\n\n\treturn true;\n}\n\nCallee: ndp_msg_type_info\nstruct ndp_msg_type_info *ndp_msg_type_info(enum ndp_msg_type msg_type)\n{\n\treturn &ndp_msg_type_info_list[msg_type];\n}\n\nCallee: ndp_msg_check_valid\nstatic bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}\n\nCallee: ndp_msg_payload_len_set\nNDP_EXPORT\nvoid ndp_msg_payload_len_set(struct ndp_msg *msg, size_t len)\n{\n\tif (len > sizeof(msg->buf))\n\t\tlen = sizeof(msg->buf);\n\tmsg->len = len;\n}\n\nCallee: ndp_msg_init\nstatic void ndp_msg_init(struct ndp_msg *msg, enum ndp_msg_type msg_type)\n{\n\tsize_t raw_struct_size = ndp_msg_type_info(msg_type)->raw_struct_size;\n\n\tndp_msg_type_set(msg, msg_type);\n\tmsg->len = raw_struct_size;\n\tmsg->opts_start = msg->buf + raw_struct_size;\n\n\t/* Set-up \"first pointers\" in all ndp_msgrs, ndp_msgra, ndp_msgns,\n\t * ndp_msgna, ndp_msgr structures.\n\t */\n\tmsg->nd_msg.generic.dataptr = ndp_msg_payload(msg);\n}\n\nCallee: ndp_msg_type_by_raw_type\nstatic int ndp_msg_type_by_raw_type(enum ndp_msg_type *p_msg_type,\n\t\t\t\t    uint8_t raw_type)\n{\n\tint i;\n\n\tfor (i = 0; i < NDP_MSG_TYPE_LIST_SIZE; i++) {\n\t\tif (ndp_msg_type_info(i)->raw_type == raw_type) {\n\t\t\t*p_msg_type = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nCallee: str_in6_addr\nstatic const char *str_in6_addr(struct in6_addr *addr)\n{\n\tstatic char buf[INET6_ADDRSTRLEN];\n\n\treturn inet_ntop(AF_INET6, addr, buf, sizeof(buf));\n}\n\nCallee: err\nNDP_EXPORT\nuint32_t ndp_msg_opt_prefix_preferred_time(struct ndp_msg *msg, int offset)\n{\n\tstruct nd_opt_prefix_info *pi =\n\t\t\tndp_msg_payload_opts_offset(msg, offset);\n\n\treturn ntohl(pi->nd_opt_pi_preferred_time);\n}\n\nCallee: myrecvfrom6\nstatic int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\n\tlen = recvmsg(sockfd, &msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\n\t/* Set ifindex to scope_id now. But since scope_id gets not\n\t * set by kernel for linklocal addresses, use pktinfo to obtain that\n\t * value right after.\n\t */\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&\n\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&\n\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\tstruct in6_pktinfo *pktinfo;\n\n\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\n\treturn 0;\n}\n\nCallee: ndp_msg_payload_maxlen\nNDP_EXPORT\nsize_t ndp_msg_payload_maxlen(struct ndp_msg *msg)\n{\n\treturn sizeof(msg->buf);\n}\n\nCallee: ndp_msg_alloc\nstatic struct ndp_msg *ndp_msg_alloc(void)\n{\n\tstruct ndp_msg *msg;\n\n\tmsg = myzalloc(sizeof(*msg));\n\tif (!msg)\n\t\treturn NULL;\n\tmsg->icmp6_hdr = (struct icmp6_hdr *) msg->buf;\n\treturn msg;\n}\n",
    "Vulnerable": false,
    "Description": "The analyzed function ndp_sock_recv() receives and parses IPv6 Neighbor Discovery messages from a raw socket and then dispatches them to registered handlers. Within this code, there is no concept of user identities, roles, or privilege checksâ€”the function operates entirely on kernel-delivered network packets and internal handler lists. It validates packet length, message type, and option structure before calling ndp_call_handlers(), which further filters handlers by message type and interface index. Because there is no protected resource or privileged action whose access should depend on an external identity or authorization decision inside this function, and all operations are strictly about safely parsing and routing packets already received on an existing socket, there is no visible improper access control (CWE-284) in this snippet itself. Any higher-level authorization policy would need to be enforced where handlers are registered or where their side effects occur, which is outside the provided code."
  }