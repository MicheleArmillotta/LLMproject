[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "rtas",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
      "996-1081"
    ],
    "function_name": "rtas",
    "contextual_snippet": "MAIN FUNCTION:\n#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\nstatic int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;\n\nSYSCALL_DEFINE1(rtas, struct rtas_args __user *, uargs)\n{\n\tstruct rtas_args args;\n\tunsigned long flags;\n\tchar *buff_copy, *errbuf = NULL;\n\tint nargs, nret, token;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtas.entry)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)\n\t\treturn -EFAULT;\n\n\tnargs = be32_to_cpu(args.nargs);\n\tnret  = be32_to_cpu(args.nret);\n\ttoken = be32_to_cpu(args.token);\n\n\tif (nargs >= ARRAY_SIZE(args.args)\n\t    || nret > ARRAY_SIZE(args.args)\n\t    || nargs + nret > ARRAY_SIZE(args.args))\n\t\treturn -EINVAL;\n\n\t/* Copy in args. */\n\tif (copy_from_user(args.args, uargs->args,\n\t\t\t   nargs * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\targs.rets = &args.args[nargs];\n\tmemset(args.rets, 0, nret * sizeof(rtas_arg_t));\n\n\t/* Need to handle ibm,suspend_me call specially */\n\tif (token == ibm_suspend_me_token) {\n\n\t\t/*\n\t\t * rtas_ibm_suspend_me assumes the streamid handle is in cpu\n\t\t * endian, or at least the hcall within it requires it.\n\t\t */\n\t\tint rc = 0;\n\t\tu64 handle = ((u64)be32_to_cpu(args.args[0]) << 32)\n\t\t              | be32_to_cpu(args.args[1]);\n\t\trc = rtas_ibm_suspend_me(handle);\n\t\tif (rc == -EAGAIN)\n\t\t\targs.rets[0] = cpu_to_be32(RTAS_NOT_SUSPENDABLE);\n\t\telse if (rc == -EIO)\n\t\t\targs.rets[0] = cpu_to_be32(-1);\n\t\telse if (rc)\n\t\t\treturn rc;\n\t\tgoto copy_return;\n\t}\n\n\tbuff_copy = get_errorlog_buffer();\n\n\tflags = lock_rtas();\n\n\trtas.args = args;\n\tenter_rtas(__pa(&rtas.args));\n\targs = rtas.args;\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(args.rets[0]) == -1)\n\t\terrbuf = __fetch_rtas_last_error(buff_copy);\n\n\tunlock_rtas(flags);\n\n\tif (buff_copy) {\n\t\tif (errbuf)\n\t\t\tlog_error(errbuf, ERR_TYPE_RTAS_LOG, 0);\n\t\tkfree(buff_copy);\n\t}\n\n copy_return:\n\t/* Copy out args. */\n\tif (copy_to_user(uargs->args + nargs,\n\t\t\t args.args + nargs,\n\t\t\t nret * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n",
    "Vulnerable": false,
    "Description": "The SYSCALL_DEFINE1(rtas) system call performs privileged RTAS operations but begins with a strict capability check: `if (!capable(CAP_SYS_ADMIN)) return -EPERM;`. All subsequent RTAS interactions (including the special ibm_suspend_me handling and generic enter_rtas() invocation) are gated behind this check. There are no alternative paths that bypass the capability verification, and the function does not expose additional resources without authorization. Based on the provided code, there is no indication of missing or incorrect access control (CWE-284)."
  }
]