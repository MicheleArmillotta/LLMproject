[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "tm_reclaim_thread",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
      "531-563"
    ],
    "function_name": "tm_reclaim_thread",
    "contextual_snippet": "MAIN FUNCTION:\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: tm_reclaim\nstatic void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}\n\nCallee: memcpy\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}\n",
    "Vulnerable": false,
    "Description": "The analyzed function tm_reclaim_thread manipulates kernel thread state and calls tm_reclaim, but it does not itself perform authorization, make access-control decisions, or expose operations conditioned on caller identity. No access-controlâ€“relevant semantic sinks (such as permission checks for users, resources, or commands) are present in this function body, so no CWE-284-specific access-control issues can be derived from it alone."
  }
]