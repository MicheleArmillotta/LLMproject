[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "cgroup_release_agent_write",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-0492/repo/kernel/cgroup/cgroup-v1.c",
      "545-561"
    ],
    "function_name": "cgroup_release_agent_write",
    "contextual_snippet": "MAIN FUNCTION:\n#include <trace/events/cgroup.h>\n#include <linux/fs_parser.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(release_agent_path_lock);\n\nstatic ssize_t cgroup_release_agent_write(struct kernfs_open_file *of,\n\t\t\t\t\t  char *buf, size_t nbytes, loff_t off)\n{\n\tstruct cgroup *cgrp;\n\n\tBUILD_BUG_ON(sizeof(cgrp->root->release_agent_path) < PATH_MAX);\n\n\tcgrp = cgroup_kn_lock_live(of->kn, false);\n\tif (!cgrp)\n\t\treturn -ENODEV;\n\tspin_lock(&release_agent_path_lock);\n\tstrlcpy(cgrp->root->release_agent_path, strstrip(buf),\n\t\tsizeof(cgrp->root->release_agent_path));\n\tspin_unlock(&release_agent_path_lock);\n\tcgroup_kn_unlock(of->kn);\n\treturn nbytes;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: cgroup_kn_unlock\nvoid cgroup_kn_unlock(struct kernfs_node *kn)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\tmutex_unlock(&cgroup_mutex);\n\n\tkernfs_unbreak_active_protection(kn);\n\tcgroup_put(cgrp);\n}\n\nCallee: cgroup_kn_lock_live\nstruct cgroup *cgroup_kn_lock_live(struct kernfs_node *kn, bool drain_offline)\n{\n\tstruct cgroup *cgrp;\n\n\tif (kernfs_type(kn) == KERNFS_DIR)\n\t\tcgrp = kn->priv;\n\telse\n\t\tcgrp = kn->parent->priv;\n\n\t/*\n\t * We're gonna grab cgroup_mutex which nests outside kernfs\n\t * active_ref.  cgroup liveliness check alone provides enough\n\t * protection against removal.  Ensure @cgrp stays accessible and\n\t * break the active_ref protection.\n\t */\n\tif (!cgroup_tryget(cgrp))\n\t\treturn NULL;\n\tkernfs_break_active_protection(kn);\n\n\tif (drain_offline)\n\t\tcgroup_lock_and_drain_offline(cgrp);\n\telse\n\t\tmutex_lock(&cgroup_mutex);\n\n\tif (!cgroup_is_dead(cgrp))\n\t\treturn cgrp;\n\n\tcgroup_kn_unlock(kn);\n\treturn NULL;\n}\n",
    "Vulnerable": true,
    "Description": "The function cgroup_release_agent_write() updates the cgroup rootâ€™s release_agent_path based solely on having a live cgroup kernfs node; it performs no authentication or authorization checks (such as verifying capabilities like CAP_SYS_ADMIN or other permission bits) before allowing the caller to change this globally significant path. If this write handler is exposed through a file that can be written by unprivileged or insufficiently privileged processes, they could arbitrarily set the release agent path, potentially causing execution of attacker-controlled binaries when cgroups are released. This constitutes improper access control (missing/insufficient authorization for a sensitive configuration operation)."
  }
]