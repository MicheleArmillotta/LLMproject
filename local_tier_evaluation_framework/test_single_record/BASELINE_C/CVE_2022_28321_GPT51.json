[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "network_netmask_match",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2022-28321/repo/modules/pam_access/pam_access.c",
      "722-816"
    ],
    "function_name": "network_netmask_match",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"pam_inline.h\"\n#include \"pam_cc_compat.h\"\n#include <security/pam_ext.h>\n#include <security/pam_modutil.h>\n#include <security/pam_modules.h>\n#include <security/_pam_macros.h>\n#include <libaudit.h>\n#include <glob.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/utsname.h>\n#include <ctype.h>\n#include <errno.h>\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"config.h\"\n\n#define NO              0\n#define YES             1\n#define MAXHOSTNAMELEN 256\n\nstatic int user_match (pam_handle_t *, char *, struct login_info *);\nstatic int group_match (pam_handle_t *, const char *, const char *, int);\nstatic int from_match (pam_handle_t *, char *, struct login_info *);\nstatic int remote_match (pam_handle_t *, char *, struct login_info *);\nstatic int string_match (pam_handle_t *, const char *, const char *, int);\nstatic int network_netmask_match (pam_handle_t *, const char *, const char *, struct login_info *);\n\nstatic int\nnetwork_netmask_match (pam_handle_t *pamh,\n\t\t       const char *tok, const char *string, struct login_info *item)\n{\n    char *netmask_ptr;\n    char netmask_string[MAXHOSTNAMELEN + 1];\n    int addr_type;\n\n    if (item->debug)\n    pam_syslog (pamh, LOG_DEBUG,\n\t\t\"network_netmask_match: tok=%s, item=%s\", tok, string);\n    /* OK, check if tok is of type addr/mask */\n    if ((netmask_ptr = strchr(tok, '/')) != NULL)\n      {\n\tlong netmask = 0;\n\n\t/* YES */\n\t*netmask_ptr = 0;\n\tnetmask_ptr++;\n\n\tif (isipaddr(tok, &addr_type, NULL) == NO)\n\t  { /* no netaddr */\n\t    return NO;\n\t  }\n\n\t/* check netmask */\n\tif (isipaddr(netmask_ptr, NULL, NULL) == NO)\n\t  { /* netmask as integre value */\n\t    char *endptr = NULL;\n\t    netmask = strtol(netmask_ptr, &endptr, 0);\n\t    if ((endptr == netmask_ptr) || (*endptr != '\\0'))\n\t\t{ /* invalid netmask value */\n\t\t  return NO;\n\t\t}\n\t    if ((netmask < 0)\n\t\t|| (addr_type == AF_INET && netmask > 32)\n\t\t|| (addr_type == AF_INET6 && netmask > 128))\n\t\t{ /* netmask value out of range */\n\t\t  return NO;\n\t\t}\n\n\t    netmask_ptr = number_to_netmask(netmask, addr_type,\n\t\tnetmask_string, MAXHOSTNAMELEN);\n\t  }\n\t}\n    else\n\t/* NO, then check if it is only an addr */\n\tif (isipaddr(tok, NULL, NULL) != YES)\n\t  {\n\t    return NO;\n\t  }\n\n    if (isipaddr(string, NULL, NULL) != YES)\n      {\n\t/* Assume network/netmask with a name of a host.  */\n\tstruct addrinfo hint;\n\n\tmemset (&hint, '\\0', sizeof (hint));\n\thint.ai_flags = AI_CANONNAME;\n\thint.ai_family = AF_UNSPEC;\n\n\tif (item->gai_rv != 0)\n\t    return NO;\n\telse if (!item->res &&\n\t\t(item->gai_rv = getaddrinfo (string, NULL, &hint, &item->res)) != 0)\n\t    return NO;\n        else\n\t  {\n\t    struct addrinfo *runp = item->res;\n\n\t    while (runp != NULL)\n\t      {\n\t\tchar buf[INET6_ADDRSTRLEN];\n\n\t\tDIAG_PUSH_IGNORE_CAST_ALIGN;\n\t\tinet_ntop (runp->ai_family,\n\t\t\trunp->ai_family == AF_INET\n\t\t\t? (void *) &((struct sockaddr_in *) runp->ai_addr)->sin_addr\n\t\t\t: (void *) &((struct sockaddr_in6 *) runp->ai_addr)->sin6_addr,\n\t\t\tbuf, sizeof (buf));\n\t\tDIAG_POP_IGNORE_CAST_ALIGN;\n\n\t\tif (are_addresses_equal(buf, tok, netmask_ptr))\n\t\t  {\n\t\t    return YES;\n\t\t  }\n\t\trunp = runp->ai_next;\n\t      }\n\t  }\n      }\n    else\n      return (are_addresses_equal(string, tok, netmask_ptr));\n\n  return NO;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: are_addresses_equal\nstatic int\nare_addresses_equal (const char *ipaddr0, const char *ipaddr1,\n\t\t     const char *netmask)\n{\n  struct sockaddr_storage addr0;\n  struct sockaddr_storage addr1;\n  int addr_type0 = 0;\n  int addr_type1 = 0;\n\n  if (isipaddr (ipaddr0, &addr_type0, &addr0) == NO)\n    return NO;\n\n  if (isipaddr (ipaddr1, &addr_type1, &addr1) == NO)\n    return NO;\n\n  if (addr_type0 != addr_type1)\n    /* different address types */\n    return NO;\n\n  if (netmask != NULL) {\n    /* Got a netmask, so normalize addresses? */\n    struct sockaddr_storage nmask;\n    unsigned char *byte_a, *byte_nm;\n\n    memset(&nmask, 0, sizeof(struct sockaddr_storage));\n    if (inet_pton(addr_type0, netmask, (void *)&nmask) > 0) {\n      unsigned int i;\n      byte_a = (unsigned char *)(&addr0);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n\n      byte_a = (unsigned char *)(&addr1);\n      byte_nm = (unsigned char *)(&nmask);\n      for (i=0; i<sizeof(struct sockaddr_storage); i++) {\n        byte_a[i] = byte_a[i] & byte_nm[i];\n      }\n    }\n  }\n\n\n  /* Are the two addresses equal? */\n  if (memcmp((void *)&addr0, (void *)&addr1,\n              sizeof(struct sockaddr_storage)) == 0) {\n    return(YES);\n  }\n\n  return(NO);\n}\n\nCallee: isipaddr\nstatic int\nisipaddr (const char *string, int *addr_type,\n\t  struct sockaddr_storage *addr)\n{\n  struct sockaddr_storage local_addr;\n  int is_ip;\n\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n\n  if (addr == NULL)\n    addr = &local_addr;\n\n  memset(addr, 0, sizeof(struct sockaddr_storage));\n\n  /* first ipv4 */\n  if (inet_pton(AF_INET, string, addr) > 0)\n    {\n      if (addr_type != NULL)\n\t*addr_type = AF_INET;\n\n      is_ip = YES;\n    }\n  else if (inet_pton(AF_INET6, string, addr) > 0)\n    { /* then ipv6 */\n      if (addr_type != NULL) {\n\t*addr_type = AF_INET6;\n      }\n      is_ip = YES;\n    }\n  else\n    is_ip = NO;\n\n  return is_ip;\n}\n\nCallee: number_to_netmask\nstatic char *\nnumber_to_netmask (long netmask, int addr_type,\n\t\t   char *ipaddr_buf, size_t ipaddr_buf_len)\n{\n  /* We use struct sockaddr_storage addr because\n   * struct in_addr/in6_addr is an integral part\n   * of struct sockaddr and we doesn't want to\n   * use its value.\n   */\n  struct sockaddr_storage nmask;\n  unsigned char *byte_nm;\n  const char *ipaddr_dst = NULL;\n  int i, ip_bytes;\n\n  if (netmask == 0) {\n    /* mask 0 is the same like no mask */\n    return(NULL);\n  }\n\n  memset(&nmask, 0, sizeof(struct sockaddr_storage));\n  if (addr_type == AF_INET6) {\n    /* ipv6 address mask */\n    ip_bytes = 16;\n  } else {\n    /* default might be an ipv4 address mask */\n    addr_type = AF_INET;\n    ip_bytes = 4;\n  }\n\n  byte_nm = (unsigned char *)(&nmask);\n  /* translate number to mask */\n  for (i=0; i<ip_bytes; i++) {\n    if (netmask >= 8) {\n      byte_nm[i] = 0xff;\n      netmask -= 8;\n    } else\n    if (netmask > 0) {\n      byte_nm[i] = 0xff << (8 - netmask);\n      break;\n    } else\n    if (netmask <= 0) {\n      break;\n    }\n  }\n\n  /* now generate netmask address string */\n  ipaddr_dst = inet_ntop(addr_type, &nmask, ipaddr_buf, ipaddr_buf_len);\n  if (ipaddr_dst == ipaddr_buf) {\n    return (ipaddr_buf);\n  }\n\n  return (NULL);\n}\n",
    "Vulnerable": false,
    "Description": "The analyzed function `network_netmask_match` only validates and compares IP addresses and netmasks (including resolving hostnames) to decide if a given address matches a network/netmask pattern. It does not perform privileged state changes, resource access, or permission decisions by itself; it simply returns YES/NO based on address comparison. There are no role, identity, or authorization checks expected at this level, so there is no direct CWE-284 improper access control issue visible in this function based solely on the provided code."
  }
]