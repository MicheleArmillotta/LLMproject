[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "examine_variable",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
      "4775-4984"
    ],
    "function_name": "examine_variable",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: GetUserId\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}\n\nCallee: SearchSysCache3\nHeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}\n\nCallee: elog\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}\n\nCallee: equal\nstatic bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}\n\nCallee: examine_simple_variable\nstatic void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}\n",
    "Vulnerable": false,
    "Description": "The function examine_variable performs only planner/optimizer work: it inspects expressions, fetches column or index statistics from system catalogs, and sets flags in VariableStatData. When it accesses statistics that could potentially reveal information, it performs explicit permission checks using pg_class_aclcheck with the current user ID and also requires that there be no security barrier quals (for tables) before marking acl_ok, which controls later use of stats for leakproofness-sensitive operations. For simple table columns, the callee examine_simple_variable additionally checks column-level ACLs and again enforces absence of securityQuals. If statistics are missing, it sets acl_ok to true only as a way to suppress later leakproofness checks, but no direct data access occurs here; it merely exposes or withholds planner statistics, not table contents. There is no path that performs privileged actions (e.g., bypassing ACLs on table data) without these checks, and the function does not modify or grant access to resourcesâ€”only reads catalog entries under the current user identity. Based solely on the provided code, there is no improper or missing access control (CWE-284) in this function."
  }
]