[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "setup_namespaces",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
      "2393-2488"
    ],
    "function_name": "setup_namespaces",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n    char template[] = \"virtiofsd-XXXXXX\";\n    char *tmpdir;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    tmpdir = mkdtemp(template);\n    if (!tmpdir) {\n        fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);\n        exit(1);\n    }\n\n    if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",\n                 tmpdir);\n        exit(1);\n    }\n\n    /* Now we can get our /proc/self/fd directory file descriptor */\n    lo->proc_self_fd = open(tmpdir, O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (umount2(tmpdir, MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (rmdir(tmpdir) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);\n    }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: fuse_log\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}\n\nCallee: exit\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}\n\nCallee: open\nint fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}\n\nCallee: setup_wait_parent_capabilities\nstatic void setup_wait_parent_capabilities(void)\n{\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    capng_apply(CAPNG_SELECT_BOTH);\n}\n",
    "Vulnerable": false,
    "Description": "The setup_namespaces() function performs namespace unsharing, forking, remounting /proc, and setting up a private /proc/self/fd directory. These are process-internal isolation and setup actions; they do not expose or grant access to external resources based on caller identity, nor do they implement any access-control policy that could be bypassed. The only capability-related operation (setup_wait_parent_capabilities) actually drops capabilities in the parent. There is no indication that user or role authorization is needed or that privileged operations are made conditionally available without checks. Therefore, based solely on the provided code, it does not exhibit improper access control (CWE-284)."
  }
]