  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "recalc_intercepts",
      "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
      "99-138"
    ],
    "function_name": "recalc_intercepts",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: is_guest_mode\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}\n\nCallee: mark_dirty\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}\n",
    "Vulnerable": false,
    "Description": "The function recalculates low-level CPU intercept bitmasks for nested virtualization based on existing control structures (L0/L1/L2) and guest mode state. It does not expose or grant new access beyond what is already encoded in the nested control areas; instead, it combines and filters intercept flags. There is no identity, role, or permission decision being made here—just bitmask manipulation of VM-exit controls—so there is no CWE-284 improper access control issue visible in this code alone."
  }