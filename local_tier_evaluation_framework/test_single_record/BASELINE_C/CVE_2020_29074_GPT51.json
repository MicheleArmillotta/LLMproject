[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "shm_create",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-29074/repo/src/scan.c",
      "247-372"
    ],
    "function_name": "shm_create",
    "contextual_snippet": "MAIN FUNCTION:\n#include <default8x16.h>\n#include \"userinput.h\"\n#include \"macosx.h\"\n#include \"screen.h\"\n#include \"unixpw.h\"\n#include \"cleanup.h\"\n#include \"pointer.h\"\n#include \"screen.h\"\n#include \"8to24.h\"\n#include \"win_utils.h\"\n#include \"xrandr.h\"\n#include \"xdamage.h\"\n#include \"xwrappers.h\"\n#include \"xinerama.h\"\n#include \"x11vnc.h\"\n\nvoid shm_delete(XShmSegmentInfo *shm);\nvoid shm_clean(XShmSegmentInfo *shm, XImage *xim);\nstatic char *flip_ximage_byte_order(XImage *xim);\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name);\n\nstatic int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: XShmAttach_wr\nStatus XShmAttach_wr(Display *disp, XShmSegmentInfo *shminfo) {\n#if HAVE_XSHM\n\treturn XShmAttach(disp, shminfo);\n#else\n\tif (!disp || !shminfo) {}\n\treturn (Status) 0;\n#endif\n}\n\nCallee: XShmCreateImage_wr\nXImage *XShmCreateImage_wr(Display* disp, Visual* vis, unsigned int depth,\n    int format, char* data, XShmSegmentInfo* shminfo, unsigned int width,\n    unsigned int height) {\n\n#if HAVE_XSHM\n\treturn XShmCreateImage(disp, vis, depth, format, data, shminfo,\n\t    width, height); \n#else\n\tif (!disp || !vis || !depth || !format || !data || !shminfo || !width || !height) {}\n\treturn (XImage *) 0;\n#endif\n}\n\nCallee: flip_ximage_byte_order\nstatic char *flip_ximage_byte_order(XImage *xim) {\n\tchar *order;\n\tif (xim->byte_order == LSBFirst) {\n\t\torder = \"MSBFirst\";\n\t\txim->byte_order = MSBFirst;\n\t\txim->bitmap_bit_order = MSBFirst;\n\t} else {\n\t\torder = \"LSBFirst\";\n\t\txim->byte_order = LSBFirst;\n\t\txim->bitmap_bit_order = LSBFirst;\n\t}\n\treturn order;\n}\n\nCallee: XCreateImage_wr\nXImage *XCreateImage_wr(Display *disp, Visual *visual, unsigned int depth,\n    int format, int offset, char *data, unsigned int width,\n    unsigned int height, int bitmap_pad, int bytes_per_line) {\n\t/*\n\t * This is a kludge to get a created XImage to exactly match what\n\t * XReadScreen returns: we noticed the rgb masks are different\n\t * from XCreateImage with the high color visual (red mask <->\n\t * blue mask).  Note we read from the root window(!) then free\n\t * the data.\n\t */\n\n\tif (raw_fb) {\t/* raw_fb hack */\n\t\tXImage *xi;\n\t\txi = (XImage *) malloc(sizeof(XImage));\n\t\tmemset(xi, 0, sizeof(XImage));\n\t\txi->depth = depth;\n\t\tif (depth >= 24) {\n\t\t\txi->bits_per_pixel = 32;\n\t\t} else if (depth > 16) {\n\t\t\txi->bits_per_pixel = 24;\n\t\t} else if (depth > 8) {\n\t\t\txi->bits_per_pixel = 16;\n\t\t} else {\n\t\t\txi->bits_per_pixel = 8;\n\t\t}\n\t\txi->format = format;\n\t\txi->xoffset = offset;\n\t\txi->data = data;\n\t\txi->width = width;\n\t\txi->height = height;\n\t\txi->bitmap_pad = bitmap_pad;\n\t\txi->bytes_per_line = bytes_per_line ? bytes_per_line : \n\t\t    xi->width * xi->bits_per_pixel / 8;\n\t\txi->bitmap_unit = -1;\t/* hint to not call XDestroyImage */\n\t\treturn xi;\n\t}\n\n#if NO_X11\n\tnox11_exit(1);\n\tif (!disp || !visual || !depth || !format || !offset || !data || !width\n\t    || !height || !width || !bitmap_pad || !bytes_per_line) {}\n\treturn NULL;\n#else\n\tif (overlay) {\n\t\tXImage *xi;\n\t\txi = xreadscreen(disp, window, 0, 0, width, height, False);\n\t\tif (xi == NULL) {\n\t\t\treturn xi;\n\t\t}\n\t\tif (xi->data != NULL) {\n\t\t\tfree(xi->data);\n\t\t}\n\t\txi->data = data;\n\t\treturn xi;\n\t}\n\n\treturn XCreateImage(disp, visual, depth, format, offset, data,\n\t    width, height, bitmap_pad, bytes_per_line);\n#endif\t/* NO_X11 */\n}\n",
    "Vulnerable": true,
    "Description": "The function shm_create() allocates a System V shared memory segment using shmget with permissions set to 0777 (world-readable and world-writable) via `shm->shmid = shmget(IPC_PRIVATE, ..., IPC_CREAT | 0777);`. This grants all local users full access to the shared memory segment without any access control or restriction. As a result, any unprivileged process on the same host can attach to, read from, or modify the shared memory used for the XShm image, potentially exposing or tampering with screen contents or other sensitive data. Using overly permissive shared memory permissions constitutes improper access control (CWE-284)."
  }
]