[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "sandbox",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-12589/repo/src/firejail/sandbox.c",
      "582-1215"
    ],
    "function_name": "sandbox",
    "contextual_snippet": "MAIN FUNCTION:\n#include <syscall.h>\n#include <sys/apparmor.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/prctl.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <sys/mount.h>\n#include \"firejail.h\"\n\n#define CLONE_NEWUSER\t0x10000000\n\nstatic int force_nonewprivs = 0;\n\nint sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// set capabilities\n\tset_caps();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n#endif\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: flush_stdin\nvoid flush_stdin(void) {\n\tif (isatty(STDIN_FILENO)) {\n\t\tint cnt = 0;\n\t\tint rv = ioctl(STDIN_FILENO, FIONREAD, &cnt);\n\t\tif (rv == 0 && cnt) {\n\t\t\tfwarning(\"removing %d bytes from stdin\\n\", cnt);\n\t\t\trv = ioctl(STDIN_FILENO, TCFLSH, TCIFLUSH);\n\t\t\t(void) rv;\n\t\t}\n\t}\n}\n\nCallee: monitor_application\nstatic int monitor_application(pid_t app_pid) {\n\tEUID_ASSERT();\n\tmonitored_pid = app_pid;\n\n\t// block signals and install handler\n\tsigset_t oldmask, newmask;\n\tsigemptyset(&oldmask);\n\tsigemptyset(&newmask);\n\tsigaddset(&newmask, SIGTERM);\n\tsigaddset(&newmask, SIGINT);\n\tsigprocmask(SIG_BLOCK, &newmask, &oldmask);\n\tinstall_handler();\n\n\t// handle --timeout\n\tint options = 0;;\n\tunsigned timeout = 0;\n\tif (cfg.timeout) {\n\t\toptions = WNOHANG;\n\t\ttimeout = cfg.timeout;\n\t}\n\n\tint status = 0;\n\twhile (monitored_pid) {\n\t\tusleep(20000);\n\t\tchar *msg;\n\t\tif (asprintf(&msg, \"monitoring pid %d\\n\", monitored_pid) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tlogmsg(msg);\n\t\tif (arg_debug)\n\t\t\tprintf(\"%s\\n\", msg);\n\t\tfree(msg);\n\n\t\tpid_t rv;\n\t\tdo {\n\t\t\t// handle signals asynchronously\n\t\t\tsigprocmask(SIG_SETMASK, &oldmask, NULL);\n\n\t\t\trv = waitpid(-1, &status, options);\n\n\t\t\t// block signals again\n\t\t\tsigprocmask(SIG_BLOCK, &newmask, NULL);\n\n\t\t\tif (rv == -1) { // we can get here if we have processes joining the sandbox (ECHILD)\n\t\t\t\tsleep(1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// handle --timeout\n\t\t\tif (options) {\n\t\t\t\tif (--timeout == 0)  {\n\t\t\t\t\tkill(-1, SIGTERM);\n\t\t\t\t\tsleep(1);\n\t\t\t\t\tflush_stdin();\n\t\t\t\t\t_exit(1);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tsleep(1);\n\t\t\t}\n\t\t}\n\t\twhile(rv != monitored_pid);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Sandbox monitor: waitpid %d retval %d status %d\\n\", monitored_pid, rv, status);\n\n\t\tDIR *dir;\n\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t// sleep 2 seconds and try again\n\t\t\tsleep(2);\n\t\t\tif (!(dir = opendir(\"/proc\"))) {\n\t\t\t\tfprintf(stderr, \"Error: cannot open /proc directory\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tstruct dirent *entry;\n\t\tmonitored_pid = 0;\n\t\twhile ((entry = readdir(dir)) != NULL) {\n\t\t\tunsigned pid;\n\t\t\tif (sscanf(entry->d_name, \"%u\", &pid) != 1)\n\t\t\t\tcontinue;\n\t\t\tif (pid == 1)\n\t\t\t\tcontinue;\n\n\t\t\t// todo: make this generic\n\t\t\t// Dillo browser leaves a dpid process running, we need to shut it down\n\t\t\tint found = 0;\n\t\t\tif (strcmp(cfg.command_name, \"dillo\") == 0) {\n\t\t\t\tchar *pidname = pid_proc_comm(pid);\n\t\t\t\tif (pidname && strcmp(pidname, \"dpid\") == 0)\n\t\t\t\t\tfound = 1;\n\t\t\t\tfree(pidname);\n\t\t\t}\n\t\t\tif (found)\n\t\t\t\tbreak;\n\n\t\t\tmonitored_pid = pid;\n\t\t\tbreak;\n\t\t}\n\t\tclosedir(dir);\n\n\t\tif (monitored_pid != 0 && arg_debug)\n\t\t\tprintf(\"Sandbox monitor: monitoring %d\\n\", monitored_pid);\n\t}\n\n\t// return the latest exit status.\n\treturn status;\n}\n\nCallee: start_application\nvoid start_application(int no_sandbox, FILE *fp) {\n\t// set environment\n\tif (no_sandbox == 0) {\n\t\tenv_defaults();\n\t\tenv_apply();\n\t}\n\t// restore original umask\n\tumask(orig_umask);\n\n\tif (arg_debug) {\n\t\tprintf(\"starting application\\n\");\n\t\tprintf(\"LD_PRELOAD=%s\\n\", getenv(\"LD_PRELOAD\"));\n\t}\n\n\t//****************************************\n\t// audit\n\t//****************************************\n\tif (arg_audit) {\n\t\tassert(arg_audit_prog);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecl(arg_audit_prog, arg_audit_prog, NULL);\n\n\t\tperror(\"execl\");\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program without using a shell\n\t//****************************************\n\telse if (arg_shell_none) {\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = cfg.original_program_index; i < cfg.original_argc; i++) {\n\t\t\t\tif (cfg.original_argv[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i - cfg.original_program_index, cfg.original_argv[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (cfg.original_program_index == 0) {\n\t\t\tfprintf(stderr, \"Error: --shell=none configured, but no program specified\\n\");\n\t\t\texit(1);\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tint rv = ok_to_run(cfg.original_argv[cfg.original_program_index]);\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\tif (rv)\n\t\t\texecvp(cfg.original_argv[cfg.original_program_index], &cfg.original_argv[cfg.original_program_index]);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: no suitable %s executable found\\n\", cfg.original_argv[cfg.original_program_index]);\n\t\texit(1);\n\t}\n\t//****************************************\n\t// start the program using a shell\n\t//****************************************\n\telse {\n\t\tassert(cfg.shell);\n\t\tassert(cfg.command_line);\n\n\t\tchar *arg[5];\n\t\tint index = 0;\n\t\targ[index++] = cfg.shell;\n\t\tif (login_shell) {\n\t\t\targ[index++] = \"-l\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Starting %s login shell\\n\", cfg.shell);\n\t\t} else {\n\t\t\targ[index++] = \"-c\";\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Running %s command through %s\\n\", cfg.command_line, cfg.shell);\n\t\t\tif (arg_doubledash)\n\t\t\t\targ[index++] = \"--\";\n\t\t\targ[index++] = cfg.command_line;\n\t\t}\n\t\targ[index] = NULL;\n\t\tassert(index < 5);\n\n\t\tif (arg_debug) {\n\t\t\tchar *msg;\n\t\t\tif (asprintf(&msg, \"sandbox %d, execvp into %s\", sandbox_pid, cfg.command_line) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tlogmsg(msg);\n\t\t\tfree(msg);\n\t\t}\n\n\t\tif (arg_debug) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < 5; i++) {\n\t\t\t\tif (arg[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tprintf(\"execvp argument %d: %s\\n\", i, arg[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!arg_command && !arg_quiet)\n\t\t\tprint_time();\n\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"ready\\n\");\n\t\t\tfclose(fp);\n\t\t}\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n#ifdef HAVE_SECCOMP\n\t\tseccomp_install_filters();\n#endif\n\t\texecvp(arg[0], arg);\n\t}\n\n\tperror(\"execvp\");\n\texit(1); // it should never get here!!!\n}\n\nCallee: set_rlimits\nvoid set_rlimits(void) {\n\tEUID_ASSERT();\n\t// resource limits\n\tstruct rlimit rl;\n\tif (arg_rlimit_cpu) {\n\t\tif (getrlimit(RLIMIT_CPU, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_cpu > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_cpu = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_cpu;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_cpu;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_CPU, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: max cpu time %llu\\n\", cfg.rlimit_cpu);\n\t}\n\n\tif (arg_rlimit_nofile) {\n\t\tif (getrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_nofile > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_nofile = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nofile;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nofile;\n#ifdef HAVE_GCOV\t// gcov-instrumented programs might crash at this point\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_NOFILE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of open file descriptors %llu\\n\", cfg.rlimit_nofile);\n\t}\n\n\tif (arg_rlimit_nproc) {\n\t\tif (getrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_nproc > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_nproc = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_nproc;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_nproc;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_NPROC, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: number of processes %llu\\n\", cfg.rlimit_nproc);\n\t}\n\n\tif (arg_rlimit_fsize) {\n\t\tif (getrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_fsize > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_fsize = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_fsize;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_fsize;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_FSIZE, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum file size %llu\\n\", cfg.rlimit_fsize);\n\t}\n\n\tif (arg_rlimit_sigpending) {\n\t\tif (getrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_sigpending > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_sigpending = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_sigpending;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_sigpending;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_SIGPENDING, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum number of signals pending %llu\\n\", cfg.rlimit_sigpending);\n\t}\n\n\tif (arg_rlimit_as) {\n\t\tif (getrlimit(RLIMIT_AS, &rl) == -1)\n\t\t\terrExit(\"getrlimit\");\n\t\tif (cfg.rlimit_as > rl.rlim_max && getuid() != 0)\n\t\t\tcfg.rlimit_as = rl.rlim_max;\n\t\t// set the new limit\n\t\trl.rlim_cur = (rlim_t) cfg.rlimit_as;\n\t\trl.rlim_max = (rlim_t) cfg.rlimit_as;\n#ifdef HAVE_GCOV\n\t\t__gcov_dump();\n#endif\n\t\tif (setrlimit(RLIMIT_AS, &rl) == -1)\n\t\t\terrExit(\"setrlimit\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Config rlimit: maximum virtual memory %llu\\n\", cfg.rlimit_as);\n\t}\n}\n\nCallee: set_nice\nvoid set_nice(int inc) {\n\terrno = 0;\n\tint rv = nice(inc);\n\t(void) rv;\n\tif (errno)\n\t\tfwarning(\"cannot set nice value\\n\");\n}\n\nCallee: fwarning\nvoid fwarning(char* fmt, ...) {\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tfprintf(stderr, \"Warning: \");\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n}\n\nCallee: checkcfg\nint checkcfg(int val) {\n\tassert(val < CFG_MAX);\n\tint line = 0;\n\tFILE *fp = NULL;\n\tchar *ptr;\n\n\tif (!initialized) {\n\t\t// initialize defaults\n\t\tint i;\n\t\tfor (i = 0; i < CFG_MAX; i++)\n\t\t\tcfg_val[i] = 1; // most of them are enabled by default\n\t\tcfg_val[CFG_RESTRICTED_NETWORK] = 0; // disabled by default\n\t\tcfg_val[CFG_FORCE_NONEWPRIVS] = 0;\n\t\tcfg_val[CFG_PRIVATE_BIN_NO_LOCAL] = 0;\n\t\tcfg_val[CFG_FIREJAIL_PROMPT] = 0;\n\t\tcfg_val[CFG_DISABLE_MNT] = 0;\n\t\tcfg_val[CFG_ARP_PROBES] = DEFAULT_ARP_PROBES;\n\t\tcfg_val[CFG_XPRA_ATTACH] = 0;\n\n\t\t// open configuration file\n\t\tconst char *fname = SYSCONFDIR \"/firejail.config\";\n\t\tfp = fopen(fname, \"r\");\n\t\tif (!fp) {\n#ifdef HAVE_GLOBALCFG\n\t\t\tfprintf(stderr, \"Error: Firejail configuration file %s not found\\n\", fname);\n\t\t\texit(1);\n#else\n\t\t\tinitialized = 1;\n\t\t\treturn\tcfg_val[val];\n#endif\n\t\t}\n\n\t\t// read configuration file\n\t\tchar buf[MAX_READ];\n\t\twhile (fgets(buf,MAX_READ, fp)) {\n\t\t\tline++;\n\t\t\tif (*buf == '#' || *buf == '\\n')\n\t\t\t\tcontinue;\n\n#define PARSE_YESNO(key, string) \\\n\t\t\telse if (strncmp(ptr, string \" \", strlen(string)+1) == 0) { \\\n\t\t\t\tif (strcmp(ptr + strlen(string) + 1, \"yes\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 1; \\\n\t\t\t\telse if (strcmp(ptr + strlen(string) + 1, \"no\") == 0) \\\n\t\t\t\t\tcfg_val[key] = 0; \\\n\t\t\t\telse \\\n\t\t\t\t\tgoto errout; \\\n\t\t\t}\n\n\t\t\t// parse line\n\t\t\tptr = line_remove_spaces(buf);\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tPARSE_YESNO(CFG_FILE_TRANSFER, \"file-transfer\")\n\t\t\tPARSE_YESNO(CFG_DBUS, \"dbus\")\n\t\t\tPARSE_YESNO(CFG_JOIN, \"join\")\n\t\t\tPARSE_YESNO(CFG_X11, \"x11\")\n\t\t\tPARSE_YESNO(CFG_APPARMOR, \"apparmor\")\n\t\t\tPARSE_YESNO(CFG_BIND, \"bind\")\n\t\t\tPARSE_YESNO(CFG_CGROUP, \"cgroup\")\n\t\t\tPARSE_YESNO(CFG_NAME_CHANGE, \"name-change\")\n\t\t\tPARSE_YESNO(CFG_USERNS, \"userns\")\n\t\t\tPARSE_YESNO(CFG_CHROOT, \"chroot\")\n\t\t\tPARSE_YESNO(CFG_FIREJAIL_PROMPT, \"firejail-prompt\")\n\t\t\tPARSE_YESNO(CFG_FOLLOW_SYMLINK_AS_USER, \"follow-symlink-as-user\")\n\t\t\tPARSE_YESNO(CFG_FORCE_NONEWPRIVS, \"force-nonewprivs\")\n\t\t\tPARSE_YESNO(CFG_SECCOMP, \"seccomp\")\n\t\t\tPARSE_YESNO(CFG_WHITELIST, \"whitelist\")\n\t\t\tPARSE_YESNO(CFG_NETWORK, \"network\")\n\t\t\tPARSE_YESNO(CFG_RESTRICTED_NETWORK, \"restricted-network\")\n\t\t\tPARSE_YESNO(CFG_XEPHYR_WINDOW_TITLE, \"xephyr-window-title\")\n\t\t\tPARSE_YESNO(CFG_OVERLAYFS, \"overlayfs\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_HOME, \"private-home\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_CACHE, \"private-cache\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_LIB, \"private-lib\")\n\t\t\tPARSE_YESNO(CFG_PRIVATE_BIN_NO_LOCAL, \"private-bin-no-local\")\n\t\t\tPARSE_YESNO(CFG_DISABLE_MNT, \"disable-mnt\")\n\t\t\tPARSE_YESNO(CFG_XPRA_ATTACH, \"xpra-attach\")\n\t\t\tPARSE_YESNO(CFG_BROWSER_DISABLE_U2F, \"browser-disable-u2f\")\n#undef PARSE_YESNO\n\n\t\t\t// netfilter\n\t\t\telse if (strncmp(ptr, \"netfilter-default \", 18) == 0) {\n\t\t\t\tchar *fname = ptr + 18;\n\t\t\t\twhile (*fname == ' ' || *fname == '\\t')\n\t\t\t\t\tptr++;\n\t\t\t\tchar *end = strchr(fname, ' ');\n\t\t\t\tif (end)\n\t\t\t\t\t*end = '\\0';\n\n\t\t\t\t// is the file present?\n\t\t\t\tstruct stat s;\n\t\t\t\tif (stat(fname, &s) == -1) {\n\t\t\t\t\tfprintf(stderr, \"Error: netfilter-default file %s not available\\n\", fname);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\n\t\t\t\tif (netfilter_default)\n\t\t\t\t\tgoto errout;\n\t\t\t\tnetfilter_default = strdup(fname);\n\t\t\t\tif (!netfilter_default)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t\tif (arg_debug)\n\t\t\t\t\tprintf(\"netfilter default file %s\\n\", fname);\n\t\t\t}\n\n\t\t\t// Xephyr screen size\n\t\t\telse if (strncmp(ptr, \"xephyr-screen \", 14) == 0) {\n\t\t\t\t// expecting two numbers and an x between them\n\t\t\t\tint n1;\n\t\t\t\tint n2;\n\t\t\t\tint rv = sscanf(ptr + 14, \"%dx%d\", &n1, &n2);\n\t\t\t\tif (rv != 2)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xephyr_screen, \"%dx%d\", n1, n2) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xephyr command extra parameters\n\t\t\telse if (strncmp(ptr, \"xephyr-extra-params \", 20) == 0) {\n\t\t\t\tif (*xephyr_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txephyr_extra_params = strdup(ptr + 20);\n\t\t\t\tif (!xephyr_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// xpra server extra parameters\n\t\t\telse if (strncmp(ptr, \"xpra-extra-params \", 18) == 0) {\n\t\t\t\tif (*xpra_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txpra_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xpra_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// Xvfb screen size\n\t\t\telse if (strncmp(ptr, \"xvfb-screen \", 12) == 0) {\n\t\t\t\t// expecting three numbers separated by x's\n\t\t\t\tunsigned int n1;\n\t\t\t\tunsigned int n2;\n\t\t\t\tunsigned int n3;\n\t\t\t\tint rv = sscanf(ptr + 12, \"%ux%ux%u\", &n1, &n2, &n3);\n\t\t\t\tif (rv != 3)\n\t\t\t\t\tgoto errout;\n\t\t\t\tif (asprintf(&xvfb_screen, \"%ux%ux%u\", n1, n2, n3) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t}\n\n\t\t\t// Xvfb extra parameters\n\t\t\telse if (strncmp(ptr, \"xvfb-extra-params \", 18) == 0) {\n\t\t\t\tif (*xvfb_extra_params != '\\0')\n\t\t\t\t\tgoto errout;\n\t\t\t\txvfb_extra_params = strdup(ptr + 18);\n\t\t\t\tif (!xvfb_extra_params)\n\t\t\t\t\terrExit(\"strdup\");\n\t\t\t}\n\n\t\t\t// quiet by default\n\t\t\telse if (strncmp(ptr, \"quiet-by-default \", 17) == 0) {\n\t\t\t\tif (strcmp(ptr + 17, \"yes\") == 0)\n\t\t\t\t\targ_quiet = 1;\n\t\t\t\telse if (strcmp(ptr + 17, \"no\") == 0)\n\t\t\t\t\targ_quiet = 0;\n\t\t\t\telse\n\t\t\t\t\tgoto errout;\n\t\t\t}\n\t\t\t// arp probes\n\t\t\telse if (strncmp(ptr, \"arp-probes \", 11) == 0) {\n\t\t\t\tint arp_probes = atoi(ptr + 11);\n\t\t\t\tif (arp_probes <= 1 || arp_probes > 30)\n\t\t\t\t\tgoto errout;\n\t\t\t\tcfg_val[CFG_ARP_PROBES] = arp_probes;\n\t\t\t}\n\t\t\telse\n\t\t\t\tgoto errout;\n\n\t\t\tfree(ptr);\n\t\t}\n\nCallee: set_cpu_affinity\nvoid set_cpu_affinity(void) {\n\t// set cpu affinity\n\tcpu_set_t mask;\n\tCPU_ZERO(&mask);\n\n\tint i;\n\tuint32_t m = 1;\n\tfor (i = 0; i < 32; i++, m <<= 1) {\n\t\tif (cfg.cpus & m)\n\t\t\tCPU_SET(i, &mask);\n\t}\n\n\tif (sched_setaffinity(0, sizeof(mask), &mask) == -1)\n\t\tfwarning(\"cannot set cpu affinity\\n\");\n\n        \t// verify cpu affinity\n\tcpu_set_t mask2;\n\tCPU_ZERO(&mask2);\n\tif (sched_getaffinity(0, sizeof(mask2), &mask2) == -1)\n\t\tfwarning(\"cannot verify cpu affinity\\n\");\n        \telse if (arg_debug) {\n\t        \tif (CPU_EQUAL(&mask, &mask2))\n        \t\t\tprintf(\"CPU affinity set\\n\");\n\t\telse\n        \t\t\tprintf(\"CPU affinity not set\\n\");\n        \t}\n}\n\nCallee: drop_privs\nvoid drop_privs(int nogroups) {\n\tgid_t gid = getgid();\n\tif (arg_debug)\n\t\tprintf(\"Drop privileges: pid %d, uid %d, gid %d, nogroups %d\\n\",  getpid(), getuid(), gid, nogroups);\n\n\t// configure supplementary groups\n\tEUID_ROOT();\n\tif (gid == 0 || nogroups) {\n\t\tif (setgroups(0, NULL) < 0)\n\t\t\terrExit(\"setgroups\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"No supplementary groups\\n\");\n\t}\n\telse if (arg_noroot)\n\t\tclean_supplementary_groups(gid);\n\n\t// set uid/gid\n\tif (setresgid(-1, getgid(), getgid()) != 0)\n\t\terrExit(\"setresgid\");\n\tif (setresuid(-1, getuid(), getuid()) != 0)\n\t\terrExit(\"setresuid\");\n}\n\nCallee: exit\nstatic void exit_err_feature(const char *feature) {\n\tfprintf(stderr, \"Error: %s feature is disabled in Firejail configuration file\\n\", feature);\n\texit(1);\n}\n\nCallee: set_caps\nstatic void set_caps(void) {\n\tif (arg_caps_drop_all)\n\t\tcaps_drop_all();\n\telse if (arg_caps_drop)\n\t\tcaps_drop_list(arg_caps_list);\n\telse if (arg_caps_keep)\n\t\tcaps_keep_list(arg_caps_list);\n\telse if (arg_caps_default_filter)\n\t\tcaps_default_filter();\n\n\t// drop discretionary access control capabilities for root sandboxes\n\t// if caps.keep, the user has to set it manually in the list\n\tif (!arg_caps_keep)\n\t\tcaps_drop_dac_override();\n}\n\nCallee: close\nvoid rtnl_close(struct rtnl_handle *rth)\n{\n\tif (rth->fd >= 0) {\n\t\tclose(rth->fd);\n\t\trth->fd = -1;\n\t}\n}\n\nCallee: wait_for_other\nvoid wait_for_other(int fd) {\n\t//****************************\n\t// wait for the parent to be initialized\n\t//****************************\n\tchar childstr[BUFLEN + 1];\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tFILE* stream;\n\tstream = fdopen(newfd, \"r\");\n\t*childstr = '\\0';\n\tif (fgets(childstr, BUFLEN, stream)) {\n\t\t// remove \\n)\n\t\tchar *ptr = childstr;\n\t\twhile(*ptr !='\\0' && *ptr != '\\n')\n\t\t\tptr++;\n\t\tif (*ptr == '\\0')\n\t\t\terrExit(\"fgets\");\n\t\t*ptr = '\\0';\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: proc %d cannot sync with peer: %s\\n\",\n\t\t\tgetpid(), ferror(stream) ? strerror(errno) : \"unexpected EOF\");\n\n\t\tint status = 0;\n\t\tpid_t pid = wait(&status);\n\t\tif (pid != -1) {\n\t\t\tif (WIFEXITED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited with status %d\\n\",\n\t\t\t\t\tpid, WEXITSTATUS(status));\n\t\t\telse if (WIFSIGNALED(status))\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly killed (%s)\\n\",\n\t\t\t\t\tpid, strsignal(WTERMSIG(status)));\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Peer %d unexpectedly exited \"\n\t\t\t\t\t\"(un-decodable wait status %04x)\\n\", pid, status);\n\t\t}\n\t\texit(1);\n\t}\n\n\tif (strcmp(childstr, \"arg_noroot=0\") == 0)\n\t\targ_noroot = 0;\n\telse if (strcmp(childstr, \"arg_noroot=1\") == 0)\n\t\targ_noroot = 1;\n\telse {\n\t\tfprintf(stderr, \"Error: unexpected message from peer: %s\\n\", childstr);\n\t\texit(1);\n\t}\n\n\tfclose(stream);\n}\n\nCallee: notify_other\nvoid notify_other(int fd) {\n\tFILE* stream;\n\tint newfd = dup(fd);\n\tif (newfd == -1)\n\t\terrExit(\"dup\");\n\tstream = fdopen(newfd, \"w\");\n\tfprintf(stream, \"arg_noroot=%d\\n\", arg_noroot);\n\tfflush(stream);\n\tfclose(stream);\n}\n\nCallee: save_nogroups\nstatic void save_nogroups(void) {\n\tif (arg_nogroups == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_GROUPS_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nogroups state\\n\");\n\t\texit(1);\n\t}\n}\n\nCallee: create_ready_for_join_file\nstatic FILE *create_ready_for_join_file(void) {\n\tFILE *fp = fopen(RUN_READY_FOR_JOIN, \"wxe\");\n\tif (fp) {\n\t\tASSERT_PERMS_STREAM(fp, 0, 0, 0644);\n\t\treturn fp;\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot create %s\\n\", RUN_READY_FOR_JOIN);\n\t\texit(1);\n\t}\n}\n\nCallee: unlink\nint unlink(const char *pathname) {\n\tif (!orig_unlink)\n\t\torig_unlink = (orig_unlink_t)dlsym(RTLD_NEXT, \"unlink\");\n\n\tint rv = orig_unlink(pathname);\n\tprintf(\"%u:%s:unlink %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}\n\nCallee: seccomp_load\nint seccomp_load(const char *fname) {\n\tassert(fname);\n\n\t// open filter file\n\tint fd = open(fname, O_RDONLY);\n\tif (fd == -1)\n\t\tgoto errexit;\n\n\t// calculate the number of entries\n\tint size = lseek(fd, 0, SEEK_END);\n\tif (size == -1)\n\t\tgoto errexit;\n\tunsigned short entries = (unsigned short) size / (unsigned short) sizeof(struct sock_filter);\n\tif (arg_debug)\n\t\tprintf(\"configuring %d seccomp entries in %s\\n\", entries, fname);\n\n\t// read filter\n\tstruct sock_filter *filter = mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);\n\tif (filter == MAP_FAILED)\n\t\tgoto errexit;\n\n\t// close file\n\tclose(fd);\n\n\tFilterList *fl = malloc(sizeof(FilterList));\n\tif (!fl) {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\texit(1);\n\t}\n\tfl->next = filter_list_head;\n\tfl->prog.len = entries;\n\tfl->prog.filter = filter;\n\tfl->fname = strdup(fname);\n\tif (fl->fname == NULL)\n\t\terrExit(\"strdup\");\n\tfilter_list_head = fl;\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\tPATH_FSEC_PRINT, fname);\n\t}\n\n\t// save the file name in seccomp list\n\tif (!load_file_list_flag)\n\t\tseccomp_save_file_list(fname);\n\n\treturn 0;\nerrexit:\n\tfprintf(stderr, \"Error: cannot read %s\\n\", fname);\n\texit(1);\n}\n\nCallee: seccomp_filter_drop\nint seccomp_filter_drop(void) {\n\t// if we have multiple seccomp commands, only one of them is executed\n\t// in the following order:\n\t//\t- seccomp.drop list\n\t//\t- seccomp list\n\t//\t- seccomp\n\tif (cfg.seccomp_list_drop == NULL) {\n\t\t// default seccomp\n\t\tif (cfg.seccomp_list == NULL) {\n\t\t\tif (arg_seccomp_block_secondary)\n\t\t\t\tseccomp_filter_block_secondary();\n\t\t\telse {\n#if defined(__x86_64__)\n#if defined(__LP64__)\n\t\t\t\tseccomp_filter_32();\n#endif\n#endif\n\t\t\t}\n\t\t}\n\t\t// default seccomp filter with additional drop list\n\t\telse { // cfg.seccomp_list != NULL\n\t\t\tif (arg_seccomp_block_secondary)\n\t\t\t\tseccomp_filter_block_secondary();\n\t\t\telse {\n#if defined(__x86_64__)\n#if defined(__LP64__)\n\t\t\t\tseccomp_filter_32();\n#endif\n#endif\n\t\t\t}\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Build default+drop seccomp filter\\n\");\n\n\t\t\t// build the seccomp filter as a regular user\n\t\t\tint rv;\n\t\t\tif (arg_allow_debuggers)\n\t\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 7,\n\t\t\t\t\t      PATH_FSECCOMP, \"default\", \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list, \"allow-debuggers\");\n\t\t\telse\n\t\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 6,\n\t\t\t\t\t      PATH_FSECCOMP, \"default\", \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list);\n\t\t\tif (rv)\n\t\t\t\texit(rv);\n\n\t\t\t// optimize the new filter\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2, PATH_FSEC_OPTIMIZE, RUN_SECCOMP_CFG);\n\t\t\tif (rv)\n\t\t\t\texit(rv);\n\t\t}\n\t}\n\n\t// drop list without defaults - secondary filters are not installed\n\t// except when secondary architectures are explicitly blocked\n\telse { // cfg.seccomp_list_drop != NULL\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tseccomp_filter_block_secondary();\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build drop seccomp filter\\n\");\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv;\n\t\tif (arg_allow_debuggers)\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 6,\n\t\t\t\t      PATH_FSECCOMP, \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_drop,  \"allow-debuggers\");\n\t\telse\n\t\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\t\tPATH_FSECCOMP, \"drop\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_drop);\n\n\t\tif (rv)\n\t\t\texit(rv);\n\n\t\t// optimize the drop filter\n\t\trv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2, PATH_FSEC_OPTIMIZE, RUN_SECCOMP_CFG);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\n\t// load the filter\n\tif (seccomp_load(RUN_SECCOMP_CFG) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"seccomp filter configured\\n\");\n\t}\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tstruct stat st;\n\t\tif (stat(RUN_SECCOMP_POSTEXEC, &st) != -1 && st.st_size != 0) {\n\t\t\tprintf(\"configuring postexec seccomp filter in %s\\n\", RUN_SECCOMP_POSTEXEC);\n\t\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\t\t  PATH_FSEC_PRINT, RUN_SECCOMP_POSTEXEC);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nCallee: seccomp_filter_keep\nint seccomp_filter_keep(void) {\n\t// secondary filters are not installed except when secondary\n\t// architectures are explicitly blocked\n\tif (arg_seccomp_block_secondary)\n\t\tseccomp_filter_block_secondary();\n\n\tif (arg_debug)\n\t\tprintf(\"Build keep seccomp filter\\n\");\n\n\t// build the seccomp filter as a regular user\n\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t PATH_FSECCOMP, \"keep\", RUN_SECCOMP_CFG, RUN_SECCOMP_POSTEXEC, cfg.seccomp_list_keep);\n\n\tif (rv) {\n\t\tfprintf(stderr, \"Error: cannot configure seccomp filter\\n\");\n\t\texit(rv);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"seccomp filter configured\\n\");\n\n\t// load the filter\n\tif (seccomp_load(RUN_SECCOMP_CFG) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"seccomp filter configured\\n\");\n\t}\n\n\tif (arg_debug && access(PATH_FSEC_PRINT, X_OK) == 0) {\n\t\tstruct stat st;\n\t\tif (stat(RUN_SECCOMP_POSTEXEC, &st) != -1 && st.st_size != 0) {\n\t\t\tprintf(\"configuring postexec seccomp filter in %s\\n\", RUN_SECCOMP_POSTEXEC);\n\t\t\tsbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 2,\n\t\t\t\t  PATH_FSEC_PRINT, RUN_SECCOMP_POSTEXEC);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nCallee: protocol_filter_save\nvoid protocol_filter_save(void) {\n\t// save protocol filter configuration in PROTOCOL_CFG\n\tFILE *fp = fopen(RUN_PROTOCOL_CFG, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\\n\", cfg.protocol);\n\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\tfclose(fp);\n}\n\nCallee: save_cgroup\nvoid save_cgroup(void) {\n\tif (cfg.cgroup == NULL)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CGROUP_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%s\", cfg.cgroup);\n\t\tfflush(0);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\t\tif (fclose(fp))\n\t\t\tgoto errout;\n\t}\n\telse\n\t\tgoto errout;\n\n\treturn;\n\nerrout:\n\tfprintf(stderr, \"Error: cannot save cgroup\\n\");\n\texit(1);\n}\n\nCallee: save_cpu\nvoid save_cpu(void) {\n\tif (cfg.cpus == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_CPU_CFG, \"w\");\n\tif (fp) {\n\t\tfprintf(fp, \"%x\\n\", cfg.cpus);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0600);\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save cpu affinity mask\\n\");\n\t\texit(1);\n\t}\n}\n\nCallee: save_nonewprivs\nstatic void save_nonewprivs(void) {\n\tif (arg_nonewprivs == 0)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_NONEWPRIVS_CFG, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"\\n\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save nonewprivs state\\n\");\n\t\texit(1);\n\t}\n}\n\nCallee: save_umask\nstatic void save_umask(void) {\n\tFILE *fp = fopen(RUN_UMASK_FILE, \"wxe\");\n\tif (fp) {\n\t\tfprintf(fp, \"%o\\n\", orig_umask);\n\t\tSET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644\n\t\tfclose(fp);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Error: cannot save umask\\n\");\n\t\texit(1);\n\t}\n}\n\nCallee: x11_xorg\nvoid x11_xorg(void) {\n#ifdef HAVE_X11\n\n\t// check xauth utility is present in the system\n\tstruct stat s;\n\tif (stat(\"/usr/bin/xauth\", &s) == -1) {\n\t\tfprintf(stderr, \"Error: xauth utility not found in /usr/bin. Please install it:\\n\"\n\t\t\t\"   Debian/Ubuntu/Mint: sudo apt-get install xauth\\n\");\n\t\texit(1);\n\t}\n\tif (s.st_uid != 0 && s.st_gid != 0) {\n\t\tfprintf(stderr, \"Error: invalid /usr/bin/xauth executable\\n\");\n\t\texit(1);\n\t}\n\n\t// get DISPLAY env\n\tchar *display = getenv(\"DISPLAY\");\n\tif (!display) {\n\t\tfputs(\"Error: --x11=xorg requires an 'outer' X11 server to use.\\n\", stderr);\n\t\texit(1);\n\t}\n\n\t// temporarily mount a tempfs on top of /tmp directory\n\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\terrExit(\"mounting /tmp\");\n\n\t// create the temporary .Xauthority file\n\tif (arg_debug)\n\t\tprintf(\"Generating a new .Xauthority file\\n\");\n\tchar tmpfname[] = \"/tmp/.tmpXauth-XXXXXX\";\n\tint fd = mkstemp(tmpfname);\n\tif (fd == -1) {\n\t\tfprintf(stderr, \"Error: cannot create .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tif (fchown(fd, getuid(), getgid()) == -1)\n\t\terrExit(\"chown\");\n\tclose(fd);\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\tdrop_privs(1);\n\t\tclearenv();\n#ifdef HAVE_GCOV\n\t\t__gcov_flush();\n#endif\n\t\texeclp(\"/usr/bin/xauth\", \"/usr/bin/xauth\", \"-v\", \"-f\", tmpfname,\n\t\t\t\"generate\", display, \"MIT-MAGIC-COOKIE-1\", \"untrusted\", NULL);\n\n\t\t_exit(127);\n\t}\n\n\t// wait for the xauth process to finish\n\tint status;\n\tif (waitpid(child, &status, 0) != child)\n\t\terrExit(\"waitpid\");\n\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t/* success */\n\t}\n\telse if (WIFEXITED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: exit %d\\n\",\n\t\t\tWEXITSTATUS(status));\n\t\texit(1);\n\t}\n\telse if (WIFSIGNALED(status)) {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: xauth: %s\\n\",\n\t\t\tstrsignal(WTERMSIG(status)));\n\t\texit(1);\n\t}\n\telse {\n\t\tfprintf(stderr, \"Failed to create untrusted X cookie: \"\n\t\t\t\"xauth: un-decodable exit status %04x\\n\", status);\n\t\texit(1);\n\t}\n\n\t// move the temporary file in RUN_XAUTHORITY_SEC_FILE in order to have it deleted\n\t// automatically when the sandbox is closed (rename doesn't work)\n\t\t\t\t\t\t  // root needed\n\tif (copy_file(tmpfname, RUN_XAUTHORITY_SEC_FILE, getuid(), getgid(), 0600)) {\n\t\tfprintf(stderr, \"Error: cannot create the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\t/* coverity[toctou] */\n\tunlink(tmpfname);\n\tumount(\"/tmp\");\n\n\t// remount RUN_XAUTHORITY_SEC_FILE noexec, nodev, nosuid\n\tfs_noexec(RUN_XAUTHORITY_SEC_FILE);\n\n\t// Ensure there is already a file in the usual location, so that bind-mount below will work.\n\tchar *dest;\n\tif (asprintf(&dest, \"%s/.Xauthority\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(dest, &s) == -1) {\n\t\ttouch_file_as_user(dest, 0600);\n\t\tif (stat(dest, &s) == -1) {\n\t\t\tfprintf(stderr, \"Error: cannot create %s\\n\", dest);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// get a file descriptor for .Xauthority\n\tfd = safe_fd(dest, O_PATH|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if the actual mount destination is a user owned regular file\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (!S_ISREG(s.st_mode) || s.st_uid != getuid()) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: .Xauthority is a symbolic link\\n\");\n\t\telse\n\t\t\tfprintf(stderr, \"Error: .Xauthority is not a user owned regular file\\n\");\n\t\texit(1);\n\t}\n\t// preserve a read-only mount\n\tstruct statvfs vfs;\n\tif (fstatvfs(fd, &vfs) == -1)\n\t\terrExit(\"fstatvfs\");\n\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\tfs_rdonly(RUN_XAUTHORITY_SEC_FILE);\n\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(RUN_XAUTHORITY_SEC_FILE, proc, \"none\", MS_BIND, \"mode=0600\") == -1) {\n\t\tfprintf(stderr, \"Error: cannot mount the new .Xauthority file\\n\");\n\t\texit(1);\n\t}\n\tfree(proc);\n\tclose(fd);\n\t// check /proc/self/mountinfo to confirm the mount is ok\n\tMountData *mptr = get_last_mount();\n\tif (strcmp(mptr->dir, dest) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\terrLogExit(\"invalid .Xauthority mount\");\n\n\tASSERT_PERMS(dest, getuid(), getgid(), 0600);\n\tfree(dest);\n#endif\n}\n\nCallee: fs_x11\nvoid fs_x11(void) {\n#ifdef HAVE_X11\n\tint display = x11_display();\n\tif (display <= 0)\n\t\treturn;\n\n\tchar *x11file;\n\tif (asprintf(&x11file, \"/tmp/.X11-unix/X%d\", display) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat x11stat;\n\tif (stat(x11file, &x11stat) == -1 || !S_ISSOCK(x11stat.st_mode)) {\n\t\tfree(x11file);\n\t\treturn;\n\t}\n\n\tif (arg_debug || arg_debug_whitelists)\n\t\tfprintf(stderr, \"Masking all X11 sockets except %s\\n\", x11file);\n\n\t// Move the real /tmp/.X11-unix to a scratch location\n\t// so we can still access x11file after we mount a\n\t// tmpfs over /tmp/.X11-unix.\n\tint rv = mkdir(RUN_WHITELIST_X11_DIR, 0700);\n\tif (rv == -1)\n\t\terrExit(\"mkdir\");\n\tif (set_perms(RUN_WHITELIST_X11_DIR, 0, 0, 0700))\n\t\terrExit(\"set_perms\");\n\n\tif (mount(\"/tmp/.X11-unix\", RUN_WHITELIST_X11_DIR, 0, MS_BIND|MS_REC, 0) < 0)\n\t\terrExit(\"mount bind\");\n\n\t// This directory must be mode 1777, or Xlib will barf.\n\tif (mount(\"tmpfs\", \"/tmp/.X11-unix\", \"tmpfs\",\n\t\tMS_NOSUID | MS_NOEXEC | MS_NODEV | MS_STRICTATIME,\n\t\t\"mode=1777,uid=0,gid=0\") < 0)\n\t\terrExit(\"mounting tmpfs on /tmp/.X11-unix\");\n\tfs_logger(\"tmpfs /tmp/.X11-unix\");\n\n\t// create an empty file which will have the desired socket bind-mounted over it\n\tint fd = open(x11file, O_RDWR|O_CREAT|O_EXCL, x11stat.st_mode & ~S_IFMT);\n\tif (fd < 0)\n\t\terrExit(x11file);\n\tif (fchown(fd, x11stat.st_uid, x11stat.st_gid))\n\t\terrExit(\"fchown\");\n\tclose(fd);\n\n\t// do the mount\n\tchar *wx11file;\n\tif (asprintf(&wx11file, \"%s/X%d\", RUN_WHITELIST_X11_DIR, display) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(wx11file, x11file, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"whitelist\", x11file);\n\n\tfree(x11file);\n\tfree(wx11file);\n\n\t// block access to RUN_WHITELIST_X11_DIR\n\tif (mount(RUN_RO_DIR, RUN_WHITELIST_X11_DIR, 0, MS_BIND, 0) < 0)\n\t\terrExit(\"mount\");\n\tfs_logger2(\"blacklist\", RUN_WHITELIST_X11_DIR);\n#endif\n}\n\nCallee: EUID_ROOT\nstatic inline void EUID_ROOT(void) {\n\tint rv = seteuid(0);\n\trv |= setegid(0);\n\t(void) rv;\n}\n\nCallee: chdir\nint fchdir(int fd) {\n#ifdef DEBUG\n\tprintf(\"%s %d\\n\", __FUNCTION__, fd);\n#endif\n\tif (!orig_fchdir)\n\t\torig_fchdir = (orig_fchdir_t)dlsym(RTLD_NEXT, \"fchdir\");\n\n\tfree(cwd);\n\tchar *pathname=malloc(PATH_MAX);\n\tif (pathname) {\n\t\tif (snprintf(pathname,PATH_MAX,\"/proc/self/fd/%d\", fd)>0) {\n\t\t\tcwd = realpath(pathname, NULL);\n\t\t} else {\n\t\t\tcwd = NULL;\n\t\t\tfprintf(stderr, \"Error: snprintf failed\\n\");\n\t\t}\n\t\tfree(pathname);\n\t} else {\n\t\tfprintf(stderr, \"Error: cannot allocate memory\\n\");\n\t\tcwd = NULL;\n\t}\n\n\tint rv = orig_fchdir(fd);\n\treturn rv;\n}\n\nCallee: stat\nint lstat64(const char *pathname, struct stat64 *buf) {\n\tif (!orig_lstat64)\n\t\torig_lstat64 = (orig_lstat64_t)dlsym(RTLD_NEXT, \"lstat64\");\n\n\tint rv = orig_lstat64(pathname, buf);\n\tprintf(\"%u:%s:lstat64 %s:%d\\n\", pid(), name(), pathname, rv);\n\treturn rv;\n}\n\nCallee: EUID_USER\nstatic inline void EUID_USER(void) {\n\tif (seteuid(firejail_uid) == -1)\n\t\terrExit(\"seteuid\");\n\tif (setegid(firejail_gid) == -1)\n\t\terrExit(\"setegid\");\n}\n\nCallee: fs_logger_change_owner\nvoid fs_logger_change_owner(void) {\n\tif (chown(RUN_FSLOGGER_FILE, 0, 0) == -1)\n\t\terrExit(\"chown\");\n}\n\nCallee: fs_logger_print\nvoid fs_logger_print(void) {\n\tif (!head)\n\t\treturn;\n\n\tFILE *fp = fopen(RUN_FSLOGGER_FILE, \"a\");\n\tif (!fp) {\n\t\tperror(\"fopen\");\n\t\treturn;\n\t}\n\tSET_PERMS_STREAM_NOERR(fp, getuid(), getgid(), 0644);\n\n\tFsMsg *ptr = head;\n\twhile (ptr) {\n\t\tfprintf(fp, \"%s\\n\", ptr->msg);\n\t\tFsMsg *next = ptr->next;\n\t\t// remove message\n\t\tfree(ptr->msg);\n\t\tfree(ptr);\n\t\tptr = next;\n\t}\n\thead = NULL;\n\tfclose(fp);\n}\n\nCallee: fs_resolvconf\nvoid fs_resolvconf(void) {\n\tif (cfg.dns1 == NULL)\n\t\treturn;\n\n\tif (arg_debug)\n\t\tprintf(\"mirroring /etc directory\\n\");\n\tif (mkdir(RUN_DNS_ETC, 0755))\n\t\terrExit(\"mkdir\");\n\tfs_logger(\"tmpfs /etc\");\n\n\tDIR *dir = opendir(\"/etc\");\n\tif (!dir)\n\t\terrExit(\"opendir\");\n\n\tstruct stat s;\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0)\n\t\t\tcontinue;\n\t\t// for resolv.conf we create a brand new file\n\t\tif (strcmp(entry->d_name, \"resolv.conf\") == 0)\n\t\t\tcontinue;\n//\t\tprintf(\"linking %s\\n\", entry->d_name);\n\n\t\tchar *src;\n\t\tif (asprintf(&src, \"/etc/%s\", entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (stat(src, &s) != 0) {\n\t\t\tfree(src);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *dest;\n\t\tif (asprintf(&dest, \"%s/%s\", RUN_DNS_ETC, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\n\t\tint symlink_done = 0;\n\t\tif (is_link(src)) {\n\t\t\tchar *rp =realpath(src, NULL);\n\t\t\tif (rp == NULL) {\n\t\t\t\tfree(src);\n\t\t\t\tfree(dest);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (symlink(rp, dest))\n\t\t\t\terrExit(\"symlink\");\n\t\t\telse\n\t\t\t\tsymlink_done = 1;\n\t\t}\n\t\telse if (S_ISDIR(s.st_mode))\n\t\t\tcreate_empty_dir_as_root(dest, s.st_mode);\n\t\telse\n\t\t\tcreate_empty_file_as_root(dest, s.st_mode);\n\n\t\t// bind-mount src on top of dest\n\t\tif (!symlink_done) {\n\t\t\tif (mount(src, dest, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind mirroring /etc\");\n\t\t}\n\t\tfs_logger2(\"clone\", src);\n\n\t\tfree(src);\n\t\tfree(dest);\n\t}\n\tclosedir(dir);\n\n\t// mount bind our private etc directory on top of /etc\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of /etc\\n\", RUN_DNS_ETC);\n\tif (mount(RUN_DNS_ETC, \"/etc\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind mirroring /etc\");\n\tfs_logger(\"mount /etc\");\n\n\tif (arg_debug)\n\t\tprintf(\"Creating a new /etc/resolv.conf file\\n\");\n\tFILE *fp = fopen(\"/etc/resolv.conf\", \"w\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: cannot create /etc/resolv.conf file\\n\");\n\t\texit(1);\n\t}\n\n\tif (cfg.dns1)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns1);\n\tif (cfg.dns2)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns2);\n\tif (cfg.dns3)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns3);\n\tif (cfg.dns4)\n\t\tfprintf(fp, \"nameserver %s\\n\", cfg.dns4);\n\n\t// mode and owner\n\tSET_PERMS_STREAM(fp, 0, 0, 0644);\n\n\tfclose(fp);\n\n\tfs_logger(\"create /etc/resolv.conf\");\n}\n\nCallee: fs_trace\nvoid fs_trace(void) {\n\t// create the new ld.so.preload file and mount-bind it\n\tif (arg_debug)\n\t\tprintf(\"Create the new ld.so.preload file\\n\");\n\n\tFILE *fp = fopen(RUN_LDPRELOAD_FILE, \"w\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tconst char *prefix = RUN_FIREJAIL_LIB_DIR;\n\n\tif (arg_trace) {\n\t\tfprintf(fp, \"%s/libtrace.so\\n\", prefix);\n\t}\n\telse if (arg_tracelog) {\n\t\tfprintf(fp, \"%s/libtracelog.so\\n\", prefix);\n\t\tfmessage(\"Blacklist violations are logged to syslog\\n\");\n\t}\n\tif (arg_seccomp_postexec) {\n\t\tfprintf(fp, \"%s/libpostexecseccomp.so\\n\", prefix);\n\t\tfmessage(\"Post-exec seccomp protector enabled\\n\");\n\t}\n\n\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\tfclose(fp);\n\n\t// mount the new preload file\n\tif (arg_debug)\n\t\tprintf(\"Mount the new ld.so.preload file\\n\");\n\tif (mount(RUN_LDPRELOAD_FILE, \"/etc/ld.so.preload\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind ld.so.preload\");\n\tfs_logger(\"create /etc/ld.so.preload\");\n}\n\nCallee: fs_dev_disable_video\nvoid fs_dev_disable_video(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_VIDEO)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}\n\nCallee: fs_dev_disable_u2f\nvoid fs_dev_disable_u2f(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_U2F)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}\n\nCallee: fs_dev_disable_dvd\nvoid fs_dev_disable_dvd(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_DVD)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}\n\nCallee: fs_dev_disable_tv\nvoid fs_dev_disable_tv(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_TV)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}\n\nCallee: fs_dev_disable_3d\nvoid fs_dev_disable_3d(void) {\n\tint i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_3D)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n}\n\nCallee: pulseaudio_init\nvoid pulseaudio_init(void) {\n\tstruct stat s;\n\n\t// do we have pulseaudio in the system?\n\tif (stat(\"/etc/pulse/client.conf\", &s) == -1) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"/etc/pulse/client.conf not found\\n\");\n\t\treturn;\n\t}\n\n\t// create the new user pulseaudio directory\n\tif (mkdir(RUN_PULSE_DIR, 0700) == -1)\n\t\terrExit(\"mkdir\");\n\t// mount it nosuid, noexec, nodev\n\tfs_noexec(RUN_PULSE_DIR);\n\n\t// create the new client.conf file\n\tchar *pulsecfg = NULL;\n\tif (asprintf(&pulsecfg, \"%s/client.conf\", RUN_PULSE_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (copy_file(\"/etc/pulse/client.conf\", pulsecfg, -1, -1, 0644)) // root needed\n\t\terrExit(\"copy_file\");\n\tFILE *fp = fopen(pulsecfg, \"a\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tfprintf(fp, \"%s\", \"\\nenable-shm = no\\n\");\n\tSET_PERMS_STREAM(fp, getuid(), getgid(), 0644);\n\tfclose(fp);\n\t// hand over the directory to the user\n\tif (set_perms(RUN_PULSE_DIR, getuid(), getgid(), 0700))\n\t\terrExit(\"set_perms\");\n\n\t// create ~/.config/pulse directory if not present\n\tchar *homeusercfg;\n\tif (asprintf(&homeusercfg, \"%s/.config\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\tfree(homeusercfg);\n\n\tif (asprintf(&homeusercfg, \"%s/.config/pulse\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (lstat(homeusercfg, &s) == -1) {\n\t\tif (create_empty_dir_as_user(homeusercfg, 0700))\n\t\t\tfs_logger2(\"create\", homeusercfg);\n\t}\n\telse if (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfprintf(stderr, \"Error: %s is a symbolic link\\n\", homeusercfg);\n\t\telse\n\t\t\tfprintf(stderr, \"Error: %s is not a directory\\n\", homeusercfg);\n\t\texit(1);\n\t}\n\n\t// if we have ~/.config/pulse mount the new directory, else set environment variable.\n\tif (stat(homeusercfg, &s) == 0) {\n\t\t// get a file descriptor for ~/.config/pulse, fails if there is any symlink\n\t\tint fd = safe_fd(homeusercfg, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\t// confirm the actual mount destination is owned by the user\n\t\tif (fstat(fd, &s) == -1)\n\t\t\terrExit(\"fstat\");\n\t\tif (s.st_uid != getuid()) {\n\t\t\tfprintf(stderr, \"Error: %s is not owned by the current user\\n\", homeusercfg);\n\t\t\texit(1);\n\t\t}\n\t\t// preserve a read-only mount\n\t\tstruct statvfs vfs;\n\t\tif (fstatvfs(fd, &vfs) == -1)\n\t\t\terrExit(\"fstatvfs\");\n\t\tif ((vfs.f_flag & MS_RDONLY) == MS_RDONLY)\n\t\t\tfs_rdonly(RUN_PULSE_DIR);\n\t\t// mount via the link in /proc/self/fd\n\t\tchar *proc;\n\t\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(RUN_PULSE_DIR, proc, \"none\", MS_BIND, NULL) < 0)\n\t\t\terrExit(\"mount pulseaudio\");\n\t\tfs_logger2(\"tmpfs\", homeusercfg);\n\t\tfree(proc);\n\t\tclose(fd);\n\t\t// check /proc/self/mountinfo to confirm the mount is ok\n\t\tMountData *mptr = get_last_mount();\n\t\tif (strcmp(mptr->dir, homeusercfg) != 0 || strcmp(mptr->fstype, \"tmpfs\") != 0)\n\t\t\terrLogExit(\"invalid pulseaudio mount\");\n\n\t\tchar *p;\n\t\tif (asprintf(&p, \"%s/client.conf\", homeusercfg) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tfs_logger2(\"create\", p);\n\t\tfree(p);\n\t}\n\n\telse {\n\t\t// set environment\n\t\tif (setenv(\"PULSE_CLIENTCONFIG\", pulsecfg, 1) < 0)\n\t\t\terrExit(\"setenv\");\n\t}\n\n\tfree(pulsecfg);\n\tfree(homeusercfg);\n}\n\nCallee: fs_dev_disable_sound\nvoid fs_dev_disable_sound(void) {\n\tunsigned i = 0;\n\twhile (dev[i].dev_fname != NULL) {\n\t\tif (dev[i].type == DEV_SOUND)\n\t\t\tdisable_file_or_dir(dev[i].dev_fname);\n\t\ti++;\n\t}\n\n\t// disable all jack sockets in /dev/shm\n\tglob_t globbuf;\n\tint globerr = glob(\"/dev/shm/jack*\", GLOB_NOSORT, NULL, &globbuf);\n\tif (globerr)\n\t\treturn;\n\n\tfor (i = 0; i < globbuf.gl_pathc; i++) {\n\t\tchar *path = globbuf.gl_pathv[i];\n\t\tassert(path);\n\t\tif (is_link(path)) {\n\t\t\tfwarning(\"skipping nosound for %s because it is a symbolic link\\n\", path);\n\t\t\tcontinue;\n\t\t}\n\t\tdisable_file_or_dir(path);\n\t}\n\tglobfree(&globbuf);\n}\n\nCallee: pulseaudio_disable\nvoid pulseaudio_disable(void) {\n\tif (arg_debug)\n\t\tprintf(\"disable pulseaudio\\n\");\n\t// blacklist user config directory\n\tdisable_file_path(cfg.homedir, \".config/pulse\");\n\n\n\t// blacklist pulseaudio socket in XDG_RUNTIME_DIR\n\tchar *name = getenv(\"XDG_RUNTIME_DIR\");\n\tif (name)\n\t\tdisable_file_path(name, \"pulse/native\");\n\n\t// try the default location anyway\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tdisable_file_path(path, \"pulse/native\");\n\tfree(path);\n\n\n\n\t// blacklist any pulse* file in /tmp directory\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tdisable_file_path(\"/tmp\", entry->d_name);\n\t\t}\n\t}\n\n\tclosedir(dir);\n}\n\nCallee: fs_blacklist\nvoid fs_blacklist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tsize_t noblacklist_c = 0;\n\tsize_t noblacklist_m = 32;\n\tchar **noblacklist = calloc(noblacklist_m, sizeof(*noblacklist));\n\n\tif (noblacklist == NULL)\n\t\terrExit(\"failed allocating memory for noblacklist entries\");\n\n\twhile (entry) {\n\t\tOPERATION op = OPERATION_MAX;\n\t\tchar *ptr;\n\n\t\t// whitelist commands handled by fs_whitelist()\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0 ||\n\t\t    strncmp(entry->data, \"nowhitelist \", 12) == 0 ||\n\t\t   *entry->data == '\\0') {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process bind command\n\t\tif (strncmp(entry->data, \"bind \", 5) == 0)  {\n\t\t\tstruct stat s;\n\t\t\tchar *dname1 = entry->data + 5;\n\t\t\tchar *dname2 = split_comma(dname1);\n\t\t\tif (dname2 == NULL ||\n\t\t\t    stat(dname1, &s) == -1 ||\n\t\t\t    stat(dname2, &s) == -1) {\n\t\t\t\tfprintf(stderr, \"Error: invalid bind command, directory missing\\n\");\n\t\t\t\tentry = entry->next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// mount --bind olddir newdir\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", dname1, dname2);\n\t\t\t// preserve dname2 mode and ownership\n\t\t\tif (mount(dname1, dname2, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\t/* coverity[toctou] */\n\t\t\tif (set_perms(dname2,  s.st_uid, s.st_gid,s.st_mode))\n\t\t\t\terrExit(\"set_perms\");\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Process noblacklist command\n\t\tif (strncmp(entry->data, \"noblacklist \", 12) == 0) {\n\t\t\tchar **enames;\n\t\t\tint i;\n\n\t\t\tif (strncmp(entry->data + 12, \"${PATH}\", 7) == 0) {\n\t\t\t\t// expand ${PATH} macro\n\t\t\t\tchar **paths = build_paths();\n\t\t\t\tunsigned int npaths = count_paths();\n\t\t\t\tenames = calloc(npaths, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\n\t\t\t\tfor (i = 0; paths[i]; i++) {\n\t\t\t\t\tif (asprintf(&enames[i], \"%s%s\", paths[i],\n\t\t\t\t\t\tentry->data + 19) == -1)\n\t\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t}\n\t\t\t\tassert(enames[npaths-1] == 0);\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// expand ${HOME} macro if found or pass as is\n\t\t\t\tenames = calloc(2, sizeof(char *));\n\t\t\t\tif (!enames)\n\t\t\t\t\terrExit(\"calloc\");\n\t\t\t\tenames[0] = expand_macros(entry->data + 12);\n\t\t\t\tassert(enames[1] == 0);\n\t\t\t}\n\n\t\t\tfor (i = 0; enames[i]; i++) {\n\t\t\t\tif (noblacklist_c >= noblacklist_m) {\n\t\t\t\t\tnoblacklist_m *= 2;\n\t\t\t\t\tnoblacklist = realloc(noblacklist, sizeof(*noblacklist) * noblacklist_m);\n\t\t\t\t\tif (noblacklist == NULL)\n\t\t\t\t\t\terrExit(\"failed increasing memory for noblacklist entries\");\n\t\t\t\t}\n\t\t\t\tnoblacklist[noblacklist_c++] = enames[i];\n\t\t\t}\n\n\t\t\tfree(enames);\n\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// process blacklist command\n\t\tif (strncmp(entry->data, \"blacklist \", 10) == 0)  {\n\t\t\tptr = entry->data + 10;\n\t\t\top = BLACKLIST_FILE;\n\t\t}\n\t\telse if (strncmp(entry->data, \"blacklist-nolog \", 16) == 0)  {\n\t\t\tptr = entry->data + 16;\n\t\t\top = BLACKLIST_NOLOG;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-only \", 10) == 0) {\n\t\t\tptr = entry->data + 10;\n\t\t\top = MOUNT_READONLY;\n\t\t}\n\t\telse if (strncmp(entry->data, \"read-write \", 11) == 0) {\n\t\t\tptr = entry->data + 11;\n\t\t\top = MOUNT_RDWR;\n\t\t}\n\t\telse if (strncmp(entry->data, \"noexec \", 7) == 0) {\n\t\t\tptr = entry->data + 7;\n\t\t\top = MOUNT_NOEXEC;\n\t\t}\n\t\telse if (strncmp(entry->data, \"tmpfs \", 6) == 0) {\n\t\t\tptr = entry->data + 6;\n\t\t\top = MOUNT_TMPFS;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkdir \", 6) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkdir(entry->data + 6);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse if (strncmp(entry->data, \"mkfile \", 7) == 0) {\n\t\t\tEUID_USER();\n\t\t\tfs_mkfile(entry->data + 7);\n\t\t\tEUID_ROOT();\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tfprintf(stderr, \"Error: invalid profile line %s\\n\", entry->data);\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// replace home macro in blacklist array\n\t\tchar *new_name = expand_macros(ptr);\n\t\tptr = new_name;\n\n\t\t// expand path macro - look for the file in /usr/local/bin,  /usr/local/sbin, /bin, /usr/bin, /sbin and  /usr/sbin directories\n\t\tif (ptr) {\n\t\t\tif (strncmp(ptr, \"${PATH}\", 7) == 0) {\n\t\t\t\tchar *fname = ptr + 7;\n\t\t\t\tsize_t fname_len = strlen(fname);\n\t\t\t\tchar **paths = build_paths(); //{\"/usr/local/bin\", \"/usr/local/sbin\", \"/bin\", \"/usr/bin/\", \"/sbin\", \"/usr/sbin\", NULL};\n\t\t\t\tint i = 0;\n\t\t\t\twhile (paths[i] != NULL) {\n\t\t\t\t\tchar *path = paths[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tchar newname[strlen(path) + fname_len + 1];\n\t\t\t\t\tsprintf(newname, \"%s%s\", path, fname);\n\t\t\t\t\tglobbing(op, newname, (const char**)noblacklist, noblacklist_c);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tglobbing(op, ptr, (const char**)noblacklist, noblacklist_c);\n\t\t}\n\n\t\tif (new_name)\n\t\t\tfree(new_name);\n\t\tentry = entry->next;\n\t}\n\n\tsize_t i;\n#ifdef TEST_NO_BLACKLIST_MATCHING\n\t// noblacklist checking\n\tfor (i = 0; i < nbcheck_size; i++)\n\t\tif (!arg_quiet && !nbcheck[i])\n\t\t\tprintf(\"TESTING warning: noblacklist %s not matched by a proper blacklist command in disable*.inc\\n\",\n\t\t\t\t noblacklist[i]);\n\n\t// free memory\n\tif (nbcheck) {\n\t\tfree(nbcheck);\n\t\tnbcheck = NULL;\n\t\tnbcheck_size = 0;\n\t}\n#endif\n\tfor (i = 0; i < noblacklist_c; i++)\n\t\tfree(noblacklist[i]);\n\tfree(noblacklist);\n}\n\nCallee: fs_whitelist\nvoid fs_whitelist(void) {\n\tProfileEntry *entry = cfg.profile;\n\tif (!entry)\n\t\treturn;\n\n\tif (asprintf(&runuser, \"/run/user/%u\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\trunuser_len = strlen(runuser);\n\thomedir_len = strlen(cfg.homedir);\n\n\tchar *new_name = NULL;\n\tint home_dir = 0;\t// /home/user directory flag\n\tint tmp_dir = 0;\t// /tmp directory flag\n\tint media_dir = 0;\t// /media directory flag\n\tint mnt_dir = 0;\t// /mnt directory flag\n\tint var_dir = 0;\t\t// /var directory flag\n\tint dev_dir = 0;\t\t// /dev directory flag\n\tint opt_dir = 0;\t\t// /opt directory flag\n\tint srv_dir = 0;                // /srv directory flag\n\tint etc_dir = 0;                // /etc directory flag\n\tint share_dir = 0;                // /usr/share directory flag\n\tint module_dir = 0;                // /sys/module directory flag\n\tint run_dir = 0;                // /run/user/$uid directory flag\n\n\tsize_t nowhitelist_c = 0;\n\tsize_t nowhitelist_m = 32;\n\tchar **nowhitelist = calloc(nowhitelist_m, sizeof(*nowhitelist));\n\tif (nowhitelist == NULL)\n\t\terrExit(\"failed allocating memory for nowhitelist entries\");\n\n\t// verify whitelist files, extract symbolic links, etc.\n\tEUID_USER();\n\tstruct stat s;\n\twhile (entry) {\n\t\tint nowhitelist_flag = 0;\n\n\t\t// handle only whitelist and nowhitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10) == 0)\n\t\t\tnowhitelist_flag = 0;\n\t\telse if (strncmp(entry->data, \"nowhitelist \", 12) == 0)\n\t\t\tnowhitelist_flag = 1;\n\t\telse {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\t\tchar *dataptr = (nowhitelist_flag)? entry->data + 12: entry->data + 10;\n\n\t\t// replace ~/ or ${HOME} into /home/username or resolve macro\n\t\tnew_name = expand_macros(dataptr);\n\t\tassert(new_name);\n\n\t\t// mount empty home directory if resolving the macro was not successful\n\t\tif (is_macro(new_name) && macro_id(new_name) > -1) {\n\t\t\t// no warning if home does not exist (e.g. in a chroot)\n\t\t\tif (stat(cfg.homedir, &s) == 0 && !nowhitelist_flag && !arg_private) {\n\t\t\t\thome_dir = 1;\n\t\t\t\tif (!arg_quiet) {\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t\tfprintf(stderr, \"*** Warning: cannot whitelist %s directory\\n\", new_name);\n\t\t\t\t\tfprintf(stderr, \"*** Any file saved in this directory will be lost when the sandbox is closed.\\n\");\n\t\t\t\t\tfprintf(stderr, \"***\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// remove trailing slashes and single dots\n\t\tif (!nowhitelist_flag)\n\t\t\ttrim_trailing_slash_or_dot(new_name);\n\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tfprintf(stderr, \"Debug %d: new_name #%s#, %s\\n\", __LINE__, new_name, (nowhitelist_flag)? \"nowhitelist\": \"whitelist\");\n\n\t\t// valid path referenced to filesystem root\n\t\tif (*new_name != '/') {\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: \\n\", __LINE__);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// extract the absolute path of the file\n\t\t// realpath function will fail with ENOENT if the file is not found or with EACCES if user has no permission\n\t\t// special processing for /dev/fd, /dev/stdin, /dev/stdout and /dev/stderr\n\t\tchar *fname;\n\t\tif (strcmp(new_name, \"/dev/fd\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd\");\n\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/0\");\n\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/1\");\n\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0)\n\t\t\tfname = strdup(\"/proc/self/fd/2\");\n\t\telse\n\t\t\tfname = realpath(new_name, NULL);\n\n\t\tif (!fname) {\n\t\t\t// file not found, blank the entry in the list and continue\n\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\tprintf(\"Removed whitelist/nowhitelist path: %s\\n\", entry->data);\n\t\t\t\tprintf(\"\\texpanded: %s\\n\", new_name);\n\t\t\t\tprintf(\"\\treal path: (null)\\n\");\n\t\t\t\tprintf(\"\\t\");fflush(0);\n\t\t\t\tperror(\"realpath\");\n\t\t\t}\n\n\t\t\t// if 1 the file was not found; mount an empty directory\n\t\t\tif (!nowhitelist_flag) {\n\t\t\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t\t\tif(!arg_private)\n\t\t\t\t\t\thome_dir = 1;\n\t\t\t\t}\n\t\t\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0)\n\t\t\t\t\ttmp_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/media/\", 7) == 0)\n\t\t\t\t\tmedia_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0)\n\t\t\t\t\tmnt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/var/\", 5) == 0)\n\t\t\t\t\tvar_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0)\n\t\t\t\t\tdev_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0)\n\t\t\t\t\topt_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0)\n\t\t\t\t\tsrv_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0)\n\t\t\t\t\tetc_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0)\n\t\t\t\t\tshare_dir = 1;\n\t\t\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0)\n\t\t\t\t\tmodule_dir = 1;\n\t\t\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/')\n\t\t\t\t\trun_dir = 1;\n\t\t\t}\n\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (arg_debug_whitelists)\n\t\t\tprintf(\"real path %s\\n\", fname);\n\n\t\tif (nowhitelist_flag) {\n\t\t\t// store the path in nowhitelist array\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Storing nowhitelist %s\\n\", fname);\n\n\t\t\tif (nowhitelist_c >= nowhitelist_m) {\n\t\t\t\tnowhitelist_m *= 2;\n\t\t\t\tnowhitelist = realloc(nowhitelist, sizeof(*nowhitelist) * nowhitelist_m);\n\t\t\t\tif (nowhitelist == NULL)\n\t\t\t\t\terrExit(\"failed increasing memory for nowhitelist entries\");\n\t\t\t}\n\t\t\tnowhitelist[nowhitelist_c++] = fname;\n\t\t\tentry->data = EMPTY_STRING;\n\t\t\tentry = entry->next;\n\t\t\tfree(new_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// check for supported directories\n\t\tif (strncmp(new_name, cfg.homedir, homedir_len) == 0 && new_name[homedir_len] == '/') {\n\t\t\t// whitelisting home directory is disabled if --private option is present\n\t\t\tif (arg_private) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"\\\"%s\\\" disabled by --private\\n\", entry->data);\n\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tentry->home_dir = 1;\n\t\t\thome_dir = 1;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tfprintf(stderr, \"Debug %d: fname #%s#, cfg.homedir #%s#\\n\",\n\t\t\t\t\t__LINE__, fname, cfg.homedir);\n\n\t\t\t// both path and absolute path are in user home,\n\t\t\t// if not check if the symlink destination is owned by the user\n\t\t\tif (strncmp(fname, cfg.homedir, homedir_len) != 0 || fname[homedir_len] != '/') {\n\t\t\t\tif (checkcfg(CFG_FOLLOW_SYMLINK_AS_USER)) {\n\t\t\t\t\tif (stat(fname, &s) == 0 && s.st_uid != getuid()) {\n\t\t\t\t\t\tfree(fname);\n\t\t\t\t\t\tgoto errexit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/tmp/\", 5) == 0) {\n\t\t\tentry->tmp_dir = 1;\n\t\t\ttmp_dir = 1;\n\n\t\t\t// both path and absolute path are under /tmp\n\t\t\tif (strncmp(fname, \"/tmp/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/media/\", 7) == 0) {\n\t\t\tentry->media_dir = 1;\n\t\t\tmedia_dir = 1;\n\t\t\t// both path and absolute path are under /media\n\t\t\tif (strncmp(fname, \"/media/\", 7) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/mnt/\", 5) == 0) {\n\t\t\tentry->mnt_dir = 1;\n\t\t\tmnt_dir = 1;\n\t\t\t// both path and absolute path are under /mnt\n\t\t\tif (strncmp(fname, \"/mnt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/var/\", 5) == 0) {\n\t\t\tentry->var_dir = 1;\n\t\t\tvar_dir = 1;\n\t\t\t// both path and absolute path are under /var\n\t\t\t// exceptions: /var/tmp, /var/run and /var/lock\n\t\t\tif (strcmp(new_name, \"/var/run\")== 0 && strcmp(fname, \"/run\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/lock\")== 0 && strcmp(fname, \"/run/lock\") == 0);\n\t\t\telse if (strcmp(new_name, \"/var/tmp\")== 0 && strcmp(fname, \"/tmp\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /var\n\t\t\t\tif (strncmp(fname, \"/var/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/dev/\", 5) == 0) {\n\t\t\tentry->dev_dir = 1;\n\t\t\tdev_dir = 1;\n\t\t\t// special handling for /dev/shm\n\t\t\t// on some platforms (Debian wheezy, Ubuntu 14.04), it is a symlink to /run/shm\n\t\t\tif (strcmp(new_name, \"/dev/shm\") == 0 && strcmp(fname, \"/run/shm\") == 0);\n\t\t\t// special handling for /dev/log, which can be a symlink to /run/systemd/journal/dev-log\n\t\t\telse if (strcmp(new_name, \"/dev/log\") == 0 && strcmp(fname, \"/run/systemd/journal/dev-log\") == 0);\n\t\t\t// special processing for /proc/self/fd files\n\t\t\telse if (strcmp(new_name, \"/dev/fd\") == 0 && strcmp(fname, \"/proc/self/fd\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdin\") == 0 && strcmp(fname, \"/proc/self/fd/0\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stdout\") == 0 && strcmp(fname, \"/proc/self/fd/1\") == 0);\n\t\t\telse if (strcmp(new_name, \"/dev/stderr\") == 0 && strcmp(fname, \"/proc/self/fd/2\") == 0);\n\t\t\telse {\n\t\t\t\t// both path and absolute path are under /dev\n\t\t\t\tif (strncmp(fname, \"/dev/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/opt/\", 5) == 0) {\n\t\t\tentry->opt_dir = 1;\n\t\t\topt_dir = 1;\n\t\t\t// both path and absolute path are under /dev\n\t\t\tif (strncmp(fname, \"/opt/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/srv/\", 5) == 0) {\n\t\t\tentry->srv_dir = 1;\n\t\t\tsrv_dir = 1;\n\t\t\t// both path and absolute path are under /srv\n\t\t\tif (strncmp(fname, \"/srv/\", 5) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/etc/\", 5) == 0) {\n\t\t\tentry->etc_dir = 1;\n\t\t\tetc_dir = 1;\n\t\t\t// special handling for some of the symlinks\n\t\t\tif (strcmp(new_name, \"/etc/localtime\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/mtab\") == 0);\n\t\t\telse if (strcmp(new_name, \"/etc/os-release\") == 0);\n\t\t\t// both path and absolute path are under /etc\n\t\t\telse {\n\t\t\t\tif (strncmp(fname, \"/etc/\", 5) != 0) {\n\t\t\t\t\tfree(fname);\n\t\t\t\t\tgoto errexit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/usr/share/\", 11) == 0) {\n\t\t\tentry->share_dir = 1;\n\t\t\tshare_dir = 1;\n\t\t\t// both path and absolute path are under /etc\n\t\t\tif (strncmp(fname, \"/usr/share/\", 11) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, \"/sys/module/\", 12) == 0) {\n\t\t\tentry->module_dir = 1;\n\t\t\tmodule_dir = 1;\n\t\t\t// both path and absolute path are under /sys/module\n\t\t\tif (strncmp(fname, \"/sys/module/\", 12) != 0) {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(new_name, runuser, runuser_len) == 0 && new_name[runuser_len] == '/') {\n\t\t\tentry->run_dir = 1;\n\t\t\trun_dir = 1;\n\t\t\t// both path and absolute path are under /run/user/$uid\n\t\t\tif (strncmp(fname, runuser, runuser_len) != 0 || fname[runuser_len] != '/') {\n\t\t\t\tfree(fname);\n\t\t\t\tgoto errexit;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfree(fname);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\t// check if the path is in nowhitelist array\n\t\tif (nowhitelist_flag == 0) {\n\t\t\tsize_t i;\n\t\t\tint found = 0;\n\t\t\tfor (i = 0; i < nowhitelist_c; i++) {\n\t\t\t\tif (nowhitelist[i] == NULL)\n\t\t\t\t\tbreak;\n\t\t\t\tif (strcmp(nowhitelist[i], fname) == 0) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Skip nowhitelisted path %s\\n\", fname);\n\t\t\t\tentry->data = EMPTY_STRING;\n\t\t\t\tentry = entry->next;\n\t\t\t\tfree(fname);\n\t\t\t\tfree(new_name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// mark symbolic links\n\t\tif (is_link(new_name))\n\t\t\tentry->link = new_name;\n\t\telse {\n\t\t\tfree(new_name);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\t// change file name in entry->data\n\t\tif (strcmp(fname, entry->data + 10) != 0) {\n\t\t\tchar *newdata;\n\t\t\tif (asprintf(&newdata, \"whitelist %s\", fname) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tentry->data = newdata;\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Replaced whitelist path: %s\\n\", entry->data);\n\t\t}\n\t\tfree(fname);\n\t\tentry = entry->next;\n\t}\n\n\t// release nowhitelist memory\n\tassert(nowhitelist);\n\tfree(nowhitelist);\n\n\tEUID_ROOT();\n\t// /home/user mountpoint\n\tif (home_dir) {\n\t\t// check if /home/user directory exists\n\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t// keep a copy of real home dir in RUN_WHITELIST_HOME_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_HOME_USER_DIR, 0755, getuid(), getgid());\n\t\t\tif (mount(cfg.homedir, RUN_WHITELIST_HOME_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount a tmpfs and initialize /home/user, overrides --allusers\n\t\t\tfs_private();\n\t\t}\n\t\telse\n\t\t\thome_dir = 0;\n\t}\n\n\t// /tmp mountpoint\n\tif (tmp_dir) {\n\t\t// keep a copy of real /tmp directory in RUN_WHITELIST_TMP_DIR\n\t\tmkdir_attr(RUN_WHITELIST_TMP_DIR, 1777, 0, 0);\n\t\tif (mount(\"/tmp\", RUN_WHITELIST_TMP_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /tmp\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /tmp directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=1777,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /tmp\");\n\t\tfs_logger(\"tmpfs /tmp\");\n\t}\n\n\t// /media mountpoint\n\tif (media_dir) {\n\t\t// some distros don't have a /media directory\n\t\tif (stat(\"/media\", &s) == 0) {\n\t\t\t// keep a copy of real /media directory in RUN_WHITELIST_MEDIA_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MEDIA_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/media\", RUN_WHITELIST_MEDIA_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /media\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /media directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/media\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /media\");\n\t\t\tfs_logger(\"tmpfs /media\");\n\t\t}\n\t\telse\n\t\t\tmedia_dir = 0;\n\t}\n\n\t// /mnt mountpoint\n\tif (mnt_dir) {\n\t\t// check if /mnt directory exists\n\t\tif (stat(\"/mnt\", &s) == 0) {\n\t\t\t// keep a copy of real /mnt directory in RUN_WHITELIST_MNT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MNT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/mnt\", RUN_WHITELIST_MNT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /mnt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /mnt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/mnt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /mnt\");\n\t\t\tfs_logger(\"tmpfs /mnt\");\n\t\t}\n\t\telse\n\t\t\tmnt_dir = 0;\n\t}\n\n\n\t// /var mountpoint\n\tif (var_dir) {\n\t\t// keep a copy of real /var directory in RUN_WHITELIST_VAR_DIR\n\t\tmkdir_attr(RUN_WHITELIST_VAR_DIR, 0755, 0, 0);\n\t\tif (mount(\"/var\", RUN_WHITELIST_VAR_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /var\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /var directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/var\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /var\");\n\t\tfs_logger(\"tmpfs /var\");\n\t}\n\n\t// /dev mountpoint\n\tif (dev_dir) {\n\t\t// keep a copy of real /dev directory in RUN_WHITELIST_DEV_DIR\n\t\tmkdir_attr(RUN_WHITELIST_DEV_DIR, 0755, 0, 0);\n\t\tif (mount(\"/dev\", RUN_WHITELIST_DEV_DIR, NULL, MS_BIND|MS_REC,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount bind\");\n\n\t\t// mount tmpfs on /dev\n\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\tprintf(\"Mounting tmpfs on /dev directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting tmpfs on /dev\");\n\t\tfs_logger(\"tmpfs /dev\");\n\t}\n\n\t// /opt mountpoint\n\tif (opt_dir) {\n\t\t// check if /opt directory exists\n\t\tif (stat(\"/opt\", &s) == 0) {\n\t\t\t// keep a copy of real /opt directory in RUN_WHITELIST_OPT_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_OPT_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/opt\", RUN_WHITELIST_OPT_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /opt\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /opt directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/opt\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /opt\");\n\t\t\tfs_logger(\"tmpfs /opt\");\n\t\t}\n\t\telse\n\t\t\topt_dir = 0;\n\t}\n\n\t// /srv mountpoint\n\tif (srv_dir) {\n\t\t// check if /srv directory exists\n\t\tif (stat(\"/srv\", &s) == 0) {\n\t\t\t// keep a copy of real /srv directory in RUN_WHITELIST_SRV_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SRV_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/srv\", RUN_WHITELIST_SRV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /srv directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/srv\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /srv\");\n\t\t\tfs_logger(\"tmpfs /srv\");\n\t\t}\n\t\telse\n\t\t\tsrv_dir = 0;\n\t}\n\n\t// /etc mountpoint\n\tif (etc_dir) {\n\t\t// check if /etc directory exists\n\t\tif (stat(\"/etc\", &s) == 0) {\n\t\t\t// keep a copy of real /etc directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_ETC_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/etc\", RUN_WHITELIST_ETC_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /etc directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/etc\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /etc\");\n\t\t\tfs_logger(\"tmpfs /etc\");\n\t\t}\n\t\telse\n\t\t\tetc_dir = 0;\n\t}\n\n\t// /usr/share mountpoint\n\tif (share_dir) {\n\t\t// check if /usr/share directory exists\n\t\tif (stat(\"/usr/share\", &s) == 0) {\n\t\t\t// keep a copy of real /usr/share directory in RUN_WHITELIST_ETC_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_SHARE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/usr/share\", RUN_WHITELIST_SHARE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /srv\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /usr/share directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/usr/share\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /usr/share\");\n\t\t\tfs_logger(\"tmpfs /usr/share\");\n\t\t}\n\t\telse\n\t\t\tshare_dir = 0;\n\t}\n\n\t// /sys/module mountpoint\n\tif (module_dir) {\n\t\t// check if /sys/module directory exists\n\t\tif (stat(\"/sys/module\", &s) == 0) {\n\t\t\t// keep a copy of real /sys/module directory in RUN_WHITELIST_MODULE_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_MODULE_DIR, 0755, 0, 0);\n\t\t\tif (mount(\"/sys/module\", RUN_WHITELIST_MODULE_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /sys/module\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on /sys/module directory\\n\");\n\t\t\tif (mount(\"tmpfs\", \"/sys/module\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /sys/module\");\n\t\t\tfs_logger(\"tmpfs /sys/module\");\n\t\t}\n\t\telse\n\t\t\tmodule_dir = 0;\n\t}\n\n\t// /run/user mountpoint\n\tif (run_dir) {\n\t\t// check if /run/user/$uid directory exists\n\t\tif (stat(runuser, &s) == 0) {\n\t\t\t// keep a copy of real /run/user/$uid directory in RUN_WHITELIST_RUN_USER_DIR\n\t\t\tmkdir_attr(RUN_WHITELIST_RUN_USER_DIR, 0700, getuid(), getgid());\n\t\t\tif (mount(runuser, RUN_WHITELIST_RUN_USER_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\n\t\t\t// mount tmpfs on /run/user/$uid\n\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", runuser);\n\t\t\tchar *options;\n\t\t\tif (asprintf(&options, \"mode=700,uid=%u,gid=%u\", getuid(), getgid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (mount(\"tmpfs\", runuser, \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME, options) < 0)\n\t\t\t\terrExit(\"mounting tmpfs on /run/user/<uid>\");\n\t\t\tfree(options);\n\t\t\tfs_logger2(\"tmpfs\", runuser);\n\t\t}\n\t\telse\n\t\t\trun_dir = 0;\n\t}\n\n\n\t// go through profile rules again, and interpret whitelist commands\n\tentry = cfg.profile;\n\twhile (entry) {\n\t\t// handle only whitelist commands\n\t\tif (strncmp(entry->data, \"whitelist \", 10)) {\n\t\t\tentry = entry->next;\n\t\t\tcontinue;\n\t\t}\n\n//printf(\"here %d#%s#\\n\", __LINE__, entry->data);\n\t\t// whitelist the real file\n\t\twhitelist_path(entry);\n\n\t\t// create the link if any\n\t\tif (entry->link) {\n\t\t\t// if the link is already there, do not bother\n\t\t\tif (lstat(entry->link, &s) != 0) {\n\t\t\t\t// create the path if necessary\n\t\t\t\tint fd = mkpath(entry->link, 0755);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists)\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\tfree(entry->link);\n\t\t\t\t\tentry->link = NULL;\n\t\t\t\t\tentry = entry->next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// get file name of symlink\n\t\t\t\tconst char *file = gnu_basename(entry->link);\n\t\t\t\t// create the link\n\t\t\t\tint rv = symlinkat(entry->data + 10, fd, file);\n\t\t\t\tif (rv) {\n\t\t\t\t\tif (arg_debug || arg_debug_whitelists) {\n\t\t\t\t\t\tperror(\"symlink\");\n\t\t\t\t\t\tprintf(\"Debug %d: cannot create symbolic link %s\\n\", __LINE__, entry->link);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (arg_debug || arg_debug_whitelists)\n\t\t\t\t\tprintf(\"Created symbolic link %s -> %s\\n\", entry->link, entry->data + 10);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tfree(entry->link);\n\t\t\tentry->link = NULL;\n\t\t}\n\n\t\tentry = entry->next;\n\t}\n\n\t// mask the real home directory, currently mounted on RUN_WHITELIST_HOME_DIR\n\tif (home_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_HOME_USER_DIR);\n\t}\n\n\t// mask the real /tmp directory, currently mounted on RUN_WHITELIST_TMP_DIR\n\tif (tmp_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_TMP_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_TMP_DIR);\n\t}\n\n\t// mask the real /var directory, currently mounted on RUN_WHITELIST_VAR_DIR\n\tif (var_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_VAR_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_VAR_DIR);\n\t}\n\n\t// mask the real /opt directory, currently mounted on RUN_WHITELIST_OPT_DIR\n\tif (opt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_OPT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_OPT_DIR);\n\t}\n\n\t// mask the real /dev directory, currently mounted on RUN_WHITELIST_DEV_DIR\n\tif (dev_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_DEV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_DEV_DIR);\n\t}\n\n\t// mask the real /media directory, currently mounted on RUN_WHITELIST_MEDIA_DIR\n\tif (media_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MEDIA_DIR);\n\t}\n\n\t// mask the real /mnt directory, currently mounted on RUN_WHITELIST_MNT_DIR\n\tif (mnt_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MNT_DIR);\n\t}\n\n\t// mask the real /srv directory, currently mounted on RUN_WHITELIST_SRV_DIR\n\tif (srv_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SRV_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SRV_DIR);\n\t}\n\n\t// mask the real /etc directory, currently mounted on RUN_WHITELIST_ETC_DIR\n\tif (etc_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_ETC_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_ETC_DIR);\n\t}\n\n\t// mask the real /usr/share directory, currently mounted on RUN_WHITELIST_SHARE_DIR\n\tif (share_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_SHARE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_SHARE_DIR);\n\t}\n\n\t// mask the real /sys/module directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (module_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_MODULE_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_MODULE_DIR);\n\t}\n\n\t// mask the real /run/user/$uid directory, currently mounted on RUN_WHITELIST_MODULE_DIR\n\tif (run_dir) {\n\t\tif (mount(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mount tmpfs\");\n\t\tfs_logger2(\"tmpfs\", RUN_WHITELIST_RUN_USER_DIR);\n\t}\n\n\tfree(runuser);\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid whitelist path %s\\n\", new_name);\n\texit(1);\n}\n\nCallee: fs_mnt\nvoid fs_mnt(const int enforce) {\n\tif (enforce) {\n\t\t// disable-mnt set in firejail.config\n\t\t// overriding with noblacklist is not possible in this case\n\t\tdisable_file(BLACKLIST_FILE, \"/mnt\");\n\t\tdisable_file(BLACKLIST_FILE, \"/media\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/mount\");\n\t\tdisable_file(BLACKLIST_FILE, \"/run/media\");\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /mnt\");\n\t\tprofile_add(\"blacklist /media\");\n\t\tprofile_add(\"blacklist /run/mount\");\n\t\tprofile_add(\"blacklist /run/media\");\n\t\tEUID_ROOT();\n\t}\n}\n\nCallee: fs_proc_sys_dev_boot\nvoid fs_proc_sys_dev_boot(void) {\n\n\tif (arg_debug)\n\t\tprintf(\"Remounting /proc and /proc/sys filesystems\\n\");\n\tif (mount(\"proc\", \"/proc\", \"proc\", MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc\");\n\tfs_logger(\"remount /proc\");\n\n\t// remount /proc/sys readonly\n\tif (mount(\"/proc/sys\", \"/proc/sys\", NULL, MS_BIND | MS_REC, NULL) < 0 ||\n\t    mount(NULL, \"/proc/sys\", NULL, MS_BIND | MS_REMOUNT | MS_RDONLY | MS_NOSUID | MS_NOEXEC | MS_NODEV | MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /proc/sys\");\n\tfs_logger(\"read-only /proc/sys\");\n\n\n\t/* Mount a version of /sys that describes the network namespace */\n\tif (arg_debug)\n\t\tprintf(\"Remounting /sys directory\\n\");\n\t// if this is an overlay, don't try to unmount, just mount a new sysfs\n\tif (!arg_overlay) {\n\t\tif (umount2(\"/sys\", MNT_DETACH) < 0 && !cfg.chrootdir)\n\t\t\tfwarning(\"failed to unmount /sys\\n\");\n\t}\n\tif (mount(\"sysfs\", \"/sys\", \"sysfs\", MS_RDONLY|MS_NOSUID|MS_NOEXEC|MS_NODEV|MS_REC, NULL) < 0)\n\t\tfwarning(\"failed to mount /sys\\n\");\n\telse\n\t\tfs_logger(\"remount /sys\");\n\n\tdisable_file(BLACKLIST_FILE, \"/sys/firmware\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/hypervisor\");\n\t{ // allow user access to some directories in /sys/ by specifying 'noblacklist' option\n\t\tEUID_USER();\n\t\tprofile_add(\"blacklist /sys/fs\");\n\t\tprofile_add(\"blacklist /sys/module\");\n\t\tEUID_ROOT();\n\t}\n\tdisable_file(BLACKLIST_FILE, \"/sys/power\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/debug\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/vmcoreinfo\");\n\tdisable_file(BLACKLIST_FILE, \"/sys/kernel/uevent_helper\");\n\n\t// various /proc/sys files\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/security\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/efi/vars\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/fs/binfmt_misc\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/core_pattern\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/modprobe\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sysrq-trigger\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/kernel/hotplug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sys/vm/panic_on_oom\");\n\n\t// various /proc files\n\tdisable_file(BLACKLIST_FILE, \"/proc/irq\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/bus\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/config.gz\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/sched_debug\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_list\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/timer_stats\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kcore\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kallsyms\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/mem\");\n\tdisable_file(BLACKLIST_FILE, \"/proc/kmem\");\n\n\t// remove kernel symbol information\n\tif (!arg_allow_debuggers) {\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/src/linux\");\n\t\tdisable_file(BLACKLIST_FILE, \"/lib/modules\");\n\t\tdisable_file(BLACKLIST_FILE, \"/usr/lib/debug\");\n\t\tdisable_file(BLACKLIST_FILE, \"/boot\");\n\t}\n\n\t// disable /selinux\n\tdisable_file(BLACKLIST_FILE, \"/selinux\");\n\n\t// disable /dev/port\n\tdisable_file(BLACKLIST_FILE, \"/dev/port\");\n\n\n\n\t// disable various ipc sockets in /run/user\n\tif (!arg_writable_run_user) {\n\t\tstruct stat s;\n\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"/run/user/%d\", getuid()) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (is_dir(fname)) { // older distros don't have this directory\n\t\t\t// disable /run/user/{uid}/gnupg\n\t\t\tchar *fnamegpg;\n\t\t\tif (asprintf(&fnamegpg, \"/run/user/%d/gnupg\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamegpg, 0700))\n\t\t\t\tfs_logger2(\"create\", fnamegpg);\n\t\t\tif (stat(fnamegpg, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamegpg);\n\t\t\tfree(fnamegpg);\n\n\t\t\t// disable /run/user/{uid}/systemd\n\t\t\tchar *fnamesysd;\n\t\t\tif (asprintf(&fnamesysd, \"/run/user/%d/systemd\", getuid()) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (create_empty_dir_as_user(fnamesysd, 0755))\n\t\t\t\tfs_logger2(\"create\", fnamesysd);\n\t\t\tif (stat(fnamesysd, &s) == 0)\n\t\t\t\tdisable_file(BLACKLIST_FILE, fnamesysd);\n\t\t\tfree(fnamesysd);\n\t\t}\n\t\tfree(fname);\n\t}\n\n\tif (getuid() != 0) {\n\t\t// disable /dev/kmsg and /proc/kmsg\n\t\tdisable_file(BLACKLIST_FILE, \"/dev/kmsg\");\n\t\tdisable_file(BLACKLIST_FILE, \"/proc/kmsg\");\n\t}\n}\n\nCallee: netns_mounts\nvoid netns_mounts(const char *nsname) {\n\tchar *etcdir = netns_etc_dir(nsname);\n\tchar *netns_name, *etc_name;\n\tstruct dirent *entry;\n\tDIR *dir;\n\n\tdir = opendir(etcdir);\n\tif (!dir) {\n\t\tfree(etcdir);\n\t\treturn;\n\t}\n\twhile ((entry = readdir(dir))) {\n\t\tif (!strcmp(entry->d_name, \".\") || !strcmp(entry->d_name, \"..\"))\n\t\t\tcontinue;\n\t\tif (asprintf(&netns_name, \"%s/%s\", etcdir, entry->d_name) < 0 ||\n\t\t    asprintf(&etc_name, \"/etc/%s\", entry->d_name) < 0)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(netns_name, etc_name, \"none\", MS_BIND, 0) < 0) {\n\t\t\tfwarning(\"bind %s -> %s failed: %s\\n\",\n\t\t\t\tnetns_name, etc_name, strerror(errno));\n\t\t}\n\t\tfree(netns_name);\n\t\tfree(etc_name);\n\t}\n\tclosedir(dir);\n\tfree(etcdir);\n}\n\nCallee: fs_mount_hosts_file\nvoid fs_mount_hosts_file(void) {\n\tif (arg_debug)\n\t\tprintf(\"Loading user hosts file\\n\");\n\n\t// check /etc/hosts file\n\tstruct stat s;\n\tif (stat(\"/etc/hosts\", &s) == -1)\n\t\tgoto errexit;\n\t// not a link\n\tif (is_link(\"/etc/hosts\"))\n\t\tgoto errexit;\n\t// owned by root\n\tif (s.st_uid != 0)\n\t\tgoto errexit;\n\n\t// bind-mount the file on top of /etc/hostname\n\tif (mount(RUN_HOSTS_FILE, \"/etc/hosts\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind /etc/hosts\");\n\tfs_logger(\"create /etc/hosts\");\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: invalid /etc/hosts file\\n\");\n\texit(1);\n}\n\nCallee: fs_hostname\nvoid fs_hostname(const char *hostname) {\n\tstruct stat s;\n\n\t// create a new /etc/hostname\n\tif (stat(\"/etc/hostname\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hostname file\\n\");\n\n\t\tcreate_empty_file_as_root(RUN_HOSTNAME_FILE, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tif (mount(RUN_HOSTNAME_FILE, \"/etc/hostname\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mount bind /etc/hostname\");\n\t\tfs_logger(\"create /etc/hostname\");\n\t}\n\n\t// create a new /etc/hosts\n\tif (cfg.hosts_file == NULL && stat(\"/etc/hosts\", &s) == 0) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating a new /etc/hosts file\\n\");\n\t\t// copy /etc/host into our new file, and modify it on the fly\n\t\t/* coverity[toctou] */\n\t\tFILE *fp1 = fopen(\"/etc/hosts\", \"r\");\n\t\tif (!fp1)\n\t\t\tgoto errexit;\n\n\t\tFILE *fp2 = fopen(RUN_HOSTS_FILE, \"w\");\n\t\tif (!fp2) {\n\t\t\tfclose(fp1);\n\t\t\tgoto errexit;\n\t\t}\n\n\t\tchar buf[4096];\n\t\tint done = 0;\n\t\twhile (fgets(buf, sizeof(buf), fp1)) {\n\t\t\t// remove '\\n'\n\t\t\tchar *ptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\n\t\t\t// copy line\n\t\t\tif (strstr(buf, \"127.0.0.1\") && done == 0) {\n\t\t\t\tdone = 1;\n\t\t\t\tfprintf(fp2, \"%s %s\\n\", buf, hostname);\n\t\t\t}\n\t\t\telse\n\t\t\t\tfprintf(fp2, \"%s\\n\", buf);\n\t\t}\n\t\tfclose(fp1);\n\t\t// mode and owner\n\t\tSET_PERMS_STREAM(fp2, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp2);\n\n\t\t// bind-mount the file on top of /etc/hostname\n\t\tfs_mount_hosts_file();\n\t}\n\treturn;\n\nerrexit:\n\tfprintf(stderr, \"Error: cannot create hostname file\\n\");\n\texit(1);\n}\n\nCallee: dbus_session_disable\nvoid dbus_session_disable(void) {\n\tif (!checkcfg(CFG_DBUS)) {\n\t\tfwarning(\"D-Bus handling is disabled in Firejail configuration file\\n\");\n\t\treturn;\n\t}\n\n\tchar *path;\n\tif (asprintf(&path, \"/run/user/%d/bus\", getuid()) == -1)\n\t\terrExit(\"asprintf\");\n\tchar *env_var;\n\tif (asprintf(&env_var, \"DBUS_SESSION_BUS_ADDRESS=unix:path=%s\", path) == -1)\n\t\terrExit(\"asprintf\");\n\n\t// set a new environment variable: DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/<UID>/bus\n\tif (setenv(\"DBUS_SESSION_BUS_ADDRESS\", env_var, 1) == -1) {\n\t\tfprintf(stderr, \"Error: cannot modify DBUS_SESSION_BUS_ADDRESS required by --nodbus\\n\");\n\t\texit(1);\n\t}\n\n\t// blacklist the path\n\tdisable_file_or_dir(path);\n\tfree(path);\n\tfree(env_var);\n\n\t// look for a possible abstract unix socket\n\n\t// --net=none\n\tif (arg_nonetwork)\n\t\treturn;\n\n\t// --net=eth0\n\tif (any_bridge_configured())\n\t\treturn;\n\n\t// --protocol=unix\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol && !strstr(cfg.protocol, \"unix\"))\n\t\treturn;\n#endif\n\n\tfwarning(\"An abstract unix socket for session D-BUS might still be available. Use --net or remove unix from --protocol set.\\n\");\n}\n\nCallee: fs_private_tmp\nvoid fs_private_tmp(void) {\n\t// check XAUTHORITY file, KDE keeps it under /tmp\n\tchar *xauth = getenv(\"XAUTHORITY\");\n\tif (xauth) {\n\t\tchar *rp = realpath(xauth, NULL);\n\t\tif (rp && strncmp(rp, \"/tmp/\", 5) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist %s\", rp) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t\tif (rp)\n\t\t\tfree(rp);\n\t}\n\n\t// whitelist x11 directory\n\tprofile_add(\"whitelist /tmp/.X11-unix\");\n\n\t// whitelist any pulse* file in /tmp directory\n\t// some distros use PulseAudio sockets under /tmp instead of the socket in /urn/user\n\tDIR *dir;\n\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t// sleep 2 seconds and try again\n\t\tsleep(2);\n\t\tif (!(dir = opendir(\"/tmp\"))) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir))) {\n\t\tif (strncmp(entry->d_name, \"pulse-\", 6) == 0) {\n\t\t\tchar *cmd;\n\t\t\tif (asprintf(&cmd, \"whitelist /tmp/%s\", entry->d_name) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tprofile_add(cmd); // profile_add does not duplicate the string\n\t\t}\n\t}\n\tclosedir(dir);\n}\n\nCallee: fs_private_cache\nvoid fs_private_cache(void) {\n\tchar *cache;\n\tif (asprintf(&cache, \"%s/.cache\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// check if ~/.cache is a valid destination\n\tstruct stat s;\n\tif (lstat(cache, &s) == -1) {\n\t\tfwarning(\"cannot find %s, tmpfs not mounted\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\tif (!S_ISDIR(s.st_mode)) {\n\t\tif (S_ISLNK(s.st_mode))\n\t\t\tfwarning(\"%s is a symbolic link, tmpfs not mounted\\n\", cache);\n\t\telse\n\t\t\tfwarning(\"%s is not a directory; cannot mount a tmpfs on top of it\\n\", cache);\n\t\tfree(cache);\n\t\treturn;\n\t}\n\t// do the mount\n\tfs_tmpfs(cache, getuid()); // check ownership of ~/.cache\n\tfree(cache);\n}\n\nCallee: fs_private_lib\nvoid fs_private_lib(void) {\n#ifndef __x86_64__\n\tfwarning(\"private-lib feature is currently available only on amd64 platforms\\n\");\n\treturn;\n#endif\n\tchar *private_list = cfg.lib_private_keep;\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Starting private-lib processing: program %s, shell %s\\n\",\n\t\t\t(cfg.original_program_index > 0)? cfg.original_argv[cfg.original_program_index]: \"none\",\n\t\t(arg_shell_none)? \"none\": cfg.shell);\n\n\t// create /run/firejail/mnt/lib directory\n\tmkdir_attr(RUN_LIB_DIR, 0755, 0, 0);\n\n\t// install standard C libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing standard C library\\n\");\n\tfslib_install_stdc();\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// copy the libs in the new lib directory for the main exe\n\tif (cfg.original_program_index > 0) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing sandboxed program libraries\\n\");\n\t\tfslib_install_list(cfg.original_argv[cfg.original_program_index]);\n\t}\n\n\t// for the shell\n\tif (!arg_shell_none) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Installing shell libraries\\n\");\n\n\t\tfslib_install_list(cfg.shell);\n\t\t// a shell is useless without some basic commands\n\t\tfslib_install_list(\"/bin/ls,/bin/cat,/bin/mv,/bin/rm\");\n\n\t}\n\n\t// for the listed libs and directories\n\tif (private_list && *private_list != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-lib files\\n\");\n\t\tfslib_install_list(private_list);\n\t}\n\n\t// for private-bin files\n\tif (arg_private_bin && cfg.bin_private_lib && *cfg.bin_private_lib != '\\0') {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"Processing private-bin files\\n\");\n\t\tfslib_install_list(cfg.bin_private_lib);\n\t}\n\tfmessage(\"Program libraries installed in %0.2f ms\\n\", timetrace_end());\n\n\t// install the reset of the system libraries\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"Installing system libraries\\n\");\n\tfslib_install_system();\n\n\t// bring in firejail directory for --trace and seccomp post exec\n\t// bring in firejail executable libraries in case we are redirected here by a firejail symlink from /usr/local/bin/firejail\n\tfslib_install_list(\"/usr/bin/firejail,firejail\"); // todo: use the installed path for the executable\n\n\tfmessage(\"Installed %d %s and %d %s\\n\", lib_cnt, (lib_cnt == 1)? \"library\": \"libraries\",\n\t\tdir_cnt, (dir_cnt == 1)? \"directory\": \"directories\");\n\n\t// mount lib filesystem\n\tmount_directories();\n}\n\nCallee: fs_private_bin_list\nvoid fs_private_bin_list(void) {\n\tchar *private_list = cfg.bin_private_keep;\n\tassert(private_list);\n\n\t// start timetrace\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/bin directory\n\tmkdir_attr(RUN_BIN_DIR, 0755, 0, 0);\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new bin directory\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(private_list);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-bin argument\\n\");\n\t\texit(1);\n\t}\n\tglobbing(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tglobbing(ptr);\n\tfree(dlist);\n\tfs_logger_print();\n\n\t// mount-bind\n\tint i = 0;\n\twhile (paths[i]) {\n\t\tstruct stat s;\n\t\tif (stat(paths[i], &s) == 0) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_BIN_DIR, paths[i]);\n\t\t\tif (mount(RUN_BIN_DIR, paths[i], NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mount bind\");\n\t\t\tfs_logger2(\"tmpfs\", paths[i]);\n\t\t\tfs_logger2(\"mount\", paths[i]);\n\t\t}\n\t\ti++;\n\t}\n\tfmessage(\"%d %s installed in %0.2f ms\\n\", prog_cnt, (prog_cnt == 1)? \"program\": \"programs\", timetrace_end());\n}\n\nCallee: fs_private_dir_list\nvoid fs_private_dir_list(const char *private_dir, const char *private_run_dir, const char *private_list) {\n\tassert(private_dir);\n\tassert(private_run_dir);\n\tassert(private_list);\n\n\ttimetrace_start();\n\n\t// create /run/firejail/mnt/etc directory\n\tmkdir_attr(private_run_dir, 0755, 0, 0);\n\tfs_logger2(\"tmpfs\", private_dir);\n\n\tfs_logger_print();\t// save the current log\n\n\n\t// copy the list of files in the new etc directory\n\t// using a new child process with root privileges\n\tif (*private_list != '\\0') {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Copying files in the new %s directory:\\n\", private_dir);\n\n\t\t// copy the list of files in the new home directory\n\t\tchar *dlist = strdup(private_list);\n\t\tif (!dlist)\n\t\t\terrExit(\"strdup\");\n\n\n\t\tchar *ptr = strtok(dlist, \",\");\n\t\tif (!ptr) {\n\t\t\tfprintf(stderr, \"Error: invalid private %s argument\\n\", private_dir);\n\t\t\texit(1);\n\t\t}\n\t\tduplicate(ptr, private_dir, private_run_dir);\n\n\t\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\t\tduplicate(ptr, private_dir, private_run_dir);\n\t\tfree(dlist);\n\t\tfs_logger_print();\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_run_dir, private_dir);\n\tif (mount(private_run_dir, private_dir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"mount\", private_dir);\n\n\tfmessage(\"Private %s installed in %0.2f ms\\n\", private_dir, timetrace_end());\n}\n\nCallee: fs_trace_preload\nvoid fs_trace_preload(void) {\n\tstruct stat s;\n\n\t// create an empty /etc/ld.so.preload\n\tif (stat(\"/etc/ld.so.preload\", &s)) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Creating an empty /etc/ld.so.preload file\\n\");\n\t\t/* coverity[toctou] */\n\t\tFILE *fp = fopen(\"/etc/ld.so.preload\", \"w\");\n\t\tif (!fp)\n\t\t\terrExit(\"fopen\");\n\t\tSET_PERMS_STREAM(fp, 0, 0, S_IRUSR | S_IWRITE | S_IRGRP | S_IROTH);\n\t\tfclose(fp);\n\t\tfs_logger(\"touch /etc/ld.so.preload\");\n\t}\n}\n\nCallee: fs_private_dev\nvoid fs_private_dev(void){\n\t// install a new /dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting tmpfs on /dev\\n\");\n\n\t// create DRI_DIR\n\t// keep a copy of dev directory\n\tmkdir_attr(RUN_DEV_DIR, 0755, 0, 0);\n\tif (mount(\"/dev\", RUN_DEV_DIR, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\n\t// create DEVLOG_FILE\n\tint have_devlog = 0;\n\tstruct stat s;\n\tif (stat(\"/dev/log\", &s) == 0) {\n\t\thave_devlog = 1;\n\t\tFILE *fp = fopen(RUN_DEVLOG_FILE, \"w\");\n\t\tif (!fp)\n\t\t\thave_devlog = 0;\n\t\telse {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(\"/dev/log\", RUN_DEVLOG_FILE, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t}\n\t}\n\n\t// mount tmpfs on top of /dev\n\tif (mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"tmpfs /dev\");\n\n\t// optional devices: sound, video cards etc...\n\tdeventry_mount();\n\n\t// bring back /dev/log\n\tif (have_devlog) {\n\t\tFILE *fp = fopen(\"/dev/log\", \"w\");\n\t\tif (fp) {\n\t\t\tfprintf(fp, \"\\n\");\n\t\t\tfclose(fp);\n\t\t\tif (mount(RUN_DEVLOG_FILE, \"/dev/log\", NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\t\terrExit(\"mounting /dev/log\");\n\t\t\tfs_logger(\"clone /dev/log\");\n\t\t}\n\t}\n\n\t// bring forward the current /dev/shm directory if necessary\n\tif (arg_debug)\n\t\tprintf(\"Process /dev/shm directory\\n\");\n\tprocess_dev_shm();\n\n\tif (mount(RUN_RO_DIR, RUN_DEV_DIR, \"none\", MS_BIND, \"mode=400,gid=0\") < 0)\n\t\terrExit(\"disable run dev directory\");\n\n\t// create default devices\n\tcreate_char_dev(\"/dev/zero\", 0666, 1, 5); // mknod -m 666 /dev/zero c 1 5\n\tfs_logger(\"mknod /dev/zero\");\n\tcreate_char_dev(\"/dev/null\", 0666, 1, 3); // mknod -m 666 /dev/null c 1 3\n\tfs_logger(\"mknod /dev/null\");\n\tcreate_char_dev(\"/dev/full\", 0666, 1, 7); // mknod -m 666 /dev/full c 1 7\n\tfs_logger(\"mknod /dev/full\");\n\tcreate_char_dev(\"/dev/random\", 0666, 1, 8); // Mknod -m 666 /dev/random c 1 8\n\tfs_logger(\"mknod /dev/random\");\n\tcreate_char_dev(\"/dev/urandom\", 0666, 1, 9); // mknod -m 666 /dev/urandom c 1 9\n\tfs_logger(\"mknod /dev/urandom\");\n\tcreate_char_dev(\"/dev/tty\", 0666,  5, 0); // mknod -m 666 /dev/tty c 5 0\n\tfs_logger(\"mknod /dev/tty\");\n#if 0\n\tcreate_dev(\"/dev/tty0\", \"mknod -m 666 /dev/tty0 c 4 0\");\n\tcreate_dev(\"/dev/console\", \"mknod -m 622 /dev/console c 5 1\");\n#endif\n\n\t// pseudo-terminal\n\tmkdir_attr(\"/dev/pts\", 0755, 0, 0);\n\tfs_logger(\"mkdir /dev/pts\");\n\tfs_logger(\"create /dev/pts\");\n\tcreate_char_dev(\"/dev/pts/ptmx\", 0666, 5, 2); //\"mknod -m 666 /dev/pts/ptmx c 5 2\");\n\tfs_logger(\"mknod /dev/pts/ptmx\");\n\tcreate_link(\"/dev/pts/ptmx\", \"/dev/ptmx\");\n\n// code before github issue #351\n\t// mount -vt devpts -o newinstance -o ptmxmode=0666 devpts //dev/pts\n//\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  \"newinstance,ptmxmode=0666\") < 0)\n//\t\terrExit(\"mounting /dev/pts\");\n\n\n\t// mount /dev/pts\n\tgid_t ttygid = get_group_id(\"tty\");\n\tchar *data;\n\tif (asprintf(&data, \"newinstance,gid=%d,mode=620,ptmxmode=0666\", (int) ttygid) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"devpts\", \"/dev/pts\", \"devpts\", MS_MGC_VAL,  data) < 0)\n\t\terrExit(\"mounting /dev/pts\");\n\tfree(data);\n\tfs_logger(\"clone /dev/pts\");\n\n\t// stdin, stdout, stderr\n#if 0\n\tcreate_link(\"/proc/self/fd\", \"/dev/fd\");\n\tcreate_link(\"/proc/self/fd/0\", \"/dev/stdin\");\n\tcreate_link(\"/proc/self/fd/1\", \"/dev/stdout\");\n\tcreate_link(\"/proc/self/fd/2\", \"/dev/stderr\");\n#endif\n\n\t// symlinks for DVD/CD players\n\tif (stat(\"/dev/sr0\", &s) == 0) {\n\t\tcreate_link(\"/dev/sr0\", \"/dev/cdrom\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/cdrw\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/dvd\");\n\t\tcreate_link(\"/dev/sr0\", \"/dev/dvdrw\");\n\t}\n}\n\nCallee: fs_private_home_list\nvoid fs_private_home_list(void) {\n\ttimetrace_start();\n\n\tchar *homedir = cfg.homedir;\n\tchar *private_list = cfg.home_private_keep;\n\tassert(homedir);\n\tassert(private_list);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\n\t// create /run/firejail/mnt/home directory\n\tmkdir_attr(RUN_HOME_DIR, 0755, uid, gid);\n\tfs_logger_print();\t// save the current log\n\n\tif (arg_debug)\n\t\tprintf(\"Copying files in the new home:\\n\");\n\n\t// copy the list of files in the new home directory\n\tchar *dlist = strdup(cfg.home_private_keep);\n\tif (!dlist)\n\t\terrExit(\"strdup\");\n\n\tchar *ptr = strtok(dlist, \",\");\n\tif (!ptr) {\n\t\tfprintf(stderr, \"Error: invalid private-home argument\\n\");\n\t\texit(1);\n\t}\n\tduplicate(ptr);\n\twhile ((ptr = strtok(NULL, \",\")) != NULL)\n\t\tduplicate(ptr);\n\n\tfs_logger_print();\t// save the current log\n\tfree(dlist);\n\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", RUN_HOME_DIR, homedir);\n\n\tif (mount(RUN_HOME_DIR, homedir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfs_logger2(\"tmpfs\", homedir);\n\n\tif (uid != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t}\n\n\tskel(homedir, uid, gid);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n\n\tif (!arg_quiet)\n\t\tfprintf(stderr, \"Home directory installed in %0.2f ms\\n\", timetrace_end());\n\n}\n\nCallee: fs_private_homedir\nvoid fs_private_homedir(void) {\n\tchar *homedir = cfg.homedir;\n\tchar *private_homedir = cfg.home_private;\n\tassert(homedir);\n\tassert(private_homedir);\n\n\tint xflag = store_xauthority();\n\tint aflag = store_asoundrc();\n\n\tuid_t u = getuid();\n\tgid_t g = getgid();\n\n\t// mount bind private_homedir on top of homedir\n\tif (arg_debug)\n\t\tprintf(\"Mount-bind %s on top of %s\\n\", private_homedir, homedir);\n\t// get a file descriptor for private_homedir, fails if there is any symlink\n\tint fd = safe_fd(private_homedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\tif (fd == -1)\n\t\terrExit(\"safe_fd\");\n\t// check if new home directory is owned by the user\n\tstruct stat s;\n\tif (fstat(fd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != getuid()) {\n\t\tfprintf(stderr, \"Error: private directory is not owned by the current user\\n\");\n\t\texit(1);\n\t}\n\tif ((S_IRWXU & s.st_mode) != S_IRWXU)\n\t\tfwarning(\"no full permissions on private directory\\n\");\n\t// mount via the link in /proc/self/fd\n\tchar *proc;\n\tif (asprintf(&proc, \"/proc/self/fd/%d\", fd) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(proc, homedir, NULL, MS_NOSUID | MS_NODEV | MS_BIND | MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(proc);\n\tclose(fd);\n\n\tfs_logger3(\"mount-bind\", private_homedir, cfg.homedir);\n\tfs_logger2(\"whitelist\", cfg.homedir);\n// preserve mode and ownership\n//\tif (chown(homedir, s.st_uid, s.st_gid) == -1)\n//\t\terrExit(\"mount-bind chown\");\n//\tif (chmod(homedir, s.st_mode) == -1)\n//\t\terrExit(\"mount-bind chmod\");\n\n\tif (u != 0) {\n\t\t// mask /root\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /root directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/root\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=700,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /root\");\n\t}\n\telse {\n\t\t// mask /home\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting a new /home directory\\n\");\n\t\tif (mount(\"tmpfs\", \"/home\", \"tmpfs\", MS_NOSUID | MS_NODEV | MS_NOEXEC | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting home directory\");\n\t\tfs_logger(\"tmpfs /home\");\n\t}\n\n\n\tskel(homedir, u, g);\n\tif (xflag)\n\t\tcopy_xauthority();\n\tif (aflag)\n\t\tcopy_asoundrc();\n}\n\nCallee: fs_basic_fs\nvoid fs_basic_fs(void) {\n\tuid_t uid = getuid();\n\n\tif (arg_debug)\n\t\tprintf(\"Basic read-only filesystem:\\n\");\n\tif (!arg_writable_etc) {\n\t\tfs_rdonly(\"/etc\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/etc\");\n\t}\n\tif (!arg_writable_var) {\n\t\tfs_rdonly(\"/var\");\n\t\tif (uid)\n\t\t\tfs_noexec(\"/var\");\n\t}\n\tfs_rdonly(\"/bin\");\n\tfs_rdonly(\"/sbin\");\n\tfs_rdonly(\"/lib\");\n\tfs_rdonly(\"/lib64\");\n\tfs_rdonly(\"/lib32\");\n\tfs_rdonly(\"/libx32\");\n\tfs_rdonly(\"/usr\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t  fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\telse\n\t\tfs_rdwr(\"/var/log\");\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (uid)\n\t\tdisable_config();\n}\n\nCallee: fs_overlayfs\nvoid fs_overlayfs(void) {\n\tstruct stat s;\n\n\t// check kernel version\n\tstruct utsname u;\n\tint rv = uname(&u);\n\tif (rv != 0)\n\t\terrExit(\"uname\");\n\tint major;\n\tint minor;\n\tif (2 != sscanf(u.release, \"%d.%d\", &major, &minor)) {\n\t\tfprintf(stderr, \"Error: cannot extract Linux kernel version: %s\\n\", u.version);\n\t\texit(1);\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Linux kernel version %d.%d\\n\", major, minor);\n\tint oldkernel = 0;\n\tif (major < 3) {\n\t\tfprintf(stderr, \"Error: minimum kernel version required 3.x\\n\");\n\t\texit(1);\n\t}\n\tif (major == 3 && minor < 18)\n\t\toldkernel = 1;\n\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tmkdir_attr(oroot, 0755, 0, 0);\n\n\t// set base for working and diff directories\n\tchar *basedir = RUN_MNT_DIR;\n\tint basefd = -1;\n\n\tif (arg_overlay_keep) {\n\t\tbasedir = cfg.overlay_dir;\n\t\tassert(basedir);\n\t\t// get a file descriptor for ~/.firejail, fails if there is any symlink\n\t\tchar *firejail;\n\t\tif (asprintf(&firejail, \"%s/.firejail\", cfg.homedir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tint fd = safe_fd(firejail, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tif (fd == -1)\n\t\t\terrExit(\"safe_fd\");\n\t\tfree(firejail);\n\t\t// create basedir if it doesn't exist\n\t\t// the new directory will be owned by root\n\t\tconst char *dirname = gnu_basename(basedir);\n\t\tif (mkdirat(fd, dirname, 0755) == -1 && errno != EEXIST) {\n\t\t\tperror(\"mkdir\");\n\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", basedir);\n\t\t\texit(1);\n\t\t}\n\t\t// open basedir\n\t\tbasefd = openat(fd, dirname, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t\tclose(fd);\n\t}\n\telse {\n\t\tbasefd = open(basedir, O_PATH|O_DIRECTORY|O_NOFOLLOW|O_CLOEXEC);\n\t}\n\tif (basefd == -1) {\n\t\tperror(\"open\");\n\t\tfprintf(stderr, \"Error: cannot open overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// confirm once more base is owned by root\n\tif (fstat(basefd, &s) == -1)\n\t\terrExit(\"fstat\");\n\tif (s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: overlay directory %s is not owned by the root user\\n\", basedir);\n\t\texit(1);\n\t}\n\t// confirm permissions of base are 0755\n\tif (((S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) & s.st_mode) != (S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)) {\n\t\tfprintf(stderr, \"Error: invalid permissions on overlay directory %s\\n\", basedir);\n\t\texit(1);\n\t}\n\n\t// create diff and work directories inside base\n\t// no need to check arg_overlay_reuse\n\tchar *odiff;\n\tif (asprintf(&odiff, \"%s/odiff\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"odiff\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", odiff);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(odiff, 0, 0, 0755);\n\n\tchar *owork;\n\tif (asprintf(&owork, \"%s/owork\", basedir) == -1)\n\t\terrExit(\"asprintf\");\n\t// the new directory will be owned by root\n\tif (mkdirat(basefd, \"owork\", 0755) == -1 && errno != EEXIST) {\n\t\tperror(\"mkdir\");\n\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", owork);\n\t\texit(1);\n\t}\n\tASSERT_PERMS(owork, 0, 0, 0755);\n\n\t// mount overlayfs\n\tif (arg_debug)\n\t\tprintf(\"Mounting OverlayFS\\n\");\n\tchar *option;\n\tif (oldkernel) { // old Ubuntu/OpenSUSE kernels\n\t\tif (arg_overlay_keep) {\n\t\t\tfprintf(stderr, \"Error: option --overlay= not available for kernels older than 3.18\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s\", odiff) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlayfs\", oroot, \"overlayfs\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\t}\n\telse { // kernel 3.18 or newer\n\t\tif (asprintf(&option, \"lowerdir=/,upperdir=%s,workdir=%s\", odiff, owork) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (mount(\"overlay\", oroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\terrExit(\"mounting overlayfs\");\n\n\t\t//***************************\n\t\t// issue #263 start code\n\t\t// My setup has a separate mount point for /home. When the overlay is mounted,\n\t\t// the overlay does not contain the original /home contents.\n\t\t// I added code to create a second overlay for /home if the overlay home dir is empty and this seems to work\n\t\t// @dshmgh, Jan 2016\n\t\t{\n\t\t\tchar *overlayhome;\n\t\t\tstruct stat s;\n\t\t\tchar *hroot;\n\t\t\tchar *hdiff;\n\t\t\tchar *hwork;\n\n\t\t\t// dons add debug\n\t\t\tif (arg_debug) printf (\"DEBUG: chroot dirs are oroot %s  odiff %s  owork %s\\n\",oroot,odiff,owork);\n\n\t\t\t// BEFORE NEXT, WE NEED TO TEST IF /home has any contents or do we need to mount it?\n\t\t\t// must create var for oroot/cfg.homedir\n\t\t\tif (asprintf(&overlayhome, \"%s%s\", oroot, cfg.homedir) == -1)\n\t\t\t\terrExit(\"asprintf\");\n\t\t\tif (arg_debug) printf (\"DEBUG: overlayhome var holds ##%s##\\n\", overlayhome);\n\n\t\t\t// if no homedir in overlay -- create another overlay for /home\n\t\t\tif (stat(cfg.homedir, &s) == 0 && stat(overlayhome, &s) == -1) {\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hdiff, \"%s/hdiff\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hdiff\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hdiff);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hdiff, 0, 0, 0755);\n\n\t\t\t\t// no need to check arg_overlay_reuse\n\t\t\t\tif (asprintf(&hwork, \"%s/hwork\", basedir) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\t// the new directory will be owned by root\n\t\t\t\tif (mkdirat(basefd, \"hwork\", 0755) == -1 && errno != EEXIST) {\n\t\t\t\t\tperror(\"mkdir\");\n\t\t\t\t\tfprintf(stderr, \"Error: cannot create overlay directory %s\\n\", hwork);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t\tASSERT_PERMS(hwork, 0, 0, 0755);\n\n\t\t\t\t// no homedir in overlay so now mount another overlay for /home\n\t\t\t\tif (asprintf(&hroot, \"%s/home\", oroot) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (asprintf(&option, \"lowerdir=/home,upperdir=%s,workdir=%s\", hdiff, hwork) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tif (mount(\"overlay\", hroot, \"overlay\", MS_MGC_VAL, option) < 0)\n\t\t\t\t\terrExit(\"mounting overlayfs for mounted home directory\");\n\n\t\t\t\tprintf(\"OverlayFS for /home configured in %s directory\\n\", basedir);\n\t\t\t\tfree(hroot);\n\t\t\t\tfree(hdiff);\n\t\t\t\tfree(hwork);\n\n\t\t\t} // stat(overlayhome)\n\t\t\tfree(overlayhome);\n\t\t}\n\t\t// issue #263 end code\n\t\t//***************************\n\t}\n\tfmessage(\"OverlayFS configured in %s directory\\n\", basedir);\n\tclose(basefd);\n\n\t// /dev, /run and /tmp are not covered by the overlay\n\t// mount-bind dev directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev\\n\");\n\tchar *dev;\n\tif (asprintf(&dev, \"%s/dev\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/dev\", dev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfs_logger(\"whitelist /dev\");\n\n\t// mount-bind run directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /run\\n\");\n\tchar *run;\n\tif (asprintf(&run, \"%s/run\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/run\", run, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /run\");\n\tfs_logger(\"whitelist /run\");\n\n\t// mount-bind tmp directory\n\tif (arg_debug)\n\t\tprintf(\"Mounting /tmp\\n\");\n\tchar *tmp;\n\tif (asprintf(&tmp, \"%s/tmp\", oroot) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mount(\"/tmp\", tmp, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /tmp\");\n\tfs_logger(\"whitelist /tmp\");\n\n\t// chroot in the new filesystem\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\tif (chroot(oroot) == -1)\n\t\terrExit(\"chroot\");\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\tif (!arg_private_dev)\n//\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t\tfs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n\n\t// cleanup and exit\n\tfree(option);\n\tfree(odiff);\n\tfree(owork);\n\tfree(dev);\n\tfree(run);\n\tfree(tmp);\n}\n\nCallee: fs_chroot\nvoid fs_chroot(const char *rootdir) {\n\tassert(rootdir);\n\n\t// mount-bind a /dev in rootdir\n\tchar *newdev;\n\tif (asprintf(&newdev, \"%s/dev\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Mounting /dev on %s\\n\", newdev);\n\tif (mount(\"/dev\", newdev, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting /dev\");\n\tfree(newdev);\n\n\t// x11\n\tif (getenv(\"FIREJAIL_X11\")) {\n\t\tchar *newx11;\n\t\tif (asprintf(&newx11, \"%s/tmp/.X11-unix\", rootdir) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting /tmp/.X11-unix on %s\\n\", newx11);\n\t\tif (mount(\"/tmp/.X11-unix\", newx11, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\t\terrExit(\"mounting /tmp/.X11-unix\");\n\t\tfree(newx11);\n\t}\n\n\t// some older distros don't have a /run directory\n\t// create one by default\n\tchar *rundir;\n\tif (asprintf(&rundir, \"%s/run\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tstruct stat s;\n\tif (lstat(rundir, &s) == 0) {\n\t\tif (S_ISLNK(s.st_mode)) {\n\t\t\tfprintf(stderr, \"Error: chroot /run is a symbolic link\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (!S_ISDIR(s.st_mode) || s.st_uid != 0) {\n\t\t\tfprintf(stderr, \"Error: chroot /run should be a directory owned by root\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tif (((S_IWGRP|S_IWOTH) & s.st_mode) != 0) {\n\t\t\tfprintf(stderr, \"Error: only root user should be given write permission on chroot /run\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\telse {\n\t\t// several sandboxes could race to create /run\n\t\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\t\terrExit(\"mkdir\");\n\t\tASSERT_PERMS(rundir, 0, 0, 0755);\n\t}\n\tfree(rundir);\n\n\t// create /run/firejail directory in chroot\n\tif (asprintf(&rundir, \"%s/run/firejail\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tfree(rundir);\n\n\t// create /run/firejail/lib directory in chroot and mount it\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_FIREJAIL_LIB_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_FIREJAIL_LIB_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// create /run/firejail/mnt directory in chroot and mount the current one\n\tif (asprintf(&rundir, \"%s%s\", rootdir, RUN_MNT_DIR) == -1)\n\t\terrExit(\"asprintf\");\n\tif (mkdir(rundir, 0755) == -1 && errno != EEXIST)\n\t\terrExit(\"mkdir\");\n\tASSERT_PERMS(rundir, 0, 0, 0755);\n\tif (mount(RUN_MNT_DIR, rundir, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mount bind\");\n\tfree(rundir);\n\n\t// copy /etc/resolv.conf in chroot directory\n\tchar *fname;\n\tif (asprintf(&fname, \"%s/etc/resolv.conf\", rootdir) == -1)\n\t\terrExit(\"asprintf\");\n\tif (arg_debug)\n\t\tprintf(\"Updating /etc/resolv.conf in %s\\n\", fname);\n\tunlink(fname);\n\tif (copy_file(\"/etc/resolv.conf\", fname, 0, 0, 0644) == -1) // root needed\n\t\tfwarning(\"/etc/resolv.conf not initialized\\n\");\n\tfree(fname);\n\n\t// chroot into the new directory\n#ifdef HAVE_GCOV\n\t__gcov_flush();\n#endif\n\t// mount the chroot dir on top of /run/firejail/mnt/oroot in order to reuse the apparmor rules for overlay\n\t// and chroot into this new directory\n\tif (arg_debug)\n\t\tprintf(\"Chrooting into %s\\n\", rootdir);\n\tchar *oroot = RUN_OVERLAY_ROOT;\n\tif (mkdir(oroot, 0755) == -1)\n\t\terrExit(\"mkdir\");\n\tif (mount(rootdir, oroot, NULL, MS_BIND|MS_REC, NULL) < 0)\n\t\terrExit(\"mounting rootdir oroot\");\n\tif (chroot(oroot) < 0)\n\t\terrExit(\"chroot\");\n\n\t// create all other /run/firejail files and directories\n\tpreproc_build_firejail_dir();\n\n\t// update /var directory in order to support multiple sandboxes running on the same root directory\n//\t\tif (!arg_private_dev)\n//\t\t\tfs_dev_shm();\n\tfs_var_lock();\n\tif (!arg_keep_var_tmp)\n\t        fs_var_tmp();\n\tif (!arg_writable_var_log)\n\t\tfs_var_log();\n\n\tfs_var_lib();\n\tfs_var_cache();\n\tfs_var_utmp();\n\tfs_machineid();\n\n\t// don't leak user information\n\trestrict_users();\n\n\t// when starting as root, firejail config is not disabled;\n\tif (getuid() != 0)\n\t\tdisable_config();\n}\n\nCallee: fs_store_hosts_file\nvoid fs_store_hosts_file(void) {\n\tcopy_file_from_user_to_root(cfg.hosts_file, RUN_HOSTS_FILE, 0, 0, 0644); // root needed\n}\n\nCallee: enforce_filters\nstatic void enforce_filters(void) {\n\t// enforce NO_NEW_PRIVS\n\targ_nonewprivs = 1;\n\tforce_nonewprivs = 1;\n\n\t// disable all capabilities\n\tfmessage(\"\\n**     Warning: dropping all Linux capabilities     **\\n\");\n\targ_caps_drop_all = 1;\n\n\t// drop all supplementary groups; /etc/group file inside chroot\n\t// is controlled by a regular usr\n\targ_nogroups = 1;\n}\n\nCallee: sbox_run\nint sbox_run(unsigned filter, int num, ...) {\n\tEUID_ROOT();\n\n\tint i;\n\tva_list valist;\n\tva_start(valist, num);\n\n\t// build argument list\n\tchar *arg[num + 1];\n\tfor (i = 0; i < num; i++)\n\t\targ[i] = va_arg(valist, char*);\n\targ[i] = NULL;\n\tva_end(valist);\n\n\tif (arg_debug) {\n\t\tprintf(\"sbox run: \");\n\t\tfor (i = 0; i <= num; i++)\n\t\t\tprintf(\"%s \", arg[i]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tpid_t child = fork();\n\tif (child < 0)\n\t\terrExit(\"fork\");\n\tif (child == 0) {\n\t\t// clean the new process\n\t\tclearenv();\n\n\t\tif (filter & SBOX_STDIN_FROM_FILE) {\n\t\t\tint fd;\n\t\t\tif((fd = open(SBOX_STDIN_FILE, O_RDONLY)) == -1) {\n\t\t\t\tfprintf(stderr,\"Error: cannot open %s\\n\", SBOX_STDIN_FILE);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tdup2(fd,STDIN_FILENO);\n\t\t\tclose(fd);\n\t\t}\n\t\telse if ((filter & SBOX_ALLOW_STDIN) == 0) {\n\t\t\tint fd = open(\"/dev/null\",O_RDWR, 0);\n\t\t\tif (fd != -1) {\n\t\t\t\tdup2(fd, STDIN_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\telse // the user could run the sandbox without /dev/null\n\t\t\t\tclose(STDIN_FILENO);\n\t\t}\n\n\t\t// close all other file descriptors\n\t\tint max = 20; // getdtablesize() is overkill for a firejail process\n\t\tfor (i = 3; i < max; i++)\n\t\t\tclose(i); // close open files\n\n\t\tumask(027);\n\n\t\t// apply filters\n\t\tif (filter & SBOX_CAPS_NONE) {\n\t\t\tcaps_drop_all();\n\t\t}\n\t\telse if (filter & SBOX_CAPS_NETWORK) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_NET_ADMIN;\n\t\t\tset |=  ((uint64_t) 1) << CAP_NET_RAW;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\t\telse if (filter & SBOX_CAPS_HIDEPID) {\n#ifndef HAVE_GCOV // the following filter will prevent GCOV from saving info in .gcda files\n\t\t\tuint64_t set = ((uint64_t) 1) << CAP_SYS_PTRACE;\n\t\t\tset |=  ((uint64_t) 1) << CAP_SYS_PACCT;\n\t\t\tcaps_set(set);\n#endif\n\t\t}\n\n\t\tif (filter & SBOX_SECCOMP) {\n\t\t\tif (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {\n\t\t\t\tperror(\"prctl(NO_NEW_PRIVS)\");\n\t\t\t}\n\t\t\tif (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog)) {\n\t\t\t\tperror(\"prctl(PR_SET_SECCOMP)\");\n\t\t\t}\n\t\t}\n\n\t\tif (filter & SBOX_ROOT) {\n\t\t\t// elevate privileges in order to get grsecurity working\n\t\t\tif (setreuid(0, 0))\n\t\t\t\terrExit(\"setreuid\");\n\t\t\tif (setregid(0, 0))\n\t\t\t\terrExit(\"setregid\");\n\t\t}\n\t\telse if (filter & SBOX_USER)\n\t\t\tdrop_privs(1);\n\n\t\tclearenv();\n\n\t\t// --quiet is passed as an environment variable\n\t\tif (arg_quiet)\n\t\t\tsetenv(\"FIREJAIL_QUIET\", \"yes\", 1);\n\n\t\tif (arg[0])\t// get rid of scan-build warning\n\t\t\texecvp(arg[0], arg);\n\t\telse\n\t\t\tassert(0);\n\t\tperror(\"execvp\");\n\t\t_exit(1);\n\t}\n\n\tint status;\n\tif (waitpid(child, &status, 0) == -1 ) {\n\t\terrExit(\"waitpid\");\n\t}\n\tif (WIFEXITED(status) && status != 0) {\n\t\tfprintf(stderr, \"Error: failed to run %s\\n\", arg[0]);\n\t\texit(1);\n\t}\n\n\treturn status;\n}\n\nCallee: env_ibus_load\nvoid env_ibus_load(void) {\n\tEUID_ASSERT();\n\n\t// check ~/.config/ibus/bus directory\n\tchar *dirname;\n\tif (asprintf(&dirname, \"%s/.config/ibus/bus\", cfg.homedir) == -1)\n\t\terrExit(\"asprintf\");\n\n\tstruct stat s;\n\tif (stat(dirname, &s) == -1)\n\t\treturn;\n\n\t// find the file\n\t/* coverity[toctou] */\n\tDIR *dir = opendir(dirname);\n\tif (!dir) {\n\t\tfree(dirname);\n\t\treturn;\n\t}\n\n\tstruct dirent *entry;\n\twhile ((entry = readdir(dir)) != NULL) {\n\t\t// check the file name ends in \"unix-0\"\n\t\tchar *ptr = strstr(entry->d_name, \"unix-0\");\n\t\tif (!ptr)\n\t\t\tcontinue;\n\t\tif (strlen(ptr) != 6)\n\t\t\tcontinue;\n\n\t\t// open the file\n\t\tchar *fname;\n\t\tif (asprintf(&fname, \"%s/%s\", dirname, entry->d_name) == -1)\n\t\t\terrExit(\"asprintf\");\n\t\tFILE *fp = fopen(fname, \"r\");\n\t\tfree(fname);\n\t\tif (!fp)\n\t\t\tcontinue;\n\n\t\t// read the file\n\t\tconst int maxline = 4096;\n\t\tchar buf[maxline];\n\t\twhile (fgets(buf, maxline, fp)) {\n\t\t\tif (strncmp(buf, \"IBUS_\", 5) != 0)\n\t\t\t\tcontinue;\n\t\t\tchar *ptr = strchr(buf, '=');\n\t\t\tif (!ptr)\n\t\t\t\tcontinue;\n\t\t\tptr = strchr(buf, '\\n');\n\t\t\tif (ptr)\n\t\t\t\t*ptr = '\\0';\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"%s\\n\", buf);\n\t\t\tenv_store(buf, SETENV);\n\t\t}\n\n\t\tfclose(fp);\n\t}\n\n\tfree(dirname);\n\tclosedir(dir);\n}\n\nCallee: any_interface_configured\nstatic inline int any_interface_configured(void) {\n\tif (cfg.interface0.configured || cfg.interface1.configured || cfg.interface2.configured || cfg.interface3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nCallee: any_bridge_configured\nstatic inline int any_bridge_configured(void) {\n\tif (cfg.bridge0.configured || cfg.bridge1.configured || cfg.bridge2.configured || cfg.bridge3.configured)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nCallee: fmessage\nvoid fmessage(char* fmt, ...) { // TODO: this function is duplicated in src/fnet/interface.c\n\tif (arg_quiet)\n\t\treturn;\n\n\tva_list args;\n\tva_start(args,fmt);\n\tvfprintf(stderr, fmt, args);\n\tva_end(args);\n\tfflush(0);\n}\n\nCallee: net_add_route\nint net_add_route(uint32_t ip, uint32_t mask, uint32_t gw) {\n\tint sock;\n\tstruct rtentry route;\n\tstruct sockaddr_in *addr;\n\tint err = 0;\n\n\t// create the socket\n\tif((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0)\n\t\terrExit(\"socket\");\n\n\tmemset(&route, 0, sizeof(route));\n\n\taddr = (struct sockaddr_in*) &route.rt_gateway;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(gw);\n\n\taddr = (struct sockaddr_in*) &route.rt_dst;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(ip);\n\n\taddr = (struct sockaddr_in*) &route.rt_genmask;\n\taddr->sin_family = AF_INET;\n\taddr->sin_addr.s_addr = htonl(mask);\n\n\troute.rt_flags = RTF_UP | RTF_GATEWAY;\n\troute.rt_metric = 0;\n\tif ((err = ioctl(sock, SIOCADDRT, &route)) != 0) {\n\t\tclose(sock);\n\t\treturn -1;\n\t}\n\n\tclose(sock);\n\treturn 0;\n}\n\nCallee: net_config_interface\nvoid net_config_interface(const char *dev, uint32_t ip, uint32_t mask, int mtu) {\n\tassert(dev);\n\n\tchar *ipstr;\n\tif (asprintf(&ipstr, \"%llu\", (long long unsigned) ip) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *maskstr;\n\tif (asprintf(&maskstr, \"%llu\", (long long unsigned) mask) == -1)\n\t\terrExit(\"asprintf\");\n\n\tchar *mtustr;\n\tif (asprintf(&mtustr, \"%d\", mtu) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 7,\n\t\tPATH_FNET, \"config\", \"interface\", dev, ipstr, maskstr, mtustr);\n\n\tfree(ipstr);\n\tfree(maskstr);\n\tfree(mtustr);\n}\n\nCallee: sandbox_if_up\nstatic void sandbox_if_up(Bridge *br) {\n\tassert(br);\n\tif (!br->configured)\n\t\treturn;\n\n\tchar *dev = br->devsandbox;\n\tnet_if_up(dev);\n\n\tif (br->arg_ip_none == 1);\t// do nothing\n\telse if (br->arg_ip_none == 0 && br->macvlan == 0) {\n\t\tif (br->ipsandbox == br->ip) {\n\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\texit(1);\n\t\t}\n\n\t\t// just assign the address\n\t\tassert(br->ipsandbox);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\telse if (br->arg_ip_none == 0 && br->macvlan == 1) {\n\t\t// reassign the macvlan address\n\t\tif (br->ipsandbox == 0)\n\t\t\t// ip address assigned by arp-scan for a macvlan device\n\t\t\tbr->ipsandbox = arp_assign(dev, br); //br->ip, br->mask);\n\t\telse {\n\t\t\tif (br->ipsandbox == br->ip) {\n\t\t\t\tfprintf(stderr, \"Error: %d.%d.%d.%d is interface %s address.\\n\", PRINT_IP(br->ipsandbox), br->dev);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tuint32_t rv = arp_check(dev, br->ipsandbox);\n\t\t\tif (rv) {\n\t\t\t\tfprintf(stderr, \"Error: the address %d.%d.%d.%d is already in use.\\n\", PRINT_IP(br->ipsandbox));\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(br->ipsandbox), dev);\n\t\tnet_config_interface(dev, br->ipsandbox, br->mask, br->mtu);\n\t\tarp_announce(dev, br);\n\t}\n\n\tif (br->ip6sandbox)\n\t\t net_if_ip6(dev, br->ip6sandbox);\n}\n\nCallee: net_config_mac\nint net_config_mac(const char *ifname, const unsigned char mac[6]) {\n\tchar *macstr;\n\tif (asprintf(&macstr, \"%02x:%02x:%02x:%02x:%02x:%02x\",\n\t\tmac[0], mac[1], mac[2], mac[3], mac[4], mac[5]) == -1)\n\t\terrExit(\"asprintf\");\n\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 5,\n\t\tPATH_FNET, \"config\", \"mac\", ifname, macstr);\n\n\tfree(macstr);\n\treturn 0;\n}\n\nCallee: mac_not_zero\nstatic inline int mac_not_zero(const unsigned char mac[6]) {\n\tint i;\n\tfor (i = 0; i < 6; i++) {\n\t\tif (mac[i] != 0)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nCallee: net_if_up\nvoid net_if_up(const char *ifname) {\n\tif (strlen(ifname) > IFNAMSIZ) {\n\t\tfprintf(stderr, \"Error: invalid network device name %s\\n\", ifname);\n\t\texit(1);\n\t}\n\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3,\n\t\tPATH_FNET, \"ifup\", ifname);\n}\n\nCallee: netfilter6\nvoid netfilter6(const char *fname) {\n\tif (fname == NULL)\n\t\treturn;\n\n\t// find iptables command\n\tchar *ip6tables = NULL;\n\tchar *ip6tables_restore = NULL;\n\tstruct stat s;\n\tif (stat(\"/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/sbin/ip6tables\";\n\t\tip6tables_restore = \"/sbin/ip6tables-restore\";\n\t}\n\telse if (stat(\"/usr/sbin/ip6tables\", &s) == 0) {\n\t\tip6tables = \"/usr/sbin/ip6tables\";\n\t\tip6tables_restore = \"/usr/sbin/ip6tables-restore\";\n\t}\n\tif (ip6tables == NULL || ip6tables_restore == NULL) {\n\t\tfprintf(stderr, \"Error: ip6tables command not found, netfilter6 not configured\\n\");\n\t\treturn;\n\t}\n\n\tif (arg_debug)\n\t\tprintf(\"Installing IPv6 firewall\\n\");\n\n\t// create an empty user-owned SBOX_STDIN_FILE\n\tcreate_empty_file_as_root(SBOX_STDIN_FILE, 0644);\n\tif (set_perms(SBOX_STDIN_FILE, getuid(), getgid(), 0644))\n\t\terrExit(\"set_perms\");\n\n\tsbox_run(SBOX_USER| SBOX_CAPS_NONE | SBOX_SECCOMP, 3, PATH_FNETFILTER, fname, SBOX_STDIN_FILE);\n\n\t// first run of iptables on this platform installs a number of kernel modules such as ip_tables, x_tables, iptable_filter\n\t// we run this command with caps and seccomp disabled in order to allow the loading of these modules\n\tsbox_run(SBOX_ROOT | SBOX_STDIN_FROM_FILE, 1, ip6tables_restore);\n\tunlink(SBOX_STDIN_FILE);\n\n\t// debug\n\tif (arg_debug)\n\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, ip6tables, \"-vL\");\n\n\treturn;\n}\n\nCallee: fs_logger\nvoid fs_logger_print_log(pid_t pid) {\n\tEUID_ASSERT();\n\n\t// in case the pid is that of a firejail process, use the pid of the first child process\n\tpid = switch_to_child(pid);\n\n\t// check privileges for non-root users\n\tuid_t uid = getuid();\n\tif (uid != 0) {\n\t\tuid_t sandbox_uid = pid_get_uid(pid);\n\t\tif (uid != sandbox_uid) {\n\t\t\tfprintf(stderr, \"Error: permission denied\\n\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\t// print RUN_FSLOGGER_FILE\n\tchar *fname;\n\tif (asprintf(&fname, \"/proc/%d/root%s\", pid, RUN_FSLOGGER_FILE) == -1)\n\t\terrExit(\"asprintf\");\n\n\tEUID_ROOT();\n\tstruct stat s;\n\tif (stat(fname, &s) == -1 || s.st_uid != 0) {\n\t\tfprintf(stderr, \"Error: Cannot access filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\t/* coverity[toctou] */\n\tFILE *fp = fopen(fname, \"r\");\n\tif (!fp) {\n\t\tfprintf(stderr, \"Error: Cannot open filesystem log\\n\");\n\t\texit(1);\n\t}\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp))\n\t\tprintf(\"%s\", buf);\n\tfclose(fp);\n\tfree(fname);\n\n\texit(0);\n}\n\nCallee: fs_logger2int\nvoid fs_logger2int(const char *msg1, int d) {\n\tFsMsg *ptr = newmsg();\n\tchar *str;\n\tif (asprintf(&str, \"%s %d\", msg1, d) == -1)\n\t\terrExit(\"asprintf\");\n\tptr->msg = str;\n\tinsertmsg(ptr);\n}\n\nCallee: preproc_mount_mnt_dir\nvoid preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}\n\nCallee: chk_chroot\nstatic void chk_chroot(void) {\n\t// if we are starting firejail inside some other container technology, we don't care about this\n\tchar *mycont = getenv(\"container\");\n\tif (mycont)\n\t\treturn;\n\n\t// check if this is a regular chroot\n\tstruct stat s;\n\tif (stat(\"/\", &s) == 0) {\n\t\tif (s.st_ino != 2)\n\t\t\treturn;\n\t}\n\n\tfprintf(stderr, \"Error: cannot mount filesystem as slave\\n\");\n\texit(1);\n}\n\nCallee: strlen\nlen = strlen(name);\n\tif (len <= 4)\n\t\treturn 0;\n\tif (*name == '$' && name[1] == '{' && name[len - 1] == '}')\n\t\treturn 1;\n\treturn 0;\n}\n\n// returns mallocated memory\nstatic char *resolve_x\n",
    "Vulnerable": false,
    "Description": "The sandbox() function performs extensive sandbox setup (namespaces, mounts, network, seccomp, capabilities, dropping privileges) but does not itself implement an external authorization model or grant/deny access to resources based on caller identity or roles. It assumes the caller is already allowed to create a sandbox and then only *reduces* privileges and access. All privileged operations (mount, chroot, overlay, user namespaces, capabilities, seccomp, etc.) are performed as root or with controlled setuid transitions and are ultimately followed by drop_privs(). This is confinement logic, not an access-control gate for other users, and there is no code path where an unprivileged caller gains extra rights or bypasses checks. Based solely on the provided code, there is no indication of improper access control (CWE-284)."
  }
]