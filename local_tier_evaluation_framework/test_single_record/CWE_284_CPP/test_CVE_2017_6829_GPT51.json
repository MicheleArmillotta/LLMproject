[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "decodeBlockWAVE",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
      "162-198"
    ],
    "function_name": "decodeBlockWAVE",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n  \t\tif (encoded[1] & 0x80)\n  \t\t\tm_adpcmState[c].previousValue -= 0x10000;\n  \n  \t\tm_adpcmState[c].index = encoded[2];\n  \n  \t\t*decoded++ = m_adpcmState[c].previousValue;\n  \n  \t\tencoded += 4;\n  \t}\n  \n  \tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n  \t{\n  \t\tfor (int c=0; c<channelCount; c++)\n  \t\t{\n  \t\t\tint16_t *output = decoded + c;\n  \t\t\tfor (int s=0; s<4; s++)\n  \t\t\t{\n  \t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n  \t\t\t\toutput += channelCount;\n  \t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n  \t\t\t\toutput += channelCount;\n  \t\t\t\tencoded++;\n  \t\t\t}\n  \t\t}\n  \n  \t\tdecoded += channelCount * 8;\n  \t}\n  \n  \treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: decodeSample\nstatic inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}\n",
    "sinks": []
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "decodeBlockQT",
      "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2017-6829/repo/libaudiofile/modules/IMA.cpp",
      "201-226"
    ],
    "function_name": "decodeBlockQT",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"../pcm.h\"\n#include \"util.h\"\n#include \"byteorder.h\"\n#include \"afinternal.h\"\n#include \"Track.h\"\n#include \"File.h\"\n#include \"Compiler.h\"\n#include \"BlockCodec.h\"\n#include <audiofile.h>\n#include <assert.h>\n#include \"IMA.h\"\n#include \"config.h\"\n\nIMA {\n  int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n  {\n  \tint channelCount = m_track->f.channelCount;\n  \n  \tfor (int c=0; c<channelCount; c++)\n  \t{\n  \t\tadpcmState state;\n  \t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n  \t\tif (predictor & 0x8000)\n  \t\t\tpredictor -= 0x10000;\n  \n  \t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n  \t\tstate.index = encoded[1] & 0x7f;\n  \t\tencoded += 2;\n  \n  \t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n  \t\t{\n  \t\t\tuint8_t e = *encoded;\n  \t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n  \t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n  \t\t\tencoded++;\n  \t\t}\n  \t}\n  \n  \treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n  }\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: decodeSample\nstatic inline int16_t decodeSample(adpcmState &state, uint8_t code)\n{\n\tint step = stepTable[state.index];\n\n\tint diff = step >> 3;\n\tif (code & 4) diff += step;\n\tif (code & 2) diff += step>>1;\n\tif (code & 1) diff += step>>2;\n\n\tint predictor = state.previousValue;\n\tif (code & 8)\n\t\tpredictor -= diff;\n\telse\n\t\tpredictor += diff;\n\n\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\tstate.index = clamp(state.index + indexTable[code], 0, 88);\n\treturn state.previousValue;\n}\n\nCallee: clamp\nstatic inline int clamp(int x, int low, int high)\n{\n\tif (x < low) return low;\n\tif (x > high) return high;\n\treturn x;\n}\n",
    "sinks": []
  }
]