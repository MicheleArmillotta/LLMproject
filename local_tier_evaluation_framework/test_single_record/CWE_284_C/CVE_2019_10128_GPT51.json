[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "examine_variable",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
      "4775-4984"
    ],
    "function_name": "examine_variable",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_index_stats_hook_type get_index_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nvoid\nexamine_variable(PlannerInfo *root, Node *node, int varRelid,\n\t\t\t\t VariableStatData *vardata)\n{\n\tNode\t   *basenode;\n\tRelids\t\tvarnos;\n\tRelOptInfo *onerel;\n\n\t/* Make sure we don't return dangling pointers in vardata */\n\tMemSet(vardata, 0, sizeof(VariableStatData));\n\n\t/* Save the exposed type of the expression */\n\tvardata->vartype = exprType(node);\n\n\t/* Look inside any binary-compatible relabeling */\n\n\tif (IsA(node, RelabelType))\n\t\tbasenode = (Node *) ((RelabelType *) node)->arg;\n\telse\n\t\tbasenode = node;\n\n\t/* Fast path for a simple Var */\n\n\tif (IsA(basenode, Var) &&\n\t\t(varRelid == 0 || varRelid == ((Var *) basenode)->varno))\n\t{\n\t\tVar\t\t   *var = (Var *) basenode;\n\n\t\t/* Set up result fields other than the stats tuple */\n\t\tvardata->var = basenode;\t/* return Var without relabeling */\n\t\tvardata->rel = find_base_rel(root, var->varno);\n\t\tvardata->atttype = var->vartype;\n\t\tvardata->atttypmod = var->vartypmod;\n\t\tvardata->isunique = has_unique_index(vardata->rel, var->varattno);\n\n\t\t/* Try to locate some stats */\n\t\texamine_simple_variable(root, var, vardata);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * Okay, it's a more complicated expression.  Determine variable\n\t * membership.  Note that when varRelid isn't zero, only vars of that\n\t * relation are considered \"real\" vars.\n\t */\n\tvarnos = pull_varnos(basenode);\n\n\tonerel = NULL;\n\n\tswitch (bms_membership(varnos))\n\t{\n\t\tcase BMS_EMPTY_SET:\n\t\t\t/* No Vars at all ... must be pseudo-constant clause */\n\t\t\tbreak;\n\t\tcase BMS_SINGLETON:\n\t\t\tif (varRelid == 0 || bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\tonerel = find_base_rel(root,\n\t\t\t\t\t\t\t\t\t   (varRelid ? varRelid : bms_singleton_member(varnos)));\n\t\t\t\tvardata->rel = onerel;\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t\tcase BMS_MULTIPLE:\n\t\t\tif (varRelid == 0)\n\t\t\t{\n\t\t\t\t/* treat it as a variable of a join relation */\n\t\t\t\tvardata->rel = find_join_rel(root, varnos);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t}\n\t\t\telse if (bms_is_member(varRelid, varnos))\n\t\t\t{\n\t\t\t\t/* ignore the vars belonging to other relations */\n\t\t\t\tvardata->rel = find_base_rel(root, varRelid);\n\t\t\t\tnode = basenode;\t/* strip any relabeling */\n\t\t\t\t/* note: no point in expressional-index search here */\n\t\t\t}\n\t\t\t/* else treat it as a constant */\n\t\t\tbreak;\n\t}\n\n\tbms_free(varnos);\n\n\tvardata->var = node;\n\tvardata->atttype = exprType(node);\n\tvardata->atttypmod = exprTypmod(node);\n\n\tif (onerel)\n\t{\n\t\t/*\n\t\t * We have an expression in vars of a single relation.  Try to match\n\t\t * it to expressional index columns, in hopes of finding some\n\t\t * statistics.\n\t\t *\n\t\t * Note that we consider all index columns including INCLUDE columns,\n\t\t * since there could be stats for such columns.  But the test for\n\t\t * uniqueness needs to be warier.\n\t\t *\n\t\t * XXX it's conceivable that there are multiple matches with different\n\t\t * index opfamilies; if so, we need to pick one that matches the\n\t\t * operator we are estimating for.  FIXME later.\n\t\t */\n\t\tListCell   *ilist;\n\n\t\tforeach(ilist, onerel->indexlist)\n\t\t{\n\t\t\tIndexOptInfo *index = (IndexOptInfo *) lfirst(ilist);\n\t\t\tListCell   *indexpr_item;\n\t\t\tint\t\t\tpos;\n\n\t\t\tindexpr_item = list_head(index->indexprs);\n\t\t\tif (indexpr_item == NULL)\n\t\t\t\tcontinue;\t\t/* no expressions here... */\n\n\t\t\tfor (pos = 0; pos < index->ncolumns; pos++)\n\t\t\t{\n\t\t\t\tif (index->indexkeys[pos] == 0)\n\t\t\t\t{\n\t\t\t\t\tNode\t   *indexkey;\n\n\t\t\t\t\tif (indexpr_item == NULL)\n\t\t\t\t\t\telog(ERROR, \"too few entries in indexprs list\");\n\t\t\t\t\tindexkey = (Node *) lfirst(indexpr_item);\n\t\t\t\t\tif (indexkey && IsA(indexkey, RelabelType))\n\t\t\t\t\t\tindexkey = (Node *) ((RelabelType *) indexkey)->arg;\n\t\t\t\t\tif (equal(node, indexkey))\n\t\t\t\t\t{\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Found a match ... is it a unique index? Tests here\n\t\t\t\t\t\t * should match has_unique_index().\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (index->unique &&\n\t\t\t\t\t\t\tindex->nkeycolumns == 1 &&\n\t\t\t\t\t\t\tpos == 0 &&\n\t\t\t\t\t\t\t(index->indpred == NIL || index->predOK))\n\t\t\t\t\t\t\tvardata->isunique = true;\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * Has it got stats?  We only consider stats for\n\t\t\t\t\t\t * non-partial indexes, since partial indexes probably\n\t\t\t\t\t\t * don't reflect whole-relation statistics; the above\n\t\t\t\t\t\t * check for uniqueness is the only info we take from\n\t\t\t\t\t\t * a partial index.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * An index stats hook, however, must make its own\n\t\t\t\t\t\t * decisions about what to do with partial indexes.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (get_index_stats_hook &&\n\t\t\t\t\t\t\t(*get_index_stats_hook) (root, index->indexoid,\n\t\t\t\t\t\t\t\t\t\t\t\t\t pos + 1, vardata))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t * The hook took control of acquiring a stats\n\t\t\t\t\t\t\t * tuple.  If it did supply a tuple, it'd better\n\t\t\t\t\t\t\t * have supplied a freefunc.\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t\t\t\t\t\t!vardata->freefunc)\n\t\t\t\t\t\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (index->indpred == NIL)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvardata->statsTuple =\n\t\t\t\t\t\t\t\tSearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t\tObjectIdGetDatum(index->indexoid),\n\t\t\t\t\t\t\t\t\t\t\t\tInt16GetDatum(pos + 1),\n\t\t\t\t\t\t\t\t\t\t\t\tBoolGetDatum(false));\n\t\t\t\t\t\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\t\t\t\t\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* Get index's table for permission check */\n\t\t\t\t\t\t\t\tRangeTblEntry *rte;\n\n\t\t\t\t\t\t\t\trte = planner_rt_fetch(index->rel->relid, root);\n\t\t\t\t\t\t\t\tAssert(rte->rtekind == RTE_RELATION);\n\n\t\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t\t * For simplicity, we insist on the whole\n\t\t\t\t\t\t\t\t * table being selectable, rather than trying\n\t\t\t\t\t\t\t\t * to identify which column(s) the index\n\t\t\t\t\t\t\t\t * depends on.  Also require all rows to be\n\t\t\t\t\t\t\t\t * selectable --- there must be no\n\t\t\t\t\t\t\t\t * securityQuals from security barrier views\n\t\t\t\t\t\t\t\t * or RLS policies.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tvardata->acl_ok =\n\t\t\t\t\t\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t\t\t\t\t\t(pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   ACL_SELECT) == ACLCHECK_OK);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t/* suppress leakproofness checks later */\n\t\t\t\t\t\t\t\tvardata->acl_ok = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (vardata->statsTuple)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tindexpr_item = lnext(indexpr_item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vardata->statsTuple)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: GetUserId\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}\n\nCallee: SearchSysCache3\nHeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}\n\nCallee: elog\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}\n\nCallee: equal\nstatic bool\nequalsJsonbScalarValue(JsonbValue *aScalar, JsonbValue *bScalar)\n{\n\tif (aScalar->type == bScalar->type)\n\t{\n\t\tswitch (aScalar->type)\n\t\t{\n\t\t\tcase jbvNull:\n\t\t\t\treturn true;\n\t\t\tcase jbvString:\n\t\t\t\treturn lengthCompareJsonbStringValue(aScalar, bScalar) == 0;\n\t\t\tcase jbvNumeric:\n\t\t\t\treturn DatumGetBool(DirectFunctionCall2(numeric_eq,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(aScalar->val.numeric),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tPointerGetDatum(bScalar->val.numeric)));\n\t\t\tcase jbvBool:\n\t\t\t\treturn aScalar->val.boolean == bScalar->val.boolean;\n\n\t\t\tdefault:\n\t\t\t\telog(ERROR, \"invalid jsonb scalar type\");\n\t\t}\n\t}\n\telog(ERROR, \"jsonb scalar type mismatch\");\n\treturn -1;\n}\n\nCallee: examine_simple_variable\nstatic void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}\n",
    "sinks": [
      {
        "sink_id": "pg_class_aclcheck(..., GetUserId(), ACL_SELECT)",
        "sink_description": "Checks whether the current user is allowed to read from the table underlying an index before using its statistics, thereby controlling access to potentially sensitive statistical information.",
        "required_conditions": [
          {
            "id": "table_select_acl_required",
            "description": "The current user must have SELECT privilege on the table whose index statistics are being consulted.",
            "locally_satisfied": true,
            "justification": "The code calls pg_class_aclcheck(rte->relid, GetUserId(), ACL_SELECT) and requires the result to be ACLCHECK_OK before setting vardata->acl_ok when index stats are found."
          },
          {
            "id": "no_security_quals_on_rte",
            "description": "The range table entry must not have security barrier quals or row-level security policies that would restrict visibility of rows.",
            "locally_satisfied": true,
            "justification": "The predicate rte->securityQuals == NIL is required along with the ACL check for vardata->acl_ok to be set when using index statistics."
          }
        ]
      },
      {
        "sink_id": "pg_class_aclcheck/pg_attribute_aclcheck in examine_simple_variable",
        "sink_description": "Determines whether the current user is allowed to read a column’s statistics, which may reveal information about underlying data distribution.",
        "required_conditions": [
          {
            "id": "column_or_table_select_acl_required",
            "description": "The current user must either have SELECT privilege on the whole table or SELECT privilege on the specific column whose statistics are being accessed.",
            "locally_satisfied": true,
            "justification": "When a pg_statistic tuple is found, vardata->acl_ok is set only if (pg_class_aclcheck(..., GetUserId(), ACL_SELECT) == ACLCHECK_OK) OR (pg_attribute_aclcheck(..., GetUserId(), ACL_SELECT) == ACLCHECK_OK)."
          },
          {
            "id": "no_security_quals_on_rte_simple",
            "description": "The referenced relation must not have security barrier quals or row-level security policies that could hide some rows.",
            "locally_satisfied": true,
            "justification": "The assignment to vardata->acl_ok also requires rte->securityQuals == NIL, ensuring that there are no additional visibility restrictions when using statistics."
          }
        ]
      }
    ]
  },
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "examine_simple_variable",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2019-10128/repo/src/backend/utils/adt/selfuncs.c",
      "4995-5159"
    ],
    "function_name": "examine_simple_variable",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"utils/varlena.h\"\n#include \"utils/typcache.h\"\n#include \"utils/tqual.h\"\n#include \"utils/timestamp.h\"\n#include \"utils/syscache.h\"\n#include \"utils/spccache.h\"\n#include \"utils/snapmgr.h\"\n#include \"utils/selfuncs.h\"\n#include \"utils/rel.h\"\n#include \"utils/pg_locale.h\"\n#include \"utils/nabstime.h\"\n#include \"utils/lsyscache.h\"\n#include \"utils/index_selfuncs.h\"\n#include \"utils/fmgroids.h\"\n#include \"utils/datum.h\"\n#include \"utils/date.h\"\n#include \"utils/bytea.h\"\n#include \"utils/builtins.h\"\n#include \"utils/acl.h\"\n#include \"statistics/statistics.h\"\n#include \"parser/parsetree.h\"\n#include \"parser/parse_coerce.h\"\n#include \"parser/parse_clause.h\"\n#include \"optimizer/var.h\"\n#include \"optimizer/restrictinfo.h\"\n#include \"optimizer/predtest.h\"\n#include \"optimizer/plancat.h\"\n#include \"optimizer/paths.h\"\n#include \"optimizer/pathnode.h\"\n#include \"optimizer/cost.h\"\n#include \"optimizer/clauses.h\"\n#include \"nodes/nodeFuncs.h\"\n#include \"nodes/makefuncs.h\"\n#include \"miscadmin.h\"\n#include \"mb/pg_wchar.h\"\n#include \"executor/executor.h\"\n#include \"catalog/pg_type.h\"\n#include \"catalog/pg_statistic_ext.h\"\n#include \"catalog/pg_statistic.h\"\n#include \"catalog/pg_opfamily.h\"\n#include \"catalog/pg_operator.h\"\n#include \"catalog/pg_collation.h\"\n#include \"catalog/pg_am.h\"\n#include \"catalog/index.h\"\n#include \"access/sysattr.h\"\n#include \"access/htup_details.h\"\n#include \"access/gin.h\"\n#include \"access/brin.h\"\n#include <math.h>\n#include <float.h>\n#include <ctype.h>\n#include \"postgres.h\"\n\nget_relation_stats_hook_type get_relation_stats_hook = NULL;\nstatic void examine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata);\n\nstatic void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: examine_simple_variable\nstatic void\nexamine_simple_variable(PlannerInfo *root, Var *var,\n\t\t\t\t\t\tVariableStatData *vardata)\n{\n\tRangeTblEntry *rte = root->simple_rte_array[var->varno];\n\n\tAssert(IsA(rte, RangeTblEntry));\n\n\tif (get_relation_stats_hook &&\n\t\t(*get_relation_stats_hook) (root, rte, var->varattno, vardata))\n\t{\n\t\t/*\n\t\t * The hook took control of acquiring a stats tuple.  If it did supply\n\t\t * a tuple, it'd better have supplied a freefunc.\n\t\t */\n\t\tif (HeapTupleIsValid(vardata->statsTuple) &&\n\t\t\t!vardata->freefunc)\n\t\t\telog(ERROR, \"no function provided to release variable stats with\");\n\t}\n\telse if (rte->rtekind == RTE_RELATION)\n\t{\n\t\t/*\n\t\t * Plain table or parent of an inheritance appendrel, so look up the\n\t\t * column in pg_statistic\n\t\t */\n\t\tvardata->statsTuple = SearchSysCache3(STATRELATTINH,\n\t\t\t\t\t\t\t\t\t\t\t  ObjectIdGetDatum(rte->relid),\n\t\t\t\t\t\t\t\t\t\t\t  Int16GetDatum(var->varattno),\n\t\t\t\t\t\t\t\t\t\t\t  BoolGetDatum(rte->inh));\n\t\tvardata->freefunc = ReleaseSysCache;\n\n\t\tif (HeapTupleIsValid(vardata->statsTuple))\n\t\t{\n\t\t\t/*\n\t\t\t * Check if user has permission to read this column.  We require\n\t\t\t * all rows to be accessible, so there must be no securityQuals\n\t\t\t * from security barrier views or RLS policies.\n\t\t\t */\n\t\t\tvardata->acl_ok =\n\t\t\t\trte->securityQuals == NIL &&\n\t\t\t\t((pg_class_aclcheck(rte->relid, GetUserId(),\n\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK) ||\n\t\t\t\t (pg_attribute_aclcheck(rte->relid, var->varattno, GetUserId(),\n\t\t\t\t\t\t\t\t\t\tACL_SELECT) == ACLCHECK_OK));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* suppress any possible leakproofness checks later */\n\t\t\tvardata->acl_ok = true;\n\t\t}\n\t}\n\telse if (rte->rtekind == RTE_SUBQUERY && !rte->inh)\n\t{\n\t\t/*\n\t\t * Plain subquery (not one that was converted to an appendrel).\n\t\t */\n\t\tQuery\t   *subquery = rte->subquery;\n\t\tRelOptInfo *rel;\n\t\tTargetEntry *ste;\n\n\t\t/*\n\t\t * Punt if it's a whole-row var rather than a plain column reference.\n\t\t */\n\t\tif (var->varattno == InvalidAttrNumber)\n\t\t\treturn;\n\n\t\t/*\n\t\t * Punt if subquery uses set operations or GROUP BY, as these will\n\t\t * mash underlying columns' stats beyond recognition.  (Set ops are\n\t\t * particularly nasty; if we forged ahead, we would return stats\n\t\t * relevant to only the leftmost subselect...)\tDISTINCT is also\n\t\t * problematic, but we check that later because there is a possibility\n\t\t * of learning something even with it.\n\t\t */\n\t\tif (subquery->setOperations ||\n\t\t\tsubquery->groupClause)\n\t\t\treturn;\n\n\t\t/*\n\t\t * OK, fetch RelOptInfo for subquery.  Note that we don't change the\n\t\t * rel returned in vardata, since caller expects it to be a rel of the\n\t\t * caller's query level.  Because we might already be recursing, we\n\t\t * can't use that rel pointer either, but have to look up the Var's\n\t\t * rel afresh.\n\t\t */\n\t\trel = find_base_rel(root, var->varno);\n\n\t\t/* If the subquery hasn't been planned yet, we have to punt */\n\t\tif (rel->subroot == NULL)\n\t\t\treturn;\n\t\tAssert(IsA(rel->subroot, PlannerInfo));\n\n\t\t/*\n\t\t * Switch our attention to the subquery as mangled by the planner. It\n\t\t * was okay to look at the pre-planning version for the tests above,\n\t\t * but now we need a Var that will refer to the subroot's live\n\t\t * RelOptInfos.  For instance, if any subquery pullup happened during\n\t\t * planning, Vars in the targetlist might have gotten replaced, and we\n\t\t * need to see the replacement expressions.\n\t\t */\n\t\tsubquery = rel->subroot->parse;\n\t\tAssert(IsA(subquery, Query));\n\n\t\t/* Get the subquery output expression referenced by the upper Var */\n\t\tste = get_tle_by_resno(subquery->targetList, var->varattno);\n\t\tif (ste == NULL || ste->resjunk)\n\t\t\telog(ERROR, \"subquery %s does not have attribute %d\",\n\t\t\t\t rte->eref->aliasname, var->varattno);\n\t\tvar = (Var *) ste->expr;\n\n\t\t/*\n\t\t * If subquery uses DISTINCT, we can't make use of any stats for the\n\t\t * variable ... but, if it's the only DISTINCT column, we are entitled\n\t\t * to consider it unique.  We do the test this way so that it works\n\t\t * for cases involving DISTINCT ON.\n\t\t */\n\t\tif (subquery->distinctClause)\n\t\t{\n\t\t\tif (list_length(subquery->distinctClause) == 1 &&\n\t\t\t\ttargetIsInSortList(ste, InvalidOid, subquery->distinctClause))\n\t\t\t\tvardata->isunique = true;\n\t\t\t/* cannot go further */\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If the sub-query originated from a view with the security_barrier\n\t\t * attribute, we must not look at the variable's statistics, though it\n\t\t * seems all right to notice the existence of a DISTINCT clause. So\n\t\t * stop here.\n\t\t *\n\t\t * This is probably a harsher restriction than necessary; it's\n\t\t * certainly OK for the selectivity estimator (which is a C function,\n\t\t * and therefore omnipotent anyway) to look at the statistics.  But\n\t\t * many selectivity estimators will happily *invoke the operator\n\t\t * function* to try to work out a good estimate - and that's not OK.\n\t\t * So for now, don't dig down for stats.\n\t\t */\n\t\tif (rte->security_barrier)\n\t\t\treturn;\n\n\t\t/* Can only handle a simple Var of subquery's query level */\n\t\tif (var && IsA(var, Var) &&\n\t\t\tvar->varlevelsup == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * OK, recurse into the subquery.  Note that the original setting\n\t\t\t * of vardata->isunique (which will surely be false) is left\n\t\t\t * unchanged in this situation.  That's what we want, since even\n\t\t\t * if the underlying column is unique, the subquery may have\n\t\t\t * joined to other tables in a way that creates duplicates.\n\t\t\t */\n\t\t\texamine_simple_variable(rel->subroot, var, vardata);\n\t\t}\n\t}\n\telse\n\t{\n\t\t/*\n\t\t * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We\n\t\t * won't see RTE_JOIN here because join alias Vars have already been\n\t\t * flattened.)\tThere's not much we can do with function outputs, but\n\t\t * maybe someday try to be smarter about VALUES and/or CTEs.\n\t\t */\n\t}\n}\n\nCallee: elog\nchar *\nformat_elog_string(const char *fmt,...)\n{\n\tErrorData\terrdata;\n\tErrorData  *edata;\n\tMemoryContext oldcontext;\n\n\t/* Initialize a mostly-dummy error frame */\n\tedata = &errdata;\n\tMemSet(edata, 0, sizeof(ErrorData));\n\t/* the default text domain is the backend's */\n\tedata->domain = save_format_domain ? save_format_domain : PG_TEXTDOMAIN(\"postgres\");\n\t/* set the errno to be used to interpret %m */\n\tedata->saved_errno = save_format_errnumber;\n\n\toldcontext = MemoryContextSwitchTo(ErrorContext);\n\n\tedata->message_id = fmt;\n\tEVALUATE_MESSAGE(edata->domain, message, false, true);\n\n\tMemoryContextSwitchTo(oldcontext);\n\n\treturn edata->message;\n}\n\nCallee: GetUserId\nOid\nGetUserId(void)\n{\n\tAssertState(OidIsValid(CurrentUserId));\n\treturn CurrentUserId;\n}\n\nCallee: SearchSysCache3\nHeapTuple\nSearchSysCache3(int cacheId,\n\t\t\t\tDatum key1, Datum key2, Datum key3)\n{\n\tAssert(cacheId >= 0 && cacheId < SysCacheSize &&\n\t\t   PointerIsValid(SysCache[cacheId]));\n\tAssert(SysCache[cacheId]->cc_nkeys == 3);\n\n\treturn SearchCatCache3(SysCache[cacheId], key1, key2, key3);\n}\n",
    "sinks": [
      {
        "sink_id": "vardata->acl_ok assignment (RTE_RELATION case)",
        "sink_description": "Determines whether the current user is allowed to read statistics for a base-table column, which affects whether later planner code may use potentially leak-prone statistics or leakproofness shortcuts.",
        "required_conditions": [
          {
            "id": "no_security_quals",
            "description": "The relation must not have security barrier quals or row-level security policies that would hide some rows from the current user.",
            "locally_satisfied": true,
            "justification": "The code requires rte->securityQuals == NIL before setting acl_ok based on ACL checks."
          },
          {
            "id": "select_acl_on_table_or_column",
            "description": "The current user must have SELECT privilege on the table or at least on the specific column whose statistics are being accessed.",
            "locally_satisfied": true,
            "justification": "The code checks pg_class_aclcheck(relid, GetUserId(), ACL_SELECT) == ACLCHECK_OK or pg_attribute_aclcheck(relid, varattno, GetUserId(), ACL_SELECT) == ACLCHECK_OK before setting acl_ok true."
          }
        ]
      },
      {
        "sink_id": "vardata->acl_ok = true (no statsTuple case)",
        "sink_description": "Marks the variable as ACL-ok when no statistics tuple exists, which suppresses later leakproofness checks related to statistics access.",
        "required_conditions": [
          {
            "id": "no_stats_means_no_privileged_data",
            "description": "If no statistics tuple is found for the column, treating the variable as ACL-ok must not expose additional protected information to unauthorized users.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "recursive examine_simple_variable on subquery Var",
        "sink_description": "Recursively inspects statistics for variables coming from subqueries, potentially traversing security boundaries such as views with security_barrier or RLS.",
        "required_conditions": [
          {
            "id": "respect_security_barrier_views",
            "description": "The function must not look into statistics of subqueries originating from security_barrier views when doing so could bypass their protection.",
            "locally_satisfied": true,
            "justification": "Before recursing, the function checks rte->security_barrier and returns early if it is true."
          },
          {
            "id": "recurse_only_into_simple_subquery_vars",
            "description": "Recursive statistics inspection into subqueries should only occur for simple Vars at the subquery’s own level to avoid unintended exposure of composed expressions or joined data.",
            "locally_satisfied": true,
            "justification": "The function checks that var is a Var with var->varlevelsup == 0 before recursing."
          }
        ]
      }
    ]
  }
]