[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "http_connect",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10130/repo/src/transports/http.c",
      "558-627"
    ],
    "function_name": "http_connect",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"curl_stream.h\"\n#include \"socket_stream.h\"\n#include \"tls_stream.h\"\n#include \"auth_negotiate.h\"\n#include \"auth.h\"\n#include \"smart.h\"\n#include \"remote.h\"\n#include \"global.h\"\n#include \"netops.h\"\n#include \"buffer.h\"\n#include \"http_parser.h\"\n#include \"git2.h\"\n\nstatic int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: giterr_set\nGIT_INLINE(int) giterr_set_after_callback_function(\n\tint error_code, const char *action)\n{\n\tif (error_code) {\n\t\tconst git_error *e = giterr_last();\n\t\tif (!e || !e->message)\n\t\t\tgiterr_set(e ? e->klass : GITERR_CALLBACK,\n\t\t\t\t\"%s callback returned %d\", action, error_code);\n\t}\n\treturn error_code;\n}\n\nCallee: giterr_last\nconst git_error *giterr_last(void)\n{\n\treturn GIT_GLOBAL->last_error;\n}\n\nCallee: giterr_clear\nvoid giterr_clear(void)\n{\n\tif (GIT_GLOBAL->last_error != NULL) {\n\t\tset_error(0, NULL);\n\t\tGIT_GLOBAL->last_error = NULL;\n\t}\n\n\terrno = 0;\n#ifdef GIT_WIN32\n\tSetLastError(0);\n#endif\n}\n\nCallee: git_stream_certificate\nGIT_INLINE(int) git_stream_certificate(git_cert **out, git_stream *st)\n{\n\tif (!st->encrypted) {\n\t\tgiterr_set(GITERR_INVALID, \"an unencrypted stream does not have a certificate\");\n\t\treturn -1;\n\t}\n\n\treturn st->certificate(out, st);\n}\n\nCallee: git_stream_is_encrypted\nGIT_INLINE(int) git_stream_is_encrypted(git_stream *st)\n{\n\treturn st->encrypted;\n}\n\nCallee: git_stream_connect\nGIT_INLINE(int) git_stream_connect(git_stream *st)\n{\n\treturn st->connect(st);\n}\n\nCallee: git__free\nGIT_INLINE(void) git__free(void *ptr)\n{\n\tfree(ptr);\n}\n\nCallee: git_stream_set_proxy\nGIT_INLINE(int) git_stream_set_proxy(git_stream *st, const char *proxy_url)\n{\n\tif (!st->proxy_support) {\n\t\tgiterr_set(GITERR_INVALID, \"proxy not supported on this stream\");\n\t\treturn -1;\n\t}\n\n\treturn st->set_proxy(st, proxy_url);\n}\n\nCallee: git_remote__get_http_proxy\nint git_remote__get_http_proxy(git_remote *remote, bool use_ssl, char **proxy_url)\n{\n\tgit_config *cfg;\n\tgit_config_entry *ce = NULL;\n\tgit_buf val = GIT_BUF_INIT;\n\tint error;\n\n\tassert(remote);\n\n\tif (!proxy_url || !remote->repo)\n\t\treturn -1;\n\n\t*proxy_url = NULL;\n\n\tif ((error = git_repository_config__weakptr(&cfg, remote->repo)) < 0)\n\t\treturn error;\n\n\t/* Go through the possible sources for proxy configuration, from most specific\n\t * to least specific. */\n\n\t/* remote.<name>.proxy config setting */\n\tif (remote->name && remote->name[0]) {\n\t\tgit_buf buf = GIT_BUF_INIT;\n\n\t\tif ((error = git_buf_printf(&buf, \"remote.%s.proxy\", remote->name)) < 0)\n\t\t\treturn error;\n\n\t\terror = git_config__lookup_entry(&ce, cfg, git_buf_cstr(&buf), false);\n\t\tgit_buf_free(&buf);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\n\t\tif (ce && ce->value) {\n\t\t\t*proxy_url = git__strdup(ce->value);\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t/* http.proxy config setting */\n\tif ((error = git_config__lookup_entry(&ce, cfg, \"http.proxy\", false)) < 0)\n\t\treturn error;\n\n\tif (ce && ce->value) {\n\t\t*proxy_url = git__strdup(ce->value);\n\t\tgoto found;\n\t}\n\n\t/* HTTP_PROXY / HTTPS_PROXY environment variables */\n\terror = git__getenv(&val, use_ssl ? \"HTTPS_PROXY\" : \"HTTP_PROXY\");\n\n\tif (error < 0) {\n\t\tif (error == GIT_ENOTFOUND) {\n\t\t\tgiterr_clear();\n\t\t\terror = 0;\n\t\t}\n\n\t\treturn error;\n\t}\n\n\t*proxy_url = git_buf_detach(&val);\n\nfound:\n\tGITERR_CHECK_ALLOC(*proxy_url);\n\tgit_config_entry_free(ce);\n\n\treturn 0;\n}\n\nCallee: git_stream_supports_proxy\nGIT_INLINE(int) git_stream_supports_proxy(git_stream *st)\n{\n\treturn st->proxy_support;\n}\n\nCallee: git_socket_stream_new\nint git_socket_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tgit_socket_stream *st;\n\n\tassert(out && host);\n\n\tst = git__calloc(1, sizeof(git_socket_stream));\n\tGITERR_CHECK_ALLOC(st);\n\n\tst->host = git__strdup(host);\n\tGITERR_CHECK_ALLOC(st->host);\n\n\tif (port) {\n\t\tst->port = git__strdup(port);\n\t\tGITERR_CHECK_ALLOC(st->port);\n\t}\n\n\tst->parent.version = GIT_STREAM_VERSION;\n\tst->parent.connect = socket_connect;\n\tst->parent.write = socket_write;\n\tst->parent.read = socket_read;\n\tst->parent.close = socket_close;\n\tst->parent.free = socket_free;\n\tst->s = INVALID_SOCKET;\n\n\t*out = (git_stream *) st;\n\treturn 0;\n}\n\nCallee: git_curl_stream_new\nint git_curl_stream_new(git_stream **out, const char *host, const char *port)\n{\n\tGIT_UNUSED(out);\n\tGIT_UNUSED(host);\n\tGIT_UNUSED(port);\n\n\tgiterr_set(GITERR_NET, \"curl is not supported in this version\");\n\treturn -1;\n}\n\nCallee: git_tls_stream_new\nint git_tls_stream_new(git_stream **out, const char *host, const char *port)\n{\n\n\tif (tls_ctor)\n\t\treturn tls_ctor(out, host, port);\n\n#ifdef GIT_SECURE_TRANSPORT\n\treturn git_stransport_stream_new(out, host, port);\n#elif defined(GIT_OPENSSL)\n\treturn git_openssl_stream_new(out, host, port);\n#else\n\tGIT_UNUSED(out);\n\tGIT_UNUSED(host);\n\tGIT_UNUSED(port);\n\n\tgiterr_set(GITERR_SSL, \"there is no TLS stream available\");\n\treturn -1;\n#endif\n}\n\nCallee: git_stream_free\nGIT_INLINE(void) git_stream_free(git_stream *st)\n{\n\tif (!st)\n\t\treturn;\n\n\tst->free(st);\n}\n\nCallee: git_stream_close\nGIT_INLINE(int) git_stream_close(git_stream *st)\n{\n\treturn st->close(st);\n}\n",
    "sinks": [
      {
        "sink_id": "git_stream_connect(t->io)",
        "sink_description": "Establishes an outgoing network connection to the remote host (possibly via proxy and with TLS). This performs network I/O on behalf of the caller to a target defined by configuration/state.",
        "required_conditions": [
          {
            "id": "remote_target_authorized",
            "description": "The caller must be authorized to initiate an HTTP(S) connection to the configured host and port for this subtransport/remote.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "proxy_configuration_trusted",
            "description": "If a proxy URL is used (from config or environment), it must be from a trusted source appropriate for this remote and caller, since traffic will be routed through it.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload)",
        "sink_description": "Invokes a user-supplied certificate verification callback that can accept or reject the remote TLS certificate, thus deciding whether to proceed with an encrypted connection.",
        "required_conditions": [
          {
            "id": "cert_callback_must_enforce_policy",
            "description": "The certificate_check_cb provided in t->owner must correctly enforce the intended trust and validation policy for remote certificates before allowing the connection to continue.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "unencrypted_disallowed_for_tls_required",
            "description": "If the higher-level policy requires encryption and valid certificates, the function must not allow continuing when git_stream_is_encrypted is false or when certificate validation fails without explicit authorization.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "git_remote__get_http_proxy(..., &proxy_url) / git_stream_set_proxy(t->io, proxy_url)",
        "sink_description": "Looks up HTTP proxy configuration (config, environment) and applies it to the stream, changing the network path for subsequent HTTP(S) traffic.",
        "required_conditions": [
          {
            "id": "proxy_use_policy_compliant",
            "description": "Using a proxy for this remote must comply with the caller’s or application’s proxy policy, including which configuration sources (config vs environment) are allowed to influence connections.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      }
    ]
  }
]