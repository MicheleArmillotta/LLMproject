[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "umount_tree",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
      "1349-1388"
    ],
    "function_name": "umount_tree",
    "contextual_snippet": "MAIN FUNCTION:\n#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic HLIST_HEAD(unmounted);\nstatic void shrink_submounts(struct mount *mnt);\n\nstatic void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: change_mnt_propagation\nvoid change_mnt_propagation(struct mount *mnt, int type)\n{\n\tif (type == MS_SHARED) {\n\t\tset_mnt_shared(mnt);\n\t\treturn;\n\t}\n\tdo_make_slave(mnt);\n\tif (type != MS_SLAVE) {\n\t\tlist_del_init(&mnt->mnt_slave);\n\t\tmnt->mnt_master = NULL;\n\t\tif (type == MS_UNBINDABLE)\n\t\t\tmnt->mnt.mnt_flags |= MNT_UNBINDABLE;\n\t\telse\n\t\t\tmnt->mnt.mnt_flags &= ~MNT_UNBINDABLE;\n\t}\n}\n\nCallee: umount_mnt\nstatic void umount_mnt(struct mount *mnt)\n{\n\t/* old mountpoint will be dropped when we can do that */\n\tmnt->mnt_ex_mountpoint = mnt->mnt_mountpoint;\n\tunhash_mnt(mnt);\n}\n\nCallee: mnt_add_count\nstatic inline void mnt_add_count(struct mount *mnt, int n)\n{\n#ifdef CONFIG_SMP\n\tthis_cpu_add(mnt->mnt_pcp->mnt_count, n);\n#else\n\tpreempt_disable();\n\tmnt->mnt_count += n;\n\tpreempt_enable();\n#endif\n}\n\nCallee: mnt_has_parent\nstatic inline int mnt_has_parent(struct mount *mnt)\n{\n\treturn mnt != mnt->mnt_parent;\n}\n\nCallee: pin_insert_group\nvoid pin_insert_group(struct fs_pin *pin, struct vfsmount *m, struct hlist_head *p)\n{\n\tspin_lock(&pin_lock);\n\tif (p)\n\t\thlist_add_head(&pin->s_list, p);\n\thlist_add_head(&pin->m_list, &real_mount(m)->mnt_pins);\n\tspin_unlock(&pin_lock);\n}\n\nCallee: __touch_mnt_namespace\nstatic void __touch_mnt_namespace(struct mnt_namespace *ns)\n{\n\tif (ns && ns->event != event) {\n\t\tns->event = event;\n\t\twake_up_interruptible(&ns->poll);\n\t}\n}\n\nCallee: list_empty\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}\n\nCallee: propagate_umount\nint propagate_umount(struct list_head *list)\n{\n\tstruct mount *mnt;\n\n\tlist_for_each_entry_reverse(mnt, list, mnt_list)\n\t\tmark_umount_candidates(mnt);\n\n\tlist_for_each_entry(mnt, list, mnt_list)\n\t\t__propagate_umount(mnt);\n\treturn 0;\n}\n\nCallee: next_mnt\nstatic struct mount *next_mnt(struct mount *p, struct mount *root)\n{\n\tstruct list_head *next = p->mnt_mounts.next;\n\tif (next == &p->mnt_mounts) {\n\t\twhile (1) {\n\t\t\tif (p == root)\n\t\t\t\treturn NULL;\n\t\t\tnext = p->mnt_child.next;\n\t\t\tif (next != &p->mnt_parent->mnt_mounts)\n\t\t\t\tbreak;\n\t\t\tp = p->mnt_parent;\n\t\t}\n\t}\n\treturn list_entry(next, struct mount, mnt_child);\n}\n\nCallee: propagate_mount_unlock\nvoid propagate_mount_unlock(struct mount *mnt)\n{\n\tstruct mount *parent = mnt->mnt_parent;\n\tstruct mount *m, *child;\n\n\tBUG_ON(parent == mnt);\n\n\tfor (m = propagation_next(parent, parent); m;\n\t\t\tm = propagation_next(m, parent)) {\n\t\tchild = __lookup_mnt_last(&m->mnt, mnt->mnt_mountpoint);\n\t\tif (child)\n\t\t\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\t}\n}\n",
    "sinks": [
      {
        "sink_id": "umount_tree(mnt, how) main loop",
        "sink_description": "System-wide unmount of a subtree of mounts from a mount namespace, including flagging mounts as unmounted, detaching them from the namespace, and changing their propagation type.",
        "required_conditions": [
          {
            "id": "caller_authorized_to_unmount_subtree",
            "description": "The caller initiating umount_tree must be authorized (by kernel VFS/namespace policy) to unmount the specified mount subtree in the affected mount namespace.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "propagation_unlock_safe",
            "description": "When UMOUNT_PROPAGATE is set, only mounts that should be unlocked for propagation are modified by propagate_mount_unlock().",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "namespace_modification_authorized",
            "description": "Detaching mounts from a mount namespace (setting mnt_ns to NULL, updating counts, unhashing) must only occur for namespaces that the caller is allowed to modify.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "propagation_change_restriction",
            "description": "Changing mount propagation to MS_PRIVATE must only be performed on mounts where the caller has permission to alter propagation semantics.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      }
    ]
  }
]