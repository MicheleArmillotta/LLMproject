[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "tm_reclaim_thread",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2015-8845/repo/arch/powerpc/kernel/process.c",
      "531-563"
    ],
    "function_name": "tm_reclaim_thread",
    "contextual_snippet": "MAIN FUNCTION:\n#include <linux/kdebug.h>\n#include <linux/kprobes.h>\n#include <asm/code-patching.h>\n#include <asm/firmware.h>\n#include <asm/debug.h>\n#include <asm/tm.h>\n#include <asm/switch_to.h>\n#include <asm/syscalls.h>\n#include <asm/runlatch.h>\n#include <asm/time.h>\n#include <asm/machdep.h>\n#include <asm/prom.h>\n#include <asm/mmu.h>\n#include <asm/processor.h>\n#include <asm/io.h>\n#include <asm/pgtable.h>\n#include <linux/uaccess.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/random.h>\n#include <linux/personality.h>\n#include <linux/kernel_stat.h>\n#include <linux/ftrace.h>\n#include <linux/utsname.h>\n#include <linux/hardirq.h>\n#include <linux/mqueue.h>\n#include <linux/kallsyms.h>\n#include <linux/export.h>\n#include <linux/init_task.h>\n#include <linux/prctl.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/unistd.h>\n#include <linux/stddef.h>\n#include <linux/smp.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n\nstatic void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: tm_reclaim\nstatic void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}\n\nCallee: memcpy\nvoid _memcpy_toio(volatile void __iomem *dest, const void *src, unsigned long n)\n{\n\tvoid *vdest = (void __force *) dest;\n\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n\twhile(n && (!IO_CHECK_ALIGN(vdest, 4) || !IO_CHECK_ALIGN(src, 4))) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\twhile(n >= 4) {\n\t\t*((volatile u32 *)vdest) = *((volatile u32 *)src);\n\t\tsrc += 4;\n\t\tvdest += 4;\n\t\tn-=4;\n\t}\n\twhile(n) {\n\t\t*((volatile u8 *)vdest) = *((u8 *)src);\n\t\tsrc++;\n\t\tvdest++;\n\t\tn--;\n\t}\n\t__asm__ __volatile__ (\"sync\" : : : \"memory\");\n}\n",
    "sinks": [
      {
        "sink_id": "tm_reclaim(thr, thr->regs->msr, cause);",
        "sink_description": "Performs transactional memory reclaim on the given thread, modifying its architectural state (registers/MSR) based on the provided cause.",
        "required_conditions": [
          {
            "id": "kernel_only_context",
            "description": "The function must only be callable in a privileged kernel context, operating on kernel-owned thread_struct and thread_info objects, not directly on attacker-controlled data.",
            "locally_satisfied": true,
            "justification": "The function is a static kernel-internal helper taking struct thread_struct and struct thread_info pointers; there are no user pointers or syscalls here, and it is not exposed as an API to unprivileged callers in this snippet."
          },
          {
            "id": "valid_thread_state",
            "description": "The thread_struct and associated regs/MSR fields must describe a valid, current thread state for which transactional memory reclaim is appropriate.",
            "locally_satisfied": false,
            "justification": null
          },
          {
            "id": "authorized_cause_usage",
            "description": "The reclaim cause must correspond to a legitimate kernel-decided reason (e.g., interrupt, context switch, abort) rather than being arbitrarily chosen by an untrusted caller.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      },
      {
        "sink_id": "thr->regs->msr |= msr_diff;",
        "sink_description": "Updates the thread's saved machine state register (MSR) bits to mark FP/VSX/Vec state as valid after transactional reclaim, affecting future privilege and FP/VSX usage handling for that thread.",
        "required_conditions": [
          {
            "id": "msr_bits_consistency",
            "description": "The msr_diff bits ORed into thr->regs->msr must be derived from a trustworthy comparison of checkpointed vs current MSR, not from attacker-controlled input.",
            "locally_satisfied": true,
            "justification": "msr_diff is computed purely from thr->ckpt_regs.msr and thr->regs->msr under a guarded path and masked to MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1 before being ORed in; no external input influences these bits in this function."
          },
          {
            "id": "thread_ownership",
            "description": "The modified MSR must belong to the same thread that the kernel intends to operate on, preventing cross-thread state corruption or privilege confusion.",
            "locally_satisfied": false,
            "justification": null
          }
        ]
      }
    ]
  }
]