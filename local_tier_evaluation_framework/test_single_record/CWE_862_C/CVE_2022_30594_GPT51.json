[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "ptrace_attach",
      "output_repos_c/CVE-2022-30594/repo/kernel/ptrace.c",
      "374-474"
    ],
    "function_name": "ptrace_attach",
    "contextual_snippet": "MAIN FUNCTION:\n#include <asm/syscall.h>\t/* for syscall_get_* */\n#include <linux/minmax.h>\n#include <linux/sched/signal.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/regset.h>\n#include <linux/uaccess.h>\n#include <linux/syscalls.h>\n#include <linux/pid_namespace.h>\n#include <linux/audit.h>\n#include <linux/uio.h>\n#include <linux/signal.h>\n#include <linux/security.h>\n#include <linux/ptrace.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/sched/task.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <linux/capability.h>\n\nstatic int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\n\t/*\n\t * Protect exec's credential calculations against our interference;\n\t * SUID, SGID and LSM creds get determined differently\n\t * under ptrace.\n\t */\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\n\ttask->ptrace = flags;\n\n\tptrace_link(task, current);\n\n\t/* SEIZE doesn't trap tracee on attach */\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\n\tspin_lock(&task->sighand->siglock);\n\n\t/*\n\t * If the task is already STOPPED, set JOBCTL_TRAP_STOP and\n\t * TRAPPING, and kick it so that it transits to TRACED.  TRAPPING\n\t * will be cleared if the child completes the transition or any\n\t * event which clears the group stop states happens.  We'll wait\n\t * for the transition to complete before returning from this\n\t * function.\n\t *\n\t * This hides STOPPED -> RUNNING -> TRACED transition from the\n\t * attaching thread but a different thread in the same group can\n\t * still observe the transient RUNNING state.  IOW, if another\n\t * thread's WNOHANG wait(2) on the stopped tracee races against\n\t * ATTACH, the wait(2) may fail due to the transient RUNNING.\n\t *\n\t * The following task_is_stopped() test is safe as both transitions\n\t * in and out of STOPPED are protected by siglock.\n\t */\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\n\tspin_unlock(&task->sighand->siglock);\n\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\t/*\n\t\t * We do not bother to change retval or clear JOBCTL_TRAPPING\n\t\t * if wait_on_bit() was interrupted by SIGKILL. The tracer will\n\t\t * not return to user-mode, it will exit and clear this bit in\n\t\t * __ptrace_unlink() if it wasn't already cleared by the tracee;\n\t\t * and until then nobody can ptrace this task.\n\t\t */\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\n\treturn retval;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n\nCallee: mutex_unlock\nstatic __always_inline void __rt_mutex_unlock(struct rt_mutex_base *lock)\n{\n\tif (likely(rt_mutex_cmpxchg_release(lock, current, NULL)))\n\t\treturn;\n\n\trt_mutex_slowunlock(lock);\n}\n\nCallee: write_unlock_irq\nvoid __lockfunc _raw_write_unlock_irq(rwlock_t *lock)\n{\n\t__raw_write_unlock_irq(lock);\n}\n\nCallee: spin_unlock\nstatic inline void __bpf_spin_unlock_irqrestore(struct bpf_spin_lock *lock)\n{\n\tunsigned long flags;\n\n\tflags = __this_cpu_read(irqsave_flags);\n\t__bpf_spin_unlock(lock);\n\tlocal_irq_restore(flags);\n}\n\nCallee: signal_wake_up_state\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}\n\nCallee: task_set_jobctl_pending\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}\n\nCallee: spin_lock\nstatic bool reg_may_point_to_spin_lock(const struct bpf_reg_state *reg)\n{\n\treturn reg->type == PTR_TO_MAP_VALUE &&\n\t\tmap_value_has_spin_lock(reg->map_ptr);\n}\n\nCallee: send_sig_info\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}\n\nCallee: ptrace_link\nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\t__ptrace_link(child, new_parent, current_cred());\n}\n\nCallee: write_lock_irq\nvoid __lockfunc _raw_write_lock_irq(rwlock_t *lock)\n{\n\t__raw_write_lock_irq(lock);\n}\n\nCallee: __ptrace_may_access\nstatic int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct mm_struct *mm;\n\tkuid_t caller_uid;\n\tkgid_t caller_gid;\n\n\tif (!(mode & PTRACE_MODE_FSCREDS) == !(mode & PTRACE_MODE_REALCREDS)) {\n\t\tWARN(1, \"denying ptrace access check without PTRACE_MODE_*CREDS\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* May we inspect the given task?\n\t * This check is used both for attaching with ptrace\n\t * and for allowing access to sensitive information in /proc.\n\t *\n\t * ptrace_attach denies several cases that /proc allows\n\t * because setting up the necessary parent/child relationship\n\t * or halting the specified task is impossible.\n\t */\n\n\t/* Don't let security modules deny introspection */\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\tif (mode & PTRACE_MODE_FSCREDS) {\n\t\tcaller_uid = cred->fsuid;\n\t\tcaller_gid = cred->fsgid;\n\t} else {\n\t\t/*\n\t\t * Using the euid would make more sense here, but something\n\t\t * in userland might rely on the old behavior, and this\n\t\t * shouldn't be a security problem since\n\t\t * PTRACE_MODE_REALCREDS implies that the caller explicitly\n\t\t * used a syscall that requests access to another process\n\t\t * (and not a filesystem syscall to procfs).\n\t\t */\n\t\tcaller_uid = cred->uid;\n\t\tcaller_gid = cred->gid;\n\t}\n\ttcred = __task_cred(task);\n\tif (uid_eq(caller_uid, tcred->euid) &&\n\t    uid_eq(caller_uid, tcred->suid) &&\n\t    uid_eq(caller_uid, tcred->uid)  &&\n\t    gid_eq(caller_gid, tcred->egid) &&\n\t    gid_eq(caller_gid, tcred->sgid) &&\n\t    gid_eq(caller_gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\t/*\n\t * If a task drops privileges and becomes nondumpable (through a syscall\n\t * like setresuid()) while we are trying to access it, we must ensure\n\t * that the dumpability is read after the credentials; otherwise,\n\t * we may be able to attach to a task that we shouldn't be able to\n\t * attach to (as if the task had dropped privileges without becoming\n\t * nondumpable).\n\t * Pairs with a write barrier in commit_creds().\n\t */\n\tsmp_rmb();\n\tmm = task->mm;\n\tif (mm &&\n\t    ((get_dumpable(mm) != SUID_DUMP_USER) &&\n\t     !ptrace_has_cap(mm->user_ns, mode)))\n\t    return -EPERM;\n\n\treturn security_ptrace_access_check(task, mode);\n}\n\nCallee: mutex_lock_interruptible\nint __sched mutex_lock_interruptible(struct mutex *lock)\n{\n\treturn __mutex_lock_common(lock, TASK_INTERRUPTIBLE, 0, NULL, _RET_IP_);\n}\n\nCallee: audit_ptrace\nvoid __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid_obj(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}\n",
    "sinks": [
      {
        "sink_id": "ptrace_attach main body",
        "sink_description": "Attaches the current task as a ptracer to another task, establishing a privileged debugging/control relationship and potentially stopping the tracee.",
        "required_conditions": [
          {
            "id": "no_kernel_threads",
            "description": "The target task must not be a kernel thread (PF_KTHREAD) to prevent tracing privileged kernel execution contexts.",
            "locally_satisfied": true,
            "justification": "The function checks `if (unlikely(task->flags & PF_KTHREAD)) goto out;` and returns -EPERM in that case."
          },
          {
            "id": "no_self_trace",
            "description": "The caller must not attempt to ptrace a task in the same thread group (self/introspection case is handled differently).",
            "locally_satisfied": true,
            "justification": "The function checks `if (same_thread_group(task, current)) goto out;` before proceeding."
          },
          {
            "id": "authorization_check_realcreds",
            "description": "The current credentials must be authorized to ptrace the target task according to ptrace access policy, including UID/GID checks, dumpability, and LSM security hooks, using real credentials for attach.",
            "locally_satisfied": true,
            "justification": "The function calls `__ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);` and aborts attach (`if (retval) goto unlock_creds;`) on failure. `__ptrace_may_access` performs credential, capability, dumpability, and `security_ptrace_access_check` checks."
          },
          {
            "id": "target_alive_and_untraced",
            "description": "The target task must not be exiting or already under ptrace control when establishing the ptrace relationship.",
            "locally_satisfied": true,
            "justification": "Under `tasklist_lock`, the code checks `if (unlikely(task->exit_state)) goto unlock_tasklist;` and `if (task->ptrace) goto unlock_tasklist;` before setting `task->ptrace = flags;` and calling `ptrace_link`."
          },
          {
            "id": "seize_flags_valid",
            "description": "For PTRACE_SEIZE, the addr argument must be zero and the supplied flags must be limited to the documented PTRACE_O_* options mask.",
            "locally_satisfied": true,
            "justification": "When `seize` is true, the function rejects non-zero `addr` and any `flags` bits outside `PTRACE_O_MASK` (`if (addr != 0) goto out; if (flags & ~PTRACE_O_MASK) goto out;`)."
          },
          {
            "id": "jobctl_trapping_transition_safe",
            "description": "If the target is already stopped, the job control flags must be updated atomically and only when the task is not in fatal/exit state to safely drive STOPPEDâ†’TRACED transition.",
            "locally_satisfied": true,
            "justification": "The function uses `task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING)` under `siglock`, which internally checks for `fatal_signal_pending` and `PF_EXITING` and updates `task->jobctl` atomically; then it calls `signal_wake_up_state`."
          },
          {
            "id": "audit_logging_of_ptrace",
            "description": "Ptrace attach operations should be auditable for accountability and policy enforcement.",
            "locally_satisfied": true,
            "justification": "The function unconditionally calls `audit_ptrace(task);` near the beginning, which records the target and security identifiers in the audit context."
          },
          {
            "id": "notify_proc_connector_on_attach",
            "description": "Userspace listeners (e.g., via proc connector) should be notified of ptrace attach events after successful attach.",
            "locally_satisfied": true,
            "justification": "On success (`retval == 0` at `out:`), the code calls `proc_ptrace_connector(task, PTRACE_ATTACH);` after waiting for JOBCTL_TRAPPING to clear."
          },
          {
            "id": "send_sigstop_only_when_attaching",
            "description": "A SIGSTOP should be sent only for non-SEIZE attaches to avoid unintended stops in PTRACE_SEIZE mode.",
            "locally_satisfied": true,
            "justification": "The function sends `SIGSTOP` with `send_sig_info(SIGSTOP, SEND_SIG_PRIV, task);` only in the `if (!seize)` branch."
          },
          {
            "id": "locking_and_cred_guard",
            "description": "Credential calculations during exec must be protected from concurrent ptrace attach to avoid races that could affect privilege/LSM decisions.",
            "locally_satisfied": true,
            "justification": "The function acquires `task->signal->cred_guard_mutex` with `mutex_lock_interruptible` before the access check and ptrace state changes, and releases it via `mutex_unlock` on all exit paths (`unlock_creds:`)."
          }
        ]
      }
    ]
  }
]