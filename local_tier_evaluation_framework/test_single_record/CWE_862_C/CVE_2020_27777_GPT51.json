[
  {
    "file_path": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "id": [
      "rtas",
      "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-27777/repo/arch/powerpc/kernel/rtas.c",
      "996-1081"
    ],
    "function_name": "rtas",
    "contextual_snippet": "MAIN FUNCTION:\n#include <asm/paca.h>\n#include <asm/topology.h>\n#include <asm/mmu.h>\n#include <asm/time.h>\n#include <linux/atomic.h>\n#include <asm/smp.h>\n#include <asm/syscalls.h>\n#include <asm/udbg.h>\n#include <linux/uaccess.h>\n#include <asm/delay.h>\n#include <asm/param.h>\n#include <asm/page.h>\n#include <asm/firmware.h>\n#include <asm/machdep.h>\n#include <asm/hvcall.h>\n#include <asm/rtas.h>\n#include <asm/prom.h>\n#include <linux/syscalls.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/memblock.h>\n#include <linux/cpumask.h>\n#include <linux/completion.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpu.h>\n#include <linux/delay.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <stdarg.h>\n\nvoid enter_rtas(unsigned long);\nstruct rtas_t rtas = {\n\t.lock = __ARCH_SPIN_LOCK_UNLOCKED\n};\nstatic int ibm_suspend_me_token = RTAS_UNKNOWN_SERVICE;\n\nSYSCALL_DEFINE1(rtas, struct rtas_args __user *, uargs)\n{\n\tstruct rtas_args args;\n\tunsigned long flags;\n\tchar *buff_copy, *errbuf = NULL;\n\tint nargs, nret, token;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!rtas.entry)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)\n\t\treturn -EFAULT;\n\n\tnargs = be32_to_cpu(args.nargs);\n\tnret  = be32_to_cpu(args.nret);\n\ttoken = be32_to_cpu(args.token);\n\n\tif (nargs >= ARRAY_SIZE(args.args)\n\t    || nret > ARRAY_SIZE(args.args)\n\t    || nargs + nret > ARRAY_SIZE(args.args))\n\t\treturn -EINVAL;\n\n\t/* Copy in args. */\n\tif (copy_from_user(args.args, uargs->args,\n\t\t\t   nargs * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\tif (token == RTAS_UNKNOWN_SERVICE)\n\t\treturn -EINVAL;\n\n\targs.rets = &args.args[nargs];\n\tmemset(args.rets, 0, nret * sizeof(rtas_arg_t));\n\n\t/* Need to handle ibm,suspend_me call specially */\n\tif (token == ibm_suspend_me_token) {\n\n\t\t/*\n\t\t * rtas_ibm_suspend_me assumes the streamid handle is in cpu\n\t\t * endian, or at least the hcall within it requires it.\n\t\t */\n\t\tint rc = 0;\n\t\tu64 handle = ((u64)be32_to_cpu(args.args[0]) << 32)\n\t\t              | be32_to_cpu(args.args[1]);\n\t\trc = rtas_ibm_suspend_me(handle);\n\t\tif (rc == -EAGAIN)\n\t\t\targs.rets[0] = cpu_to_be32(RTAS_NOT_SUSPENDABLE);\n\t\telse if (rc == -EIO)\n\t\t\targs.rets[0] = cpu_to_be32(-1);\n\t\telse if (rc)\n\t\t\treturn rc;\n\t\tgoto copy_return;\n\t}\n\n\tbuff_copy = get_errorlog_buffer();\n\n\tflags = lock_rtas();\n\n\trtas.args = args;\n\tenter_rtas(__pa(&rtas.args));\n\targs = rtas.args;\n\n\t/* A -1 return code indicates that the last command couldn't\n\t   be completed due to a hardware error. */\n\tif (be32_to_cpu(args.rets[0]) == -1)\n\t\terrbuf = __fetch_rtas_last_error(buff_copy);\n\n\tunlock_rtas(flags);\n\n\tif (buff_copy) {\n\t\tif (errbuf)\n\t\t\tlog_error(errbuf, ERR_TYPE_RTAS_LOG, 0);\n\t\tkfree(buff_copy);\n\t}\n\n copy_return:\n\t/* Copy out args. */\n\tif (copy_to_user(uargs->args + nargs,\n\t\t\t args.args + nargs,\n\t\t\t nret * sizeof(rtas_arg_t)) != 0)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n-------- CONTEXTUAL INFORMATIONS - CALLEES CODE --------\n-------- Code of the functions used by the analyzed function -------- \n\n",
    "sinks": [
      {
        "sink_id": "SYSCALL_DEFINE1(rtas, ...)",
        "sink_description": "System call entry that allows user space to invoke RTAS (Run-Time Abstraction Services) firmware operations via an rtas_args structure, potentially performing privileged platform actions on behalf of the caller.",
        "required_conditions": [
          {
            "id": "caller_must_have_sys_admin",
            "description": "Only callers with CAP_SYS_ADMIN privilege may invoke RTAS firmware services through this syscall.",
            "locally_satisfied": true,
            "justification": "The function immediately checks capable(CAP_SYS_ADMIN) and returns -EPERM if the caller lacks this capability."
          },
          {
            "id": "rtas_entry_must_be_available",
            "description": "RTAS firmware entry point must be initialized and valid before attempting to execute any RTAS call.",
            "locally_satisfied": true,
            "justification": "The function checks if (!rtas.entry) and returns -EINVAL if the entry point is not available."
          },
          {
            "id": "rtas_command_interface_bounds",
            "description": "The nargs and nret values supplied by user space must be within the static bounds of the rtas_args array to prevent out-of-bounds access to RTAS argument/return storage.",
            "locally_satisfied": true,
            "justification": "The code validates nargs, nret, and nargs + nret against ARRAY_SIZE(args.args) and returns -EINVAL on violation before using them."
          },
          {
            "id": "ibm_suspend_me_requires_authorized_context",
            "description": "The special ibm,suspend_me RTAS service must only be invoked in an authorized context since it can suspend the partition or alter system power state.",
            "locally_satisfied": true,
            "justification": "The syscall as a whole is already gated by CAP_SYS_ADMIN, and the ibm_suspend_me path is only taken when the token matches ibm_suspend_me_token under that gate."
          },
          {
            "id": "rtas_invocation_requires_privileged_gate_only",
            "description": "Unprivileged user space must not be able to indirectly trigger arbitrary RTAS services without going through a privilege check that enforces platform policy on which services may be used.",
            "locally_satisfied": true,
            "justification": "The only entry point is this syscall, which enforces capable(CAP_SYS_ADMIN) before any RTAS token is accepted or executed."
          }
        ]
      },
      {
        "sink_id": "enter_rtas(__pa(&rtas.args))",
        "sink_description": "Transfers control to RTAS firmware with the prepared argument block, causing the firmware to execute the requested privileged platform operation.",
        "required_conditions": [
          {
            "id": "rtas_args_must_be_sanitized",
            "description": "The argument block passed to RTAS must be validated/sanitized so that only intended, policy-allowed RTAS tokens and parameters originating from an authorized caller are executed.",
            "locally_satisfied": true,
            "justification": "User input is first copied into a local args struct, nargs/nret bounds are checked, the token is checked against RTAS_UNKNOWN_SERVICE, and the whole syscall is restricted to CAP_SYS_ADMIN, limiting who can choose tokens and arguments."
          },
          {
            "id": "exclusive_firmware_access_control",
            "description": "Concurrent RTAS invocations must be serialized to prevent races and unintended sharing of a global RTAS argument structure among different callers.",
            "locally_satisfied": true,
            "justification": "The code acquires a lock via lock_rtas(), assigns rtas.args, invokes enter_rtas, and then releases the lock with unlock_rtas(flags), enforcing serialized access to the global RTAS state."
          }
        ]
      },
      {
        "sink_id": "log_error(errbuf, ERR_TYPE_RTAS_LOG, 0)",
        "sink_description": "Logs RTAS hardware error information into the system error log, potentially exposing hardware state or firmware error details.",
        "required_conditions": [
          {
            "id": "error_logging_authorized",
            "description": "Only authorized code paths should be able to emit RTAS error logs, as they may contain sensitive platform diagnostic information.",
            "locally_satisfied": true,
            "justification": "The logging occurs only as part of this CAP_SYS_ADMIN-gated syscall after an RTAS call fails with a specific return code; no unprivileged direct logging path is provided here."
          }
        ]
      }
    ]
  }
]