[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "926-979",
    "snippet": "int main(int argc, char** argv) {\n  FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;\n  FLAGS_open_files = leveldb::Options().max_open_files;\n  std::string default_db_path;\n\n  for (int i = 1; i < argc; i++) {\n    double d;\n    int n;\n    char junk;\n    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n      FLAGS_compression_ratio = d;\n    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_histogram = n;\n    } else if (sscanf(argv[i], \"--use_existing_db=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_use_existing_db = n;\n    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n      FLAGS_num = n;\n    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n      FLAGS_reads = n;\n    } else if (sscanf(argv[i], \"--threads=%d%c\", &n, &junk) == 1) {\n      FLAGS_threads = n;\n    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_value_size = n;\n    } else if (sscanf(argv[i], \"--write_buffer_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_write_buffer_size = n;\n    } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_cache_size = n;\n    } else if (sscanf(argv[i], \"--bloom_bits=%d%c\", &n, &junk) == 1) {\n      FLAGS_bloom_bits = n;\n    } else if (sscanf(argv[i], \"--open_files=%d%c\", &n, &junk) == 1) {\n      FLAGS_open_files = n;\n    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n      FLAGS_db = argv[i] + 5;\n    } else {\n      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n      exit(1);\n    }\n  }\n\n  // Choose a location for the test database if none given with --db=<path>\n  if (FLAGS_db == NULL) {\n      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n      default_db_path += \"/dbbench\";\n      FLAGS_db = default_db_path.c_str();\n  }\n\n  leveldb::Benchmark benchmark;\n  benchmark.Run();\n  return 0;\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readrandom,\"  // Extra run to allow previous compactions to quiesce\n    \"readseq,\"\n    \"readreverse,\"\n    \"compact,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"readreverse,\"\n    \"fill100K,\"\n    \"crc32c,\"\n    \"snappycomp,\"\n    \"snappyuncomp,\"\n    \"acquireload,\"\n    ;",
      "static int FLAGS_num = 1000000;",
      "static int FLAGS_reads = -1;",
      "static int FLAGS_threads = 1;",
      "static int FLAGS_value_size = 100;",
      "static double FLAGS_compression_ratio = 0.5;",
      "static bool FLAGS_histogram = false;",
      "static int FLAGS_write_buffer_size = 0;",
      "static int FLAGS_cache_size = -1;",
      "static int FLAGS_open_files = 0;",
      "static int FLAGS_bloom_bits = -1;",
      "static bool FLAGS_use_existing_db = false;",
      "static const char* FLAGS_db = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "benchmark.Run",
          "args": [],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "Run",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "418-529",
          "snippet": "void Run() {\n    PrintHeader();\n    Open();\n\n    const char* benchmarks = FLAGS_benchmarks;\n    while (benchmarks != NULL) {\n      const char* sep = strchr(benchmarks, ',');\n      Slice name;\n      if (sep == NULL) {\n        name = benchmarks;\n        benchmarks = NULL;\n      } else {\n        name = Slice(benchmarks, sep - benchmarks);\n        benchmarks = sep + 1;\n      }\n\n      // Reset parameters that may be overriddden bwlow\n      num_ = FLAGS_num;\n      reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);\n      value_size_ = FLAGS_value_size;\n      entries_per_batch_ = 1;\n      write_options_ = WriteOptions();\n\n      void (Benchmark::*method)(ThreadState*) = NULL;\n      bool fresh_db = false;\n      int num_threads = FLAGS_threads;\n\n      if (name == Slice(\"fillseq\")) {\n        fresh_db = true;\n        method = &Benchmark::WriteSeq;\n      } else if (name == Slice(\"fillbatch\")) {\n        fresh_db = true;\n        entries_per_batch_ = 1000;\n        method = &Benchmark::WriteSeq;\n      } else if (name == Slice(\"fillrandom\")) {\n        fresh_db = true;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"overwrite\")) {\n        fresh_db = false;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"fillsync\")) {\n        fresh_db = true;\n        num_ /= 1000;\n        write_options_.sync = true;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"fill100K\")) {\n        fresh_db = true;\n        num_ /= 1000;\n        value_size_ = 100 * 1000;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"readseq\")) {\n        method = &Benchmark::ReadSequential;\n      } else if (name == Slice(\"readreverse\")) {\n        method = &Benchmark::ReadReverse;\n      } else if (name == Slice(\"readrandom\")) {\n        method = &Benchmark::ReadRandom;\n      } else if (name == Slice(\"readmissing\")) {\n        method = &Benchmark::ReadMissing;\n      } else if (name == Slice(\"seekrandom\")) {\n        method = &Benchmark::SeekRandom;\n      } else if (name == Slice(\"readhot\")) {\n        method = &Benchmark::ReadHot;\n      } else if (name == Slice(\"readrandomsmall\")) {\n        reads_ /= 1000;\n        method = &Benchmark::ReadRandom;\n      } else if (name == Slice(\"deleteseq\")) {\n        method = &Benchmark::DeleteSeq;\n      } else if (name == Slice(\"deleterandom\")) {\n        method = &Benchmark::DeleteRandom;\n      } else if (name == Slice(\"readwhilewriting\")) {\n        num_threads++;  // Add extra thread for writing\n        method = &Benchmark::ReadWhileWriting;\n      } else if (name == Slice(\"compact\")) {\n        method = &Benchmark::Compact;\n      } else if (name == Slice(\"crc32c\")) {\n        method = &Benchmark::Crc32c;\n      } else if (name == Slice(\"acquireload\")) {\n        method = &Benchmark::AcquireLoad;\n      } else if (name == Slice(\"snappycomp\")) {\n        method = &Benchmark::SnappyCompress;\n      } else if (name == Slice(\"snappyuncomp\")) {\n        method = &Benchmark::SnappyUncompress;\n      } else if (name == Slice(\"heapprofile\")) {\n        HeapProfile();\n      } else if (name == Slice(\"stats\")) {\n        PrintStats(\"leveldb.stats\");\n      } else if (name == Slice(\"sstables\")) {\n        PrintStats(\"leveldb.sstables\");\n      } else {\n        if (name != Slice()) {  // No error message for empty name\n          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n        }\n      }\n\n      if (fresh_db) {\n        if (FLAGS_use_existing_db) {\n          fprintf(stdout, \"%-12s : skipped (--use_existing_db is true)\\n\",\n                  name.ToString().c_str());\n          method = NULL;\n        } else {\n          delete db_;\n          db_ = NULL;\n          DestroyDB(FLAGS_db, Options());\n          Open();\n        }\n      }\n\n      if (method != NULL) {\n        RunBenchmark(num_threads, name, method);\n      }\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readrandom,\"  // Extra run to allow previous compactions to quiesce\n    \"readseq,\"\n    \"readreverse,\"\n    \"compact,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"readreverse,\"\n    \"fill100K,\"\n    \"crc32c,\"\n    \"snappycomp,\"\n    \"snappyuncomp,\"\n    \"acquireload,\"\n    ;",
            "static int FLAGS_num = 1000000;",
            "static int FLAGS_reads = -1;",
            "static int FLAGS_threads = 1;",
            "static int FLAGS_value_size = 100;",
            "static bool FLAGS_use_existing_db = false;",
            "static const char* FLAGS_db = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readrandom,\"  // Extra run to allow previous compactions to quiesce\n    \"readseq,\"\n    \"readreverse,\"\n    \"compact,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"readreverse,\"\n    \"fill100K,\"\n    \"crc32c,\"\n    \"snappycomp,\"\n    \"snappyuncomp,\"\n    \"acquireload,\"\n    ;\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic int FLAGS_threads = 1;\nstatic int FLAGS_value_size = 100;\nstatic bool FLAGS_use_existing_db = false;\nstatic const char* FLAGS_db = NULL;\n\nBenchmark {\n  void Run() {\n      PrintHeader();\n      Open();\n  \n      const char* benchmarks = FLAGS_benchmarks;\n      while (benchmarks != NULL) {\n        const char* sep = strchr(benchmarks, ',');\n        Slice name;\n        if (sep == NULL) {\n          name = benchmarks;\n          benchmarks = NULL;\n        } else {\n          name = Slice(benchmarks, sep - benchmarks);\n          benchmarks = sep + 1;\n        }\n  \n        // Reset parameters that may be overriddden bwlow\n        num_ = FLAGS_num;\n        reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);\n        value_size_ = FLAGS_value_size;\n        entries_per_batch_ = 1;\n        write_options_ = WriteOptions();\n  \n        void (Benchmark::*method)(ThreadState*) = NULL;\n        bool fresh_db = false;\n        int num_threads = FLAGS_threads;\n  \n        if (name == Slice(\"fillseq\")) {\n          fresh_db = true;\n          method = &Benchmark::WriteSeq;\n        } else if (name == Slice(\"fillbatch\")) {\n          fresh_db = true;\n          entries_per_batch_ = 1000;\n          method = &Benchmark::WriteSeq;\n        } else if (name == Slice(\"fillrandom\")) {\n          fresh_db = true;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"overwrite\")) {\n          fresh_db = false;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"fillsync\")) {\n          fresh_db = true;\n          num_ /= 1000;\n          write_options_.sync = true;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"fill100K\")) {\n          fresh_db = true;\n          num_ /= 1000;\n          value_size_ = 100 * 1000;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"readseq\")) {\n          method = &Benchmark::ReadSequential;\n        } else if (name == Slice(\"readreverse\")) {\n          method = &Benchmark::ReadReverse;\n        } else if (name == Slice(\"readrandom\")) {\n          method = &Benchmark::ReadRandom;\n        } else if (name == Slice(\"readmissing\")) {\n          method = &Benchmark::ReadMissing;\n        } else if (name == Slice(\"seekrandom\")) {\n          method = &Benchmark::SeekRandom;\n        } else if (name == Slice(\"readhot\")) {\n          method = &Benchmark::ReadHot;\n        } else if (name == Slice(\"readrandomsmall\")) {\n          reads_ /= 1000;\n          method = &Benchmark::ReadRandom;\n        } else if (name == Slice(\"deleteseq\")) {\n          method = &Benchmark::DeleteSeq;\n        } else if (name == Slice(\"deleterandom\")) {\n          method = &Benchmark::DeleteRandom;\n        } else if (name == Slice(\"readwhilewriting\")) {\n          num_threads++;  // Add extra thread for writing\n          method = &Benchmark::ReadWhileWriting;\n        } else if (name == Slice(\"compact\")) {\n          method = &Benchmark::Compact;\n        } else if (name == Slice(\"crc32c\")) {\n          method = &Benchmark::Crc32c;\n        } else if (name == Slice(\"acquireload\")) {\n          method = &Benchmark::AcquireLoad;\n        } else if (name == Slice(\"snappycomp\")) {\n          method = &Benchmark::SnappyCompress;\n        } else if (name == Slice(\"snappyuncomp\")) {\n          method = &Benchmark::SnappyUncompress;\n        } else if (name == Slice(\"heapprofile\")) {\n          HeapProfile();\n        } else if (name == Slice(\"stats\")) {\n          PrintStats(\"leveldb.stats\");\n        } else if (name == Slice(\"sstables\")) {\n          PrintStats(\"leveldb.sstables\");\n        } else {\n          if (name != Slice()) {  // No error message for empty name\n            fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n          }\n        }\n  \n        if (fresh_db) {\n          if (FLAGS_use_existing_db) {\n            fprintf(stdout, \"%-12s : skipped (--use_existing_db is true)\\n\",\n                    name.ToString().c_str());\n            method = NULL;\n          } else {\n            delete db_;\n            db_ = NULL;\n            DestroyDB(FLAGS_db, Options());\n            Open();\n          }\n        }\n  \n        if (method != NULL) {\n          RunBenchmark(num_threads, name, method);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_db_path.c_str",
          "args": [],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Env::Default",
          "args": [
            "&default_db_path"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Env::Default",
          "args": [],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid flag '%s'\\n\"",
            "argv[i]"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--db=\"",
            "5"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--open_files=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--bloom_bits=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--cache_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--write_buffer_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--value_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--threads=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--reads=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--num=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--use_existing_db=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--histogram=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--compression_ratio=%lf%c\"",
            "&d",
            "&junk"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"--benchmarks=\""
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Slice",
          "args": [
            "\"--benchmarks=\""
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "Slice",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "37-37",
          "snippet": "Slice(const char* s) : data_(s), size_(strlen(s)) { }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  Slice(const char* s) : data_(s), size_(strlen(s)) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::Options",
          "args": [],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "Options",
          "container": "Options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/options.cc",
          "lines": "12-26",
          "snippet": "Options::Options()\n    : comparator(BytewiseComparator()),\n      create_if_missing(false),\n      error_if_exists(false),\n      paranoid_checks(false),\n      env(Env::Default()),\n      info_log(NULL),\n      write_buffer_size(4<<20),\n      max_open_files(1000),\n      block_cache(NULL),\n      block_size(4096),\n      block_restart_interval(16),\n      compression(kSnappyCompression),\n      filter_policy(NULL) {\n}",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/options.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/options.h\"\n\nOptions {\n  Options::Options()\n      : comparator(BytewiseComparator()),\n        create_if_missing(false),\n        error_if_exists(false),\n        paranoid_checks(false),\n        env(Env::Default()),\n        info_log(NULL),\n        write_buffer_size(4<<20),\n        max_open_files(1000),\n        block_cache(NULL),\n        block_size(4096),\n        block_restart_interval(16),\n        compression(kSnappyCompression),\n        filter_policy(NULL) {\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readrandom,\"  // Extra run to allow previous compactions to quiesce\n    \"readseq,\"\n    \"readreverse,\"\n    \"compact,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"readreverse,\"\n    \"fill100K,\"\n    \"crc32c,\"\n    \"snappycomp,\"\n    \"snappyuncomp,\"\n    \"acquireload,\"\n    ;\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic int FLAGS_threads = 1;\nstatic int FLAGS_value_size = 100;\nstatic double FLAGS_compression_ratio = 0.5;\nstatic bool FLAGS_histogram = false;\nstatic int FLAGS_write_buffer_size = 0;\nstatic int FLAGS_cache_size = -1;\nstatic int FLAGS_open_files = 0;\nstatic int FLAGS_bloom_bits = -1;\nstatic bool FLAGS_use_existing_db = false;\nstatic const char* FLAGS_db = NULL;\n\nint main(int argc, char** argv) {\n  FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;\n  FLAGS_open_files = leveldb::Options().max_open_files;\n  std::string default_db_path;\n\n  for (int i = 1; i < argc; i++) {\n    double d;\n    int n;\n    char junk;\n    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n      FLAGS_compression_ratio = d;\n    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_histogram = n;\n    } else if (sscanf(argv[i], \"--use_existing_db=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_use_existing_db = n;\n    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n      FLAGS_num = n;\n    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n      FLAGS_reads = n;\n    } else if (sscanf(argv[i], \"--threads=%d%c\", &n, &junk) == 1) {\n      FLAGS_threads = n;\n    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_value_size = n;\n    } else if (sscanf(argv[i], \"--write_buffer_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_write_buffer_size = n;\n    } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_cache_size = n;\n    } else if (sscanf(argv[i], \"--bloom_bits=%d%c\", &n, &junk) == 1) {\n      FLAGS_bloom_bits = n;\n    } else if (sscanf(argv[i], \"--open_files=%d%c\", &n, &junk) == 1) {\n      FLAGS_open_files = n;\n    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n      FLAGS_db = argv[i] + 5;\n    } else {\n      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n      exit(1);\n    }\n  }\n\n  // Choose a location for the test database if none given with --db=<path>\n  if (FLAGS_db == NULL) {\n      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n      default_db_path += \"/dbbench\";\n      FLAGS_db = default_db_path.c_str();\n  }\n\n  leveldb::Benchmark benchmark;\n  benchmark.Run();\n  return 0;\n}"
  },
  {
    "function_name": "HeapProfile",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "906-921",
    "snippet": "void HeapProfile() {\n    char fname[100];\n    snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n    WritableFile* file;\n    Status s = Env::Default()->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n      return;\n    }\n    bool ok = port::GetHeapProfile(WriteToFile, file);\n    delete file;\n    if (!ok) {\n      fprintf(stderr, \"heap profiling not supported\\n\");\n      Env::Default()->DeleteFile(fname);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* FLAGS_db = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "fname"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"heap profiling not supported\\n\""
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port::GetHeapProfile",
          "args": [
            "WriteToFile",
            "file"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "GetHeapProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.h",
          "lines": "167-169",
          "snippet": "inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n  return false;\n}",
          "includes": [
            "#include <snappy.h>",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy.h>\n#include <stdint.h>\n#include <string>\n\ninline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 912
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "fname",
            "&file"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "fname",
            "sizeof(fname)",
            "\"%s/heap-%04d\"",
            "FLAGS_db",
            "++heap_counter_"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic const char* FLAGS_db = NULL;\n\nBenchmark {\n  void HeapProfile() {\n      char fname[100];\n      snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n      WritableFile* file;\n      Status s = Env::Default()->NewWritableFile(fname, &file);\n      if (!s.ok()) {\n        fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n        return;\n      }\n      bool ok = port::GetHeapProfile(WriteToFile, file);\n      delete file;\n      if (!ok) {\n        fprintf(stderr, \"heap profiling not supported\\n\");\n        Env::Default()->DeleteFile(fname);\n      }\n    }\n}"
  },
  {
    "function_name": "WriteToFile",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "902-904",
    "snippet": "static void WriteToFile(void* arg, const char* buf, int n) {\n    reinterpret_cast<WritableFile*>(arg)->Append(Slice(buf, n));\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<WritableFile*>",
          "args": [
            "Slice(buf, n)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "buf",
            "n"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<WritableFile*>",
          "args": [
            "arg"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  static void WriteToFile(void* arg, const char* buf, int n) {\n      reinterpret_cast<WritableFile*>(arg)->Append(Slice(buf, n));\n    }\n}"
  },
  {
    "function_name": "PrintStats",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "894-900",
    "snippet": "void PrintStats(const char* key) {\n    std::string stats;\n    if (!db_->GetProperty(key, &stats)) {\n      stats = \"(failed)\";\n    }\n    fprintf(stdout, \"\\n%s\\n\", stats.c_str());\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"\\n%s\\n\"",
            "stats.c_str()"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stats.c_str",
          "args": [],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->GetProperty",
          "args": [
            "key",
            "&stats"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "GetProperty",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1349-1401",
          "snippet": "bool DBImpl::GetProperty(const Slice& property, std::string* value) {\n  value->clear();\n\n  MutexLock l(&mutex_);\n  Slice in = property;\n  Slice prefix(\"leveldb.\");\n  if (!in.starts_with(prefix)) return false;\n  in.remove_prefix(prefix.size());\n\n  if (in.starts_with(\"num-files-at-level\")) {\n    in.remove_prefix(strlen(\"num-files-at-level\"));\n    uint64_t level;\n    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();\n    if (!ok || level >= config::kNumLevels) {\n      return false;\n    } else {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"%d\",\n               versions_->NumLevelFiles(static_cast<int>(level)));\n      *value = buf;\n      return true;\n    }\n  } else if (in == \"stats\") {\n    char buf[200];\n    snprintf(buf, sizeof(buf),\n             \"                               Compactions\\n\"\n             \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n             \"--------------------------------------------------\\n\"\n             );\n    value->append(buf);\n    for (int level = 0; level < config::kNumLevels; level++) {\n      int files = versions_->NumLevelFiles(level);\n      if (stats_[level].micros > 0 || files > 0) {\n        snprintf(\n            buf, sizeof(buf),\n            \"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\",\n            level,\n            files,\n            versions_->NumLevelBytes(level) / 1048576.0,\n            stats_[level].micros / 1e6,\n            stats_[level].bytes_read / 1048576.0,\n            stats_[level].bytes_written / 1048576.0);\n        value->append(buf);\n      }\n    }\n    return true;\n  } else if (in == \"sstables\") {\n    *value = versions_->current()->DebugString();\n    return true;\n  }\n\n  return false;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  bool DBImpl::GetProperty(const Slice& property, std::string* value) {\n    value->clear();\n  \n    MutexLock l(&mutex_);\n    Slice in = property;\n    Slice prefix(\"leveldb.\");\n    if (!in.starts_with(prefix)) return false;\n    in.remove_prefix(prefix.size());\n  \n    if (in.starts_with(\"num-files-at-level\")) {\n      in.remove_prefix(strlen(\"num-files-at-level\"));\n      uint64_t level;\n      bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();\n      if (!ok || level >= config::kNumLevels) {\n        return false;\n      } else {\n        char buf[100];\n        snprintf(buf, sizeof(buf), \"%d\",\n                 versions_->NumLevelFiles(static_cast<int>(level)));\n        *value = buf;\n        return true;\n      }\n    } else if (in == \"stats\") {\n      char buf[200];\n      snprintf(buf, sizeof(buf),\n               \"                               Compactions\\n\"\n               \"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\\n\"\n               \"--------------------------------------------------\\n\"\n               );\n      value->append(buf);\n      for (int level = 0; level < config::kNumLevels; level++) {\n        int files = versions_->NumLevelFiles(level);\n        if (stats_[level].micros > 0 || files > 0) {\n          snprintf(\n              buf, sizeof(buf),\n              \"%3d %8d %8.0f %9.0f %8.0f %9.0f\\n\",\n              level,\n              files,\n              versions_->NumLevelBytes(level) / 1048576.0,\n              stats_[level].micros / 1e6,\n              stats_[level].bytes_read / 1048576.0,\n              stats_[level].bytes_written / 1048576.0);\n          value->append(buf);\n        }\n      }\n      return true;\n    } else if (in == \"sstables\") {\n      *value = versions_->current()->DebugString();\n      return true;\n    }\n  \n    return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void PrintStats(const char* key) {\n      std::string stats;\n      if (!db_->GetProperty(key, &stats)) {\n        stats = \"(failed)\";\n      }\n      fprintf(stdout, \"\\n%s\\n\", stats.c_str());\n    }\n}"
  },
  {
    "function_name": "Compact",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "890-892",
    "snippet": "void Compact(ThreadState* thread) {\n    db_->CompactRange(NULL, NULL);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "db_->CompactRange",
          "args": [
            "NULL",
            "NULL"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "CompactRange",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "536-551",
          "snippet": "void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n  int max_level_with_files = 1;\n  {\n    MutexLock l(&mutex_);\n    Version* base = versions_->current();\n    for (int level = 1; level < config::kNumLevels; level++) {\n      if (base->OverlapInLevel(level, begin, end)) {\n        max_level_with_files = level;\n      }\n    }\n  }\n  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n  for (int level = 0; level < max_level_with_files; level++) {\n    TEST_CompactRange(level, begin, end);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n    int max_level_with_files = 1;\n    {\n      MutexLock l(&mutex_);\n      Version* base = versions_->current();\n      for (int level = 1; level < config::kNumLevels; level++) {\n        if (base->OverlapInLevel(level, begin, end)) {\n          max_level_with_files = level;\n        }\n      }\n    }\n    TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n    for (int level = 0; level < max_level_with_files; level++) {\n      TEST_CompactRange(level, begin, end);\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void Compact(ThreadState* thread) {\n      db_->CompactRange(NULL, NULL);\n    }\n}"
  },
  {
    "function_name": "ReadWhileWriting",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "860-888",
    "snippet": "void ReadWhileWriting(ThreadState* thread) {\n    if (thread->tid > 0) {\n      ReadRandom(thread);\n    } else {\n      // Special thread that keeps writing until other threads are done.\n      RandomGenerator gen;\n      while (true) {\n        {\n          MutexLock l(&thread->shared->mu);\n          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {\n            // Other threads have finished\n            break;\n          }\n        }\n\n        const int k = thread->rand.Next() % FLAGS_num;\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));\n        if (!s.ok()) {\n          fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n          exit(1);\n        }\n      }\n\n      // Do not count any of the preceding work/delay in stats.\n      thread->stats.Start();\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.Start",
          "args": [],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "176-186",
          "snippet": "void Start() {\n    next_report_ = 100;\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    bytes_ = 0;\n    seconds_ = 0;\n    start_ = Env::Default()->NowMicros();\n    finish_ = start_;\n    message_.clear();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Start() {\n      next_report_ = 100;\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      bytes_ = 0;\n      seconds_ = 0;\n      start_ = Env::Default()->NowMicros();\n      finish_ = start_;\n      message_.clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"put error: %s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Put",
          "args": [
            "write_options_",
            "key",
            "gen.Generate(value_size_)"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen.Generate",
          "args": [
            "value_size_"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "Generate",
          "container": "RandomGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "131-138",
          "snippet": "Slice Generate(size_t len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nRandomGenerator {\n  Slice Generate(size_t len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->rand.Next",
          "args": [],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadRandom",
          "args": [
            "thread"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "ReadRandom",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "769-785",
          "snippet": "void ReadRandom(ThreadState* thread) {\n    ReadOptions options;\n    std::string value;\n    int found = 0;\n    for (int i = 0; i < reads_; i++) {\n      char key[100];\n      const int k = thread->rand.Next() % FLAGS_num;\n      snprintf(key, sizeof(key), \"%016d\", k);\n      if (db_->Get(options, key, &value).ok()) {\n        found++;\n      }\n      thread->stats.FinishedSingleOp();\n    }\n    char msg[100];\n    snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n    thread->stats.AddMessage(msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_num = 1000000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void ReadRandom(ThreadState* thread) {\n      ReadOptions options;\n      std::string value;\n      int found = 0;\n      for (int i = 0; i < reads_; i++) {\n        char key[100];\n        const int k = thread->rand.Next() % FLAGS_num;\n        snprintf(key, sizeof(key), \"%016d\", k);\n        if (db_->Get(options, key, &value).ok()) {\n          found++;\n        }\n        thread->stats.FinishedSingleOp();\n      }\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n      thread->stats.AddMessage(msg);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void ReadWhileWriting(ThreadState* thread) {\n      if (thread->tid > 0) {\n        ReadRandom(thread);\n      } else {\n        // Special thread that keeps writing until other threads are done.\n        RandomGenerator gen;\n        while (true) {\n          {\n            MutexLock l(&thread->shared->mu);\n            if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {\n              // Other threads have finished\n              break;\n            }\n          }\n  \n          const int k = thread->rand.Next() % FLAGS_num;\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n          Status s = db_->Put(write_options_, key, gen.Generate(value_size_));\n          if (!s.ok()) {\n            fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n            exit(1);\n          }\n        }\n  \n        // Do not count any of the preceding work/delay in stats.\n        thread->stats.Start();\n      }\n    }\n}"
  },
  {
    "function_name": "DeleteRandom",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "856-858",
    "snippet": "void DeleteRandom(ThreadState* thread) {\n    DoDelete(thread, false);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoDelete",
          "args": [
            "thread",
            "false"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "DoDelete",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "831-850",
          "snippet": "void DoDelete(ThreadState* thread, bool seq) {\n    RandomGenerator gen;\n    WriteBatch batch;\n    Status s;\n    for (int i = 0; i < num_; i += entries_per_batch_) {\n      batch.Clear();\n      for (int j = 0; j < entries_per_batch_; j++) {\n        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        batch.Delete(key);\n        thread->stats.FinishedSingleOp();\n      }\n      s = db_->Write(write_options_, &batch);\n      if (!s.ok()) {\n        fprintf(stderr, \"del error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_num = 1000000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void DoDelete(ThreadState* thread, bool seq) {\n      RandomGenerator gen;\n      WriteBatch batch;\n      Status s;\n      for (int i = 0; i < num_; i += entries_per_batch_) {\n        batch.Clear();\n        for (int j = 0; j < entries_per_batch_; j++) {\n          const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n          batch.Delete(key);\n          thread->stats.FinishedSingleOp();\n        }\n        s = db_->Write(write_options_, &batch);\n        if (!s.ok()) {\n          fprintf(stderr, \"del error: %s\\n\", s.ToString().c_str());\n          exit(1);\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void DeleteRandom(ThreadState* thread) {\n      DoDelete(thread, false);\n    }\n}"
  },
  {
    "function_name": "DeleteSeq",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "852-854",
    "snippet": "void DeleteSeq(ThreadState* thread) {\n    DoDelete(thread, true);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoDelete",
          "args": [
            "thread",
            "true"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "DoDelete",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "831-850",
          "snippet": "void DoDelete(ThreadState* thread, bool seq) {\n    RandomGenerator gen;\n    WriteBatch batch;\n    Status s;\n    for (int i = 0; i < num_; i += entries_per_batch_) {\n      batch.Clear();\n      for (int j = 0; j < entries_per_batch_; j++) {\n        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        batch.Delete(key);\n        thread->stats.FinishedSingleOp();\n      }\n      s = db_->Write(write_options_, &batch);\n      if (!s.ok()) {\n        fprintf(stderr, \"del error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_num = 1000000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void DoDelete(ThreadState* thread, bool seq) {\n      RandomGenerator gen;\n      WriteBatch batch;\n      Status s;\n      for (int i = 0; i < num_; i += entries_per_batch_) {\n        batch.Clear();\n        for (int j = 0; j < entries_per_batch_; j++) {\n          const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n          batch.Delete(key);\n          thread->stats.FinishedSingleOp();\n        }\n        s = db_->Write(write_options_, &batch);\n        if (!s.ok()) {\n          fprintf(stderr, \"del error: %s\\n\", s.ToString().c_str());\n          exit(1);\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void DeleteSeq(ThreadState* thread) {\n      DoDelete(thread, true);\n    }\n}"
  },
  {
    "function_name": "DoDelete",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "831-850",
    "snippet": "void DoDelete(ThreadState* thread, bool seq) {\n    RandomGenerator gen;\n    WriteBatch batch;\n    Status s;\n    for (int i = 0; i < num_; i += entries_per_batch_) {\n      batch.Clear();\n      for (int j = 0; j < entries_per_batch_; j++) {\n        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        batch.Delete(key);\n        thread->stats.FinishedSingleOp();\n      }\n      s = db_->Write(write_options_, &batch);\n      if (!s.ok()) {\n        fprintf(stderr, \"del error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"del error: %s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Write",
          "args": [
            "write_options_",
            "&batch"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1162-1233",
          "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Delete",
          "args": [
            "key"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "78-81",
          "snippet": "virtual void Delete(const Slice& key) {\n    printf(\"  del '%s'\\n\",\n           EscapeString(key).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Delete(const Slice& key) {\n      printf(\"  del '%s'\\n\",\n             EscapeString(key).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->rand.Next",
          "args": [],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Clear",
          "args": [],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void DoDelete(ThreadState* thread, bool seq) {\n      RandomGenerator gen;\n      WriteBatch batch;\n      Status s;\n      for (int i = 0; i < num_; i += entries_per_batch_) {\n        batch.Clear();\n        for (int j = 0; j < entries_per_batch_; j++) {\n          const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n          batch.Delete(key);\n          thread->stats.FinishedSingleOp();\n        }\n        s = db_->Write(write_options_, &batch);\n        if (!s.ok()) {\n          fprintf(stderr, \"del error: %s\\n\", s.ToString().c_str());\n          exit(1);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "SeekRandom",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "812-829",
    "snippet": "void SeekRandom(ThreadState* thread) {\n    ReadOptions options;\n    std::string value;\n    int found = 0;\n    for (int i = 0; i < reads_; i++) {\n      Iterator* iter = db_->NewIterator(options);\n      char key[100];\n      const int k = thread->rand.Next() % FLAGS_num;\n      snprintf(key, sizeof(key), \"%016d\", k);\n      iter->Seek(key);\n      if (iter->Valid() && iter->key() == key) found++;\n      delete iter;\n      thread->stats.FinishedSingleOp();\n    }\n    char msg[100];\n    snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n    thread->stats.AddMessage(msg);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddMessage",
          "args": [
            "msg"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "AddMessage",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "205-207",
          "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg",
            "sizeof(msg)",
            "\"(%d of %d found)\"",
            "found",
            "num_"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Seek",
          "args": [
            "key"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "274-286",
          "snippet": "void DBIter::Seek(const Slice& target) {\n  direction_ = kForward;\n  ClearSavedValue();\n  saved_key_.clear();\n  AppendInternalKey(\n      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));\n  iter_->Seek(saved_key_);\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Seek(const Slice& target) {\n    direction_ = kForward;\n    ClearSavedValue();\n    saved_key_.clear();\n    AppendInternalKey(\n        &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));\n    iter_->Seek(saved_key_);\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->rand.Next",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->NewIterator",
          "args": [
            "options"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void SeekRandom(ThreadState* thread) {\n      ReadOptions options;\n      std::string value;\n      int found = 0;\n      for (int i = 0; i < reads_; i++) {\n        Iterator* iter = db_->NewIterator(options);\n        char key[100];\n        const int k = thread->rand.Next() % FLAGS_num;\n        snprintf(key, sizeof(key), \"%016d\", k);\n        iter->Seek(key);\n        if (iter->Valid() && iter->key() == key) found++;\n        delete iter;\n        thread->stats.FinishedSingleOp();\n      }\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n      thread->stats.AddMessage(msg);\n    }\n}"
  },
  {
    "function_name": "ReadHot",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "799-810",
    "snippet": "void ReadHot(ThreadState* thread) {\n    ReadOptions options;\n    std::string value;\n    const int range = (FLAGS_num + 99) / 100;\n    for (int i = 0; i < reads_; i++) {\n      char key[100];\n      const int k = thread->rand.Next() % range;\n      snprintf(key, sizeof(key), \"%016d\", k);\n      db_->Get(options, key, &value);\n      thread->stats.FinishedSingleOp();\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Get",
          "args": [
            "options",
            "key",
            "&value"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1077-1122",
          "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Get(const ReadOptions& options,\n                     const Slice& key,\n                     std::string* value) {\n    Status s;\n    MutexLock l(&mutex_);\n    SequenceNumber snapshot;\n    if (options.snapshot != NULL) {\n      snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n    } else {\n      snapshot = versions_->LastSequence();\n    }\n  \n    MemTable* mem = mem_;\n    MemTable* imm = imm_;\n    Version* current = versions_->current();\n    mem->Ref();\n    if (imm != NULL) imm->Ref();\n    current->Ref();\n  \n    bool have_stat_update = false;\n    Version::GetStats stats;\n  \n    // Unlock while reading from files and memtables\n    {\n      mutex_.Unlock();\n      // First look in the memtable, then in the immutable memtable (if any).\n      LookupKey lkey(key, snapshot);\n      if (mem->Get(lkey, value, &s)) {\n        // Done\n      } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n        // Done\n      } else {\n        s = current->Get(options, lkey, value, &stats);\n        have_stat_update = true;\n      }\n      mutex_.Lock();\n    }\n  \n    if (have_stat_update && current->UpdateStats(stats)) {\n      MaybeScheduleCompaction();\n    }\n    mem->Unref();\n    if (imm != NULL) imm->Unref();\n    current->Unref();\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->rand.Next",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void ReadHot(ThreadState* thread) {\n      ReadOptions options;\n      std::string value;\n      const int range = (FLAGS_num + 99) / 100;\n      for (int i = 0; i < reads_; i++) {\n        char key[100];\n        const int k = thread->rand.Next() % range;\n        snprintf(key, sizeof(key), \"%016d\", k);\n        db_->Get(options, key, &value);\n        thread->stats.FinishedSingleOp();\n      }\n    }\n}"
  },
  {
    "function_name": "ReadMissing",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "787-797",
    "snippet": "void ReadMissing(ThreadState* thread) {\n    ReadOptions options;\n    std::string value;\n    for (int i = 0; i < reads_; i++) {\n      char key[100];\n      const int k = thread->rand.Next() % FLAGS_num;\n      snprintf(key, sizeof(key), \"%016d.\", k);\n      db_->Get(options, key, &value);\n      thread->stats.FinishedSingleOp();\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Get",
          "args": [
            "options",
            "key",
            "&value"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1077-1122",
          "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Get(const ReadOptions& options,\n                     const Slice& key,\n                     std::string* value) {\n    Status s;\n    MutexLock l(&mutex_);\n    SequenceNumber snapshot;\n    if (options.snapshot != NULL) {\n      snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n    } else {\n      snapshot = versions_->LastSequence();\n    }\n  \n    MemTable* mem = mem_;\n    MemTable* imm = imm_;\n    Version* current = versions_->current();\n    mem->Ref();\n    if (imm != NULL) imm->Ref();\n    current->Ref();\n  \n    bool have_stat_update = false;\n    Version::GetStats stats;\n  \n    // Unlock while reading from files and memtables\n    {\n      mutex_.Unlock();\n      // First look in the memtable, then in the immutable memtable (if any).\n      LookupKey lkey(key, snapshot);\n      if (mem->Get(lkey, value, &s)) {\n        // Done\n      } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n        // Done\n      } else {\n        s = current->Get(options, lkey, value, &stats);\n        have_stat_update = true;\n      }\n      mutex_.Lock();\n    }\n  \n    if (have_stat_update && current->UpdateStats(stats)) {\n      MaybeScheduleCompaction();\n    }\n    mem->Unref();\n    if (imm != NULL) imm->Unref();\n    current->Unref();\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d.\"",
            "k"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->rand.Next",
          "args": [],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void ReadMissing(ThreadState* thread) {\n      ReadOptions options;\n      std::string value;\n      for (int i = 0; i < reads_; i++) {\n        char key[100];\n        const int k = thread->rand.Next() % FLAGS_num;\n        snprintf(key, sizeof(key), \"%016d.\", k);\n        db_->Get(options, key, &value);\n        thread->stats.FinishedSingleOp();\n      }\n    }\n}"
  },
  {
    "function_name": "ReadRandom",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "769-785",
    "snippet": "void ReadRandom(ThreadState* thread) {\n    ReadOptions options;\n    std::string value;\n    int found = 0;\n    for (int i = 0; i < reads_; i++) {\n      char key[100];\n      const int k = thread->rand.Next() % FLAGS_num;\n      snprintf(key, sizeof(key), \"%016d\", k);\n      if (db_->Get(options, key, &value).ok()) {\n        found++;\n      }\n      thread->stats.FinishedSingleOp();\n    }\n    char msg[100];\n    snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n    thread->stats.AddMessage(msg);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddMessage",
          "args": [
            "msg"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "AddMessage",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "205-207",
          "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg",
            "sizeof(msg)",
            "\"(%d of %d found)\"",
            "found",
            "num_"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Get",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "349-367",
          "snippet": "CTxDestination Get() const {\n        if (!IsValid())\n            return CNoDestination();\n        switch (nVersion) {\n        case PUBKEY_ADDRESS:\n        case PUBKEY_ADDRESS_TEST: {\n            uint160 id;\n            memcpy(&id, &vchData[0], 20);\n            return CKeyID(id);\n        }\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            uint160 id;\n            memcpy(&id, &vchData[0], 20);\n            return CScriptID(id);\n        }\n        }\n        return CNoDestination();\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  CTxDestination Get() const {\n          if (!IsValid())\n              return CNoDestination();\n          switch (nVersion) {\n          case PUBKEY_ADDRESS:\n          case PUBKEY_ADDRESS_TEST: {\n              uint160 id;\n              memcpy(&id, &vchData[0], 20);\n              return CKeyID(id);\n          }\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              uint160 id;\n              memcpy(&id, &vchData[0], 20);\n              return CScriptID(id);\n          }\n          }\n          return CNoDestination();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Get",
          "args": [
            "options",
            "key",
            "&value"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1077-1122",
          "snippet": "Status DBImpl::Get(const ReadOptions& options,\n                   const Slice& key,\n                   std::string* value) {\n  Status s;\n  MutexLock l(&mutex_);\n  SequenceNumber snapshot;\n  if (options.snapshot != NULL) {\n    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n  } else {\n    snapshot = versions_->LastSequence();\n  }\n\n  MemTable* mem = mem_;\n  MemTable* imm = imm_;\n  Version* current = versions_->current();\n  mem->Ref();\n  if (imm != NULL) imm->Ref();\n  current->Ref();\n\n  bool have_stat_update = false;\n  Version::GetStats stats;\n\n  // Unlock while reading from files and memtables\n  {\n    mutex_.Unlock();\n    // First look in the memtable, then in the immutable memtable (if any).\n    LookupKey lkey(key, snapshot);\n    if (mem->Get(lkey, value, &s)) {\n      // Done\n    } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n      // Done\n    } else {\n      s = current->Get(options, lkey, value, &stats);\n      have_stat_update = true;\n    }\n    mutex_.Lock();\n  }\n\n  if (have_stat_update && current->UpdateStats(stats)) {\n    MaybeScheduleCompaction();\n  }\n  mem->Unref();\n  if (imm != NULL) imm->Unref();\n  current->Unref();\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Get(const ReadOptions& options,\n                     const Slice& key,\n                     std::string* value) {\n    Status s;\n    MutexLock l(&mutex_);\n    SequenceNumber snapshot;\n    if (options.snapshot != NULL) {\n      snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;\n    } else {\n      snapshot = versions_->LastSequence();\n    }\n  \n    MemTable* mem = mem_;\n    MemTable* imm = imm_;\n    Version* current = versions_->current();\n    mem->Ref();\n    if (imm != NULL) imm->Ref();\n    current->Ref();\n  \n    bool have_stat_update = false;\n    Version::GetStats stats;\n  \n    // Unlock while reading from files and memtables\n    {\n      mutex_.Unlock();\n      // First look in the memtable, then in the immutable memtable (if any).\n      LookupKey lkey(key, snapshot);\n      if (mem->Get(lkey, value, &s)) {\n        // Done\n      } else if (imm != NULL && imm->Get(lkey, value, &s)) {\n        // Done\n      } else {\n        s = current->Get(options, lkey, value, &stats);\n        have_stat_update = true;\n      }\n      mutex_.Lock();\n    }\n  \n    if (have_stat_update && current->UpdateStats(stats)) {\n      MaybeScheduleCompaction();\n    }\n    mem->Unref();\n    if (imm != NULL) imm->Unref();\n    current->Unref();\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->rand.Next",
          "args": [],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void ReadRandom(ThreadState* thread) {\n      ReadOptions options;\n      std::string value;\n      int found = 0;\n      for (int i = 0; i < reads_; i++) {\n        char key[100];\n        const int k = thread->rand.Next() % FLAGS_num;\n        snprintf(key, sizeof(key), \"%016d\", k);\n        if (db_->Get(options, key, &value).ok()) {\n          found++;\n        }\n        thread->stats.FinishedSingleOp();\n      }\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d of %d found)\", found, num_);\n      thread->stats.AddMessage(msg);\n    }\n}"
  },
  {
    "function_name": "ReadReverse",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "756-767",
    "snippet": "void ReadReverse(ThreadState* thread) {\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    int i = 0;\n    int64_t bytes = 0;\n    for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {\n      bytes += iter->key().size() + iter->value().size();\n      thread->stats.FinishedSingleOp();\n      ++i;\n    }\n    delete iter;\n    thread->stats.AddBytes(bytes);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddBytes",
          "args": [
            "bytes"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "AddBytes",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "235-237",
          "snippet": "void AddBytes(int64_t n) {\n    bytes_ += n;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddBytes(int64_t n) {\n      bytes_ += n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Prev",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "Prev",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "205-230",
          "snippet": "void DBIter::Prev() {\n  assert(valid_);\n\n  if (direction_ == kForward) {  // Switch directions?\n    // iter_ is pointing at the current entry.  Scan backwards until\n    // the key changes so we can use the normal reverse scanning code.\n    assert(iter_->Valid());  // Otherwise valid_ would have been false\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    while (true) {\n      iter_->Prev();\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        ClearSavedValue();\n        return;\n      }\n      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n                                    saved_key_) < 0) {\n        break;\n      }\n    }\n    direction_ = kReverse;\n  }\n\n  FindPrevUserEntry();\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Prev() {\n    assert(valid_);\n  \n    if (direction_ == kForward) {  // Switch directions?\n      // iter_ is pointing at the current entry.  Scan backwards until\n      // the key changes so we can use the normal reverse scanning code.\n      assert(iter_->Valid());  // Otherwise valid_ would have been false\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n      while (true) {\n        iter_->Prev();\n        if (!iter_->Valid()) {\n          valid_ = false;\n          saved_key_.clear();\n          ClearSavedValue();\n          return;\n        }\n        if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n                                      saved_key_) < 0) {\n          break;\n        }\n      }\n      direction_ = kReverse;\n    }\n  \n    FindPrevUserEntry();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToLast",
          "args": [],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToLast",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "299-304",
          "snippet": "void DBIter::SeekToLast() {\n  direction_ = kReverse;\n  ClearSavedValue();\n  iter_->SeekToLast();\n  FindPrevUserEntry();\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToLast() {\n    direction_ = kReverse;\n    ClearSavedValue();\n    iter_->SeekToLast();\n    FindPrevUserEntry();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->NewIterator",
          "args": [
            "ReadOptions()"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void ReadReverse(ThreadState* thread) {\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      int i = 0;\n      int64_t bytes = 0;\n      for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {\n        bytes += iter->key().size() + iter->value().size();\n        thread->stats.FinishedSingleOp();\n        ++i;\n      }\n      delete iter;\n      thread->stats.AddBytes(bytes);\n    }\n}"
  },
  {
    "function_name": "ReadSequential",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "743-754",
    "snippet": "void ReadSequential(ThreadState* thread) {\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    int i = 0;\n    int64_t bytes = 0;\n    for (iter->SeekToFirst(); i < reads_ && iter->Valid(); iter->Next()) {\n      bytes += iter->key().size() + iter->value().size();\n      thread->stats.FinishedSingleOp();\n      ++i;\n    }\n    delete iter;\n    thread->stats.AddBytes(bytes);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddBytes",
          "args": [
            "bytes"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "AddBytes",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "235-237",
          "snippet": "void AddBytes(int64_t n) {\n    bytes_ += n;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddBytes(int64_t n) {\n      bytes_ += n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->NewIterator",
          "args": [
            "ReadOptions()"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void ReadSequential(ThreadState* thread) {\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      int i = 0;\n      int64_t bytes = 0;\n      for (iter->SeekToFirst(); i < reads_ && iter->Valid(); iter->Next()) {\n        bytes += iter->key().size() + iter->value().size();\n        thread->stats.FinishedSingleOp();\n        ++i;\n      }\n      delete iter;\n      thread->stats.AddBytes(bytes);\n    }\n}"
  },
  {
    "function_name": "DoWrite",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "713-741",
    "snippet": "void DoWrite(ThreadState* thread, bool seq) {\n    if (num_ != FLAGS_num) {\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d ops)\", num_);\n      thread->stats.AddMessage(msg);\n    }\n\n    RandomGenerator gen;\n    WriteBatch batch;\n    Status s;\n    int64_t bytes = 0;\n    for (int i = 0; i < num_; i += entries_per_batch_) {\n      batch.Clear();\n      for (int j = 0; j < entries_per_batch_; j++) {\n        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        batch.Put(key, gen.Generate(value_size_));\n        bytes += value_size_ + strlen(key);\n        thread->stats.FinishedSingleOp();\n      }\n      s = db_->Write(write_options_, &batch);\n      if (!s.ok()) {\n        fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n    thread->stats.AddBytes(bytes);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddBytes",
          "args": [
            "bytes"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "AddBytes",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "235-237",
          "snippet": "void AddBytes(int64_t n) {\n    bytes_ += n;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddBytes(int64_t n) {\n      bytes_ += n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"put error: %s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->Write",
          "args": [
            "write_options_",
            "&batch"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1162-1233",
          "snippet": "Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n  Writer w(&mutex_);\n  w.batch = my_batch;\n  w.sync = options.sync;\n  w.done = false;\n\n  MutexLock l(&mutex_);\n  writers_.push_back(&w);\n  while (!w.done && &w != writers_.front()) {\n    w.cv.Wait();\n  }\n  if (w.done) {\n    return w.status;\n  }\n\n  // May temporarily unlock and wait.\n  Status status = MakeRoomForWrite(my_batch == NULL);\n  uint64_t last_sequence = versions_->LastSequence();\n  Writer* last_writer = &w;\n  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n    WriteBatch* updates = BuildBatchGroup(&last_writer);\n    WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n    last_sequence += WriteBatchInternal::Count(updates);\n\n    // Add to log and apply to memtable.  We can release the lock\n    // during this phase since &w is currently responsible for logging\n    // and protects against concurrent loggers and concurrent writes\n    // into mem_.\n    {\n      mutex_.Unlock();\n      status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n      bool sync_error = false;\n      if (status.ok() && options.sync) {\n        status = logfile_->Sync();\n        if (!status.ok()) {\n          sync_error = true;\n        }\n      }\n      if (status.ok()) {\n        status = WriteBatchInternal::InsertInto(updates, mem_);\n      }\n      mutex_.Lock();\n      if (sync_error) {\n        // The state of the log file is indeterminate: the log record we\n        // just added may or may not show up when the DB is re-opened.\n        // So we force the DB into a mode where all future writes fail.\n        RecordBackgroundError(status);\n      }\n    }\n    if (updates == tmp_batch_) tmp_batch_->Clear();\n\n    versions_->SetLastSequence(last_sequence);\n  }\n\n  while (true) {\n    Writer* ready = writers_.front();\n    writers_.pop_front();\n    if (ready != &w) {\n      ready->status = status;\n      ready->done = true;\n      ready->cv.Signal();\n    }\n    if (ready == last_writer) break;\n  }\n\n  // Notify new head of write queue\n  if (!writers_.empty()) {\n    writers_.front()->cv.Signal();\n  }\n\n  return status;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {\n    Writer w(&mutex_);\n    w.batch = my_batch;\n    w.sync = options.sync;\n    w.done = false;\n  \n    MutexLock l(&mutex_);\n    writers_.push_back(&w);\n    while (!w.done && &w != writers_.front()) {\n      w.cv.Wait();\n    }\n    if (w.done) {\n      return w.status;\n    }\n  \n    // May temporarily unlock and wait.\n    Status status = MakeRoomForWrite(my_batch == NULL);\n    uint64_t last_sequence = versions_->LastSequence();\n    Writer* last_writer = &w;\n    if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions\n      WriteBatch* updates = BuildBatchGroup(&last_writer);\n      WriteBatchInternal::SetSequence(updates, last_sequence + 1);\n      last_sequence += WriteBatchInternal::Count(updates);\n  \n      // Add to log and apply to memtable.  We can release the lock\n      // during this phase since &w is currently responsible for logging\n      // and protects against concurrent loggers and concurrent writes\n      // into mem_.\n      {\n        mutex_.Unlock();\n        status = log_->AddRecord(WriteBatchInternal::Contents(updates));\n        bool sync_error = false;\n        if (status.ok() && options.sync) {\n          status = logfile_->Sync();\n          if (!status.ok()) {\n            sync_error = true;\n          }\n        }\n        if (status.ok()) {\n          status = WriteBatchInternal::InsertInto(updates, mem_);\n        }\n        mutex_.Lock();\n        if (sync_error) {\n          // The state of the log file is indeterminate: the log record we\n          // just added may or may not show up when the DB is re-opened.\n          // So we force the DB into a mode where all future writes fail.\n          RecordBackgroundError(status);\n        }\n      }\n      if (updates == tmp_batch_) tmp_batch_->Clear();\n  \n      versions_->SetLastSequence(last_sequence);\n    }\n  \n    while (true) {\n      Writer* ready = writers_.front();\n      writers_.pop_front();\n      if (ready != &w) {\n        ready->status = status;\n        ready->done = true;\n        ready->cv.Signal();\n      }\n      if (ready == last_writer) break;\n    }\n  \n    // Notify new head of write queue\n    if (!writers_.empty()) {\n      writers_.front()->cv.Signal();\n    }\n  \n    return status;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "batch.Put",
          "args": [
            "key",
            "gen.Generate(value_size_)"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "73-77",
          "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen.Generate",
          "args": [
            "value_size_"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "Generate",
          "container": "RandomGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "131-138",
          "snippet": "Slice Generate(size_t len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nRandomGenerator {\n  Slice Generate(size_t len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->rand.Next",
          "args": [],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Clear",
          "args": [],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.AddMessage",
          "args": [
            "msg"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "AddMessage",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "205-207",
          "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg",
            "sizeof(msg)",
            "\"(%d ops)\"",
            "num_"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void DoWrite(ThreadState* thread, bool seq) {\n      if (num_ != FLAGS_num) {\n        char msg[100];\n        snprintf(msg, sizeof(msg), \"(%d ops)\", num_);\n        thread->stats.AddMessage(msg);\n      }\n  \n      RandomGenerator gen;\n      WriteBatch batch;\n      Status s;\n      int64_t bytes = 0;\n      for (int i = 0; i < num_; i += entries_per_batch_) {\n        batch.Clear();\n        for (int j = 0; j < entries_per_batch_; j++) {\n          const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n          batch.Put(key, gen.Generate(value_size_));\n          bytes += value_size_ + strlen(key);\n          thread->stats.FinishedSingleOp();\n        }\n        s = db_->Write(write_options_, &batch);\n        if (!s.ok()) {\n          fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n          exit(1);\n        }\n      }\n      thread->stats.AddBytes(bytes);\n    }\n}"
  },
  {
    "function_name": "WriteRandom",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "709-711",
    "snippet": "void WriteRandom(ThreadState* thread) {\n    DoWrite(thread, false);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoWrite",
          "args": [
            "thread",
            "false"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "DoWrite",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "713-741",
          "snippet": "void DoWrite(ThreadState* thread, bool seq) {\n    if (num_ != FLAGS_num) {\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d ops)\", num_);\n      thread->stats.AddMessage(msg);\n    }\n\n    RandomGenerator gen;\n    WriteBatch batch;\n    Status s;\n    int64_t bytes = 0;\n    for (int i = 0; i < num_; i += entries_per_batch_) {\n      batch.Clear();\n      for (int j = 0; j < entries_per_batch_; j++) {\n        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        batch.Put(key, gen.Generate(value_size_));\n        bytes += value_size_ + strlen(key);\n        thread->stats.FinishedSingleOp();\n      }\n      s = db_->Write(write_options_, &batch);\n      if (!s.ok()) {\n        fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n    thread->stats.AddBytes(bytes);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_num = 1000000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void DoWrite(ThreadState* thread, bool seq) {\n      if (num_ != FLAGS_num) {\n        char msg[100];\n        snprintf(msg, sizeof(msg), \"(%d ops)\", num_);\n        thread->stats.AddMessage(msg);\n      }\n  \n      RandomGenerator gen;\n      WriteBatch batch;\n      Status s;\n      int64_t bytes = 0;\n      for (int i = 0; i < num_; i += entries_per_batch_) {\n        batch.Clear();\n        for (int j = 0; j < entries_per_batch_; j++) {\n          const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n          batch.Put(key, gen.Generate(value_size_));\n          bytes += value_size_ + strlen(key);\n          thread->stats.FinishedSingleOp();\n        }\n        s = db_->Write(write_options_, &batch);\n        if (!s.ok()) {\n          fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n          exit(1);\n        }\n      }\n      thread->stats.AddBytes(bytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void WriteRandom(ThreadState* thread) {\n      DoWrite(thread, false);\n    }\n}"
  },
  {
    "function_name": "WriteSeq",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "705-707",
    "snippet": "void WriteSeq(ThreadState* thread) {\n    DoWrite(thread, true);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoWrite",
          "args": [
            "thread",
            "true"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "DoWrite",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "713-741",
          "snippet": "void DoWrite(ThreadState* thread, bool seq) {\n    if (num_ != FLAGS_num) {\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d ops)\", num_);\n      thread->stats.AddMessage(msg);\n    }\n\n    RandomGenerator gen;\n    WriteBatch batch;\n    Status s;\n    int64_t bytes = 0;\n    for (int i = 0; i < num_; i += entries_per_batch_) {\n      batch.Clear();\n      for (int j = 0; j < entries_per_batch_; j++) {\n        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        batch.Put(key, gen.Generate(value_size_));\n        bytes += value_size_ + strlen(key);\n        thread->stats.FinishedSingleOp();\n      }\n      s = db_->Write(write_options_, &batch);\n      if (!s.ok()) {\n        fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n    thread->stats.AddBytes(bytes);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_num = 1000000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\n\nBenchmark {\n  void DoWrite(ThreadState* thread, bool seq) {\n      if (num_ != FLAGS_num) {\n        char msg[100];\n        snprintf(msg, sizeof(msg), \"(%d ops)\", num_);\n        thread->stats.AddMessage(msg);\n      }\n  \n      RandomGenerator gen;\n      WriteBatch batch;\n      Status s;\n      int64_t bytes = 0;\n      for (int i = 0; i < num_; i += entries_per_batch_) {\n        batch.Clear();\n        for (int j = 0; j < entries_per_batch_; j++) {\n          const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n          batch.Put(key, gen.Generate(value_size_));\n          bytes += value_size_ + strlen(key);\n          thread->stats.FinishedSingleOp();\n        }\n        s = db_->Write(write_options_, &batch);\n        if (!s.ok()) {\n          fprintf(stderr, \"put error: %s\\n\", s.ToString().c_str());\n          exit(1);\n        }\n      }\n      thread->stats.AddBytes(bytes);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void WriteSeq(ThreadState* thread) {\n      DoWrite(thread, true);\n    }\n}"
  },
  {
    "function_name": "Open",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "690-703",
    "snippet": "void Open() {\n    assert(db_ == NULL);\n    Options options;\n    options.create_if_missing = !FLAGS_use_existing_db;\n    options.block_cache = cache_;\n    options.write_buffer_size = FLAGS_write_buffer_size;\n    options.max_open_files = FLAGS_open_files;\n    options.filter_policy = filter_policy_;\n    Status s = DB::Open(options, FLAGS_db, &db_);\n    if (!s.ok()) {\n      fprintf(stderr, \"open error: %s\\n\", s.ToString().c_str());\n      exit(1);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_write_buffer_size = 0;",
      "static int FLAGS_open_files = 0;",
      "static bool FLAGS_use_existing_db = false;",
      "static const char* FLAGS_db = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"open error: %s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DB::Open",
          "args": [
            "options",
            "FLAGS_db",
            "&db_"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1445-1477",
          "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "db_ == NULL"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_write_buffer_size = 0;\nstatic int FLAGS_open_files = 0;\nstatic bool FLAGS_use_existing_db = false;\nstatic const char* FLAGS_db = NULL;\n\nBenchmark {\n  void Open() {\n      assert(db_ == NULL);\n      Options options;\n      options.create_if_missing = !FLAGS_use_existing_db;\n      options.block_cache = cache_;\n      options.write_buffer_size = FLAGS_write_buffer_size;\n      options.max_open_files = FLAGS_open_files;\n      options.filter_policy = filter_policy_;\n      Status s = DB::Open(options, FLAGS_db, &db_);\n      if (!s.ok()) {\n        fprintf(stderr, \"open error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n}"
  },
  {
    "function_name": "SnappyUncompress",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "668-688",
    "snippet": "void SnappyUncompress(ThreadState* thread) {\n    RandomGenerator gen;\n    Slice input = gen.Generate(Options().block_size);\n    std::string compressed;\n    bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);\n    int64_t bytes = 0;\n    char* uncompressed = new char[input.size()];\n    while (ok && bytes < 1024 * 1048576) {  // Compress 1G\n      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),\n                                    uncompressed);\n      bytes += input.size();\n      thread->stats.FinishedSingleOp();\n    }\n    delete[] uncompressed;\n\n    if (!ok) {\n      thread->stats.AddMessage(\"(snappy failure)\");\n    } else {\n      thread->stats.AddBytes(bytes);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddBytes",
          "args": [
            "bytes"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "AddBytes",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "235-237",
          "snippet": "void AddBytes(int64_t n) {\n    bytes_ += n;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddBytes(int64_t n) {\n      bytes_ += n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.AddMessage",
          "args": [
            "\"(snappy failure)\""
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "AddMessage",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "205-207",
          "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.size",
          "args": [],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port::Snappy_Uncompress",
          "args": [
            "compressed.data()",
            "compressed.size()",
            "uncompressed"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "Snappy_Uncompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.h",
          "lines": "158-165",
          "snippet": "inline bool Snappy_Uncompress(const char* input, size_t length,\n                              char* output) {\n#ifdef SNAPPY\n  return snappy::RawUncompress(input, length, output);\n#else\n  return false;\n#endif\n}",
          "includes": [
            "#include <snappy.h>",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy.h>\n#include <stdint.h>\n#include <string>\n\ninline bool Snappy_Uncompress(const char* input, size_t length,\n                              char* output) {\n#ifdef SNAPPY\n  return snappy::RawUncompress(input, length, output);\n#else\n  return false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "compressed.data",
          "args": [],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port::Snappy_Compress",
          "args": [
            "input.data()",
            "input.size()",
            "&compressed"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "Snappy_Compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.h",
          "lines": "136-147",
          "snippet": "inline bool Snappy_Compress(const char* input, size_t length,\n                            ::std::string* output) {\n#ifdef SNAPPY\n  output->resize(snappy::MaxCompressedLength(length));\n  size_t outlen;\n  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n  output->resize(outlen);\n  return true;\n#endif\n\n  return false;\n}",
          "includes": [
            "#include <snappy.h>",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy.h>\n#include <stdint.h>\n#include <string>\n\ninline bool Snappy_Compress(const char* input, size_t length,\n                            ::std::string* output) {\n#ifdef SNAPPY\n  output->resize(snappy::MaxCompressedLength(length));\n  size_t outlen;\n  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n  output->resize(outlen);\n  return true;\n#endif\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.data",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen.Generate",
          "args": [
            "Options().block_size"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "Generate",
          "container": "RandomGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "131-138",
          "snippet": "Slice Generate(size_t len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nRandomGenerator {\n  Slice Generate(size_t len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Options",
          "args": [],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentOptions",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "238-251",
          "snippet": "Options CurrentOptions() {\n    Options options;\n    switch (option_config_) {\n      case kFilter:\n        options.filter_policy = filter_policy_;\n        break;\n      case kUncompressed:\n        options.compression = kNoCompression;\n        break;\n      default:\n        break;\n    }\n    return options;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  Options CurrentOptions() {\n      Options options;\n      switch (option_config_) {\n        case kFilter:\n          options.filter_policy = filter_policy_;\n          break;\n        case kUncompressed:\n          options.compression = kNoCompression;\n          break;\n        default:\n          break;\n      }\n      return options;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void SnappyUncompress(ThreadState* thread) {\n      RandomGenerator gen;\n      Slice input = gen.Generate(Options().block_size);\n      std::string compressed;\n      bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);\n      int64_t bytes = 0;\n      char* uncompressed = new char[input.size()];\n      while (ok && bytes < 1024 * 1048576) {  // Compress 1G\n        ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),\n                                      uncompressed);\n        bytes += input.size();\n        thread->stats.FinishedSingleOp();\n      }\n      delete[] uncompressed;\n  \n      if (!ok) {\n        thread->stats.AddMessage(\"(snappy failure)\");\n      } else {\n        thread->stats.AddBytes(bytes);\n      }\n    }\n}"
  },
  {
    "function_name": "SnappyCompress",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "643-666",
    "snippet": "void SnappyCompress(ThreadState* thread) {\n    RandomGenerator gen;\n    Slice input = gen.Generate(Options().block_size);\n    int64_t bytes = 0;\n    int64_t produced = 0;\n    bool ok = true;\n    std::string compressed;\n    while (ok && bytes < 1024 * 1048576) {  // Compress 1G\n      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);\n      produced += compressed.size();\n      bytes += input.size();\n      thread->stats.FinishedSingleOp();\n    }\n\n    if (!ok) {\n      thread->stats.AddMessage(\"(snappy failure)\");\n    } else {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"(output: %.1f%%)\",\n               (produced * 100.0) / bytes);\n      thread->stats.AddMessage(buf);\n      thread->stats.AddBytes(bytes);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddBytes",
          "args": [
            "bytes"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "AddBytes",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "235-237",
          "snippet": "void AddBytes(int64_t n) {\n    bytes_ += n;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddBytes(int64_t n) {\n      bytes_ += n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.AddMessage",
          "args": [
            "buf"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "AddMessage",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "205-207",
          "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"(output: %.1f%%)\"",
            "(produced * 100.0) / bytes"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.size",
          "args": [],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port::Snappy_Compress",
          "args": [
            "input.data()",
            "input.size()",
            "&compressed"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "Snappy_Compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.h",
          "lines": "136-147",
          "snippet": "inline bool Snappy_Compress(const char* input, size_t length,\n                            ::std::string* output) {\n#ifdef SNAPPY\n  output->resize(snappy::MaxCompressedLength(length));\n  size_t outlen;\n  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n  output->resize(outlen);\n  return true;\n#endif\n\n  return false;\n}",
          "includes": [
            "#include <snappy.h>",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy.h>\n#include <stdint.h>\n#include <string>\n\ninline bool Snappy_Compress(const char* input, size_t length,\n                            ::std::string* output) {\n#ifdef SNAPPY\n  output->resize(snappy::MaxCompressedLength(length));\n  size_t outlen;\n  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n  output->resize(outlen);\n  return true;\n#endif\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "input.data",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen.Generate",
          "args": [
            "Options().block_size"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "Generate",
          "container": "RandomGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "131-138",
          "snippet": "Slice Generate(size_t len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nRandomGenerator {\n  Slice Generate(size_t len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Options",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentOptions",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "238-251",
          "snippet": "Options CurrentOptions() {\n    Options options;\n    switch (option_config_) {\n      case kFilter:\n        options.filter_policy = filter_policy_;\n        break;\n      case kUncompressed:\n        options.compression = kNoCompression;\n        break;\n      default:\n        break;\n    }\n    return options;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  Options CurrentOptions() {\n      Options options;\n      switch (option_config_) {\n        case kFilter:\n          options.filter_policy = filter_policy_;\n          break;\n        case kUncompressed:\n          options.compression = kNoCompression;\n          break;\n        default:\n          break;\n      }\n      return options;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void SnappyCompress(ThreadState* thread) {\n      RandomGenerator gen;\n      Slice input = gen.Generate(Options().block_size);\n      int64_t bytes = 0;\n      int64_t produced = 0;\n      bool ok = true;\n      std::string compressed;\n      while (ok && bytes < 1024 * 1048576) {  // Compress 1G\n        ok = port::Snappy_Compress(input.data(), input.size(), &compressed);\n        produced += compressed.size();\n        bytes += input.size();\n        thread->stats.FinishedSingleOp();\n      }\n  \n      if (!ok) {\n        thread->stats.AddMessage(\"(snappy failure)\");\n      } else {\n        char buf[100];\n        snprintf(buf, sizeof(buf), \"(output: %.1f%%)\",\n                 (produced * 100.0) / bytes);\n        thread->stats.AddMessage(buf);\n        thread->stats.AddBytes(bytes);\n      }\n    }\n}"
  },
  {
    "function_name": "AcquireLoad",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "627-641",
    "snippet": "void AcquireLoad(ThreadState* thread) {\n    int dummy;\n    port::AtomicPointer ap(&dummy);\n    int count = 0;\n    void *ptr = NULL;\n    thread->stats.AddMessage(\"(each op is 1000 loads)\");\n    while (count < 100000) {\n      for (int i = 0; i < 1000; i++) {\n        ptr = ap.Acquire_Load();\n      }\n      count++;\n      thread->stats.FinishedSingleOp();\n    }\n    if (ptr == NULL) exit(1); // Disable unused variable warning.\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ap.Acquire_Load",
          "args": [],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->stats.AddMessage",
          "args": [
            "\"(each op is 1000 loads)\""
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "AddMessage",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "205-207",
          "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void AcquireLoad(ThreadState* thread) {\n      int dummy;\n      port::AtomicPointer ap(&dummy);\n      int count = 0;\n      void *ptr = NULL;\n      thread->stats.AddMessage(\"(each op is 1000 loads)\");\n      while (count < 100000) {\n        for (int i = 0; i < 1000; i++) {\n          ptr = ap.Acquire_Load();\n        }\n        count++;\n        thread->stats.FinishedSingleOp();\n      }\n      if (ptr == NULL) exit(1); // Disable unused variable warning.\n    }\n}"
  },
  {
    "function_name": "Crc32c",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "608-625",
    "snippet": "void Crc32c(ThreadState* thread) {\n    // Checksum about 500MB of data total\n    const int size = 4096;\n    const char* label = \"(4K per op)\";\n    std::string data(size, 'x');\n    int64_t bytes = 0;\n    uint32_t crc = 0;\n    while (bytes < 500 * 1048576) {\n      crc = crc32c::Value(data.data(), size);\n      thread->stats.FinishedSingleOp();\n      bytes += size;\n    }\n    // Print so result is not dead\n    fprintf(stderr, \"... crc=0x%x\\r\", static_cast<unsigned int>(crc));\n\n    thread->stats.AddBytes(bytes);\n    thread->stats.AddMessage(label);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "thread->stats.AddMessage",
          "args": [
            "label"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "AddMessage",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "205-207",
          "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.AddBytes",
          "args": [
            "bytes"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "AddBytes",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "235-237",
          "snippet": "void AddBytes(int64_t n) {\n    bytes_ += n;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddBytes(int64_t n) {\n      bytes_ += n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"... crc=0x%x\\r\"",
            "static_cast<unsigned int>(crc)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned int>",
          "args": [
            "crc"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread->stats.FinishedSingleOp",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "209-233",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c::Value",
          "args": [
            "data.data()",
            "size"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.data",
          "args": [],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void Crc32c(ThreadState* thread) {\n      // Checksum about 500MB of data total\n      const int size = 4096;\n      const char* label = \"(4K per op)\";\n      std::string data(size, 'x');\n      int64_t bytes = 0;\n      uint32_t crc = 0;\n      while (bytes < 500 * 1048576) {\n        crc = crc32c::Value(data.data(), size);\n        thread->stats.FinishedSingleOp();\n        bytes += size;\n      }\n      // Print so result is not dead\n      fprintf(stderr, \"... crc=0x%x\\r\", static_cast<unsigned int>(crc));\n  \n      thread->stats.AddBytes(bytes);\n      thread->stats.AddMessage(label);\n    }\n}"
  },
  {
    "function_name": "RunBenchmark",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "567-606",
    "snippet": "void RunBenchmark(int n, Slice name,\n                    void (Benchmark::*method)(ThreadState*)) {\n    SharedState shared;\n    shared.total = n;\n    shared.num_initialized = 0;\n    shared.num_done = 0;\n    shared.start = false;\n\n    ThreadArg* arg = new ThreadArg[n];\n    for (int i = 0; i < n; i++) {\n      arg[i].bm = this;\n      arg[i].method = method;\n      arg[i].shared = &shared;\n      arg[i].thread = new ThreadState(i);\n      arg[i].thread->shared = &shared;\n      Env::Default()->StartThread(ThreadBody, &arg[i]);\n    }\n\n    shared.mu.Lock();\n    while (shared.num_initialized < n) {\n      shared.cv.Wait();\n    }\n\n    shared.start = true;\n    shared.cv.SignalAll();\n    while (shared.num_done < n) {\n      shared.cv.Wait();\n    }\n    shared.mu.Unlock();\n\n    for (int i = 1; i < n; i++) {\n      arg[0].thread->stats.Merge(arg[i].thread->stats);\n    }\n    arg[0].thread->stats.Report(name);\n\n    for (int i = 0; i < n; i++) {\n      delete arg[i].thread;\n    }\n    delete[] arg;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arg[0].thread->stats.Report",
          "args": [
            "name"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "Report",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "239-265",
          "snippet": "void Report(const Slice& name) {\n    // Pretend at least one op was done in case we are running a benchmark\n    // that does not call FinishedSingleOp().\n    if (done_ < 1) done_ = 1;\n\n    std::string extra;\n    if (bytes_ > 0) {\n      // Rate is computed on actual elapsed time, not the sum of per-thread\n      // elapsed times.\n      double elapsed = (finish_ - start_) * 1e-6;\n      char rate[100];\n      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n               (bytes_ / 1048576.0) / elapsed);\n      extra = rate;\n    }\n    AppendWithSpace(&extra, message_);\n\n    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n            name.ToString().c_str(),\n            seconds_ * 1e6 / done_,\n            (extra.empty() ? \"\" : \" \"),\n            extra.c_str());\n    if (FLAGS_histogram) {\n      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n    }\n    fflush(stdout);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void Report(const Slice& name) {\n      // Pretend at least one op was done in case we are running a benchmark\n      // that does not call FinishedSingleOp().\n      if (done_ < 1) done_ = 1;\n  \n      std::string extra;\n      if (bytes_ > 0) {\n        // Rate is computed on actual elapsed time, not the sum of per-thread\n        // elapsed times.\n        double elapsed = (finish_ - start_) * 1e-6;\n        char rate[100];\n        snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n                 (bytes_ / 1048576.0) / elapsed);\n        extra = rate;\n      }\n      AppendWithSpace(&extra, message_);\n  \n      fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n              name.ToString().c_str(),\n              seconds_ * 1e6 / done_,\n              (extra.empty() ? \"\" : \" \"),\n              extra.c_str());\n      if (FLAGS_histogram) {\n        fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n      }\n      fflush(stdout);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "arg[0].thread->stats.Merge",
          "args": [
            "arg[i].thread->stats"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "Merge",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "188-198",
          "snippet": "void Merge(const Stats& other) {\n    hist_.Merge(other.hist_);\n    done_ += other.done_;\n    bytes_ += other.bytes_;\n    seconds_ += other.seconds_;\n    if (other.start_ < start_) start_ = other.start_;\n    if (other.finish_ > finish_) finish_ = other.finish_;\n\n    // Just keep the messages from one thread\n    if (message_.empty()) message_ = other.message_;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Merge(const Stats& other) {\n      hist_.Merge(other.hist_);\n      done_ += other.done_;\n      bytes_ += other.bytes_;\n      seconds_ += other.seconds_;\n      if (other.start_ < start_) start_ = other.start_;\n      if (other.finish_ > finish_) finish_ = other.finish_;\n  \n      // Just keep the messages from one thread\n      if (message_.empty()) message_ = other.message_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shared.mu.Unlock",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shared.cv.Wait",
          "args": [],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shared.cv.SignalAll",
          "args": [],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "SignalAll",
          "container": "CondVar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "110-118",
          "snippet": "void CondVar::SignalAll() {\n  wait_mtx_.Lock();\n  ::ReleaseSemaphore(sem1_, waiting_, NULL);\n  while(waiting_ > 0) {\n    --waiting_;\n    ::WaitForSingleObject(sem2_, INFINITE);\n  }\n  wait_mtx_.Unlock();\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nCondVar {\n  void CondVar::SignalAll() {\n    wait_mtx_.Lock();\n    ::ReleaseSemaphore(sem1_, waiting_, NULL);\n    while(waiting_ > 0) {\n      --waiting_;\n      ::WaitForSingleObject(sem2_, INFINITE);\n    }\n    wait_mtx_.Unlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shared.mu.Lock",
          "args": [],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "ThreadBody",
            "&arg[i]"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void RunBenchmark(int n, Slice name,\n                      void (Benchmark::*method)(ThreadState*)) {\n      SharedState shared;\n      shared.total = n;\n      shared.num_initialized = 0;\n      shared.num_done = 0;\n      shared.start = false;\n  \n      ThreadArg* arg = new ThreadArg[n];\n      for (int i = 0; i < n; i++) {\n        arg[i].bm = this;\n        arg[i].method = method;\n        arg[i].shared = &shared;\n        arg[i].thread = new ThreadState(i);\n        arg[i].thread->shared = &shared;\n        Env::Default()->StartThread(ThreadBody, &arg[i]);\n      }\n  \n      shared.mu.Lock();\n      while (shared.num_initialized < n) {\n        shared.cv.Wait();\n      }\n  \n      shared.start = true;\n      shared.cv.SignalAll();\n      while (shared.num_done < n) {\n        shared.cv.Wait();\n      }\n      shared.mu.Unlock();\n  \n      for (int i = 1; i < n; i++) {\n        arg[0].thread->stats.Merge(arg[i].thread->stats);\n      }\n      arg[0].thread->stats.Report(name);\n  \n      for (int i = 0; i < n; i++) {\n        delete arg[i].thread;\n      }\n      delete[] arg;\n    }\n}"
  },
  {
    "function_name": "ThreadBody",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "539-565",
    "snippet": "static void ThreadBody(void* v) {\n    ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);\n    SharedState* shared = arg->shared;\n    ThreadState* thread = arg->thread;\n    {\n      MutexLock l(&shared->mu);\n      shared->num_initialized++;\n      if (shared->num_initialized >= shared->total) {\n        shared->cv.SignalAll();\n      }\n      while (!shared->start) {\n        shared->cv.Wait();\n      }\n    }\n\n    thread->stats.Start();\n    (arg->bm->*(arg->method))(thread);\n    thread->stats.Stop();\n\n    {\n      MutexLock l(&shared->mu);\n      shared->num_done++;\n      if (shared->num_done >= shared->total) {\n        shared->cv.SignalAll();\n      }\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shared->cv.SignalAll",
          "args": [],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "SignalAll",
          "container": "CondVar",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "110-118",
          "snippet": "void CondVar::SignalAll() {\n  wait_mtx_.Lock();\n  ::ReleaseSemaphore(sem1_, waiting_, NULL);\n  while(waiting_ > 0) {\n    --waiting_;\n    ::WaitForSingleObject(sem2_, INFINITE);\n  }\n  wait_mtx_.Unlock();\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nCondVar {\n  void CondVar::SignalAll() {\n    wait_mtx_.Lock();\n    ::ReleaseSemaphore(sem1_, waiting_, NULL);\n    while(waiting_ > 0) {\n      --waiting_;\n      ::WaitForSingleObject(sem2_, INFINITE);\n    }\n    wait_mtx_.Unlock();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.Stop",
          "args": [],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "Stop",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "200-203",
          "snippet": "void Stop() {\n    finish_ = Env::Default()->NowMicros();\n    seconds_ = (finish_ - start_) * 1e-6;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Stop() {\n      finish_ = Env::Default()->NowMicros();\n      seconds_ = (finish_ - start_) * 1e-6;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread->stats.Start",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "176-186",
          "snippet": "void Start() {\n    next_report_ = 100;\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    bytes_ = 0;\n    seconds_ = 0;\n    start_ = Env::Default()->NowMicros();\n    finish_ = start_;\n    message_.clear();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Start() {\n      next_report_ = 100;\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      bytes_ = 0;\n      seconds_ = 0;\n      start_ = Env::Default()->NowMicros();\n      finish_ = start_;\n      message_.clear();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "shared->cv.Wait",
          "args": [],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<ThreadArg*>",
          "args": [
            "v"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  static void ThreadBody(void* v) {\n      ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);\n      SharedState* shared = arg->shared;\n      ThreadState* thread = arg->thread;\n      {\n        MutexLock l(&shared->mu);\n        shared->num_initialized++;\n        if (shared->num_initialized >= shared->total) {\n          shared->cv.SignalAll();\n        }\n        while (!shared->start) {\n          shared->cv.Wait();\n        }\n      }\n  \n      thread->stats.Start();\n      (arg->bm->*(arg->method))(thread);\n      thread->stats.Stop();\n  \n      {\n        MutexLock l(&shared->mu);\n        shared->num_done++;\n        if (shared->num_done >= shared->total) {\n          shared->cv.SignalAll();\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "Run",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "418-529",
    "snippet": "void Run() {\n    PrintHeader();\n    Open();\n\n    const char* benchmarks = FLAGS_benchmarks;\n    while (benchmarks != NULL) {\n      const char* sep = strchr(benchmarks, ',');\n      Slice name;\n      if (sep == NULL) {\n        name = benchmarks;\n        benchmarks = NULL;\n      } else {\n        name = Slice(benchmarks, sep - benchmarks);\n        benchmarks = sep + 1;\n      }\n\n      // Reset parameters that may be overriddden bwlow\n      num_ = FLAGS_num;\n      reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);\n      value_size_ = FLAGS_value_size;\n      entries_per_batch_ = 1;\n      write_options_ = WriteOptions();\n\n      void (Benchmark::*method)(ThreadState*) = NULL;\n      bool fresh_db = false;\n      int num_threads = FLAGS_threads;\n\n      if (name == Slice(\"fillseq\")) {\n        fresh_db = true;\n        method = &Benchmark::WriteSeq;\n      } else if (name == Slice(\"fillbatch\")) {\n        fresh_db = true;\n        entries_per_batch_ = 1000;\n        method = &Benchmark::WriteSeq;\n      } else if (name == Slice(\"fillrandom\")) {\n        fresh_db = true;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"overwrite\")) {\n        fresh_db = false;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"fillsync\")) {\n        fresh_db = true;\n        num_ /= 1000;\n        write_options_.sync = true;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"fill100K\")) {\n        fresh_db = true;\n        num_ /= 1000;\n        value_size_ = 100 * 1000;\n        method = &Benchmark::WriteRandom;\n      } else if (name == Slice(\"readseq\")) {\n        method = &Benchmark::ReadSequential;\n      } else if (name == Slice(\"readreverse\")) {\n        method = &Benchmark::ReadReverse;\n      } else if (name == Slice(\"readrandom\")) {\n        method = &Benchmark::ReadRandom;\n      } else if (name == Slice(\"readmissing\")) {\n        method = &Benchmark::ReadMissing;\n      } else if (name == Slice(\"seekrandom\")) {\n        method = &Benchmark::SeekRandom;\n      } else if (name == Slice(\"readhot\")) {\n        method = &Benchmark::ReadHot;\n      } else if (name == Slice(\"readrandomsmall\")) {\n        reads_ /= 1000;\n        method = &Benchmark::ReadRandom;\n      } else if (name == Slice(\"deleteseq\")) {\n        method = &Benchmark::DeleteSeq;\n      } else if (name == Slice(\"deleterandom\")) {\n        method = &Benchmark::DeleteRandom;\n      } else if (name == Slice(\"readwhilewriting\")) {\n        num_threads++;  // Add extra thread for writing\n        method = &Benchmark::ReadWhileWriting;\n      } else if (name == Slice(\"compact\")) {\n        method = &Benchmark::Compact;\n      } else if (name == Slice(\"crc32c\")) {\n        method = &Benchmark::Crc32c;\n      } else if (name == Slice(\"acquireload\")) {\n        method = &Benchmark::AcquireLoad;\n      } else if (name == Slice(\"snappycomp\")) {\n        method = &Benchmark::SnappyCompress;\n      } else if (name == Slice(\"snappyuncomp\")) {\n        method = &Benchmark::SnappyUncompress;\n      } else if (name == Slice(\"heapprofile\")) {\n        HeapProfile();\n      } else if (name == Slice(\"stats\")) {\n        PrintStats(\"leveldb.stats\");\n      } else if (name == Slice(\"sstables\")) {\n        PrintStats(\"leveldb.sstables\");\n      } else {\n        if (name != Slice()) {  // No error message for empty name\n          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n        }\n      }\n\n      if (fresh_db) {\n        if (FLAGS_use_existing_db) {\n          fprintf(stdout, \"%-12s : skipped (--use_existing_db is true)\\n\",\n                  name.ToString().c_str());\n          method = NULL;\n        } else {\n          delete db_;\n          db_ = NULL;\n          DestroyDB(FLAGS_db, Options());\n          Open();\n        }\n      }\n\n      if (method != NULL) {\n        RunBenchmark(num_threads, name, method);\n      }\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readrandom,\"  // Extra run to allow previous compactions to quiesce\n    \"readseq,\"\n    \"readreverse,\"\n    \"compact,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"readreverse,\"\n    \"fill100K,\"\n    \"crc32c,\"\n    \"snappycomp,\"\n    \"snappyuncomp,\"\n    \"acquireload,\"\n    ;",
      "static int FLAGS_num = 1000000;",
      "static int FLAGS_reads = -1;",
      "static int FLAGS_threads = 1;",
      "static int FLAGS_value_size = 100;",
      "static bool FLAGS_use_existing_db = false;",
      "static const char* FLAGS_db = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RunBenchmark",
          "args": [
            "num_threads",
            "name",
            "method"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "RunBenchmark",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "567-606",
          "snippet": "void RunBenchmark(int n, Slice name,\n                    void (Benchmark::*method)(ThreadState*)) {\n    SharedState shared;\n    shared.total = n;\n    shared.num_initialized = 0;\n    shared.num_done = 0;\n    shared.start = false;\n\n    ThreadArg* arg = new ThreadArg[n];\n    for (int i = 0; i < n; i++) {\n      arg[i].bm = this;\n      arg[i].method = method;\n      arg[i].shared = &shared;\n      arg[i].thread = new ThreadState(i);\n      arg[i].thread->shared = &shared;\n      Env::Default()->StartThread(ThreadBody, &arg[i]);\n    }\n\n    shared.mu.Lock();\n    while (shared.num_initialized < n) {\n      shared.cv.Wait();\n    }\n\n    shared.start = true;\n    shared.cv.SignalAll();\n    while (shared.num_done < n) {\n      shared.cv.Wait();\n    }\n    shared.mu.Unlock();\n\n    for (int i = 1; i < n; i++) {\n      arg[0].thread->stats.Merge(arg[i].thread->stats);\n    }\n    arg[0].thread->stats.Report(name);\n\n    for (int i = 0; i < n; i++) {\n      delete arg[i].thread;\n    }\n    delete[] arg;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void RunBenchmark(int n, Slice name,\n                      void (Benchmark::*method)(ThreadState*)) {\n      SharedState shared;\n      shared.total = n;\n      shared.num_initialized = 0;\n      shared.num_done = 0;\n      shared.start = false;\n  \n      ThreadArg* arg = new ThreadArg[n];\n      for (int i = 0; i < n; i++) {\n        arg[i].bm = this;\n        arg[i].method = method;\n        arg[i].shared = &shared;\n        arg[i].thread = new ThreadState(i);\n        arg[i].thread->shared = &shared;\n        Env::Default()->StartThread(ThreadBody, &arg[i]);\n      }\n  \n      shared.mu.Lock();\n      while (shared.num_initialized < n) {\n        shared.cv.Wait();\n      }\n  \n      shared.start = true;\n      shared.cv.SignalAll();\n      while (shared.num_done < n) {\n        shared.cv.Wait();\n      }\n      shared.mu.Unlock();\n  \n      for (int i = 1; i < n; i++) {\n        arg[0].thread->stats.Merge(arg[i].thread->stats);\n      }\n      arg[0].thread->stats.Report(name);\n  \n      for (int i = 0; i < n; i++) {\n        delete arg[i].thread;\n      }\n      delete[] arg;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Open",
          "args": [],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "690-703",
          "snippet": "void Open() {\n    assert(db_ == NULL);\n    Options options;\n    options.create_if_missing = !FLAGS_use_existing_db;\n    options.block_cache = cache_;\n    options.write_buffer_size = FLAGS_write_buffer_size;\n    options.max_open_files = FLAGS_open_files;\n    options.filter_policy = filter_policy_;\n    Status s = DB::Open(options, FLAGS_db, &db_);\n    if (!s.ok()) {\n      fprintf(stderr, \"open error: %s\\n\", s.ToString().c_str());\n      exit(1);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_write_buffer_size = 0;",
            "static int FLAGS_open_files = 0;",
            "static bool FLAGS_use_existing_db = false;",
            "static const char* FLAGS_db = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_write_buffer_size = 0;\nstatic int FLAGS_open_files = 0;\nstatic bool FLAGS_use_existing_db = false;\nstatic const char* FLAGS_db = NULL;\n\nBenchmark {\n  void Open() {\n      assert(db_ == NULL);\n      Options options;\n      options.create_if_missing = !FLAGS_use_existing_db;\n      options.block_cache = cache_;\n      options.write_buffer_size = FLAGS_write_buffer_size;\n      options.max_open_files = FLAGS_open_files;\n      options.filter_policy = filter_policy_;\n      Status s = DB::Open(options, FLAGS_db, &db_);\n      if (!s.ok()) {\n        fprintf(stderr, \"open error: %s\\n\", s.ToString().c_str());\n        exit(1);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DestroyDB",
          "args": [
            "FLAGS_db",
            "Options()"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "DestroyDB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1482-1511",
          "snippet": "Status DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nStatus DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Options",
          "args": [],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentOptions",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "238-251",
          "snippet": "Options CurrentOptions() {\n    Options options;\n    switch (option_config_) {\n      case kFilter:\n        options.filter_policy = filter_policy_;\n        break;\n      case kUncompressed:\n        options.compression = kNoCompression;\n        break;\n      default:\n        break;\n    }\n    return options;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  Options CurrentOptions() {\n      Options options;\n      switch (option_config_) {\n        case kFilter:\n          options.filter_policy = filter_policy_;\n          break;\n        case kUncompressed:\n          options.compression = kNoCompression;\n          break;\n        default:\n          break;\n      }\n      return options;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%-12s : skipped (--use_existing_db is true)\\n\"",
            "name.ToString().c_str()"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.ToString",
          "args": [],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unknown benchmark '%s'\\n\"",
            "name.ToString().c_str()"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "66-66",
          "snippet": "std::string ToString() const { return std::string(data_, size_); }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  std::string ToString() const { return std::string(data_, size_); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintStats",
          "args": [
            "\"leveldb.sstables\""
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "PrintStats",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "894-900",
          "snippet": "void PrintStats(const char* key) {\n    std::string stats;\n    if (!db_->GetProperty(key, &stats)) {\n      stats = \"(failed)\";\n    }\n    fprintf(stdout, \"\\n%s\\n\", stats.c_str());\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void PrintStats(const char* key) {\n      std::string stats;\n      if (!db_->GetProperty(key, &stats)) {\n        stats = \"(failed)\";\n      }\n      fprintf(stdout, \"\\n%s\\n\", stats.c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"sstables\""
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HeapProfile",
          "args": [],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "HeapProfile",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "906-921",
          "snippet": "void HeapProfile() {\n    char fname[100];\n    snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n    WritableFile* file;\n    Status s = Env::Default()->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n      return;\n    }\n    bool ok = port::GetHeapProfile(WriteToFile, file);\n    delete file;\n    if (!ok) {\n      fprintf(stderr, \"heap profiling not supported\\n\");\n      Env::Default()->DeleteFile(fname);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* FLAGS_db = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic const char* FLAGS_db = NULL;\n\nBenchmark {\n  void HeapProfile() {\n      char fname[100];\n      snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n      WritableFile* file;\n      Status s = Env::Default()->NewWritableFile(fname, &file);\n      if (!s.ok()) {\n        fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n        return;\n      }\n      bool ok = port::GetHeapProfile(WriteToFile, file);\n      delete file;\n      if (!ok) {\n        fprintf(stderr, \"heap profiling not supported\\n\");\n        Env::Default()->DeleteFile(fname);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "benchmarks",
            "','"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintHeader",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "PrintHeader",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "314-330",
          "snippet": "void PrintHeader() {\n    const int kKeySize = 16;\n    PrintEnvironment();\n    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n    fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n            FLAGS_value_size,\n            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n    fprintf(stdout, \"Entries:    %d\\n\", num_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0));\n    fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n             / 1048576.0));\n    PrintWarnings();\n    fprintf(stdout, \"------------------------------------------------\\n\");\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_value_size = 100;",
            "static double FLAGS_compression_ratio = 0.5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_value_size = 100;\nstatic double FLAGS_compression_ratio = 0.5;\n\nBenchmark {\n  void PrintHeader() {\n      const int kKeySize = 16;\n      PrintEnvironment();\n      fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n      fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n              FLAGS_value_size,\n              static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n      fprintf(stdout, \"Entries:    %d\\n\", num_);\n      fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n              ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n               / 1048576.0));\n      fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n              (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n               / 1048576.0));\n      PrintWarnings();\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readrandom,\"  // Extra run to allow previous compactions to quiesce\n    \"readseq,\"\n    \"readreverse,\"\n    \"compact,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"readreverse,\"\n    \"fill100K,\"\n    \"crc32c,\"\n    \"snappycomp,\"\n    \"snappyuncomp,\"\n    \"acquireload,\"\n    ;\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic int FLAGS_threads = 1;\nstatic int FLAGS_value_size = 100;\nstatic bool FLAGS_use_existing_db = false;\nstatic const char* FLAGS_db = NULL;\n\nBenchmark {\n  void Run() {\n      PrintHeader();\n      Open();\n  \n      const char* benchmarks = FLAGS_benchmarks;\n      while (benchmarks != NULL) {\n        const char* sep = strchr(benchmarks, ',');\n        Slice name;\n        if (sep == NULL) {\n          name = benchmarks;\n          benchmarks = NULL;\n        } else {\n          name = Slice(benchmarks, sep - benchmarks);\n          benchmarks = sep + 1;\n        }\n  \n        // Reset parameters that may be overriddden bwlow\n        num_ = FLAGS_num;\n        reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);\n        value_size_ = FLAGS_value_size;\n        entries_per_batch_ = 1;\n        write_options_ = WriteOptions();\n  \n        void (Benchmark::*method)(ThreadState*) = NULL;\n        bool fresh_db = false;\n        int num_threads = FLAGS_threads;\n  \n        if (name == Slice(\"fillseq\")) {\n          fresh_db = true;\n          method = &Benchmark::WriteSeq;\n        } else if (name == Slice(\"fillbatch\")) {\n          fresh_db = true;\n          entries_per_batch_ = 1000;\n          method = &Benchmark::WriteSeq;\n        } else if (name == Slice(\"fillrandom\")) {\n          fresh_db = true;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"overwrite\")) {\n          fresh_db = false;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"fillsync\")) {\n          fresh_db = true;\n          num_ /= 1000;\n          write_options_.sync = true;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"fill100K\")) {\n          fresh_db = true;\n          num_ /= 1000;\n          value_size_ = 100 * 1000;\n          method = &Benchmark::WriteRandom;\n        } else if (name == Slice(\"readseq\")) {\n          method = &Benchmark::ReadSequential;\n        } else if (name == Slice(\"readreverse\")) {\n          method = &Benchmark::ReadReverse;\n        } else if (name == Slice(\"readrandom\")) {\n          method = &Benchmark::ReadRandom;\n        } else if (name == Slice(\"readmissing\")) {\n          method = &Benchmark::ReadMissing;\n        } else if (name == Slice(\"seekrandom\")) {\n          method = &Benchmark::SeekRandom;\n        } else if (name == Slice(\"readhot\")) {\n          method = &Benchmark::ReadHot;\n        } else if (name == Slice(\"readrandomsmall\")) {\n          reads_ /= 1000;\n          method = &Benchmark::ReadRandom;\n        } else if (name == Slice(\"deleteseq\")) {\n          method = &Benchmark::DeleteSeq;\n        } else if (name == Slice(\"deleterandom\")) {\n          method = &Benchmark::DeleteRandom;\n        } else if (name == Slice(\"readwhilewriting\")) {\n          num_threads++;  // Add extra thread for writing\n          method = &Benchmark::ReadWhileWriting;\n        } else if (name == Slice(\"compact\")) {\n          method = &Benchmark::Compact;\n        } else if (name == Slice(\"crc32c\")) {\n          method = &Benchmark::Crc32c;\n        } else if (name == Slice(\"acquireload\")) {\n          method = &Benchmark::AcquireLoad;\n        } else if (name == Slice(\"snappycomp\")) {\n          method = &Benchmark::SnappyCompress;\n        } else if (name == Slice(\"snappyuncomp\")) {\n          method = &Benchmark::SnappyUncompress;\n        } else if (name == Slice(\"heapprofile\")) {\n          HeapProfile();\n        } else if (name == Slice(\"stats\")) {\n          PrintStats(\"leveldb.stats\");\n        } else if (name == Slice(\"sstables\")) {\n          PrintStats(\"leveldb.sstables\");\n        } else {\n          if (name != Slice()) {  // No error message for empty name\n            fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n          }\n        }\n  \n        if (fresh_db) {\n          if (FLAGS_use_existing_db) {\n            fprintf(stdout, \"%-12s : skipped (--use_existing_db is true)\\n\",\n                    name.ToString().c_str());\n            method = NULL;\n          } else {\n            delete db_;\n            db_ = NULL;\n            DestroyDB(FLAGS_db, Options());\n            Open();\n          }\n        }\n  \n        if (method != NULL) {\n          RunBenchmark(num_threads, name, method);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "Benchmark",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "389-410",
    "snippet": "Benchmark()\n  : cache_(FLAGS_cache_size >= 0 ? NewLRUCache(FLAGS_cache_size) : NULL),\n    filter_policy_(FLAGS_bloom_bits >= 0\n                   ? NewBloomFilterPolicy(FLAGS_bloom_bits)\n                   : NULL),\n    db_(NULL),\n    num_(FLAGS_num),\n    value_size_(FLAGS_value_size),\n    entries_per_batch_(1),\n    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n    heap_counter_(0) {\n    std::vector<std::string> files;\n    Env::Default()->GetChildren(FLAGS_db, &files);\n    for (size_t i = 0; i < files.size(); i++) {\n      if (Slice(files[i]).starts_with(\"heap-\")) {\n        Env::Default()->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n      }\n    }\n    if (!FLAGS_use_existing_db) {\n      DestroyDB(FLAGS_db, Options());\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;",
      "static int FLAGS_reads = -1;",
      "static int FLAGS_value_size = 100;",
      "static int FLAGS_cache_size = -1;",
      "static int FLAGS_bloom_bits = -1;",
      "static bool FLAGS_use_existing_db = false;",
      "static const char* FLAGS_db = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DestroyDB",
          "args": [
            "FLAGS_db",
            "Options()"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "DestroyDB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1482-1511",
          "snippet": "Status DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nStatus DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Options",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentOptions",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "238-251",
          "snippet": "Options CurrentOptions() {\n    Options options;\n    switch (option_config_) {\n      case kFilter:\n        options.filter_policy = filter_policy_;\n        break;\n      case kUncompressed:\n        options.compression = kNoCompression;\n        break;\n      default:\n        break;\n    }\n    return options;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  Options CurrentOptions() {\n      Options options;\n      switch (option_config_) {\n        case kFilter:\n          options.filter_policy = filter_policy_;\n          break;\n        case kUncompressed:\n          options.compression = kNoCompression;\n          break;\n        default:\n          break;\n      }\n      return options;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "std::string(FLAGS_db) + \"/\" + files[i]"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "FLAGS_db"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"heap-\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "FLAGS_db",
            "&files"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewBloomFilterPolicy",
          "args": [
            "FLAGS_bloom_bits"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewLRUCache",
          "args": [
            "FLAGS_cache_size"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic int FLAGS_value_size = 100;\nstatic int FLAGS_cache_size = -1;\nstatic int FLAGS_bloom_bits = -1;\nstatic bool FLAGS_use_existing_db = false;\nstatic const char* FLAGS_db = NULL;\n\nBenchmark {\n  Benchmark()\n    : cache_(FLAGS_cache_size >= 0 ? NewLRUCache(FLAGS_cache_size) : NULL),\n      filter_policy_(FLAGS_bloom_bits >= 0\n                     ? NewBloomFilterPolicy(FLAGS_bloom_bits)\n                     : NULL),\n      db_(NULL),\n      num_(FLAGS_num),\n      value_size_(FLAGS_value_size),\n      entries_per_batch_(1),\n      reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n      heap_counter_(0) {\n      std::vector<std::string> files;\n      Env::Default()->GetChildren(FLAGS_db, &files);\n      for (size_t i = 0; i < files.size(); i++) {\n        if (Slice(files[i]).starts_with(\"heap-\")) {\n          Env::Default()->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n        }\n      }\n      if (!FLAGS_use_existing_db) {\n        DestroyDB(FLAGS_db, Options());\n      }\n    }\n}"
  },
  {
    "function_name": "PrintEnvironment",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "353-386",
    "snippet": "void PrintEnvironment() {\n    fprintf(stderr, \"LevelDB:    version %d.%d\\n\",\n            kMajorVersion, kMinorVersion);\n\n#if defined(__linux)\n    time_t now = time(NULL);\n    fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n\n    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n    if (cpuinfo != NULL) {\n      char line[1000];\n      int num_cpus = 0;\n      std::string cpu_type;\n      std::string cache_size;\n      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        const char* sep = strchr(line, ':');\n        if (sep == NULL) {\n          continue;\n        }\n        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n        Slice val = TrimSpace(Slice(sep + 1));\n        if (key == \"model name\") {\n          ++num_cpus;\n          cpu_type = val.ToString();\n        } else if (key == \"cache size\") {\n          cache_size = val.ToString();\n        }\n      }\n      fclose(cpuinfo);\n      fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n      fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n    }\n#endif\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CPUCache:   %s\\n\"",
            "cache_size.c_str()"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_size.c_str",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CPU:        %d * %s\\n\"",
            "num_cpus",
            "cpu_type.c_str()"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_type.c_str",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "cpuinfo"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val.ToString",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TrimSpace",
          "args": [
            "Slice(sep + 1)"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "TrimSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "141-151",
          "snippet": "static Slice TrimSpace(Slice s) {\n  size_t start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  size_t limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic Slice TrimSpace(Slice s) {\n  size_t start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  size_t limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "sep + 1"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "cpuinfo"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/cpuinfo\"",
            "\"r\""
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Date:       %s\"",
            "ctime(&now)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&now"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "pt_to_time_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "38-43",
          "snippet": "std::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"LevelDB:    version %d.%d\\n\"",
            "kMajorVersion",
            "kMinorVersion"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void PrintEnvironment() {\n      fprintf(stderr, \"LevelDB:    version %d.%d\\n\",\n              kMajorVersion, kMinorVersion);\n  \n  #if defined(__linux)\n      time_t now = time(NULL);\n      fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n  \n      FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n      if (cpuinfo != NULL) {\n        char line[1000];\n        int num_cpus = 0;\n        std::string cpu_type;\n        std::string cache_size;\n        while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n          const char* sep = strchr(line, ':');\n          if (sep == NULL) {\n            continue;\n          }\n          Slice key = TrimSpace(Slice(line, sep - 1 - line));\n          Slice val = TrimSpace(Slice(sep + 1));\n          if (key == \"model name\") {\n            ++num_cpus;\n            cpu_type = val.ToString();\n          } else if (key == \"cache size\") {\n            cache_size = val.ToString();\n          }\n        }\n        fclose(cpuinfo);\n        fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n        fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n      }\n  #endif\n    }\n}"
  },
  {
    "function_name": "PrintWarnings",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "332-351",
    "snippet": "void PrintWarnings() {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n    fprintf(stdout,\n            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n            );\n#endif\n#ifndef NDEBUG\n    fprintf(stdout,\n            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n\n    // See if snappy is working by attempting to compress a compressible string\n    const char text[] = \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";\n    std::string compressed;\n    if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {\n      fprintf(stdout, \"WARNING: Snappy compression is not enabled\\n\");\n    } else if (compressed.size() >= sizeof(text)) {\n      fprintf(stdout, \"WARNING: Snappy compression is not effective\\n\");\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Snappy compression is not effective\\n\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compressed.size",
          "args": [],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Snappy compression is not enabled\\n\""
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port::Snappy_Compress",
          "args": [
            "text",
            "sizeof(text)",
            "&compressed"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "Snappy_Compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.h",
          "lines": "136-147",
          "snippet": "inline bool Snappy_Compress(const char* input, size_t length,\n                            ::std::string* output) {\n#ifdef SNAPPY\n  output->resize(snappy::MaxCompressedLength(length));\n  size_t outlen;\n  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n  output->resize(outlen);\n  return true;\n#endif\n\n  return false;\n}",
          "includes": [
            "#include <snappy.h>",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy.h>\n#include <stdint.h>\n#include <string>\n\ninline bool Snappy_Compress(const char* input, size_t length,\n                            ::std::string* output) {\n#ifdef SNAPPY\n  output->resize(snappy::MaxCompressedLength(length));\n  size_t outlen;\n  snappy::RawCompress(input, length, &(*output)[0], &outlen);\n  output->resize(outlen);\n  return true;\n#endif\n\n  return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void PrintWarnings() {\n  #if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(stdout,\n              \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n              );\n  #endif\n  #ifndef NDEBUG\n      fprintf(stdout,\n              \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n  #endif\n  \n      // See if snappy is working by attempting to compress a compressible string\n      const char text[] = \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";\n      std::string compressed;\n      if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {\n        fprintf(stdout, \"WARNING: Snappy compression is not enabled\\n\");\n      } else if (compressed.size() >= sizeof(text)) {\n        fprintf(stdout, \"WARNING: Snappy compression is not effective\\n\");\n      }\n    }\n}"
  },
  {
    "function_name": "PrintHeader",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "314-330",
    "snippet": "void PrintHeader() {\n    const int kKeySize = 16;\n    PrintEnvironment();\n    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n    fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n            FLAGS_value_size,\n            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n    fprintf(stdout, \"Entries:    %d\\n\", num_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0));\n    fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n             / 1048576.0));\n    PrintWarnings();\n    fprintf(stdout, \"------------------------------------------------\\n\");\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_value_size = 100;",
      "static double FLAGS_compression_ratio = 0.5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"------------------------------------------------\\n\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintWarnings",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "PrintWarnings",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "332-351",
          "snippet": "void PrintWarnings() {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n    fprintf(stdout,\n            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n            );\n#endif\n#ifndef NDEBUG\n    fprintf(stdout,\n            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n\n    // See if snappy is working by attempting to compress a compressible string\n    const char text[] = \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";\n    std::string compressed;\n    if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {\n      fprintf(stdout, \"WARNING: Snappy compression is not enabled\\n\");\n    } else if (compressed.size() >= sizeof(text)) {\n      fprintf(stdout, \"WARNING: Snappy compression is not effective\\n\");\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void PrintWarnings() {\n  #if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(stdout,\n              \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n              );\n  #endif\n  #ifndef NDEBUG\n      fprintf(stdout,\n              \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n  #endif\n  \n      // See if snappy is working by attempting to compress a compressible string\n      const char text[] = \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";\n      std::string compressed;\n      if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {\n        fprintf(stdout, \"WARNING: Snappy compression is not enabled\\n\");\n      } else if (compressed.size() >= sizeof(text)) {\n        fprintf(stdout, \"WARNING: Snappy compression is not effective\\n\");\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"FileSize:   %.1f MB (estimated)\\n\"",
            "(((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n             / 1048576.0)"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"RawSize:    %.1f MB (estimated)\\n\"",
            "((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0)"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int64_t>",
          "args": [
            "kKeySize + FLAGS_value_size"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Entries:    %d\\n\"",
            "num_"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Values:     %d bytes each (%d bytes after compression)\\n\"",
            "FLAGS_value_size",
            "static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5)"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "FLAGS_value_size * FLAGS_compression_ratio + 0.5"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Keys:       %d bytes each\\n\"",
            "kKeySize"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintEnvironment",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "PrintEnvironment",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "353-386",
          "snippet": "void PrintEnvironment() {\n    fprintf(stderr, \"LevelDB:    version %d.%d\\n\",\n            kMajorVersion, kMinorVersion);\n\n#if defined(__linux)\n    time_t now = time(NULL);\n    fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n\n    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n    if (cpuinfo != NULL) {\n      char line[1000];\n      int num_cpus = 0;\n      std::string cpu_type;\n      std::string cache_size;\n      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        const char* sep = strchr(line, ':');\n        if (sep == NULL) {\n          continue;\n        }\n        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n        Slice val = TrimSpace(Slice(sep + 1));\n        if (key == \"model name\") {\n          ++num_cpus;\n          cpu_type = val.ToString();\n        } else if (key == \"cache size\") {\n          cache_size = val.ToString();\n        }\n      }\n      fclose(cpuinfo);\n      fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n      fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n    }\n#endif\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nBenchmark {\n  void PrintEnvironment() {\n      fprintf(stderr, \"LevelDB:    version %d.%d\\n\",\n              kMajorVersion, kMinorVersion);\n  \n  #if defined(__linux)\n      time_t now = time(NULL);\n      fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n  \n      FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n      if (cpuinfo != NULL) {\n        char line[1000];\n        int num_cpus = 0;\n        std::string cpu_type;\n        std::string cache_size;\n        while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n          const char* sep = strchr(line, ':');\n          if (sep == NULL) {\n            continue;\n          }\n          Slice key = TrimSpace(Slice(line, sep - 1 - line));\n          Slice val = TrimSpace(Slice(sep + 1));\n          if (key == \"model name\") {\n            ++num_cpus;\n            cpu_type = val.ToString();\n          } else if (key == \"cache size\") {\n            cache_size = val.ToString();\n          }\n        }\n        fclose(cpuinfo);\n        fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n        fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n      }\n  #endif\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic int FLAGS_value_size = 100;\nstatic double FLAGS_compression_ratio = 0.5;\n\nBenchmark {\n  void PrintHeader() {\n      const int kKeySize = 16;\n      PrintEnvironment();\n      fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n      fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n              FLAGS_value_size,\n              static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n      fprintf(stdout, \"Entries:    %d\\n\", num_);\n      fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n              ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n               / 1048576.0));\n      fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n              (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n               / 1048576.0));\n      PrintWarnings();\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n}"
  },
  {
    "function_name": "ThreadState",
    "container": "ThreadState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "294-297",
    "snippet": "ThreadState(int index)\n      : tid(index),\n        rand(1000 + index) {\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nThreadState {\n  ThreadState(int index)\n        : tid(index),\n          rand(1000 + index) {\n    }\n}"
  },
  {
    "function_name": "SharedState",
    "container": "SharedState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "284-284",
    "snippet": "SharedState() : cv(&mu) { }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nSharedState {\n  SharedState() : cv(&mu) { }\n}"
  },
  {
    "function_name": "Report",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "239-265",
    "snippet": "void Report(const Slice& name) {\n    // Pretend at least one op was done in case we are running a benchmark\n    // that does not call FinishedSingleOp().\n    if (done_ < 1) done_ = 1;\n\n    std::string extra;\n    if (bytes_ > 0) {\n      // Rate is computed on actual elapsed time, not the sum of per-thread\n      // elapsed times.\n      double elapsed = (finish_ - start_) * 1e-6;\n      char rate[100];\n      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n               (bytes_ / 1048576.0) / elapsed);\n      extra = rate;\n    }\n    AppendWithSpace(&extra, message_);\n\n    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n            name.ToString().c_str(),\n            seconds_ * 1e6 / done_,\n            (extra.empty() ? \"\" : \" \"),\n            extra.c_str());\n    if (FLAGS_histogram) {\n      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n    }\n    fflush(stdout);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_histogram = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Microseconds per op:\\n%s\\n\"",
            "hist_.ToString().c_str()"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_.ToString",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%-12s : %11.3f micros/op;%s%s\\n\"",
            "name.ToString().c_str()",
            "seconds_ * 1e6 / done_",
            "(extra.empty() ? \"\" : \" \")",
            "extra.c_str()"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extra.c_str",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extra.empty",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppendWithSpace",
          "args": [
            "&extra",
            "message_"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "AppendWithSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "153-159",
          "snippet": "static void AppendWithSpace(std::string* str, Slice msg) {\n  if (msg.empty()) return;\n  if (!str->empty()) {\n    str->push_back(' ');\n  }\n  str->append(msg.data(), msg.size());\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic void AppendWithSpace(std::string* str, Slice msg) {\n  if (msg.empty()) return;\n  if (!str->empty()) {\n    str->push_back(' ');\n  }\n  str->append(msg.data(), msg.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "rate",
            "sizeof(rate)",
            "\"%6.1f MB/s\"",
            "(bytes_ / 1048576.0) / elapsed"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void Report(const Slice& name) {\n      // Pretend at least one op was done in case we are running a benchmark\n      // that does not call FinishedSingleOp().\n      if (done_ < 1) done_ = 1;\n  \n      std::string extra;\n      if (bytes_ > 0) {\n        // Rate is computed on actual elapsed time, not the sum of per-thread\n        // elapsed times.\n        double elapsed = (finish_ - start_) * 1e-6;\n        char rate[100];\n        snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n                 (bytes_ / 1048576.0) / elapsed);\n        extra = rate;\n      }\n      AppendWithSpace(&extra, message_);\n  \n      fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n              name.ToString().c_str(),\n              seconds_ * 1e6 / done_,\n              (extra.empty() ? \"\" : \" \"),\n              extra.c_str());\n      if (FLAGS_histogram) {\n        fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n      }\n      fflush(stdout);\n    }\n}"
  },
  {
    "function_name": "AddBytes",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "235-237",
    "snippet": "void AddBytes(int64_t n) {\n    bytes_ += n;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddBytes(int64_t n) {\n      bytes_ += n;\n    }\n}"
  },
  {
    "function_name": "FinishedSingleOp",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "209-233",
    "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros();\n      double micros = now - last_op_finish_;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_histogram = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"... finished %d ops%30s\\r\"",
            "done_",
            "\"\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"long op: %.1f micros%30s\\r\"",
            "micros",
            "\"\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_.Add",
          "args": [
            "micros"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "DBImpl::CompactionStats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.h",
          "lines": "185-189",
          "snippet": "void Add(const CompactionStats& c) {\n      this->micros += c.micros;\n      this->bytes_read += c.bytes_read;\n      this->bytes_written += c.bytes_written;\n    }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/snapshot.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/dbformat.h\"",
            "#include <set>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/snapshot.h\"\n#include \"db/log_writer.h\"\n#include \"db/dbformat.h\"\n#include <set>\n#include <deque>\n\nDBImpl {\n  CompactionStats {\n    void Add(const CompactionStats& c) {\n          this->micros += c.micros;\n          this->bytes_read += c.bytes_read;\n          this->bytes_written += c.bytes_written;\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic bool FLAGS_histogram = false;\n\nStats {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros();\n        double micros = now - last_op_finish_;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
  },
  {
    "function_name": "AddMessage",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "205-207",
    "snippet": "void AddMessage(Slice msg) {\n    AppendWithSpace(&message_, msg);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AppendWithSpace",
          "args": [
            "&message_",
            "msg"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "AppendWithSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "153-159",
          "snippet": "static void AppendWithSpace(std::string* str, Slice msg) {\n  if (msg.empty()) return;\n  if (!str->empty()) {\n    str->push_back(' ');\n  }\n  str->append(msg.data(), msg.size());\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic void AppendWithSpace(std::string* str, Slice msg) {\n  if (msg.empty()) return;\n  if (!str->empty()) {\n    str->push_back(' ');\n  }\n  str->append(msg.data(), msg.size());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void AddMessage(Slice msg) {\n      AppendWithSpace(&message_, msg);\n    }\n}"
  },
  {
    "function_name": "Stop",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "200-203",
    "snippet": "void Stop() {\n    finish_ = Env::Default()->NowMicros();\n    seconds_ = (finish_ - start_) * 1e-6;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Stop() {\n      finish_ = Env::Default()->NowMicros();\n      seconds_ = (finish_ - start_) * 1e-6;\n    }\n}"
  },
  {
    "function_name": "Merge",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "188-198",
    "snippet": "void Merge(const Stats& other) {\n    hist_.Merge(other.hist_);\n    done_ += other.done_;\n    bytes_ += other.bytes_;\n    seconds_ += other.seconds_;\n    if (other.start_ < start_) start_ = other.start_;\n    if (other.finish_ > finish_) finish_ = other.finish_;\n\n    // Just keep the messages from one thread\n    if (message_.empty()) message_ = other.message_;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message_.empty",
          "args": [],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_.Merge",
          "args": [
            "other.hist_"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "Merge",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "188-198",
          "snippet": "void Merge(const Stats& other) {\n    hist_.Merge(other.hist_);\n    done_ += other.done_;\n    bytes_ += other.bytes_;\n    seconds_ += other.seconds_;\n    if (other.start_ < start_) start_ = other.start_;\n    if (other.finish_ > finish_) finish_ = other.finish_;\n\n    // Just keep the messages from one thread\n    if (message_.empty()) message_ = other.message_;\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Merge(const Stats& other) {\n      hist_.Merge(other.hist_);\n      done_ += other.done_;\n      bytes_ += other.bytes_;\n      seconds_ += other.seconds_;\n      if (other.start_ < start_) start_ = other.start_;\n      if (other.finish_ > finish_) finish_ = other.finish_;\n  \n      // Just keep the messages from one thread\n      if (message_.empty()) message_ = other.message_;\n    }\n}"
  },
  {
    "function_name": "Start",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "176-186",
    "snippet": "void Start() {\n    next_report_ = 100;\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    bytes_ = 0;\n    seconds_ = 0;\n    start_ = Env::Default()->NowMicros();\n    finish_ = start_;\n    message_.clear();\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "message_.clear",
          "args": [],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_.Clear",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Start() {\n      next_report_ = 100;\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      bytes_ = 0;\n      seconds_ = 0;\n      start_ = Env::Default()->NowMicros();\n      finish_ = start_;\n      message_.clear();\n    }\n}"
  },
  {
    "function_name": "Stats",
    "container": "Stats",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "174-174",
    "snippet": "Stats() { Start(); }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Start",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "Stats",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
          "lines": "176-186",
          "snippet": "void Start() {\n    next_report_ = 100;\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    bytes_ = 0;\n    seconds_ = 0;\n    start_ = Env::Default()->NowMicros();\n    finish_ = start_;\n    message_.clear();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/histogram.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/db_impl.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <sys/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  void Start() {\n      next_report_ = 100;\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      bytes_ = 0;\n      seconds_ = 0;\n      start_ = Env::Default()->NowMicros();\n      finish_ = start_;\n      message_.clear();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nStats {\n  Stats() { Start(); }\n}"
  },
  {
    "function_name": "AppendWithSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "153-159",
    "snippet": "static void AppendWithSpace(std::string* str, Slice msg) {\n  if (msg.empty()) return;\n  if (!str->empty()) {\n    str->push_back(' ');\n  }\n  str->append(msg.data(), msg.size());\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "str->append",
          "args": [
            "msg.data()",
            "msg.size()"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg.size",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg.data",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str->push_back",
          "args": [
            "' '"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str->empty",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic void AppendWithSpace(std::string* str, Slice msg) {\n  if (msg.empty()) return;\n  if (!str->empty()) {\n    str->push_back(' ');\n  }\n  str->append(msg.data(), msg.size());\n}"
  },
  {
    "function_name": "TrimSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "141-151",
    "snippet": "static Slice TrimSpace(Slice s) {\n  size_t start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  size_t limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "s.data() + start",
            "limit - start"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.data",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "s[limit-1]"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "s[start]"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic Slice TrimSpace(Slice s) {\n  size_t start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  size_t limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}"
  },
  {
    "function_name": "Generate",
    "container": "RandomGenerator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "131-138",
    "snippet": "Slice Generate(size_t len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "data_.data() + pos_ - len",
            "len"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_.data",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len < data_.size()"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_.size",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nRandomGenerator {\n  Slice Generate(size_t len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
  },
  {
    "function_name": "RandomGenerator",
    "container": "RandomGenerator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_bench.cc",
    "lines": "116-129",
    "snippet": "RandomGenerator() {\n    // We use a limited amount of data over and over again and ensure\n    // that it is larger than the compression window (32KB), and also\n    // large enough to serve all typical value sizes we want to write.\n    Random rnd(301);\n    std::string piece;\n    while (data_.size() < 1048576) {\n      // Add a short fragment that is as compressible as specified\n      // by FLAGS_compression_ratio.\n      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n      data_.append(piece);\n    }\n    pos_ = 0;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/histogram.h\"",
      "#include \"util/crc32c.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/version_set.h\"",
      "#include \"db/db_impl.h\"",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <sys/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static double FLAGS_compression_ratio = 0.5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data_.append",
          "args": [
            "piece"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::CompressibleString",
          "args": [
            "&rnd",
            "FLAGS_compression_ratio",
            "100",
            "&piece"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "CompressibleString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testutil.cc",
          "lines": "34-48",
          "snippet": "extern Slice CompressibleString(Random* rnd, double compressed_fraction,\n                                size_t len, std::string* dst) {\n  int raw = static_cast<int>(len * compressed_fraction);\n  if (raw < 1) raw = 1;\n  std::string raw_data;\n  RandomString(rnd, raw, &raw_data);\n\n  // Duplicate the random data until we have filled \"len\" bytes\n  dst->clear();\n  while (dst->size() < len) {\n    dst->append(raw_data);\n  }\n  dst->resize(len);\n  return Slice(*dst);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/testutil.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/testutil.h\"\n\nextern Slice CompressibleString(Random* rnd, double compressed_fraction,\n                                size_t len, std::string* dst) {\n  int raw = static_cast<int>(len * compressed_fraction);\n  if (raw < 1) raw = 1;\n  std::string raw_data;\n  RandomString(rnd, raw, &raw_data);\n\n  // Duplicate the random data until we have filled \"len\" bytes\n  dst->clear();\n  while (dst->size() < len) {\n    dst->append(raw_data);\n  }\n  dst->resize(len);\n  return Slice(*dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_.size",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/histogram.h\"\n#include \"util/crc32c.h\"\n#include \"port/port.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/cache.h\"\n#include \"db/version_set.h\"\n#include \"db/db_impl.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n\nstatic double FLAGS_compression_ratio = 0.5;\n\nRandomGenerator {\n  RandomGenerator() {\n      // We use a limited amount of data over and over again and ensure\n      // that it is larger than the compression window (32KB), and also\n      // large enough to serve all typical value sizes we want to write.\n      Random rnd(301);\n      std::string piece;\n      while (data_.size() < 1048576) {\n        // Add a short fragment that is as compressible as specified\n        // by FLAGS_compression_ratio.\n        test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n        data_.append(piece);\n      }\n      pos_ = 0;\n    }\n}"
  }
]