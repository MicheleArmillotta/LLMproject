[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "484-528",
    "snippet": "int main(int argc, char** argv) {\n  std::string default_db_path;\n  for (int i = 1; i < argc; i++) {\n    double d;\n    int n;\n    char junk;\n    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n      FLAGS_compression_ratio = d;\n    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_histogram = n;\n    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n      FLAGS_num = n;\n    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n      FLAGS_reads = n;\n    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_value_size = n;\n    } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_cache_size = n;\n    } else if (sscanf(argv[i], \"--page_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_page_size = n;\n    } else if (sscanf(argv[i], \"--compression=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_compression = (n == 1) ? true : false;\n    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n      FLAGS_db = argv[i] + 5;\n    } else {\n      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n      exit(1);\n    }\n  }\n\n  // Choose a location for the test database if none given with --db=<path>\n  if (FLAGS_db == NULL) {\n      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n      default_db_path += \"/dbbench\";\n      FLAGS_db = default_db_path.c_str();\n  }\n\n  leveldb::Benchmark benchmark;\n  benchmark.Run();\n  return 0;\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillrandsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq100K,\"\n    \"readrand100K,\"\n    ;",
      "static int FLAGS_num = 1000000;",
      "static int FLAGS_reads = -1;",
      "static int FLAGS_value_size = 100;",
      "static double FLAGS_compression_ratio = 0.5;",
      "static bool FLAGS_histogram = false;",
      "static int FLAGS_cache_size = 4194304;",
      "static int FLAGS_page_size = 1024;",
      "static bool FLAGS_compression = true;",
      "static const char* FLAGS_db = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "benchmark.Run",
          "args": [],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "Run",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "319-386",
          "snippet": "void Run() {\n    PrintHeader();\n    Open(false);\n\n    const char* benchmarks = FLAGS_benchmarks;\n    while (benchmarks != NULL) {\n      const char* sep = strchr(benchmarks, ',');\n      Slice name;\n      if (sep == NULL) {\n        name = benchmarks;\n        benchmarks = NULL;\n      } else {\n        name = Slice(benchmarks, sep - benchmarks);\n        benchmarks = sep + 1;\n      }\n\n      Start();\n\n      bool known = true;\n      bool write_sync = false;\n      if (name == Slice(\"fillseq\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n        \n      } else if (name == Slice(\"fillrandom\")) {\n        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"overwrite\")) {\n        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillrandsync\")) {\n        write_sync = true;\n        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillseqsync\")) {\n        write_sync = true;\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillrand100K\")) {\n        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillseq100K\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"readseq\")) {\n        ReadSequential();\n      } else if (name == Slice(\"readrandom\")) {\n        ReadRandom();\n      } else if (name == Slice(\"readrand100K\")) {\n        int n = reads_;\n        reads_ /= 1000;\n        ReadRandom();\n        reads_ = n;\n      } else if (name == Slice(\"readseq100K\")) {\n        int n = reads_;\n        reads_ /= 1000;\n        ReadSequential();\n        reads_ = n;\n      } else {\n        known = false;\n        if (name != Slice()) {  // No error message for empty name\n          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n        }\n      }\n      if (known) {\n        Stop(name);\n      }\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillrandsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq100K,\"\n    \"readrand100K,\"\n    ;",
            "static int FLAGS_value_size = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillrandsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq100K,\"\n    \"readrand100K,\"\n    ;\nstatic int FLAGS_value_size = 100;\n\nBenchmark {\n  void Run() {\n      PrintHeader();\n      Open(false);\n  \n      const char* benchmarks = FLAGS_benchmarks;\n      while (benchmarks != NULL) {\n        const char* sep = strchr(benchmarks, ',');\n        Slice name;\n        if (sep == NULL) {\n          name = benchmarks;\n          benchmarks = NULL;\n        } else {\n          name = Slice(benchmarks, sep - benchmarks);\n          benchmarks = sep + 1;\n        }\n  \n        Start();\n  \n        bool known = true;\n        bool write_sync = false;\n        if (name == Slice(\"fillseq\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n          \n        } else if (name == Slice(\"fillrandom\")) {\n          Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"overwrite\")) {\n          Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillrandsync\")) {\n          write_sync = true;\n          Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillseqsync\")) {\n          write_sync = true;\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillrand100K\")) {\n          Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillseq100K\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"readseq\")) {\n          ReadSequential();\n        } else if (name == Slice(\"readrandom\")) {\n          ReadRandom();\n        } else if (name == Slice(\"readrand100K\")) {\n          int n = reads_;\n          reads_ /= 1000;\n          ReadRandom();\n          reads_ = n;\n        } else if (name == Slice(\"readseq100K\")) {\n          int n = reads_;\n          reads_ /= 1000;\n          ReadSequential();\n          reads_ = n;\n        } else {\n          known = false;\n          if (name != Slice()) {  // No error message for empty name\n            fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n          }\n        }\n        if (known) {\n          Stop(name);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_db_path.c_str",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Env::Default",
          "args": [
            "&default_db_path"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Env::Default",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid flag '%s'\\n\"",
            "argv[i]"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--db=\"",
            "5"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--compression=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--page_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--cache_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--value_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--reads=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--num=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--histogram=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--compression_ratio=%lf%c\"",
            "&d",
            "&junk"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"--benchmarks=\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Slice",
          "args": [
            "\"--benchmarks=\""
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "Slice",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "37-37",
          "snippet": "Slice(const char* s) : data_(s), size_(strlen(s)) { }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  Slice(const char* s) : data_(s), size_(strlen(s)) { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillrandsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq100K,\"\n    \"readrand100K,\"\n    ;\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic int FLAGS_value_size = 100;\nstatic double FLAGS_compression_ratio = 0.5;\nstatic bool FLAGS_histogram = false;\nstatic int FLAGS_cache_size = 4194304;\nstatic int FLAGS_page_size = 1024;\nstatic bool FLAGS_compression = true;\nstatic const char* FLAGS_db = NULL;\n\nint main(int argc, char** argv) {\n  std::string default_db_path;\n  for (int i = 1; i < argc; i++) {\n    double d;\n    int n;\n    char junk;\n    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n      FLAGS_compression_ratio = d;\n    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_histogram = n;\n    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n      FLAGS_num = n;\n    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n      FLAGS_reads = n;\n    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_value_size = n;\n    } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_cache_size = n;\n    } else if (sscanf(argv[i], \"--page_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_page_size = n;\n    } else if (sscanf(argv[i], \"--compression=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_compression = (n == 1) ? true : false;\n    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n      FLAGS_db = argv[i] + 5;\n    } else {\n      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n      exit(1);\n    }\n  }\n\n  // Choose a location for the test database if none given with --db=<path>\n  if (FLAGS_db == NULL) {\n      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n      default_db_path += \"/dbbench\";\n      FLAGS_db = default_db_path.c_str();\n  }\n\n  leveldb::Benchmark benchmark;\n  benchmark.Run();\n  return 0;\n}"
  },
  {
    "function_name": "ReadRandom",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "470-479",
    "snippet": "void ReadRandom() {\n    std::string value;\n    for (int i = 0; i < reads_; i++) {\n      char key[100];\n      const int k = rand_.Next() % reads_;\n      snprintf(key, sizeof(key), \"%016d\", k);\n      db_->get(key, &value);\n      FinishedSingleOp();\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FinishedSingleOp",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "226-250",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->get",
          "args": [
            "key",
            "&value"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand_.Next",
          "args": [],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void ReadRandom() {\n      std::string value;\n      for (int i = 0; i < reads_; i++) {\n        char key[100];\n        const int k = rand_.Next() % reads_;\n        snprintf(key, sizeof(key), \"%016d\", k);\n        db_->get(key, &value);\n        FinishedSingleOp();\n      }\n    }\n}"
  },
  {
    "function_name": "ReadSequential",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "459-468",
    "snippet": "void ReadSequential() {\n    kyotocabinet::DB::Cursor* cur = db_->cursor();\n    cur->jump();\n    std::string ckey, cvalue;\n    while (cur->get(&ckey, &cvalue, true)) {\n      bytes_ += ckey.size() + cvalue.size();\n      FinishedSingleOp();\n    }\n    delete cur;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FinishedSingleOp",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "226-250",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cvalue.size",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cur->get",
          "args": [
            "&ckey",
            "&cvalue",
            "true"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cur->jump",
          "args": [],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->cursor",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void ReadSequential() {\n      kyotocabinet::DB::Cursor* cur = db_->cursor();\n      cur->jump();\n      std::string ckey, cvalue;\n      while (cur->get(&ckey, &cvalue, true)) {\n        bytes_ += ckey.size() + cvalue.size();\n        FinishedSingleOp();\n      }\n      delete cur;\n    }\n}"
  },
  {
    "function_name": "Write",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "424-457",
    "snippet": "void Write(bool sync, Order order, DBState state,\n             int num_entries, int value_size, int entries_per_batch) {\n    // Create new database if state == FRESH\n    if (state == FRESH) {\n      if (FLAGS_use_existing_db) {\n        message_ = \"skipping (--use_existing_db is true)\";\n        return;\n      }\n      delete db_;\n      db_ = NULL;\n      Open(sync);\n      Start();  // Do not count time taken to destroy/open\n    }\n\n    if (num_entries != num_) {\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n      message_ = msg;\n    }\n\n    // Write to database\n    for (int i = 0; i < num_entries; i++)\n    {\n      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);\n      char key[100];\n      snprintf(key, sizeof(key), \"%016d\", k);\n      bytes_ += value_size + strlen(key);\n      std::string cpp_key = key;\n      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {\n        fprintf(stderr, \"set error: %s\\n\", db_->error().name());\n      }\n      FinishedSingleOp();\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_use_existing_db = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "FinishedSingleOp",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "226-250",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"set error: %s\\n\"",
            "db_->error().name()"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->error",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->error",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->set",
          "args": [
            "cpp_key",
            "gen_.Generate(value_size).ToString()"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_.Generate",
          "args": [],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_.Generate",
          "args": [
            "value_size"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "Generate",
          "container": "RandomGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "108-115",
          "snippet": "Slice Generate(int len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nRandomGenerator {\n  Slice Generate(int len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand_.Next",
          "args": [],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg",
            "sizeof(msg)",
            "\"(%d ops)\"",
            "num_entries"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Start",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "216-224",
          "snippet": "void Start() {\n    start_ = Env::Default()->NowMicros() * 1e-6;\n    bytes_ = 0;\n    message_.clear();\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    next_report_ = 100;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void Start() {\n      start_ = Env::Default()->NowMicros() * 1e-6;\n      bytes_ = 0;\n      message_.clear();\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      next_report_ = 100;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Open",
          "args": [
            "sync"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "389-422",
          "snippet": "void Open(bool sync) {\n    assert(db_ == NULL);\n\n    // Initialize db_\n    db_ = new kyotocabinet::TreeDB();\n    char file_name[100];\n    db_num_++;\n    std::string test_dir;\n    Env::Default()->GetTestDirectory(&test_dir);\n    snprintf(file_name, sizeof(file_name),\n             \"%s/dbbench_polyDB-%d.kct\",\n             test_dir.c_str(),\n             db_num_);\n\n    // Create tuning options and open the database\n    int open_options = kyotocabinet::PolyDB::OWRITER |\n                       kyotocabinet::PolyDB::OCREATE;\n    int tune_options = kyotocabinet::TreeDB::TSMALL |\n        kyotocabinet::TreeDB::TLINEAR;\n    if (FLAGS_compression) {\n      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;\n      db_->tune_compressor(&comp_);\n    }\n    db_->tune_options(tune_options);\n    db_->tune_page_cache(FLAGS_cache_size);\n    db_->tune_page(FLAGS_page_size);\n    db_->tune_map(256LL<<20);\n    if (sync) {\n      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;\n    }\n    if (!db_->open(file_name, open_options)) {\n      fprintf(stderr, \"open error: %s\\n\", db_->error().name());\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_cache_size = 4194304;",
            "static int FLAGS_page_size = 1024;",
            "static bool FLAGS_compression = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_cache_size = 4194304;\nstatic int FLAGS_page_size = 1024;\nstatic bool FLAGS_compression = true;\n\nBenchmark {\n  void Open(bool sync) {\n      assert(db_ == NULL);\n  \n      // Initialize db_\n      db_ = new kyotocabinet::TreeDB();\n      char file_name[100];\n      db_num_++;\n      std::string test_dir;\n      Env::Default()->GetTestDirectory(&test_dir);\n      snprintf(file_name, sizeof(file_name),\n               \"%s/dbbench_polyDB-%d.kct\",\n               test_dir.c_str(),\n               db_num_);\n  \n      // Create tuning options and open the database\n      int open_options = kyotocabinet::PolyDB::OWRITER |\n                         kyotocabinet::PolyDB::OCREATE;\n      int tune_options = kyotocabinet::TreeDB::TSMALL |\n          kyotocabinet::TreeDB::TLINEAR;\n      if (FLAGS_compression) {\n        tune_options |= kyotocabinet::TreeDB::TCOMPRESS;\n        db_->tune_compressor(&comp_);\n      }\n      db_->tune_options(tune_options);\n      db_->tune_page_cache(FLAGS_cache_size);\n      db_->tune_page(FLAGS_page_size);\n      db_->tune_map(256LL<<20);\n      if (sync) {\n        open_options |= kyotocabinet::PolyDB::OAUTOSYNC;\n      }\n      if (!db_->open(file_name, open_options)) {\n        fprintf(stderr, \"open error: %s\\n\", db_->error().name());\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_use_existing_db = false;\n\nBenchmark {\n  void Write(bool sync, Order order, DBState state,\n               int num_entries, int value_size, int entries_per_batch) {\n      // Create new database if state == FRESH\n      if (state == FRESH) {\n        if (FLAGS_use_existing_db) {\n          message_ = \"skipping (--use_existing_db is true)\";\n          return;\n        }\n        delete db_;\n        db_ = NULL;\n        Open(sync);\n        Start();  // Do not count time taken to destroy/open\n      }\n  \n      if (num_entries != num_) {\n        char msg[100];\n        snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n        message_ = msg;\n      }\n  \n      // Write to database\n      for (int i = 0; i < num_entries; i++)\n      {\n        const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        bytes_ += value_size + strlen(key);\n        std::string cpp_key = key;\n        if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {\n          fprintf(stderr, \"set error: %s\\n\", db_->error().name());\n        }\n        FinishedSingleOp();\n      }\n    }\n}"
  },
  {
    "function_name": "Open",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "389-422",
    "snippet": "void Open(bool sync) {\n    assert(db_ == NULL);\n\n    // Initialize db_\n    db_ = new kyotocabinet::TreeDB();\n    char file_name[100];\n    db_num_++;\n    std::string test_dir;\n    Env::Default()->GetTestDirectory(&test_dir);\n    snprintf(file_name, sizeof(file_name),\n             \"%s/dbbench_polyDB-%d.kct\",\n             test_dir.c_str(),\n             db_num_);\n\n    // Create tuning options and open the database\n    int open_options = kyotocabinet::PolyDB::OWRITER |\n                       kyotocabinet::PolyDB::OCREATE;\n    int tune_options = kyotocabinet::TreeDB::TSMALL |\n        kyotocabinet::TreeDB::TLINEAR;\n    if (FLAGS_compression) {\n      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;\n      db_->tune_compressor(&comp_);\n    }\n    db_->tune_options(tune_options);\n    db_->tune_page_cache(FLAGS_cache_size);\n    db_->tune_page(FLAGS_page_size);\n    db_->tune_map(256LL<<20);\n    if (sync) {\n      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;\n    }\n    if (!db_->open(file_name, open_options)) {\n      fprintf(stderr, \"open error: %s\\n\", db_->error().name());\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_cache_size = 4194304;",
      "static int FLAGS_page_size = 1024;",
      "static bool FLAGS_compression = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"open error: %s\\n\"",
            "db_->error().name()"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->error",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->error",
          "args": [],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->open",
          "args": [
            "file_name",
            "open_options"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->tune_map",
          "args": [
            "256LL<<20"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->tune_page",
          "args": [
            "FLAGS_page_size"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->tune_page_cache",
          "args": [
            "FLAGS_cache_size"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->tune_options",
          "args": [
            "tune_options"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->tune_compressor",
          "args": [
            "&comp_"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "file_name",
            "sizeof(file_name)",
            "\"%s/dbbench_polyDB-%d.kct\"",
            "test_dir.c_str()",
            "db_num_"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_dir.c_str",
          "args": [],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "&test_dir"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "db_ == NULL"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_cache_size = 4194304;\nstatic int FLAGS_page_size = 1024;\nstatic bool FLAGS_compression = true;\n\nBenchmark {\n  void Open(bool sync) {\n      assert(db_ == NULL);\n  \n      // Initialize db_\n      db_ = new kyotocabinet::TreeDB();\n      char file_name[100];\n      db_num_++;\n      std::string test_dir;\n      Env::Default()->GetTestDirectory(&test_dir);\n      snprintf(file_name, sizeof(file_name),\n               \"%s/dbbench_polyDB-%d.kct\",\n               test_dir.c_str(),\n               db_num_);\n  \n      // Create tuning options and open the database\n      int open_options = kyotocabinet::PolyDB::OWRITER |\n                         kyotocabinet::PolyDB::OCREATE;\n      int tune_options = kyotocabinet::TreeDB::TSMALL |\n          kyotocabinet::TreeDB::TLINEAR;\n      if (FLAGS_compression) {\n        tune_options |= kyotocabinet::TreeDB::TCOMPRESS;\n        db_->tune_compressor(&comp_);\n      }\n      db_->tune_options(tune_options);\n      db_->tune_page_cache(FLAGS_cache_size);\n      db_->tune_page(FLAGS_page_size);\n      db_->tune_map(256LL<<20);\n      if (sync) {\n        open_options |= kyotocabinet::PolyDB::OAUTOSYNC;\n      }\n      if (!db_->open(file_name, open_options)) {\n        fprintf(stderr, \"open error: %s\\n\", db_->error().name());\n      }\n    }\n}"
  },
  {
    "function_name": "Run",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "319-386",
    "snippet": "void Run() {\n    PrintHeader();\n    Open(false);\n\n    const char* benchmarks = FLAGS_benchmarks;\n    while (benchmarks != NULL) {\n      const char* sep = strchr(benchmarks, ',');\n      Slice name;\n      if (sep == NULL) {\n        name = benchmarks;\n        benchmarks = NULL;\n      } else {\n        name = Slice(benchmarks, sep - benchmarks);\n        benchmarks = sep + 1;\n      }\n\n      Start();\n\n      bool known = true;\n      bool write_sync = false;\n      if (name == Slice(\"fillseq\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n        \n      } else if (name == Slice(\"fillrandom\")) {\n        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"overwrite\")) {\n        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillrandsync\")) {\n        write_sync = true;\n        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillseqsync\")) {\n        write_sync = true;\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillrand100K\")) {\n        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"fillseq100K\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n        DBSynchronize(db_);\n      } else if (name == Slice(\"readseq\")) {\n        ReadSequential();\n      } else if (name == Slice(\"readrandom\")) {\n        ReadRandom();\n      } else if (name == Slice(\"readrand100K\")) {\n        int n = reads_;\n        reads_ /= 1000;\n        ReadRandom();\n        reads_ = n;\n      } else if (name == Slice(\"readseq100K\")) {\n        int n = reads_;\n        reads_ /= 1000;\n        ReadSequential();\n        reads_ = n;\n      } else {\n        known = false;\n        if (name != Slice()) {  // No error message for empty name\n          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n        }\n      }\n      if (known) {\n        Stop(name);\n      }\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillrandsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq100K,\"\n    \"readrand100K,\"\n    ;",
      "static int FLAGS_value_size = 100;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Stop",
          "args": [
            "name"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "Stop",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "252-279",
          "snippet": "void Stop(const Slice& name) {\n    double finish = Env::Default()->NowMicros() * 1e-6;\n\n    // Pretend at least one op was done in case we are running a benchmark\n    // that does not call FinishedSingleOp().\n    if (done_ < 1) done_ = 1;\n\n    if (bytes_ > 0) {\n      char rate[100];\n      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n               (bytes_ / 1048576.0) / (finish - start_));\n      if (!message_.empty()) {\n        message_  = std::string(rate) + \" \" + message_;\n      } else {\n        message_ = rate;\n      }\n    }\n\n    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n            name.ToString().c_str(),\n            (finish - start_) * 1e6 / done_,\n            (message_.empty() ? \"\" : \" \"),\n            message_.c_str());\n    if (FLAGS_histogram) {\n      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n    }\n    fflush(stdout);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void Stop(const Slice& name) {\n      double finish = Env::Default()->NowMicros() * 1e-6;\n  \n      // Pretend at least one op was done in case we are running a benchmark\n      // that does not call FinishedSingleOp().\n      if (done_ < 1) done_ = 1;\n  \n      if (bytes_ > 0) {\n        char rate[100];\n        snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n                 (bytes_ / 1048576.0) / (finish - start_));\n        if (!message_.empty()) {\n          message_  = std::string(rate) + \" \" + message_;\n        } else {\n          message_ = rate;\n        }\n      }\n  \n      fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n              name.ToString().c_str(),\n              (finish - start_) * 1e6 / done_,\n              (message_.empty() ? \"\" : \" \"),\n              message_.c_str());\n      if (FLAGS_histogram) {\n        fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n      }\n      fflush(stdout);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unknown benchmark '%s'\\n\"",
            "name.ToString().c_str()"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.ToString",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "66-66",
          "snippet": "std::string ToString() const { return std::string(data_, size_); }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  std::string ToString() const { return std::string(data_, size_); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadSequential",
          "args": [],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ReadSequential",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "459-468",
          "snippet": "void ReadSequential() {\n    kyotocabinet::DB::Cursor* cur = db_->cursor();\n    cur->jump();\n    std::string ckey, cvalue;\n    while (cur->get(&ckey, &cvalue, true)) {\n      bytes_ += ckey.size() + cvalue.size();\n      FinishedSingleOp();\n    }\n    delete cur;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void ReadSequential() {\n      kyotocabinet::DB::Cursor* cur = db_->cursor();\n      cur->jump();\n      std::string ckey, cvalue;\n      while (cur->get(&ckey, &cvalue, true)) {\n        bytes_ += ckey.size() + cvalue.size();\n        FinishedSingleOp();\n      }\n      delete cur;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"readseq100K\""
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadRandom",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "ReadRandom",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "470-479",
          "snippet": "void ReadRandom() {\n    std::string value;\n    for (int i = 0; i < reads_; i++) {\n      char key[100];\n      const int k = rand_.Next() % reads_;\n      snprintf(key, sizeof(key), \"%016d\", k);\n      db_->get(key, &value);\n      FinishedSingleOp();\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void ReadRandom() {\n      std::string value;\n      for (int i = 0; i < reads_; i++) {\n        char key[100];\n        const int k = rand_.Next() % reads_;\n        snprintf(key, sizeof(key), \"%016d\", k);\n        db_->get(key, &value);\n        FinishedSingleOp();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DBSynchronize",
          "args": [
            "db_"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "DBSynchronize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "74-81",
          "snippet": "inline\nstatic void DBSynchronize(kyotocabinet::TreeDB* db_)\n{\n  // Synchronize will flush writes to disk\n  if (!db_->synchronize()) {\n    fprintf(stderr, \"synchronize error: %s\\n\", db_->error().name());\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void DBSynchronize(kyotocabinet::TreeDB* db_)\n{\n  // Synchronize will flush writes to disk\n  if (!db_->synchronize()) {\n    fprintf(stderr, \"synchronize error: %s\\n\", db_->error().name());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "write_sync",
            "SEQUENTIAL",
            "FRESH",
            "num_ / 1000",
            "100 * 1000",
            "1"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "424-457",
          "snippet": "void Write(bool sync, Order order, DBState state,\n             int num_entries, int value_size, int entries_per_batch) {\n    // Create new database if state == FRESH\n    if (state == FRESH) {\n      if (FLAGS_use_existing_db) {\n        message_ = \"skipping (--use_existing_db is true)\";\n        return;\n      }\n      delete db_;\n      db_ = NULL;\n      Open(sync);\n      Start();  // Do not count time taken to destroy/open\n    }\n\n    if (num_entries != num_) {\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n      message_ = msg;\n    }\n\n    // Write to database\n    for (int i = 0; i < num_entries; i++)\n    {\n      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);\n      char key[100];\n      snprintf(key, sizeof(key), \"%016d\", k);\n      bytes_ += value_size + strlen(key);\n      std::string cpp_key = key;\n      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {\n        fprintf(stderr, \"set error: %s\\n\", db_->error().name());\n      }\n      FinishedSingleOp();\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_use_existing_db = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_use_existing_db = false;\n\nBenchmark {\n  void Write(bool sync, Order order, DBState state,\n               int num_entries, int value_size, int entries_per_batch) {\n      // Create new database if state == FRESH\n      if (state == FRESH) {\n        if (FLAGS_use_existing_db) {\n          message_ = \"skipping (--use_existing_db is true)\";\n          return;\n        }\n        delete db_;\n        db_ = NULL;\n        Open(sync);\n        Start();  // Do not count time taken to destroy/open\n      }\n  \n      if (num_entries != num_) {\n        char msg[100];\n        snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n        message_ = msg;\n      }\n  \n      // Write to database\n      for (int i = 0; i < num_entries; i++)\n      {\n        const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n        bytes_ += value_size + strlen(key);\n        std::string cpp_key = key;\n        if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {\n          fprintf(stderr, \"set error: %s\\n\", db_->error().name());\n        }\n        FinishedSingleOp();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Start",
          "args": [],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "216-224",
          "snippet": "void Start() {\n    start_ = Env::Default()->NowMicros() * 1e-6;\n    bytes_ = 0;\n    message_.clear();\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    next_report_ = 100;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void Start() {\n      start_ = Env::Default()->NowMicros() * 1e-6;\n      bytes_ = 0;\n      message_.clear();\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      next_report_ = 100;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "benchmarks",
            "sep - benchmarks"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "benchmarks",
            "','"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Open",
          "args": [
            "false"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "389-422",
          "snippet": "void Open(bool sync) {\n    assert(db_ == NULL);\n\n    // Initialize db_\n    db_ = new kyotocabinet::TreeDB();\n    char file_name[100];\n    db_num_++;\n    std::string test_dir;\n    Env::Default()->GetTestDirectory(&test_dir);\n    snprintf(file_name, sizeof(file_name),\n             \"%s/dbbench_polyDB-%d.kct\",\n             test_dir.c_str(),\n             db_num_);\n\n    // Create tuning options and open the database\n    int open_options = kyotocabinet::PolyDB::OWRITER |\n                       kyotocabinet::PolyDB::OCREATE;\n    int tune_options = kyotocabinet::TreeDB::TSMALL |\n        kyotocabinet::TreeDB::TLINEAR;\n    if (FLAGS_compression) {\n      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;\n      db_->tune_compressor(&comp_);\n    }\n    db_->tune_options(tune_options);\n    db_->tune_page_cache(FLAGS_cache_size);\n    db_->tune_page(FLAGS_page_size);\n    db_->tune_map(256LL<<20);\n    if (sync) {\n      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;\n    }\n    if (!db_->open(file_name, open_options)) {\n      fprintf(stderr, \"open error: %s\\n\", db_->error().name());\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_cache_size = 4194304;",
            "static int FLAGS_page_size = 1024;",
            "static bool FLAGS_compression = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_cache_size = 4194304;\nstatic int FLAGS_page_size = 1024;\nstatic bool FLAGS_compression = true;\n\nBenchmark {\n  void Open(bool sync) {\n      assert(db_ == NULL);\n  \n      // Initialize db_\n      db_ = new kyotocabinet::TreeDB();\n      char file_name[100];\n      db_num_++;\n      std::string test_dir;\n      Env::Default()->GetTestDirectory(&test_dir);\n      snprintf(file_name, sizeof(file_name),\n               \"%s/dbbench_polyDB-%d.kct\",\n               test_dir.c_str(),\n               db_num_);\n  \n      // Create tuning options and open the database\n      int open_options = kyotocabinet::PolyDB::OWRITER |\n                         kyotocabinet::PolyDB::OCREATE;\n      int tune_options = kyotocabinet::TreeDB::TSMALL |\n          kyotocabinet::TreeDB::TLINEAR;\n      if (FLAGS_compression) {\n        tune_options |= kyotocabinet::TreeDB::TCOMPRESS;\n        db_->tune_compressor(&comp_);\n      }\n      db_->tune_options(tune_options);\n      db_->tune_page_cache(FLAGS_cache_size);\n      db_->tune_page(FLAGS_page_size);\n      db_->tune_map(256LL<<20);\n      if (sync) {\n        open_options |= kyotocabinet::PolyDB::OAUTOSYNC;\n      }\n      if (!db_->open(file_name, open_options)) {\n        fprintf(stderr, \"open error: %s\\n\", db_->error().name());\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintHeader",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "PrintHeader",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "151-167",
          "snippet": "void PrintHeader() {\n    const int kKeySize = 16;\n    PrintEnvironment();\n    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n    fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n            FLAGS_value_size,\n            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n    fprintf(stdout, \"Entries:    %d\\n\", num_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0));\n    fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n             / 1048576.0));\n    PrintWarnings();\n    fprintf(stdout, \"------------------------------------------------\\n\");\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_value_size = 100;",
            "static double FLAGS_compression_ratio = 0.5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_value_size = 100;\nstatic double FLAGS_compression_ratio = 0.5;\n\nBenchmark {\n  void PrintHeader() {\n      const int kKeySize = 16;\n      PrintEnvironment();\n      fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n      fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n              FLAGS_value_size,\n              static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n      fprintf(stdout, \"Entries:    %d\\n\", num_);\n      fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n              ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n               / 1048576.0));\n      fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n              (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n               / 1048576.0));\n      PrintWarnings();\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillrandsync,\"\n    \"fillrandom,\"\n    \"overwrite,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq100K,\"\n    \"readrand100K,\"\n    ;\nstatic int FLAGS_value_size = 100;\n\nBenchmark {\n  void Run() {\n      PrintHeader();\n      Open(false);\n  \n      const char* benchmarks = FLAGS_benchmarks;\n      while (benchmarks != NULL) {\n        const char* sep = strchr(benchmarks, ',');\n        Slice name;\n        if (sep == NULL) {\n          name = benchmarks;\n          benchmarks = NULL;\n        } else {\n          name = Slice(benchmarks, sep - benchmarks);\n          benchmarks = sep + 1;\n        }\n  \n        Start();\n  \n        bool known = true;\n        bool write_sync = false;\n        if (name == Slice(\"fillseq\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n          \n        } else if (name == Slice(\"fillrandom\")) {\n          Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"overwrite\")) {\n          Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillrandsync\")) {\n          write_sync = true;\n          Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillseqsync\")) {\n          write_sync = true;\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillrand100K\")) {\n          Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"fillseq100K\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n          DBSynchronize(db_);\n        } else if (name == Slice(\"readseq\")) {\n          ReadSequential();\n        } else if (name == Slice(\"readrandom\")) {\n          ReadRandom();\n        } else if (name == Slice(\"readrand100K\")) {\n          int n = reads_;\n          reads_ /= 1000;\n          ReadRandom();\n          reads_ = n;\n        } else if (name == Slice(\"readseq100K\")) {\n          int n = reads_;\n          reads_ /= 1000;\n          ReadSequential();\n          reads_ = n;\n        } else {\n          known = false;\n          if (name != Slice()) {  // No error message for empty name\n            fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n          }\n        }\n        if (known) {\n          Stop(name);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "Benchmark",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "291-311",
    "snippet": "Benchmark()\n  : db_(NULL),\n    num_(FLAGS_num),\n    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n    bytes_(0),\n    rand_(301) {\n    std::vector<std::string> files;\n    std::string test_dir;\n    Env::Default()->GetTestDirectory(&test_dir);\n    Env::Default()->GetChildren(test_dir.c_str(), &files);\n    if (!FLAGS_use_existing_db) {\n      for (int i = 0; i < files.size(); i++) {\n        if (Slice(files[i]).starts_with(\"dbbench_polyDB\")) {\n          std::string file_name(test_dir);\n          file_name += \"/\";\n          file_name += files[i];\n          Env::Default()->DeleteFile(file_name.c_str());\n        }\n      }\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;",
      "static int FLAGS_reads = -1;",
      "static bool FLAGS_use_existing_db = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "file_name.c_str()"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_name.c_str",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"dbbench_polyDB\""
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "test_dir.c_str()",
            "&files"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_dir.c_str",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "&test_dir"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic bool FLAGS_use_existing_db = false;\n\nBenchmark {\n  Benchmark()\n    : db_(NULL),\n      num_(FLAGS_num),\n      reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n      bytes_(0),\n      rand_(301) {\n      std::vector<std::string> files;\n      std::string test_dir;\n      Env::Default()->GetTestDirectory(&test_dir);\n      Env::Default()->GetChildren(test_dir.c_str(), &files);\n      if (!FLAGS_use_existing_db) {\n        for (int i = 0; i < files.size(); i++) {\n          if (Slice(files[i]).starts_with(\"dbbench_polyDB\")) {\n            std::string file_name(test_dir);\n            file_name += \"/\";\n            file_name += files[i];\n            Env::Default()->DeleteFile(file_name.c_str());\n          }\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "Stop",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "252-279",
    "snippet": "void Stop(const Slice& name) {\n    double finish = Env::Default()->NowMicros() * 1e-6;\n\n    // Pretend at least one op was done in case we are running a benchmark\n    // that does not call FinishedSingleOp().\n    if (done_ < 1) done_ = 1;\n\n    if (bytes_ > 0) {\n      char rate[100];\n      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n               (bytes_ / 1048576.0) / (finish - start_));\n      if (!message_.empty()) {\n        message_  = std::string(rate) + \" \" + message_;\n      } else {\n        message_ = rate;\n      }\n    }\n\n    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n            name.ToString().c_str(),\n            (finish - start_) * 1e6 / done_,\n            (message_.empty() ? \"\" : \" \"),\n            message_.c_str());\n    if (FLAGS_histogram) {\n      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n    }\n    fflush(stdout);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_histogram = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Microseconds per op:\\n%s\\n\"",
            "hist_.ToString().c_str()"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_.ToString",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%-12s : %11.3f micros/op;%s%s\\n\"",
            "name.ToString().c_str()",
            "(finish - start_) * 1e6 / done_",
            "(message_.empty() ? \"\" : \" \")",
            "message_.c_str()"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message_.c_str",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message_.empty",
          "args": [],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "rate"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "rate",
            "sizeof(rate)",
            "\"%6.1f MB/s\"",
            "(bytes_ / 1048576.0) / (finish - start_)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void Stop(const Slice& name) {\n      double finish = Env::Default()->NowMicros() * 1e-6;\n  \n      // Pretend at least one op was done in case we are running a benchmark\n      // that does not call FinishedSingleOp().\n      if (done_ < 1) done_ = 1;\n  \n      if (bytes_ > 0) {\n        char rate[100];\n        snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n                 (bytes_ / 1048576.0) / (finish - start_));\n        if (!message_.empty()) {\n          message_  = std::string(rate) + \" \" + message_;\n        } else {\n          message_ = rate;\n        }\n      }\n  \n      fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n              name.ToString().c_str(),\n              (finish - start_) * 1e6 / done_,\n              (message_.empty() ? \"\" : \" \"),\n              message_.c_str());\n      if (FLAGS_histogram) {\n        fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n      }\n      fflush(stdout);\n    }\n}"
  },
  {
    "function_name": "FinishedSingleOp",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "226-250",
    "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_histogram = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"... finished %d ops%30s\\r\"",
            "done_",
            "\"\""
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"long op: %.1f micros%30s\\r\"",
            "micros",
            "\"\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_.Add",
          "args": [
            "micros"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "181-184",
          "snippet": "void Add(std::vector<T> &vChecks) {\n        if (pqueue != NULL)\n            pqueue->Add(vChecks);\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  void Add(std::vector<T> &vChecks) {\n          if (pqueue != NULL)\n              pqueue->Add(vChecks);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
  },
  {
    "function_name": "Start",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "216-224",
    "snippet": "void Start() {\n    start_ = Env::Default()->NowMicros() * 1e-6;\n    bytes_ = 0;\n    message_.clear();\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    next_report_ = 100;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_.Clear",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "Histogram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/histogram.cc",
          "lines": "33-42",
          "snippet": "void Histogram::Clear() {\n  min_ = kBucketLimit[kNumBuckets-1];\n  max_ = 0;\n  num_ = 0;\n  sum_ = 0;\n  sum_squares_ = 0;\n  for (int i = 0; i < kNumBuckets; i++) {\n    buckets_[i] = 0;\n  }\n}",
          "includes": [
            "#include \"util/histogram.h\"",
            "#include \"port/port.h\"",
            "#include <stdio.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/histogram.h\"\n#include \"port/port.h\"\n#include <stdio.h>\n#include <math.h>\n\nHistogram {\n  void Histogram::Clear() {\n    min_ = kBucketLimit[kNumBuckets-1];\n    max_ = 0;\n    num_ = 0;\n    sum_ = 0;\n    sum_squares_ = 0;\n    for (int i = 0; i < kNumBuckets; i++) {\n      buckets_[i] = 0;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message_.clear",
          "args": [],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void Start() {\n      start_ = Env::Default()->NowMicros() * 1e-6;\n      bytes_ = 0;\n      message_.clear();\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      next_report_ = 100;\n    }\n}"
  },
  {
    "function_name": "PrintEnvironment",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "181-214",
    "snippet": "void PrintEnvironment() {\n    fprintf(stderr, \"Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\\n\",\n            kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);\n\n#if defined(__linux)\n    time_t now = time(NULL);\n    fprintf(stderr, \"Date:           %s\", ctime(&now));  // ctime() adds newline\n\n    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n    if (cpuinfo != NULL) {\n      char line[1000];\n      int num_cpus = 0;\n      std::string cpu_type;\n      std::string cache_size;\n      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        const char* sep = strchr(line, ':');\n        if (sep == NULL) {\n          continue;\n        }\n        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n        Slice val = TrimSpace(Slice(sep + 1));\n        if (key == \"model name\") {\n          ++num_cpus;\n          cpu_type = val.ToString();\n        } else if (key == \"cache size\") {\n          cache_size = val.ToString();\n        }\n      }\n      fclose(cpuinfo);\n      fprintf(stderr, \"CPU:            %d * %s\\n\", num_cpus, cpu_type.c_str());\n      fprintf(stderr, \"CPUCache:       %s\\n\", cache_size.c_str());\n    }\n#endif\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CPUCache:       %s\\n\"",
            "cache_size.c_str()"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_size.c_str",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CPU:            %d * %s\\n\"",
            "num_cpus",
            "cpu_type.c_str()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_type.c_str",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "cpuinfo"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val.ToString",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TrimSpace",
          "args": [
            "Slice(sep + 1)"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "TrimSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "118-128",
          "snippet": "static Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "sep + 1"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "line",
            "sep - 1 - line"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "cpuinfo"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/cpuinfo\"",
            "\"r\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Date:           %s\"",
            "ctime(&now)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&now"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "pt_to_time_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "38-43",
          "snippet": "std::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\\n\"",
            "kyotocabinet::VERSION",
            "kyotocabinet::LIBVER",
            "kyotocabinet::LIBREV"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintEnvironment() {\n      fprintf(stderr, \"Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\\n\",\n              kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);\n  \n  #if defined(__linux)\n      time_t now = time(NULL);\n      fprintf(stderr, \"Date:           %s\", ctime(&now));  // ctime() adds newline\n  \n      FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n      if (cpuinfo != NULL) {\n        char line[1000];\n        int num_cpus = 0;\n        std::string cpu_type;\n        std::string cache_size;\n        while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n          const char* sep = strchr(line, ':');\n          if (sep == NULL) {\n            continue;\n          }\n          Slice key = TrimSpace(Slice(line, sep - 1 - line));\n          Slice val = TrimSpace(Slice(sep + 1));\n          if (key == \"model name\") {\n            ++num_cpus;\n            cpu_type = val.ToString();\n          } else if (key == \"cache size\") {\n            cache_size = val.ToString();\n          }\n        }\n        fclose(cpuinfo);\n        fprintf(stderr, \"CPU:            %d * %s\\n\", num_cpus, cpu_type.c_str());\n        fprintf(stderr, \"CPUCache:       %s\\n\", cache_size.c_str());\n      }\n  #endif\n    }\n}"
  },
  {
    "function_name": "PrintWarnings",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "169-179",
    "snippet": "void PrintWarnings() {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n    fprintf(stdout,\n            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n            );\n#endif\n#ifndef NDEBUG\n    fprintf(stdout,\n            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintWarnings() {\n  #if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(stdout,\n              \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n              );\n  #endif\n  #ifndef NDEBUG\n      fprintf(stdout,\n              \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n  #endif\n    }\n}"
  },
  {
    "function_name": "PrintHeader",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "151-167",
    "snippet": "void PrintHeader() {\n    const int kKeySize = 16;\n    PrintEnvironment();\n    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n    fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n            FLAGS_value_size,\n            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n    fprintf(stdout, \"Entries:    %d\\n\", num_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0));\n    fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n             / 1048576.0));\n    PrintWarnings();\n    fprintf(stdout, \"------------------------------------------------\\n\");\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_value_size = 100;",
      "static double FLAGS_compression_ratio = 0.5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"------------------------------------------------\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintWarnings",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "PrintWarnings",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "169-179",
          "snippet": "void PrintWarnings() {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n    fprintf(stdout,\n            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n            );\n#endif\n#ifndef NDEBUG\n    fprintf(stdout,\n            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintWarnings() {\n  #if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(stdout,\n              \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n              );\n  #endif\n  #ifndef NDEBUG\n      fprintf(stdout,\n              \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n  #endif\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"FileSize:   %.1f MB (estimated)\\n\"",
            "(((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n             / 1048576.0)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"RawSize:    %.1f MB (estimated)\\n\"",
            "((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int64_t>",
          "args": [
            "kKeySize + FLAGS_value_size"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Entries:    %d\\n\"",
            "num_"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Values:     %d bytes each (%d bytes after compression)\\n\"",
            "FLAGS_value_size",
            "static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "FLAGS_value_size * FLAGS_compression_ratio + 0.5"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Keys:       %d bytes each\\n\"",
            "kKeySize"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintEnvironment",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "PrintEnvironment",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
          "lines": "181-214",
          "snippet": "void PrintEnvironment() {\n    fprintf(stderr, \"Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\\n\",\n            kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);\n\n#if defined(__linux)\n    time_t now = time(NULL);\n    fprintf(stderr, \"Date:           %s\", ctime(&now));  // ctime() adds newline\n\n    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n    if (cpuinfo != NULL) {\n      char line[1000];\n      int num_cpus = 0;\n      std::string cpu_type;\n      std::string cache_size;\n      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        const char* sep = strchr(line, ':');\n        if (sep == NULL) {\n          continue;\n        }\n        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n        Slice val = TrimSpace(Slice(sep + 1));\n        if (key == \"model name\") {\n          ++num_cpus;\n          cpu_type = val.ToString();\n        } else if (key == \"cache size\") {\n          cache_size = val.ToString();\n        }\n      }\n      fclose(cpuinfo);\n      fprintf(stderr, \"CPU:            %d * %s\\n\", num_cpus, cpu_type.c_str());\n      fprintf(stderr, \"CPUCache:       %s\\n\", cache_size.c_str());\n    }\n#endif\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <kcpolydb.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintEnvironment() {\n      fprintf(stderr, \"Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\\n\",\n              kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);\n  \n  #if defined(__linux)\n      time_t now = time(NULL);\n      fprintf(stderr, \"Date:           %s\", ctime(&now));  // ctime() adds newline\n  \n      FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n      if (cpuinfo != NULL) {\n        char line[1000];\n        int num_cpus = 0;\n        std::string cpu_type;\n        std::string cache_size;\n        while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n          const char* sep = strchr(line, ':');\n          if (sep == NULL) {\n            continue;\n          }\n          Slice key = TrimSpace(Slice(line, sep - 1 - line));\n          Slice val = TrimSpace(Slice(sep + 1));\n          if (key == \"model name\") {\n            ++num_cpus;\n            cpu_type = val.ToString();\n          } else if (key == \"cache size\") {\n            cache_size = val.ToString();\n          }\n        }\n        fclose(cpuinfo);\n        fprintf(stderr, \"CPU:            %d * %s\\n\", num_cpus, cpu_type.c_str());\n        fprintf(stderr, \"CPUCache:       %s\\n\", cache_size.c_str());\n      }\n  #endif\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_value_size = 100;\nstatic double FLAGS_compression_ratio = 0.5;\n\nBenchmark {\n  void PrintHeader() {\n      const int kKeySize = 16;\n      PrintEnvironment();\n      fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n      fprintf(stdout, \"Values:     %d bytes each (%d bytes after compression)\\n\",\n              FLAGS_value_size,\n              static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));\n      fprintf(stdout, \"Entries:    %d\\n\", num_);\n      fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n              ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n               / 1048576.0));\n      fprintf(stdout, \"FileSize:   %.1f MB (estimated)\\n\",\n              (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)\n               / 1048576.0));\n      PrintWarnings();\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n}"
  },
  {
    "function_name": "TrimSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "118-128",
    "snippet": "static Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "s.data() + start",
            "limit - start"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.data",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "s[limit-1]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "s[start]"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}"
  },
  {
    "function_name": "Generate",
    "container": "RandomGenerator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "108-115",
    "snippet": "Slice Generate(int len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "data_.data() + pos_ - len",
            "len"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_.data",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len < data_.size()"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_.size",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nRandomGenerator {\n  Slice Generate(int len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
  },
  {
    "function_name": "RandomGenerator",
    "container": "RandomGenerator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "93-106",
    "snippet": "RandomGenerator() {\n    // We use a limited amount of data over and over again and ensure\n    // that it is larger than the compression window (32KB), and also\n    // large enough to serve all typical value sizes we want to write.\n    Random rnd(301);\n    std::string piece;\n    while (data_.size() < 1048576) {\n      // Add a short fragment that is as compressible as specified\n      // by FLAGS_compression_ratio.\n      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n      data_.append(piece);\n    }\n    pos_ = 0;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static double FLAGS_compression_ratio = 0.5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data_.append",
          "args": [
            "piece"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::CompressibleString",
          "args": [
            "&rnd",
            "FLAGS_compression_ratio",
            "100",
            "&piece"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "CompressibleString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testutil.cc",
          "lines": "34-48",
          "snippet": "extern Slice CompressibleString(Random* rnd, double compressed_fraction,\n                                size_t len, std::string* dst) {\n  int raw = static_cast<int>(len * compressed_fraction);\n  if (raw < 1) raw = 1;\n  std::string raw_data;\n  RandomString(rnd, raw, &raw_data);\n\n  // Duplicate the random data until we have filled \"len\" bytes\n  dst->clear();\n  while (dst->size() < len) {\n    dst->append(raw_data);\n  }\n  dst->resize(len);\n  return Slice(*dst);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/testutil.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/testutil.h\"\n\nextern Slice CompressibleString(Random* rnd, double compressed_fraction,\n                                size_t len, std::string* dst) {\n  int raw = static_cast<int>(len * compressed_fraction);\n  if (raw < 1) raw = 1;\n  std::string raw_data;\n  RandomString(rnd, raw, &raw_data);\n\n  // Duplicate the random data until we have filled \"len\" bytes\n  dst->clear();\n  while (dst->size() < len) {\n    dst->append(raw_data);\n  }\n  dst->resize(len);\n  return Slice(*dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_.size",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic double FLAGS_compression_ratio = 0.5;\n\nRandomGenerator {\n  RandomGenerator() {\n      // We use a limited amount of data over and over again and ensure\n      // that it is larger than the compression window (32KB), and also\n      // large enough to serve all typical value sizes we want to write.\n      Random rnd(301);\n      std::string piece;\n      while (data_.size() < 1048576) {\n        // Add a short fragment that is as compressible as specified\n        // by FLAGS_compression_ratio.\n        test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n        data_.append(piece);\n      }\n      pos_ = 0;\n    }\n}"
  },
  {
    "function_name": "DBSynchronize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_tree_db.cc",
    "lines": "74-81",
    "snippet": "inline\nstatic void DBSynchronize(kyotocabinet::TreeDB* db_)\n{\n  // Synchronize will flush writes to disk\n  if (!db_->synchronize()) {\n    fprintf(stderr, \"synchronize error: %s\\n\", db_->error().name());\n  }\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <kcpolydb.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"synchronize error: %s\\n\"",
            "db_->error().name()"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->error",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->error",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->synchronize",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <kcpolydb.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void DBSynchronize(kyotocabinet::TreeDB* db_)\n{\n  // Synchronize will flush writes to disk\n  if (!db_->synchronize()) {\n    fprintf(stderr, \"synchronize error: %s\\n\", db_->error().name());\n  }\n}"
  }
]