[
  {
    "function_name": "KeyMayMatch",
    "container": "BloomFilterPolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/bloom.cc",
    "lines": "63-87",
    "snippet": "virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {\n    const size_t len = bloom_filter.size();\n    if (len < 2) return false;\n\n    const char* array = bloom_filter.data();\n    const size_t bits = (len - 1) * 8;\n\n    // Use the encoded k so that we can read filters generated by\n    // bloom filters created using different parameters.\n    const size_t k = array[len-1];\n    if (k > 30) {\n      // Reserved for potentially new encodings for short bloom filters.\n      // Consider it a match.\n      return true;\n    }\n\n    uint32_t h = BloomHash(key);\n    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits\n    for (size_t j = 0; j < k; j++) {\n      const uint32_t bitpos = h % bits;\n      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;\n      h += delta;\n    }\n    return true;\n  }",
    "includes": [
      "#include \"util/hash.h\"",
      "#include \"leveldb/slice.h\"",
      "#include \"leveldb/filter_policy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BloomHash",
          "args": [
            "key"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "BloomHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/bloom.cc",
          "lines": "13-15",
          "snippet": "static uint32_t BloomHash(const Slice& key) {\n  return Hash(key.data(), key.size(), 0xbc9f1d34);\n}",
          "includes": [
            "#include \"util/hash.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/hash.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n\nstatic uint32_t BloomHash(const Slice& key) {\n  return Hash(key.data(), key.size(), 0xbc9f1d34);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bloom_filter.data",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bloom_filter.size",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/hash.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n\nBloomFilterPolicy {\n  virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {\n      const size_t len = bloom_filter.size();\n      if (len < 2) return false;\n  \n      const char* array = bloom_filter.data();\n      const size_t bits = (len - 1) * 8;\n  \n      // Use the encoded k so that we can read filters generated by\n      // bloom filters created using different parameters.\n      const size_t k = array[len-1];\n      if (k > 30) {\n        // Reserved for potentially new encodings for short bloom filters.\n        // Consider it a match.\n        return true;\n      }\n  \n      uint32_t h = BloomHash(key);\n      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits\n      for (size_t j = 0; j < k; j++) {\n        const uint32_t bitpos = h % bits;\n        if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;\n        h += delta;\n      }\n      return true;\n    }\n}"
  },
  {
    "function_name": "CreateFilter",
    "container": "BloomFilterPolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/bloom.cc",
    "lines": "35-61",
    "snippet": "virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n    // Compute bloom filter size (in both bits and bytes)\n    size_t bits = n * bits_per_key_;\n\n    // For small n, we can see a very high false positive rate.  Fix it\n    // by enforcing a minimum bloom filter length.\n    if (bits < 64) bits = 64;\n\n    size_t bytes = (bits + 7) / 8;\n    bits = bytes * 8;\n\n    const size_t init_size = dst->size();\n    dst->resize(init_size + bytes, 0);\n    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter\n    char* array = &(*dst)[init_size];\n    for (size_t i = 0; i < n; i++) {\n      // Use double-hashing to generate a sequence of hash values.\n      // See analysis in [Kirsch,Mitzenmacher 2006].\n      uint32_t h = BloomHash(keys[i]);\n      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits\n      for (size_t j = 0; j < k_; j++) {\n        const uint32_t bitpos = h % bits;\n        array[bitpos/8] |= (1 << (bitpos % 8));\n        h += delta;\n      }\n    }\n  }",
    "includes": [
      "#include \"util/hash.h\"",
      "#include \"leveldb/slice.h\"",
      "#include \"leveldb/filter_policy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BloomHash",
          "args": [
            "keys[i]"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "BloomHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/bloom.cc",
          "lines": "13-15",
          "snippet": "static uint32_t BloomHash(const Slice& key) {\n  return Hash(key.data(), key.size(), 0xbc9f1d34);\n}",
          "includes": [
            "#include \"util/hash.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/hash.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n\nstatic uint32_t BloomHash(const Slice& key) {\n  return Hash(key.data(), key.size(), 0xbc9f1d34);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dst->push_back",
          "args": [
            "static_cast<char>(k_)"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "k_"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->resize",
          "args": [
            "init_size + bytes",
            "0"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->size",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/hash.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n\nBloomFilterPolicy {\n  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n      // Compute bloom filter size (in both bits and bytes)\n      size_t bits = n * bits_per_key_;\n  \n      // For small n, we can see a very high false positive rate.  Fix it\n      // by enforcing a minimum bloom filter length.\n      if (bits < 64) bits = 64;\n  \n      size_t bytes = (bits + 7) / 8;\n      bits = bytes * 8;\n  \n      const size_t init_size = dst->size();\n      dst->resize(init_size + bytes, 0);\n      dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter\n      char* array = &(*dst)[init_size];\n      for (size_t i = 0; i < n; i++) {\n        // Use double-hashing to generate a sequence of hash values.\n        // See analysis in [Kirsch,Mitzenmacher 2006].\n        uint32_t h = BloomHash(keys[i]);\n        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits\n        for (size_t j = 0; j < k_; j++) {\n          const uint32_t bitpos = h % bits;\n          array[bitpos/8] |= (1 << (bitpos % 8));\n          h += delta;\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "BloomFilterPolicy",
    "container": "BloomFilterPolicy",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/bloom.cc",
    "lines": "23-29",
    "snippet": "explicit BloomFilterPolicy(int bits_per_key)\n      : bits_per_key_(bits_per_key) {\n    // We intentionally round down to reduce probing cost a little bit\n    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)\n    if (k_ < 1) k_ = 1;\n    if (k_ > 30) k_ = 30;\n  }",
    "includes": [
      "#include \"util/hash.h\"",
      "#include \"leveldb/slice.h\"",
      "#include \"leveldb/filter_policy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "bits_per_key * 0.69"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/hash.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n\nBloomFilterPolicy {\n  explicit BloomFilterPolicy(int bits_per_key)\n        : bits_per_key_(bits_per_key) {\n      // We intentionally round down to reduce probing cost a little bit\n      k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)\n      if (k_ < 1) k_ = 1;\n      if (k_ > 30) k_ = 30;\n    }\n}"
  },
  {
    "function_name": "BloomHash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/bloom.cc",
    "lines": "13-15",
    "snippet": "static uint32_t BloomHash(const Slice& key) {\n  return Hash(key.data(), key.size(), 0xbc9f1d34);\n}",
    "includes": [
      "#include \"util/hash.h\"",
      "#include \"leveldb/slice.h\"",
      "#include \"leveldb/filter_policy.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "key.data()",
            "key.size()",
            "0xbc9f1d34"
          ],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/hash.cc",
          "lines": "18-49",
          "snippet": "uint32_t Hash(const char* data, size_t n, uint32_t seed) {\n  // Similar to murmur hash\n  const uint32_t m = 0xc6a4a793;\n  const uint32_t r = 24;\n  const char* limit = data + n;\n  uint32_t h = seed ^ (n * m);\n\n  // Pick up four bytes at a time\n  while (data + 4 <= limit) {\n    uint32_t w = DecodeFixed32(data);\n    data += 4;\n    h += w;\n    h *= m;\n    h ^= (h >> 16);\n  }\n\n  // Pick up remaining bytes\n  switch (limit - data) {\n    case 3:\n      h += data[2] << 16;\n      FALLTHROUGH_INTENDED;\n    case 2:\n      h += data[1] << 8;\n      FALLTHROUGH_INTENDED;\n    case 1:\n      h += data[0];\n      h *= m;\n      h ^= (h >> r);\n      break;\n  }\n  return h;\n}",
          "includes": [
            "#include \"util/hash.h\"",
            "#include \"util/coding.h\"",
            "#include <string.h>"
          ],
          "macros_used": [
            "#define FALLTHROUGH_INTENDED do { } while (0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/hash.h\"\n#include \"util/coding.h\"\n#include <string.h>\n\n#define FALLTHROUGH_INTENDED do { } while (0)\n\nuint32_t Hash(const char* data, size_t n, uint32_t seed) {\n  // Similar to murmur hash\n  const uint32_t m = 0xc6a4a793;\n  const uint32_t r = 24;\n  const char* limit = data + n;\n  uint32_t h = seed ^ (n * m);\n\n  // Pick up four bytes at a time\n  while (data + 4 <= limit) {\n    uint32_t w = DecodeFixed32(data);\n    data += 4;\n    h += w;\n    h *= m;\n    h ^= (h >> 16);\n  }\n\n  // Pick up remaining bytes\n  switch (limit - data) {\n    case 3:\n      h += data[2] << 16;\n      FALLTHROUGH_INTENDED;\n    case 2:\n      h += data[1] << 8;\n      FALLTHROUGH_INTENDED;\n    case 1:\n      h += data[0];\n      h *= m;\n      h ^= (h >> r);\n      break;\n  }\n  return h;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.size",
          "args": [],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.data",
          "args": [],
          "line": 14
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/hash.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n\nstatic uint32_t BloomHash(const Slice& key) {\n  return Hash(key.data(), key.size(), 0xbc9f1d34);\n}"
  }
]