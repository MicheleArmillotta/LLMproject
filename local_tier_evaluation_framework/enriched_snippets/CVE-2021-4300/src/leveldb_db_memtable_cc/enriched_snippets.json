[
  {
    "function_name": "Get",
    "container": "MemTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "108-143",
    "snippet": "bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {\n  Slice memkey = key.memtable_key();\n  Table::Iterator iter(&table_);\n  iter.Seek(memkey.data());\n  if (iter.Valid()) {\n    // entry format is:\n    //    klength  varint32\n    //    userkey  char[klength]\n    //    tag      uint64\n    //    vlength  varint32\n    //    value    char[vlength]\n    // Check that it belongs to same user key.  We do not check the\n    // sequence number since the Seek() call above should have skipped\n    // all entries with overly large sequence numbers.\n    const char* entry = iter.key();\n    uint32_t key_length;\n    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);\n    if (comparator_.comparator.user_comparator()->Compare(\n            Slice(key_ptr, key_length - 8),\n            key.user_key()) == 0) {\n      // Correct user key\n      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);\n      switch (static_cast<ValueType>(tag & 0xff)) {\n        case kTypeValue: {\n          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);\n          value->assign(v.data(), v.size());\n          return true;\n        }\n        case kTypeDeletion:\n          *s = Status::NotFound(Slice());\n          return true;\n      }\n    }\n  }\n  return false;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::NotFound",
          "args": [
            "Slice()"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "NotFound",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "35-37",
          "snippet": "static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kNotFound, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kNotFound, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "66-66",
          "snippet": "std::string ToString() const { return std::string(data_, size_); }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  std::string ToString() const { return std::string(data_, size_); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value->assign",
          "args": [
            "v.data()",
            "v.size()"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.size",
          "args": [],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "TransactionTablePriv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "170-173",
          "snippet": "int size()\n    {\n        return cachedWallet.size();\n    }",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTablePriv {\n  int size()\n      {\n          return cachedWallet.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.data",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLengthPrefixedSlice",
          "args": [
            "key_ptr + key_length"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<ValueType>",
          "args": [
            "tag & 0xff"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeFixed64",
          "args": [
            "key_ptr + key_length - 8"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "72-83",
          "snippet": "inline uint64_t DecodeFixed64(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint64_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    uint64_t lo = DecodeFixed32(ptr);\n    uint64_t hi = DecodeFixed32(ptr + 4);\n    return (hi << 32) | lo;\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint64_t DecodeFixed64(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint64_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    uint64_t lo = DecodeFixed32(ptr);\n    uint64_t hi = DecodeFixed32(ptr + 4);\n    return (hi << 32) | lo;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "comparator_.comparator.user_comparator",
          "args": [
            "Slice(key_ptr, key_length - 8)",
            "key.user_key()"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.user_key",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "comparator_.comparator.user_comparator",
          "args": [],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetVarint32Ptr",
          "args": [
            "entry",
            "entry+5",
            "&key_length"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter.key",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "61-61",
          "snippet": "virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter.Valid",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "55-55",
          "snippet": "virtual bool Valid() const { return iter_.Valid(); }",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual bool Valid() const { return iter_.Valid(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter.Seek",
          "args": [
            "memkey.data()"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "56-56",
          "snippet": "virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memkey.data",
          "args": [],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.memtable_key",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "memtable_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "198-198",
          "snippet": "Slice memtable_key() const { return Slice(start_, end_ - start_); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice memtable_key() const { return Slice(start_, end_ - start_); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {\n    Slice memkey = key.memtable_key();\n    Table::Iterator iter(&table_);\n    iter.Seek(memkey.data());\n    if (iter.Valid()) {\n      // entry format is:\n      //    klength  varint32\n      //    userkey  char[klength]\n      //    tag      uint64\n      //    vlength  varint32\n      //    value    char[vlength]\n      // Check that it belongs to same user key.  We do not check the\n      // sequence number since the Seek() call above should have skipped\n      // all entries with overly large sequence numbers.\n      const char* entry = iter.key();\n      uint32_t key_length;\n      const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);\n      if (comparator_.comparator.user_comparator()->Compare(\n              Slice(key_ptr, key_length - 8),\n              key.user_key()) == 0) {\n        // Correct user key\n        const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);\n        switch (static_cast<ValueType>(tag & 0xff)) {\n          case kTypeValue: {\n            Slice v = GetLengthPrefixedSlice(key_ptr + key_length);\n            value->assign(v.data(), v.size());\n            return true;\n          }\n          case kTypeDeletion:\n            *s = Status::NotFound(Slice());\n            return true;\n        }\n      }\n    }\n    return false;\n  }\n}"
  },
  {
    "function_name": "Add",
    "container": "MemTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "82-106",
    "snippet": "void MemTable::Add(SequenceNumber s, ValueType type,\n                   const Slice& key,\n                   const Slice& value) {\n  // Format of an entry is concatenation of:\n  //  key_size     : varint32 of internal_key.size()\n  //  key bytes    : char[internal_key.size()]\n  //  value_size   : varint32 of value.size()\n  //  value bytes  : char[value.size()]\n  size_t key_size = key.size();\n  size_t val_size = value.size();\n  size_t internal_key_size = key_size + 8;\n  const size_t encoded_len =\n      VarintLength(internal_key_size) + internal_key_size +\n      VarintLength(val_size) + val_size;\n  char* buf = arena_.Allocate(encoded_len);\n  char* p = EncodeVarint32(buf, internal_key_size);\n  memcpy(p, key.data(), key_size);\n  p += key_size;\n  EncodeFixed64(p, (s << 8) | type);\n  p += 8;\n  p = EncodeVarint32(p, val_size);\n  memcpy(p, value.data(), val_size);\n  assert((p + val_size) - buf == encoded_len);\n  table_.Insert(buf);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "table_.Insert",
          "args": [
            "buf"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "Insert",
          "container": "SkipList<Key,Comparator>",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/skiplist.h",
          "lines": "334-367",
          "snippet": "void SkipList<Key,Comparator>::Insert(const Key& key) {\n  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()\n  // here since Insert() is externally synchronized.\n  Node* prev[kMaxHeight];\n  Node* x = FindGreaterOrEqual(key, prev);\n\n  // Our data structure does not allow duplicate insertion\n  assert(x == NULL || !Equal(key, x->key));\n\n  int height = RandomHeight();\n  if (height > GetMaxHeight()) {\n    for (int i = GetMaxHeight(); i < height; i++) {\n      prev[i] = head_;\n    }\n    //fprintf(stderr, \"Change height from %d to %d\\n\", max_height_, height);\n\n    // It is ok to mutate max_height_ without any synchronization\n    // with concurrent readers.  A concurrent reader that observes\n    // the new value of max_height_ will see either the old value of\n    // new level pointers from head_ (NULL), or a new value set in\n    // the loop below.  In the former case the reader will\n    // immediately drop to the next level since NULL sorts after all\n    // keys.  In the latter case the reader will use the new node.\n    max_height_.NoBarrier_Store(reinterpret_cast<void*>(height));\n  }\n\n  x = NewNode(key, height);\n  for (int i = 0; i < height; i++) {\n    // NoBarrier_SetNext() suffices since we will add a barrier when\n    // we publish a pointer to \"x\" in prev[i].\n    x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));\n    prev[i]->SetNext(i, x);\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/arena.h\"",
            "#include \"port/port.h\"",
            "#include <stdlib.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/arena.h\"\n#include \"port/port.h\"\n#include <stdlib.h>\n#include <assert.h>\n\nSkipList<Key,Comparator> {\n  void SkipList<Key,Comparator>::Insert(const Key& key) {\n    // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()\n    // here since Insert() is externally synchronized.\n    Node* prev[kMaxHeight];\n    Node* x = FindGreaterOrEqual(key, prev);\n  \n    // Our data structure does not allow duplicate insertion\n    assert(x == NULL || !Equal(key, x->key));\n  \n    int height = RandomHeight();\n    if (height > GetMaxHeight()) {\n      for (int i = GetMaxHeight(); i < height; i++) {\n        prev[i] = head_;\n      }\n      //fprintf(stderr, \"Change height from %d to %d\\n\", max_height_, height);\n  \n      // It is ok to mutate max_height_ without any synchronization\n      // with concurrent readers.  A concurrent reader that observes\n      // the new value of max_height_ will see either the old value of\n      // new level pointers from head_ (NULL), or a new value set in\n      // the loop below.  In the former case the reader will\n      // immediately drop to the next level since NULL sorts after all\n      // keys.  In the latter case the reader will use the new node.\n      max_height_.NoBarrier_Store(reinterpret_cast<void*>(height));\n    }\n  \n    x = NewNode(key, height);\n    for (int i = 0; i < height; i++) {\n      // NoBarrier_SetNext() suffices since we will add a barrier when\n      // we publish a pointer to \"x\" in prev[i].\n      x->NoBarrier_SetNext(i, prev[i]->NoBarrier_Next(i));\n      prev[i]->SetNext(i, x);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "(p + val_size) - buf == encoded_len"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "value.data()",
            "val_size"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "value.data",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeVarint32",
          "args": [
            "p",
            "val_size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeFixed64",
          "args": [
            "p",
            "(s << 8) | type"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeFixed64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "20-33",
          "snippet": "void EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "key.data()",
            "key_size"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.data",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeVarint32",
          "args": [
            "buf",
            "internal_key_size"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arena_.Allocate",
          "args": [
            "encoded_len"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VarintLength",
          "args": [
            "val_size"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "VarintLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "103-110",
          "snippet": "int VarintLength(uint64_t v) {\n  int len = 1;\n  while (v >= 128) {\n    v >>= 7;\n    len++;\n  }\n  return len;\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nint VarintLength(uint64_t v) {\n  int len = 1;\n  while (v >= 128) {\n    v >>= 7;\n    len++;\n  }\n  return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "value.size",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  void MemTable::Add(SequenceNumber s, ValueType type,\n                     const Slice& key,\n                     const Slice& value) {\n    // Format of an entry is concatenation of:\n    //  key_size     : varint32 of internal_key.size()\n    //  key bytes    : char[internal_key.size()]\n    //  value_size   : varint32 of value.size()\n    //  value bytes  : char[value.size()]\n    size_t key_size = key.size();\n    size_t val_size = value.size();\n    size_t internal_key_size = key_size + 8;\n    const size_t encoded_len =\n        VarintLength(internal_key_size) + internal_key_size +\n        VarintLength(val_size) + val_size;\n    char* buf = arena_.Allocate(encoded_len);\n    char* p = EncodeVarint32(buf, internal_key_size);\n    memcpy(p, key.data(), key_size);\n    p += key_size;\n    EncodeFixed64(p, (s << 8) | type);\n    p += 8;\n    p = EncodeVarint32(p, val_size);\n    memcpy(p, value.data(), val_size);\n    assert((p + val_size) - buf == encoded_len);\n    table_.Insert(buf);\n  }\n}"
  },
  {
    "function_name": "status",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "67-67",
    "snippet": "virtual Status status() const { return Status::OK(); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual Status status() const { return Status::OK(); }\n}"
  },
  {
    "function_name": "value",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "62-65",
    "snippet": "virtual Slice value() const {\n    Slice key_slice = GetLengthPrefixedSlice(iter_.key());\n    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());\n  }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetLengthPrefixedSlice",
          "args": [
            "key_slice.data() + key_slice.size()"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_slice.size",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_slice.data",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter_.key",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "61-61",
          "snippet": "virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual Slice value() const {\n      Slice key_slice = GetLengthPrefixedSlice(iter_.key());\n      return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());\n    }\n}"
  },
  {
    "function_name": "key",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "61-61",
    "snippet": "virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetLengthPrefixedSlice",
          "args": [
            "iter_.key()"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_.key",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "61-61",
          "snippet": "virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }\n}"
  },
  {
    "function_name": "Prev",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "60-60",
    "snippet": "virtual void Prev() { iter_.Prev(); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_.Prev",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "Prev",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "60-60",
          "snippet": "virtual void Prev() { iter_.Prev(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual void Prev() { iter_.Prev(); }\n}"
  },
  {
    "function_name": "Next",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "59-59",
    "snippet": "virtual void Next() { iter_.Next(); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_.Next",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "59-59",
          "snippet": "virtual void Next() { iter_.Next(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual void Next() { iter_.Next(); }\n}"
  },
  {
    "function_name": "SeekToLast",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "58-58",
    "snippet": "virtual void SeekToLast() { iter_.SeekToLast(); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_.SeekToLast",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToLast",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "58-58",
          "snippet": "virtual void SeekToLast() { iter_.SeekToLast(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual void SeekToLast() { iter_.SeekToLast(); }\n}"
  },
  {
    "function_name": "SeekToFirst",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "57-57",
    "snippet": "virtual void SeekToFirst() { iter_.SeekToFirst(); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_.SeekToFirst",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "57-57",
          "snippet": "virtual void SeekToFirst() { iter_.SeekToFirst(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual void SeekToFirst() { iter_.SeekToFirst(); }\n}"
  },
  {
    "function_name": "Seek",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "56-56",
    "snippet": "virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_.Seek",
          "args": [
            "EncodeKey(&tmp_, k)"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "56-56",
          "snippet": "virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "EncodeKey",
          "args": [
            "&tmp_",
            "k"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }\n}"
  },
  {
    "function_name": "Valid",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "55-55",
    "snippet": "virtual bool Valid() const { return iter_.Valid(); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_.Valid",
          "args": [],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "MemTableIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "55-55",
          "snippet": "virtual bool Valid() const { return iter_.Valid(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  virtual bool Valid() const { return iter_.Valid(); }\n}"
  },
  {
    "function_name": "MemTableIterator",
    "container": "MemTableIterator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "53-53",
    "snippet": "explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTableIterator {\n  explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }\n}"
  },
  {
    "function_name": "operator()",
    "container": "MemTable::KeyComparator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "33-39",
    "snippet": "int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)\n    const {\n  // Internal keys are encoded as length-prefixed strings.\n  Slice a = GetLengthPrefixedSlice(aptr);\n  Slice b = GetLengthPrefixedSlice(bptr);\n  return comparator.Compare(a, b);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "comparator.Compare",
          "args": [
            "a",
            "b"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLengthPrefixedSlice",
          "args": [
            "bptr"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  KeyComparator {\n    int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)\n        const {\n      // Internal keys are encoded as length-prefixed strings.\n      Slice a = GetLengthPrefixedSlice(aptr);\n      Slice b = GetLengthPrefixedSlice(bptr);\n      return comparator.Compare(a, b);\n    }\n  }\n}"
  },
  {
    "function_name": "ApproximateMemoryUsage",
    "container": "MemTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "31-31",
    "snippet": "size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arena_.MemoryUsage",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "MemoryUsage",
          "container": "Arena",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/arena.h",
          "lines": "29-31",
          "snippet": "size_t MemoryUsage() const {\n    return blocks_memory_ + blocks_.capacity() * sizeof(char*);\n  }",
          "includes": [
            "#include <stdint.h>",
            "#include <stddef.h>",
            "#include <assert.h>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stddef.h>\n#include <assert.h>\n#include <vector>\n\nArena {\n  size_t MemoryUsage() const {\n      return blocks_memory_ + blocks_.capacity() * sizeof(char*);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }\n}"
  },
  {
    "function_name": "~MemTable",
    "container": "MemTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "27-29",
    "snippet": "MemTable::~MemTable() {\n  assert(refs_ == 0);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "refs_ == 0"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  MemTable::~MemTable() {\n    assert(refs_ == 0);\n  }\n}"
  },
  {
    "function_name": "MemTable",
    "container": "MemTable",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "21-25",
    "snippet": "MemTable::MemTable(const InternalKeyComparator& cmp)\n    : comparator_(cmp),\n      refs_(0),\n      table_(comparator_, &arena_) {\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nMemTable {\n  MemTable::MemTable(const InternalKeyComparator& cmp)\n      : comparator_(cmp),\n        refs_(0),\n        table_(comparator_, &arena_) {\n  }\n}"
  },
  {
    "function_name": "GetLengthPrefixedSlice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
    "lines": "14-19",
    "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/memtable.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "p",
            "len"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "GetVarint32Ptr",
          "args": [
            "p",
            "p + 5",
            "&len"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
  }
]