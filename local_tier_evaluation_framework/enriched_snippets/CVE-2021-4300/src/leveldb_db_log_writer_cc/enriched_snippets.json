[
  {
    "function_name": "EmitPhysicalRecord",
    "container": "Writer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
    "lines": "75-100",
    "snippet": "Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {\n  assert(n <= 0xffff);  // Must fit in two bytes\n  assert(block_offset_ + kHeaderSize + n <= kBlockSize);\n\n  // Format the header\n  char buf[kHeaderSize];\n  buf[4] = static_cast<char>(n & 0xff);\n  buf[5] = static_cast<char>(n >> 8);\n  buf[6] = static_cast<char>(t);\n\n  // Compute the crc of the record type and the payload.\n  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);\n  crc = crc32c::Mask(crc);                 // Adjust for storage\n  EncodeFixed32(buf, crc);\n\n  // Write the header and the payload\n  Status s = dest_->Append(Slice(buf, kHeaderSize));\n  if (s.ok()) {\n    s = dest_->Append(Slice(ptr, n));\n    if (s.ok()) {\n      s = dest_->Flush();\n    }\n  }\n  block_offset_ += kHeaderSize + n;\n  return s;\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdint.h>",
      "#include \"db/log_writer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dest_->Flush",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "Flush",
          "container": "LogTest::StringDest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "46-46",
          "snippet": "virtual Status Flush() { return Status::OK(); }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringDest {\n    virtual Status Flush() { return Status::OK(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dest_->Append",
          "args": [
            "Slice(ptr, n)"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "Append",
          "container": "LogTest::StringDest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "48-51",
          "snippet": "virtual Status Append(const Slice& slice) {\n      contents_.append(slice.data(), slice.size());\n      return Status::OK();\n    }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringDest {\n    virtual Status Append(const Slice& slice) {\n          contents_.append(slice.data(), slice.size());\n          return Status::OK();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "ptr",
            "n"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeFixed32",
          "args": [
            "buf",
            "crc"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "9-18",
          "snippet": "void EncodeFixed32(char* buf, uint32_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid EncodeFixed32(char* buf, uint32_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c::Mask",
          "args": [
            "crc"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "Mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/crc32c.h",
          "lines": "31-34",
          "snippet": "inline uint32_t Mask(uint32_t crc) {\n  // Rotate right by 15 bits and add a constant.\n  return ((crc >> 15) | (crc << 17)) + kMaskDelta;\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stddef.h>\n\ninline uint32_t Mask(uint32_t crc) {\n  // Rotate right by 15 bits and add a constant.\n  return ((crc >> 15) | (crc << 17)) + kMaskDelta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c::Extend",
          "args": [
            "type_crc_[t]",
            "ptr",
            "n"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "Extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/crc32c.cc",
          "lines": "286-329",
          "snippet": "uint32_t Extend(uint32_t crc, const char* buf, size_t size) {\n  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n  const uint8_t *e = p + size;\n  uint32_t l = crc ^ 0xffffffffu;\n\n#define STEP1 do {                              \\\n    int c = (l & 0xff) ^ *p++;                  \\\n    l = table0_[c] ^ (l >> 8);                  \\\n} while (0)\n#define STEP4 do {                              \\\n    uint32_t c = l ^ LE_LOAD32(p);              \\\n    p += 4;                                     \\\n    l = table3_[c & 0xff] ^                     \\\n        table2_[(c >> 8) & 0xff] ^              \\\n        table1_[(c >> 16) & 0xff] ^             \\\n        table0_[c >> 24];                       \\\n} while (0)\n\n  // Point x at first 4-byte aligned byte in string.  This might be\n  // just past the end of the string.\n  const uintptr_t pval = reinterpret_cast<uintptr_t>(p);\n  const uint8_t* x = reinterpret_cast<const uint8_t*>(((pval + 3) >> 2) << 2);\n  if (x <= e) {\n    // Process bytes until finished or p is 4-byte aligned\n    while (p != x) {\n      STEP1;\n    }\n  }\n  // Process bytes 16 at a time\n  while ((e-p) >= 16) {\n    STEP4; STEP4; STEP4; STEP4;\n  }\n  // Process bytes 4 at a time\n  while ((e-p) >= 4) {\n    STEP4;\n  }\n  // Process the last few bytes\n  while (p != e) {\n    STEP1;\n  }\n#undef STEP4\n#undef STEP1\n  return l ^ 0xffffffffu;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include <stdint.h>",
            "#include \"util/crc32c.h\""
          ],
          "macros_used": [
            "#define STEP4 do {                              \\\n    uint32_t c = l ^ LE_LOAD32(p);              \\\n    p += 4;                                     \\\n    l = table3_[c & 0xff] ^                     \\\n        table2_[(c >> 8) & 0xff] ^              \\\n        table1_[(c >> 16) & 0xff] ^             \\\n        table0_[c >> 24];                       \\\n} while (0)",
            "#define STEP1 do {                              \\\n    int c = (l & 0xff) ^ *p++;                  \\\n    l = table0_[c] ^ (l >> 8);                  \\\n} while (0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include <stdint.h>\n#include \"util/crc32c.h\"\n\n#define STEP4 do {                              \\\n    uint32_t c = l ^ LE_LOAD32(p);              \\\n    p += 4;                                     \\\n    l = table3_[c & 0xff] ^                     \\\n        table2_[(c >> 8) & 0xff] ^              \\\n        table1_[(c >> 16) & 0xff] ^             \\\n        table0_[c >> 24];                       \\\n} while (0)\n#define STEP1 do {                              \\\n    int c = (l & 0xff) ^ *p++;                  \\\n    l = table0_[c] ^ (l >> 8);                  \\\n} while (0)\n\nuint32_t Extend(uint32_t crc, const char* buf, size_t size) {\n  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n  const uint8_t *e = p + size;\n  uint32_t l = crc ^ 0xffffffffu;\n\n#define STEP1 do {                              \\\n    int c = (l & 0xff) ^ *p++;                  \\\n    l = table0_[c] ^ (l >> 8);                  \\\n} while (0)\n#define STEP4 do {                              \\\n    uint32_t c = l ^ LE_LOAD32(p);              \\\n    p += 4;                                     \\\n    l = table3_[c & 0xff] ^                     \\\n        table2_[(c >> 8) & 0xff] ^              \\\n        table1_[(c >> 16) & 0xff] ^             \\\n        table0_[c >> 24];                       \\\n} while (0)\n\n  // Point x at first 4-byte aligned byte in string.  This might be\n  // just past the end of the string.\n  const uintptr_t pval = reinterpret_cast<uintptr_t>(p);\n  const uint8_t* x = reinterpret_cast<const uint8_t*>(((pval + 3) >> 2) << 2);\n  if (x <= e) {\n    // Process bytes until finished or p is 4-byte aligned\n    while (p != x) {\n      STEP1;\n    }\n  }\n  // Process bytes 16 at a time\n  while ((e-p) >= 16) {\n    STEP4; STEP4; STEP4; STEP4;\n  }\n  // Process bytes 4 at a time\n  while ((e-p) >= 4) {\n    STEP4;\n  }\n  // Process the last few bytes\n  while (p != e) {\n    STEP1;\n  }\n#undef STEP4\n#undef STEP1\n  return l ^ 0xffffffffu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "t"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "n >> 8"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "n & 0xff"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "block_offset_ + kHeaderSize + n <= kBlockSize"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "n <= 0xffff"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {\n    assert(n <= 0xffff);  // Must fit in two bytes\n    assert(block_offset_ + kHeaderSize + n <= kBlockSize);\n  \n    // Format the header\n    char buf[kHeaderSize];\n    buf[4] = static_cast<char>(n & 0xff);\n    buf[5] = static_cast<char>(n >> 8);\n    buf[6] = static_cast<char>(t);\n  \n    // Compute the crc of the record type and the payload.\n    uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);\n    crc = crc32c::Mask(crc);                 // Adjust for storage\n    EncodeFixed32(buf, crc);\n  \n    // Write the header and the payload\n    Status s = dest_->Append(Slice(buf, kHeaderSize));\n    if (s.ok()) {\n      s = dest_->Append(Slice(ptr, n));\n      if (s.ok()) {\n        s = dest_->Flush();\n      }\n    }\n    block_offset_ += kHeaderSize + n;\n    return s;\n  }\n}"
  },
  {
    "function_name": "AddRecord",
    "container": "Writer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
    "lines": "27-73",
    "snippet": "Status Writer::AddRecord(const Slice& slice) {\n  const char* ptr = slice.data();\n  size_t left = slice.size();\n\n  // Fragment the record if necessary and emit it.  Note that if slice\n  // is empty, we still want to iterate once to emit a single\n  // zero-length record\n  Status s;\n  bool begin = true;\n  do {\n    const int leftover = kBlockSize - block_offset_;\n    assert(leftover >= 0);\n    if (leftover < kHeaderSize) {\n      // Switch to a new block\n      if (leftover > 0) {\n        // Fill the trailer (literal below relies on kHeaderSize being 7)\n        assert(kHeaderSize == 7);\n        dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n      }\n      block_offset_ = 0;\n    }\n\n    // Invariant: we never leave < kHeaderSize bytes in a block.\n    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n\n    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n    const size_t fragment_length = (left < avail) ? left : avail;\n\n    RecordType type;\n    const bool end = (left == fragment_length);\n    if (begin && end) {\n      type = kFullType;\n    } else if (begin) {\n      type = kFirstType;\n    } else if (end) {\n      type = kLastType;\n    } else {\n      type = kMiddleType;\n    }\n\n    s = EmitPhysicalRecord(type, ptr, fragment_length);\n    ptr += fragment_length;\n    left -= fragment_length;\n    begin = false;\n  } while (s.ok() && left > 0);\n  return s;\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdint.h>",
      "#include \"db/log_writer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EmitPhysicalRecord",
          "args": [
            "type",
            "ptr",
            "fragment_length"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "EmitPhysicalRecord",
          "container": "Writer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
          "lines": "75-100",
          "snippet": "Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {\n  assert(n <= 0xffff);  // Must fit in two bytes\n  assert(block_offset_ + kHeaderSize + n <= kBlockSize);\n\n  // Format the header\n  char buf[kHeaderSize];\n  buf[4] = static_cast<char>(n & 0xff);\n  buf[5] = static_cast<char>(n >> 8);\n  buf[6] = static_cast<char>(t);\n\n  // Compute the crc of the record type and the payload.\n  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);\n  crc = crc32c::Mask(crc);                 // Adjust for storage\n  EncodeFixed32(buf, crc);\n\n  // Write the header and the payload\n  Status s = dest_->Append(Slice(buf, kHeaderSize));\n  if (s.ok()) {\n    s = dest_->Append(Slice(ptr, n));\n    if (s.ok()) {\n      s = dest_->Flush();\n    }\n  }\n  block_offset_ += kHeaderSize + n;\n  return s;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdint.h>",
            "#include \"db/log_writer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {\n    assert(n <= 0xffff);  // Must fit in two bytes\n    assert(block_offset_ + kHeaderSize + n <= kBlockSize);\n  \n    // Format the header\n    char buf[kHeaderSize];\n    buf[4] = static_cast<char>(n & 0xff);\n    buf[5] = static_cast<char>(n >> 8);\n    buf[6] = static_cast<char>(t);\n  \n    // Compute the crc of the record type and the payload.\n    uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);\n    crc = crc32c::Mask(crc);                 // Adjust for storage\n    EncodeFixed32(buf, crc);\n  \n    // Write the header and the payload\n    Status s = dest_->Append(Slice(buf, kHeaderSize));\n    if (s.ok()) {\n      s = dest_->Append(Slice(ptr, n));\n      if (s.ok()) {\n        s = dest_->Flush();\n      }\n    }\n    block_offset_ += kHeaderSize + n;\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "kBlockSize - block_offset_ - kHeaderSize >= 0"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dest_->Append",
          "args": [
            "Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover)"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Append",
          "container": "LogTest::StringDest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "48-51",
          "snippet": "virtual Status Append(const Slice& slice) {\n      contents_.append(slice.data(), slice.size());\n      return Status::OK();\n    }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringDest {\n    virtual Status Append(const Slice& slice) {\n          contents_.append(slice.data(), slice.size());\n          return Status::OK();\n        }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"\\x00\\x00\\x00\\x00\\x00\\x00\"",
            "leftover"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "kHeaderSize == 7"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "leftover >= 0"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slice.size",
          "args": [],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "slice.data",
          "args": [],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::AddRecord(const Slice& slice) {\n    const char* ptr = slice.data();\n    size_t left = slice.size();\n  \n    // Fragment the record if necessary and emit it.  Note that if slice\n    // is empty, we still want to iterate once to emit a single\n    // zero-length record\n    Status s;\n    bool begin = true;\n    do {\n      const int leftover = kBlockSize - block_offset_;\n      assert(leftover >= 0);\n      if (leftover < kHeaderSize) {\n        // Switch to a new block\n        if (leftover > 0) {\n          // Fill the trailer (literal below relies on kHeaderSize being 7)\n          assert(kHeaderSize == 7);\n          dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n        }\n        block_offset_ = 0;\n      }\n  \n      // Invariant: we never leave < kHeaderSize bytes in a block.\n      assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n  \n      const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n      const size_t fragment_length = (left < avail) ? left : avail;\n  \n      RecordType type;\n      const bool end = (left == fragment_length);\n      if (begin && end) {\n        type = kFullType;\n      } else if (begin) {\n        type = kFirstType;\n      } else if (end) {\n        type = kLastType;\n      } else {\n        type = kMiddleType;\n      }\n  \n      s = EmitPhysicalRecord(type, ptr, fragment_length);\n      ptr += fragment_length;\n      left -= fragment_length;\n      begin = false;\n    } while (s.ok() && left > 0);\n    return s;\n  }\n}"
  },
  {
    "function_name": "~Writer",
    "container": "Writer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
    "lines": "24-25",
    "snippet": "Writer::~Writer() {\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdint.h>",
      "#include \"db/log_writer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Writer::~Writer() {\n  }\n}"
  },
  {
    "function_name": "Writer",
    "container": "Writer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
    "lines": "15-22",
    "snippet": "Writer::Writer(WritableFile* dest)\n    : dest_(dest),\n      block_offset_(0) {\n  for (int i = 0; i <= kMaxRecordType; i++) {\n    char t = static_cast<char>(i);\n    type_crc_[i] = crc32c::Value(&t, 1);\n  }\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdint.h>",
      "#include \"db/log_writer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crc32c::Value",
          "args": [
            "&t",
            "1"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "i"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Writer::Writer(WritableFile* dest)\n      : dest_(dest),\n        block_offset_(0) {\n    for (int i = 0; i <= kMaxRecordType; i++) {\n      char t = static_cast<char>(i);\n      type_crc_[i] = crc32c::Value(&t, 1);\n    }\n  }\n}"
  }
]