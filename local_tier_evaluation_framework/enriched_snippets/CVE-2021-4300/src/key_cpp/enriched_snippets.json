[
  {
    "function_name": "IsValid",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "412-425",
    "snippet": "bool CKey::IsValid()\n{\n    if (!fSet)\n        return false;\n\n    if (!EC_KEY_check_key(pkey))\n        return false;\n\n    bool fCompr;\n    CSecret secret = GetSecret(fCompr);\n    CKey key2;\n    key2.SetSecret(secret, fCompr);\n    return GetPubKey() == key2.GetPubKey();\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key2.GetPubKey",
          "args": [],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key2.SetSecret",
          "args": [
            "secret",
            "fCompr"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "SetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "209-230",
          "snippet": "bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n{\n    EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n    if (vchSecret.size() != 32)\n        throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n    BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n    if (bn == NULL)\n        throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n    if (!EC_KEY_regenerate_key(pkey,bn))\n    {\n        BN_clear_free(bn);\n        throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n    }\n    BN_clear_free(bn);\n    fSet = true;\n    if (fCompressed || fCompressedPubKey)\n        SetCompressedPubKey();\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n  {\n      EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n      if (vchSecret.size() != 32)\n          throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n      BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n      if (bn == NULL)\n          throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n      if (!EC_KEY_regenerate_key(pkey,bn))\n      {\n          BN_clear_free(bn);\n          throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n      }\n      BN_clear_free(bn);\n      fSet = true;\n      if (fCompressed || fCompressedPubKey)\n          SetCompressedPubKey();\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetSecret",
          "args": [
            "fCompr"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "GetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "232-245",
          "snippet": "CSecret CKey::GetSecret(bool &fCompressed) const\n{\n    CSecret vchRet;\n    vchRet.resize(32);\n    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n    int nBytes = BN_num_bytes(bn);\n    if (bn == NULL)\n        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n    if (n != nBytes)\n        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n    fCompressed = fCompressedPubKey;\n    return vchRet;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CSecret CKey::GetSecret(bool &fCompressed) const\n  {\n      CSecret vchRet;\n      vchRet.resize(32);\n      const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n      int nBytes = BN_num_bytes(bn);\n      if (bn == NULL)\n          throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n      int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n      if (n != nBytes)\n          throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n      fCompressed = fCompressedPubKey;\n      return vchRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_check_key",
          "args": [
            "pkey"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::IsValid()\n  {\n      if (!fSet)\n          return false;\n  \n      if (!EC_KEY_check_key(pkey))\n          return false;\n  \n      bool fCompr;\n      CSecret secret = GetSecret(fCompr);\n      CKey key2;\n      key2.SetSecret(secret, fCompr);\n      return GetPubKey() == key2.GetPubKey();\n  }\n}"
  },
  {
    "function_name": "VerifyCompact",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "401-410",
    "snippet": "bool CKey::VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    CKey key;\n    if (!key.SetCompactSignature(hash, vchSig))\n        return false;\n    if (GetPubKey() != key.GetPubKey())\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetCompactSignature",
          "args": [
            "hash",
            "vchSig"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompactSignature",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "364-390",
          "snippet": "bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    if (vchSig.size() != 65)\n        return false;\n    int nV = vchSig[0];\n    if (nV<27 || nV>=35)\n        return false;\n    ECDSA_SIG *sig = ECDSA_SIG_new();\n    BN_bin2bn(&vchSig[1],32,sig->r);\n    BN_bin2bn(&vchSig[33],32,sig->s);\n\n    EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (nV >= 31)\n    {\n        SetCompressedPubKey();\n        nV -= 4;\n    }\n    if (ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), nV - 27, 0) == 1)\n    {\n        fSet = true;\n        ECDSA_SIG_free(sig);\n        return true;\n    }\n    ECDSA_SIG_free(sig);\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      if (vchSig.size() != 65)\n          return false;\n      int nV = vchSig[0];\n      if (nV<27 || nV>=35)\n          return false;\n      ECDSA_SIG *sig = ECDSA_SIG_new();\n      BN_bin2bn(&vchSig[1],32,sig->r);\n      BN_bin2bn(&vchSig[33],32,sig->s);\n  \n      EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (nV >= 31)\n      {\n          SetCompressedPubKey();\n          nV -= 4;\n      }\n      if (ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), nV - 27, 0) == 1)\n      {\n          fSet = true;\n          ECDSA_SIG_free(sig);\n          return true;\n      }\n      ECDSA_SIG_free(sig);\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      CKey key;\n      if (!key.SetCompactSignature(hash, vchSig))\n          return false;\n      if (GetPubKey() != key.GetPubKey())\n          return false;\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "Verify",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "392-399",
    "snippet": "bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    // -1 = error, 0 = bad sig, 1 = good\n    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ECDSA_verify",
          "args": [
            "0",
            "(unsigned char*)&hash",
            "sizeof(hash)",
            "&vchSig[0]",
            "vchSig.size()",
            "pkey"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.size",
          "args": [],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      // -1 = error, 0 = bad sig, 1 = good\n      if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n          return false;\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "SetCompactSignature",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "364-390",
    "snippet": "bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    if (vchSig.size() != 65)\n        return false;\n    int nV = vchSig[0];\n    if (nV<27 || nV>=35)\n        return false;\n    ECDSA_SIG *sig = ECDSA_SIG_new();\n    BN_bin2bn(&vchSig[1],32,sig->r);\n    BN_bin2bn(&vchSig[33],32,sig->s);\n\n    EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (nV >= 31)\n    {\n        SetCompressedPubKey();\n        nV -= 4;\n    }\n    if (ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), nV - 27, 0) == 1)\n    {\n        fSet = true;\n        ECDSA_SIG_free(sig);\n        return true;\n    }\n    ECDSA_SIG_free(sig);\n    return false;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ECDSA_SIG_free",
          "args": [
            "sig"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ECDSA_SIG_free",
          "args": [
            "sig"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ECDSA_SIG_recover_key_GFp",
          "args": [
            "pkey",
            "sig",
            "(unsigned char*)&hash",
            "sizeof(hash)",
            "nV - 27",
            "0"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "ECDSA_SIG_recover_key_GFp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "52-121",
          "snippet": "int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n{\n    if (!eckey) return 0;\n\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n\n    BIGNUM *x = NULL;\n    BIGNUM *e = NULL;\n    BIGNUM *order = NULL;\n    BIGNUM *sor = NULL;\n    BIGNUM *eor = NULL;\n    BIGNUM *field = NULL;\n    EC_POINT *R = NULL;\n    EC_POINT *O = NULL;\n    EC_POINT *Q = NULL;\n    BIGNUM *rr = NULL;\n    BIGNUM *zero = NULL;\n    int n = 0;\n    int i = recid / 2;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n    BN_CTX_start(ctx);\n    order = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n    x = BN_CTX_get(ctx);\n    if (!BN_copy(x, order)) { ret=-1; goto err; }\n    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n    field = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n    if (check)\n    {\n        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n    }\n    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    n = EC_GROUP_get_degree(group);\n    e = BN_CTX_get(ctx);\n    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n    zero = BN_CTX_get(ctx);\n    if (!BN_zero(zero)) { ret=-1; goto err; }\n    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n    rr = BN_CTX_get(ctx);\n    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n    sor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n    eor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n\n    ret = 1;\n\nerr:\n    if (ctx) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n    if (R != NULL) EC_POINT_free(R);\n    if (O != NULL) EC_POINT_free(O);\n    if (Q != NULL) EC_POINT_free(Q);\n    return ret;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nint ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n{\n    if (!eckey) return 0;\n\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n\n    BIGNUM *x = NULL;\n    BIGNUM *e = NULL;\n    BIGNUM *order = NULL;\n    BIGNUM *sor = NULL;\n    BIGNUM *eor = NULL;\n    BIGNUM *field = NULL;\n    EC_POINT *R = NULL;\n    EC_POINT *O = NULL;\n    EC_POINT *Q = NULL;\n    BIGNUM *rr = NULL;\n    BIGNUM *zero = NULL;\n    int n = 0;\n    int i = recid / 2;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n    BN_CTX_start(ctx);\n    order = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n    x = BN_CTX_get(ctx);\n    if (!BN_copy(x, order)) { ret=-1; goto err; }\n    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n    field = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n    if (check)\n    {\n        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n    }\n    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    n = EC_GROUP_get_degree(group);\n    e = BN_CTX_get(ctx);\n    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n    zero = BN_CTX_get(ctx);\n    if (!BN_zero(zero)) { ret=-1; goto err; }\n    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n    rr = BN_CTX_get(ctx);\n    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n    sor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n    eor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n\n    ret = 1;\n\nerr:\n    if (ctx) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n    if (R != NULL) EC_POINT_free(R);\n    if (O != NULL) EC_POINT_free(O);\n    if (Q != NULL) EC_POINT_free(Q);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetCompressedPubKey",
          "args": [],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompressedPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "123-127",
          "snippet": "void CKey::SetCompressedPubKey()\n{\n    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n    fCompressedPubKey = true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::SetCompressedPubKey()\n  {\n      EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n      fCompressedPubKey = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "NID_secp256k1"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "pkey"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_bin2bn",
          "args": [
            "&vchSig[33]",
            "32",
            "sig->s"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_bin2bn",
          "args": [
            "&vchSig[1]",
            "32",
            "sig->r"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ECDSA_SIG_new",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.size",
          "args": [],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      if (vchSig.size() != 65)\n          return false;\n      int nV = vchSig[0];\n      if (nV<27 || nV>=35)\n          return false;\n      ECDSA_SIG *sig = ECDSA_SIG_new();\n      BN_bin2bn(&vchSig[1],32,sig->r);\n      BN_bin2bn(&vchSig[33],32,sig->s);\n  \n      EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (nV >= 31)\n      {\n          SetCompressedPubKey();\n          nV -= 4;\n      }\n      if (ECDSA_SIG_recover_key_GFp(pkey, sig, (unsigned char*)&hash, sizeof(hash), nV - 27, 0) == 1)\n      {\n          fSet = true;\n          ECDSA_SIG_free(sig);\n          return true;\n      }\n      ECDSA_SIG_free(sig);\n      return false;\n  }\n}"
  },
  {
    "function_name": "SignCompact",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "318-358",
    "snippet": "bool CKey::SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)\n{\n    bool fOk = false;\n    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n    if (sig==NULL)\n        return false;\n    vchSig.clear();\n    vchSig.resize(65,0);\n    int nBitsR = BN_num_bits(sig->r);\n    int nBitsS = BN_num_bits(sig->s);\n    if (nBitsR <= 256 && nBitsS <= 256)\n    {\n        int nRecId = -1;\n        for (int i=0; i<4; i++)\n        {\n            CKey keyRec;\n            keyRec.fSet = true;\n            if (fCompressedPubKey)\n                keyRec.SetCompressedPubKey();\n            if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1)\n                if (keyRec.GetPubKey() == this->GetPubKey())\n                {\n                    nRecId = i;\n                    break;\n                }\n        }\n\n        if (nRecId == -1)\n        {\n            ECDSA_SIG_free(sig);\n            throw key_error(\"CKey::SignCompact() : unable to construct recoverable key\");\n        }\n\n        vchSig[0] = nRecId+27+(fCompressedPubKey ? 4 : 0);\n        BN_bn2bin(sig->r,&vchSig[33-(nBitsR+7)/8]);\n        BN_bn2bin(sig->s,&vchSig[65-(nBitsS+7)/8]);\n        fOk = true;\n    }\n    ECDSA_SIG_free(sig);\n    return fOk;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ECDSA_SIG_free",
          "args": [
            "sig"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_bn2bin",
          "args": [
            "sig->s",
            "&vchSig[65-(nBitsS+7)/8]"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_bn2bin",
          "args": [
            "sig->r",
            "&vchSig[33-(nBitsR+7)/8]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::SignCompact() : unable to construct recoverable key\""
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ECDSA_SIG_free",
          "args": [
            "sig"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->GetPubKey",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ECDSA_SIG_recover_key_GFp",
          "args": [
            "keyRec.pkey",
            "sig",
            "(unsigned char*)&hash",
            "sizeof(hash)",
            "i",
            "1"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ECDSA_SIG_recover_key_GFp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "52-121",
          "snippet": "int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n{\n    if (!eckey) return 0;\n\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n\n    BIGNUM *x = NULL;\n    BIGNUM *e = NULL;\n    BIGNUM *order = NULL;\n    BIGNUM *sor = NULL;\n    BIGNUM *eor = NULL;\n    BIGNUM *field = NULL;\n    EC_POINT *R = NULL;\n    EC_POINT *O = NULL;\n    EC_POINT *Q = NULL;\n    BIGNUM *rr = NULL;\n    BIGNUM *zero = NULL;\n    int n = 0;\n    int i = recid / 2;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n    BN_CTX_start(ctx);\n    order = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n    x = BN_CTX_get(ctx);\n    if (!BN_copy(x, order)) { ret=-1; goto err; }\n    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n    field = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n    if (check)\n    {\n        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n    }\n    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    n = EC_GROUP_get_degree(group);\n    e = BN_CTX_get(ctx);\n    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n    zero = BN_CTX_get(ctx);\n    if (!BN_zero(zero)) { ret=-1; goto err; }\n    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n    rr = BN_CTX_get(ctx);\n    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n    sor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n    eor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n\n    ret = 1;\n\nerr:\n    if (ctx) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n    if (R != NULL) EC_POINT_free(R);\n    if (O != NULL) EC_POINT_free(O);\n    if (Q != NULL) EC_POINT_free(Q);\n    return ret;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nint ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n{\n    if (!eckey) return 0;\n\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n\n    BIGNUM *x = NULL;\n    BIGNUM *e = NULL;\n    BIGNUM *order = NULL;\n    BIGNUM *sor = NULL;\n    BIGNUM *eor = NULL;\n    BIGNUM *field = NULL;\n    EC_POINT *R = NULL;\n    EC_POINT *O = NULL;\n    EC_POINT *Q = NULL;\n    BIGNUM *rr = NULL;\n    BIGNUM *zero = NULL;\n    int n = 0;\n    int i = recid / 2;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n    BN_CTX_start(ctx);\n    order = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n    x = BN_CTX_get(ctx);\n    if (!BN_copy(x, order)) { ret=-1; goto err; }\n    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n    field = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n    if (check)\n    {\n        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n    }\n    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    n = EC_GROUP_get_degree(group);\n    e = BN_CTX_get(ctx);\n    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n    zero = BN_CTX_get(ctx);\n    if (!BN_zero(zero)) { ret=-1; goto err; }\n    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n    rr = BN_CTX_get(ctx);\n    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n    sor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n    eor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n\n    ret = 1;\n\nerr:\n    if (ctx) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n    if (R != NULL) EC_POINT_free(R);\n    if (O != NULL) EC_POINT_free(O);\n    if (Q != NULL) EC_POINT_free(Q);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyRec.SetCompressedPubKey",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompressedPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "123-127",
          "snippet": "void CKey::SetCompressedPubKey()\n{\n    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n    fCompressedPubKey = true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::SetCompressedPubKey()\n  {\n      EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n      fCompressedPubKey = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "sig->s"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bits",
          "args": [
            "sig->r"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.resize",
          "args": [
            "65",
            "0"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.clear",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ECDSA_do_sign",
          "args": [
            "(unsigned char*)&hash",
            "sizeof(hash)",
            "pkey"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)\n  {\n      bool fOk = false;\n      ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n      if (sig==NULL)\n          return false;\n      vchSig.clear();\n      vchSig.resize(65,0);\n      int nBitsR = BN_num_bits(sig->r);\n      int nBitsS = BN_num_bits(sig->s);\n      if (nBitsR <= 256 && nBitsS <= 256)\n      {\n          int nRecId = -1;\n          for (int i=0; i<4; i++)\n          {\n              CKey keyRec;\n              keyRec.fSet = true;\n              if (fCompressedPubKey)\n                  keyRec.SetCompressedPubKey();\n              if (ECDSA_SIG_recover_key_GFp(keyRec.pkey, sig, (unsigned char*)&hash, sizeof(hash), i, 1) == 1)\n                  if (keyRec.GetPubKey() == this->GetPubKey())\n                  {\n                      nRecId = i;\n                      break;\n                  }\n          }\n  \n          if (nRecId == -1)\n          {\n              ECDSA_SIG_free(sig);\n              throw key_error(\"CKey::SignCompact() : unable to construct recoverable key\");\n          }\n  \n          vchSig[0] = nRecId+27+(fCompressedPubKey ? 4 : 0);\n          BN_bn2bin(sig->r,&vchSig[33-(nBitsR+7)/8]);\n          BN_bn2bin(sig->s,&vchSig[65-(nBitsS+7)/8]);\n          fOk = true;\n      }\n      ECDSA_SIG_free(sig);\n      return fOk;\n  }\n}"
  },
  {
    "function_name": "Sign",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "286-312",
    "snippet": "bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n{\n    vchSig.clear();\n    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n    if (sig == NULL)\n        return false;\n    BN_CTX *ctx = BN_CTX_new();\n    BN_CTX_start(ctx);\n    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n    BIGNUM *order = BN_CTX_get(ctx);\n    BIGNUM *halforder = BN_CTX_get(ctx);\n    EC_GROUP_get_order(group, order, ctx);\n    BN_rshift1(halforder, order);\n    if (BN_cmp(sig->s, halforder) > 0) {\n        // enforce low S values, by negating the value (modulo the order) if above order/2.\n        BN_sub(sig->s, order, sig->s);\n    }\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    unsigned int nSize = ECDSA_size(pkey);\n    vchSig.resize(nSize); // Make sure it is big enough\n    unsigned char *pos = &vchSig[0];\n    nSize = i2d_ECDSA_SIG(sig, &pos);\n    ECDSA_SIG_free(sig);\n    vchSig.resize(nSize); // Shrink to fit actual size\n    return true;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vchSig.resize",
          "args": [
            "nSize"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ECDSA_SIG_free",
          "args": [
            "sig"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i2d_ECDSA_SIG",
          "args": [
            "sig",
            "&pos"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ECDSA_size",
          "args": [
            "pkey"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "ctx"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_end",
          "args": [
            "ctx"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_sub",
          "args": [
            "sig->s",
            "order",
            "sig->s"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "sig->s",
            "halforder"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_rshift1",
          "args": [
            "halforder",
            "order"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_get_order",
          "args": [
            "group",
            "order",
            "ctx"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "pkey"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_start",
          "args": [
            "ctx"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ECDSA_do_sign",
          "args": [
            "(unsigned char*)&hash",
            "sizeof(hash)",
            "pkey"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.clear",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n  {\n      vchSig.clear();\n      ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n      if (sig == NULL)\n          return false;\n      BN_CTX *ctx = BN_CTX_new();\n      BN_CTX_start(ctx);\n      const EC_GROUP *group = EC_KEY_get0_group(pkey);\n      BIGNUM *order = BN_CTX_get(ctx);\n      BIGNUM *halforder = BN_CTX_get(ctx);\n      EC_GROUP_get_order(group, order, ctx);\n      BN_rshift1(halforder, order);\n      if (BN_cmp(sig->s, halforder) > 0) {\n          // enforce low S values, by negating the value (modulo the order) if above order/2.\n          BN_sub(sig->s, order, sig->s);\n      }\n      BN_CTX_end(ctx);\n      BN_CTX_free(ctx);\n      unsigned int nSize = ECDSA_size(pkey);\n      vchSig.resize(nSize); // Make sure it is big enough\n      unsigned char *pos = &vchSig[0];\n      nSize = i2d_ECDSA_SIG(sig, &pos);\n      ECDSA_SIG_free(sig);\n      vchSig.resize(nSize); // Shrink to fit actual size\n      return true;\n  }\n}"
  },
  {
    "function_name": "GetPubKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "274-284",
    "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [
            "vchPubKey"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "CPubKey",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "71-71",
          "snippet": "CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\""
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2o_ECPublicKey",
          "args": [
            "pkey",
            "&pbegin"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i2o_ECPublicKey",
          "args": [
            "pkey",
            "NULL"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
  },
  {
    "function_name": "SetPubKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "259-272",
    "snippet": "bool CKey::SetPubKey(const CPubKey& vchPubKey)\n{\n    const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n    {\n        fSet = true;\n        if (vchPubKey.vchPubKey.size() == 33)\n            SetCompressedPubKey();\n        return true;\n    }\n    pkey = NULL;\n    Reset();\n    return false;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reset",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "Reset",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "129-138",
          "snippet": "void CKey::Reset()\n{\n    fCompressedPubKey = false;\n    if (pkey != NULL)\n        EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n    fSet = false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::Reset()\n  {\n      fCompressedPubKey = false;\n      if (pkey != NULL)\n          EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n      fSet = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetCompressedPubKey",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompressedPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "123-127",
          "snippet": "void CKey::SetCompressedPubKey()\n{\n    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n    fCompressedPubKey = true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::SetCompressedPubKey()\n  {\n      EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n      fCompressedPubKey = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchPubKey.vchPubKey.size",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2i_ECPublicKey",
          "args": [
            "&pkey",
            "&pbegin",
            "vchPubKey.vchPubKey.size()"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPubKey(const CPubKey& vchPubKey)\n  {\n      const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n      if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n      {\n          fSet = true;\n          if (vchPubKey.vchPubKey.size() == 33)\n              SetCompressedPubKey();\n          return true;\n      }\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
  },
  {
    "function_name": "GetPrivKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "247-257",
    "snippet": "CPrivKey CKey::GetPrivKey() const\n{\n    int nSize = i2d_ECPrivateKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n    CPrivKey vchPrivKey(nSize, 0);\n    unsigned char* pbegin = &vchPrivKey[0];\n    if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n    return vchPrivKey;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\""
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i2d_ECPrivateKey",
          "args": [
            "pkey",
            "&pbegin"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i2d_ECPrivateKey",
          "args": [
            "pkey",
            "NULL"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPrivKey CKey::GetPrivKey() const\n  {\n      int nSize = i2d_ECPrivateKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey failed\");\n      CPrivKey vchPrivKey(nSize, 0);\n      unsigned char* pbegin = &vchPrivKey[0];\n      if (i2d_ECPrivateKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPrivKey() : i2d_ECPrivateKey returned unexpected size\");\n      return vchPrivKey;\n  }\n}"
  },
  {
    "function_name": "GetSecret",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "232-245",
    "snippet": "CSecret CKey::GetSecret(bool &fCompressed) const\n{\n    CSecret vchRet;\n    vchRet.resize(32);\n    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n    int nBytes = BN_num_bytes(bn);\n    if (bn == NULL)\n        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n    if (n != nBytes)\n        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n    fCompressed = fCompressedPubKey;\n    return vchRet;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::GetSecret(): BN_bn2bin failed\""
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_bn2bin",
          "args": [
            "bn",
            "&vchRet[32 - nBytes]"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_num_bytes",
          "args": [
            "bn"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_private_key",
          "args": [
            "pkey"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchRet.resize",
          "args": [
            "32"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CSecret CKey::GetSecret(bool &fCompressed) const\n  {\n      CSecret vchRet;\n      vchRet.resize(32);\n      const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n      int nBytes = BN_num_bytes(bn);\n      if (bn == NULL)\n          throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n      int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n      if (n != nBytes)\n          throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n      fCompressed = fCompressedPubKey;\n      return vchRet;\n  }\n}"
  },
  {
    "function_name": "SetSecret",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "209-230",
    "snippet": "bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n{\n    EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n    if (vchSecret.size() != 32)\n        throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n    BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n    if (bn == NULL)\n        throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n    if (!EC_KEY_regenerate_key(pkey,bn))\n    {\n        BN_clear_free(bn);\n        throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n    }\n    BN_clear_free(bn);\n    fSet = true;\n    if (fCompressed || fCompressedPubKey)\n        SetCompressedPubKey();\n    return true;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetCompressedPubKey",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompressedPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "123-127",
          "snippet": "void CKey::SetCompressedPubKey()\n{\n    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n    fCompressedPubKey = true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::SetCompressedPubKey()\n  {\n      EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n      fCompressedPubKey = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "bn"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::SetSecret() : EC_KEY_regenerate_key failed\""
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_clear_free",
          "args": [
            "bn"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_regenerate_key",
          "args": [
            "pkey",
            "bn"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "EC_KEY_regenerate_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "13-47",
          "snippet": "int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    EC_POINT *pub_key = NULL;\n\n    if (!eckey) return 0;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    pub_key = EC_POINT_new(group);\n\n    if (pub_key == NULL)\n        goto err;\n\n    if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n        goto err;\n\n    EC_KEY_set_private_key(eckey,priv_key);\n    EC_KEY_set_public_key(eckey,pub_key);\n\n    ok = 1;\n\nerr:\n\n    if (pub_key)\n        EC_POINT_free(pub_key);\n    if (ctx != NULL)\n        BN_CTX_free(ctx);\n\n    return(ok);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nint EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    EC_POINT *pub_key = NULL;\n\n    if (!eckey) return 0;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    pub_key = EC_POINT_new(group);\n\n    if (pub_key == NULL)\n        goto err;\n\n    if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n        goto err;\n\n    EC_KEY_set_private_key(eckey,priv_key);\n    EC_KEY_set_public_key(eckey,pub_key);\n\n    ok = 1;\n\nerr:\n\n    if (pub_key)\n        EC_POINT_free(pub_key);\n    if (ctx != NULL)\n        BN_CTX_free(ctx);\n\n    return(ok);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_bin2bn",
          "args": [
            "&vchSecret[0]",
            "32",
            "BN_new()"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_new",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSecret.size",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "NID_secp256k1"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "pkey"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n  {\n      EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n      if (vchSecret.size() != 32)\n          throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n      BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n      if (bn == NULL)\n          throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n      if (!EC_KEY_regenerate_key(pkey,bn))\n      {\n          BN_clear_free(bn);\n          throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n      }\n      BN_clear_free(bn);\n      fSet = true;\n      if (fCompressed || fCompressedPubKey)\n          SetCompressedPubKey();\n      return true;\n  }\n}"
  },
  {
    "function_name": "SetPrivKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "186-207",
    "snippet": "bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n{\n    const unsigned char* pbegin = &vchPrivKey[0];\n    if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n    {\n        // In testing, d2i_ECPrivateKey can return true\n        // but fill in pkey with a key that fails\n        // EC_KEY_check_key, so:\n        if (EC_KEY_check_key(pkey))\n        {\n            fSet = true;\n            return true;\n        }\n    }\n    // If vchPrivKey data is bad d2i_ECPrivateKey() can\n    // leave pkey in a state where calling EC_KEY_free()\n    // crashes. To avoid that, set pkey to NULL and\n    // leak the memory (a leak is better than a crash)\n    pkey = NULL;\n    Reset();\n    return false;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reset",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "Reset",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "129-138",
          "snippet": "void CKey::Reset()\n{\n    fCompressedPubKey = false;\n    if (pkey != NULL)\n        EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n    fSet = false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::Reset()\n  {\n      fCompressedPubKey = false;\n      if (pkey != NULL)\n          EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n      fSet = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_check_key",
          "args": [
            "pkey"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d2i_ECPrivateKey",
          "args": [
            "&pkey",
            "&pbegin",
            "vchPrivKey.size()"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchPrivKey.size",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n  {\n      const unsigned char* pbegin = &vchPrivKey[0];\n      if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n      {\n          // In testing, d2i_ECPrivateKey can return true\n          // but fill in pkey with a key that fails\n          // EC_KEY_check_key, so:\n          if (EC_KEY_check_key(pkey))\n          {\n              fSet = true;\n              return true;\n          }\n      }\n      // If vchPrivKey data is bad d2i_ECPrivateKey() can\n      // leave pkey in a state where calling EC_KEY_free()\n      // crashes. To avoid that, set pkey to NULL and\n      // leak the memory (a leak is better than a crash)\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
  },
  {
    "function_name": "MakeNewKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "177-184",
    "snippet": "void CKey::MakeNewKey(bool fCompressed)\n{\n    if (!EC_KEY_generate_key(pkey))\n        throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n    if (fCompressed)\n        SetCompressedPubKey();\n    fSet = true;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetCompressedPubKey",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompressedPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "123-127",
          "snippet": "void CKey::SetCompressedPubKey()\n{\n    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n    fCompressedPubKey = true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::SetCompressedPubKey()\n  {\n      EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n      fCompressedPubKey = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::MakeNewKey() : EC_KEY_generate_key failed\""
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_generate_key",
          "args": [
            "pkey"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::MakeNewKey(bool fCompressed)\n  {\n      if (!EC_KEY_generate_key(pkey))\n          throw key_error(\"CKey::MakeNewKey() : EC_KEY_generate_key failed\");\n      if (fCompressed)\n          SetCompressedPubKey();\n      fSet = true;\n  }\n}"
  },
  {
    "function_name": "IsCompressed",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "172-175",
    "snippet": "bool CKey::IsCompressed() const\n{\n    return fCompressedPubKey;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::IsCompressed() const\n  {\n      return fCompressedPubKey;\n  }\n}"
  },
  {
    "function_name": "IsNull",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "167-170",
    "snippet": "bool CKey::IsNull() const\n{\n    return !fSet;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::IsNull() const\n  {\n      return !fSet;\n  }\n}"
  },
  {
    "function_name": "~CKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "162-165",
    "snippet": "CKey::~CKey()\n{\n    EC_KEY_free(pkey);\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "pkey"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CKey::~CKey()\n  {\n      EC_KEY_free(pkey);\n  }\n}"
  },
  {
    "function_name": "CKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "146-152",
    "snippet": "CKey::CKey(const CKey& b)\n{\n    pkey = EC_KEY_dup(b.pkey);\n    if (pkey == NULL)\n        throw key_error(\"CKey::CKey(const CKey&) : EC_KEY_dup failed\");\n    fSet = b.fSet;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::CKey(const CKey&) : EC_KEY_dup failed\""
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_dup",
          "args": [
            "b.pkey"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CKey::CKey(const CKey& b)\n  {\n      pkey = EC_KEY_dup(b.pkey);\n      if (pkey == NULL)\n          throw key_error(\"CKey::CKey(const CKey&) : EC_KEY_dup failed\");\n      fSet = b.fSet;\n  }\n}"
  },
  {
    "function_name": "CKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "140-144",
    "snippet": "CKey::CKey()\n{\n    pkey = NULL;\n    Reset();\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Reset",
          "args": [],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "Reset",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "129-138",
          "snippet": "void CKey::Reset()\n{\n    fCompressedPubKey = false;\n    if (pkey != NULL)\n        EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n    fSet = false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::Reset()\n  {\n      fCompressedPubKey = false;\n      if (pkey != NULL)\n          EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n      fSet = false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CKey::CKey()\n  {\n      pkey = NULL;\n      Reset();\n  }\n}"
  },
  {
    "function_name": "Reset",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "129-138",
    "snippet": "void CKey::Reset()\n{\n    fCompressedPubKey = false;\n    if (pkey != NULL)\n        EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n    fSet = false;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_error",
          "args": [
            "\"CKey::CKey() : EC_KEY_new_by_curve_name failed\""
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EC_KEY_new_by_curve_name",
          "args": [
            "NID_secp256k1"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_free",
          "args": [
            "pkey"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::Reset()\n  {\n      fCompressedPubKey = false;\n      if (pkey != NULL)\n          EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::CKey() : EC_KEY_new_by_curve_name failed\");\n      fSet = false;\n  }\n}"
  },
  {
    "function_name": "SetCompressedPubKey",
    "container": "CKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "123-127",
    "snippet": "void CKey::SetCompressedPubKey()\n{\n    EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n    fCompressedPubKey = true;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EC_KEY_set_conv_form",
          "args": [
            "pkey",
            "POINT_CONVERSION_COMPRESSED"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  void CKey::SetCompressedPubKey()\n  {\n      EC_KEY_set_conv_form(pkey, POINT_CONVERSION_COMPRESSED);\n      fCompressedPubKey = true;\n  }\n}"
  },
  {
    "function_name": "ECDSA_SIG_recover_key_GFp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "52-121",
    "snippet": "int ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n{\n    if (!eckey) return 0;\n\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n\n    BIGNUM *x = NULL;\n    BIGNUM *e = NULL;\n    BIGNUM *order = NULL;\n    BIGNUM *sor = NULL;\n    BIGNUM *eor = NULL;\n    BIGNUM *field = NULL;\n    EC_POINT *R = NULL;\n    EC_POINT *O = NULL;\n    EC_POINT *Q = NULL;\n    BIGNUM *rr = NULL;\n    BIGNUM *zero = NULL;\n    int n = 0;\n    int i = recid / 2;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n    BN_CTX_start(ctx);\n    order = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n    x = BN_CTX_get(ctx);\n    if (!BN_copy(x, order)) { ret=-1; goto err; }\n    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n    field = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n    if (check)\n    {\n        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n    }\n    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    n = EC_GROUP_get_degree(group);\n    e = BN_CTX_get(ctx);\n    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n    zero = BN_CTX_get(ctx);\n    if (!BN_zero(zero)) { ret=-1; goto err; }\n    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n    rr = BN_CTX_get(ctx);\n    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n    sor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n    eor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n\n    ret = 1;\n\nerr:\n    if (ctx) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n    if (R != NULL) EC_POINT_free(R);\n    if (O != NULL) EC_POINT_free(O);\n    if (Q != NULL) EC_POINT_free(Q);\n    return ret;\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EC_POINT_free",
          "args": [
            "Q"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_free",
          "args": [
            "O"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_free",
          "args": [
            "R"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "ctx"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_end",
          "args": [
            "ctx"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_public_key",
          "args": [
            "eckey",
            "Q"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_mul",
          "args": [
            "group",
            "Q",
            "eor",
            "R",
            "sor",
            "ctx"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mod_mul",
          "args": [
            "eor",
            "e",
            "rr",
            "order",
            "ctx"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mod_mul",
          "args": [
            "sor",
            "ecsig->s",
            "rr",
            "order",
            "ctx"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mod_inverse",
          "args": [
            "rr",
            "ecsig->r",
            "order",
            "ctx"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mod_sub",
          "args": [
            "e",
            "zero",
            "e",
            "order",
            "ctx"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_zero",
          "args": [
            "zero"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_rshift",
          "args": [
            "e",
            "e",
            "8-(n & 7)"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_bin2bn",
          "args": [
            "msg",
            "msglen",
            "e"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_get_degree",
          "args": [
            "group"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_new",
          "args": [
            "group"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_is_at_infinity",
          "args": [
            "group",
            "O"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_mul",
          "args": [
            "group",
            "O",
            "NULL",
            "R",
            "order",
            "ctx"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_new",
          "args": [
            "group"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_set_compressed_coordinates_GFp",
          "args": [
            "group",
            "R",
            "x",
            "recid % 2",
            "ctx"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_new",
          "args": [
            "group"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_cmp",
          "args": [
            "x",
            "field"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_get_curve_GFp",
          "args": [
            "group",
            "field",
            "NULL",
            "NULL",
            "ctx"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_add",
          "args": [
            "x",
            "x",
            "ecsig->r"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mul_word",
          "args": [
            "x",
            "i"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_copy",
          "args": [
            "x",
            "order"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_GROUP_get_order",
          "args": [
            "group",
            "order",
            "ctx"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_get",
          "args": [
            "ctx"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_start",
          "args": [
            "ctx"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "eckey"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nint ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n{\n    if (!eckey) return 0;\n\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n\n    BIGNUM *x = NULL;\n    BIGNUM *e = NULL;\n    BIGNUM *order = NULL;\n    BIGNUM *sor = NULL;\n    BIGNUM *eor = NULL;\n    BIGNUM *field = NULL;\n    EC_POINT *R = NULL;\n    EC_POINT *O = NULL;\n    EC_POINT *Q = NULL;\n    BIGNUM *rr = NULL;\n    BIGNUM *zero = NULL;\n    int n = 0;\n    int i = recid / 2;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n    if ((ctx = BN_CTX_new()) == NULL) { ret = -1; goto err; }\n    BN_CTX_start(ctx);\n    order = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_order(group, order, ctx)) { ret = -2; goto err; }\n    x = BN_CTX_get(ctx);\n    if (!BN_copy(x, order)) { ret=-1; goto err; }\n    if (!BN_mul_word(x, i)) { ret=-1; goto err; }\n    if (!BN_add(x, x, ecsig->r)) { ret=-1; goto err; }\n    field = BN_CTX_get(ctx);\n    if (!EC_GROUP_get_curve_GFp(group, field, NULL, NULL, ctx)) { ret=-2; goto err; }\n    if (BN_cmp(x, field) >= 0) { ret=0; goto err; }\n    if ((R = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    if (!EC_POINT_set_compressed_coordinates_GFp(group, R, x, recid % 2, ctx)) { ret=0; goto err; }\n    if (check)\n    {\n        if ((O = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n        if (!EC_POINT_mul(group, O, NULL, R, order, ctx)) { ret=-2; goto err; }\n        if (!EC_POINT_is_at_infinity(group, O)) { ret = 0; goto err; }\n    }\n    if ((Q = EC_POINT_new(group)) == NULL) { ret = -2; goto err; }\n    n = EC_GROUP_get_degree(group);\n    e = BN_CTX_get(ctx);\n    if (!BN_bin2bn(msg, msglen, e)) { ret=-1; goto err; }\n    if (8*msglen > n) BN_rshift(e, e, 8-(n & 7));\n    zero = BN_CTX_get(ctx);\n    if (!BN_zero(zero)) { ret=-1; goto err; }\n    if (!BN_mod_sub(e, zero, e, order, ctx)) { ret=-1; goto err; }\n    rr = BN_CTX_get(ctx);\n    if (!BN_mod_inverse(rr, ecsig->r, order, ctx)) { ret=-1; goto err; }\n    sor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(sor, ecsig->s, rr, order, ctx)) { ret=-1; goto err; }\n    eor = BN_CTX_get(ctx);\n    if (!BN_mod_mul(eor, e, rr, order, ctx)) { ret=-1; goto err; }\n    if (!EC_POINT_mul(group, Q, eor, R, sor, ctx)) { ret=-2; goto err; }\n    if (!EC_KEY_set_public_key(eckey, Q)) { ret=-2; goto err; }\n\n    ret = 1;\n\nerr:\n    if (ctx) {\n        BN_CTX_end(ctx);\n        BN_CTX_free(ctx);\n    }\n    if (R != NULL) EC_POINT_free(R);\n    if (O != NULL) EC_POINT_free(O);\n    if (Q != NULL) EC_POINT_free(Q);\n    return ret;\n}"
  },
  {
    "function_name": "EC_KEY_regenerate_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
    "lines": "13-47",
    "snippet": "int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    EC_POINT *pub_key = NULL;\n\n    if (!eckey) return 0;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    pub_key = EC_POINT_new(group);\n\n    if (pub_key == NULL)\n        goto err;\n\n    if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n        goto err;\n\n    EC_KEY_set_private_key(eckey,priv_key);\n    EC_KEY_set_public_key(eckey,pub_key);\n\n    ok = 1;\n\nerr:\n\n    if (pub_key)\n        EC_POINT_free(pub_key);\n    if (ctx != NULL)\n        BN_CTX_free(ctx);\n\n    return(ok);\n}",
    "includes": [
      "#include \"key.h\"",
      "#include <openssl/obj_mac.h>",
      "#include <openssl/ecdsa.h>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BN_CTX_free",
          "args": [
            "ctx"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_free",
          "args": [
            "pub_key"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_public_key",
          "args": [
            "eckey",
            "pub_key"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_set_private_key",
          "args": [
            "eckey",
            "priv_key"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_mul",
          "args": [
            "group",
            "pub_key",
            "priv_key",
            "NULL",
            "NULL",
            "ctx"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_POINT_new",
          "args": [
            "group"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_CTX_new",
          "args": [],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EC_KEY_get0_group",
          "args": [
            "eckey"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nint EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n{\n    int ok = 0;\n    BN_CTX *ctx = NULL;\n    EC_POINT *pub_key = NULL;\n\n    if (!eckey) return 0;\n\n    const EC_GROUP *group = EC_KEY_get0_group(eckey);\n\n    if ((ctx = BN_CTX_new()) == NULL)\n        goto err;\n\n    pub_key = EC_POINT_new(group);\n\n    if (pub_key == NULL)\n        goto err;\n\n    if (!EC_POINT_mul(group, pub_key, priv_key, NULL, NULL, ctx))\n        goto err;\n\n    EC_KEY_set_private_key(eckey,priv_key);\n    EC_KEY_set_public_key(eckey,pub_key);\n\n    ok = 1;\n\nerr:\n\n    if (pub_key)\n        EC_POINT_free(pub_key);\n    if (ctx != NULL)\n        BN_CTX_free(ctx);\n\n    return(ok);\n}"
  }
]