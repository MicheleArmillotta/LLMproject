[
  {
    "function_name": "Add",
    "container": "CCheckQueueControl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "181-184",
    "snippet": "void Add(std::vector<T> &vChecks) {\n        if (pqueue != NULL)\n            pqueue->Add(vChecks);\n    }",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pqueue->Add",
          "args": [
            "vChecks"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "181-184",
          "snippet": "void Add(std::vector<T> &vChecks) {\n        if (pqueue != NULL)\n            pqueue->Add(vChecks);\n    }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  void Add(std::vector<T> &vChecks) {\n          if (pqueue != NULL)\n              pqueue->Add(vChecks);\n      }\n}"
  },
  {
    "function_name": "Wait",
    "container": "CCheckQueueControl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "173-179",
    "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pqueue->Wait",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "Wait",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "173-179",
          "snippet": "bool Wait() {\n        if (pqueue == NULL)\n            return true;\n        bool fRet = pqueue->Wait();\n        fDone = true;\n        return fRet;\n    }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  bool Wait() {\n          if (pqueue == NULL)\n              return true;\n          bool fRet = pqueue->Wait();\n          fDone = true;\n          return fRet;\n      }\n}"
  },
  {
    "function_name": "CCheckQueueControl",
    "container": "CCheckQueueControl",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "164-171",
    "snippet": "CCheckQueueControl(CCheckQueue<T> *pqueueIn) : pqueue(pqueueIn), fDone(false) {\n        // passed queue is supposed to be unused, or NULL\n        if (pqueue != NULL) {\n            assert(pqueue->nTotal == pqueue->nIdle);\n            assert(pqueue->nTodo == 0);\n            assert(pqueue->fAllOk == true);\n        }\n    }",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pqueue->fAllOk == true"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pqueue->nTodo == 0"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pqueue->nTotal == pqueue->nIdle"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  CCheckQueueControl(CCheckQueue<T> *pqueueIn) : pqueue(pqueueIn), fDone(false) {\n          // passed queue is supposed to be unused, or NULL\n          if (pqueue != NULL) {\n              assert(pqueue->nTotal == pqueue->nIdle);\n              assert(pqueue->nTodo == 0);\n              assert(pqueue->fAllOk == true);\n          }\n      }\n}"
  },
  {
    "function_name": "Add",
    "container": "CCheckQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "136-147",
    "snippet": "void Add(std::vector<T> &vChecks) {\n        boost::unique_lock<boost::mutex> lock(mutex);\n        BOOST_FOREACH(T &check, vChecks) {\n            queue.push_back(T());\n            check.swap(queue.back());\n        }\n        nTodo += vChecks.size();\n        if (vChecks.size() == 1)\n            condWorker.notify_one();\n        else if (vChecks.size() > 1)\n            condWorker.notify_all();\n    }",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "condWorker.notify_all",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vChecks.size",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "condWorker.notify_one",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check.swap",
          "args": [
            "queue.back()"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue.back",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue.push_back",
          "args": [
            "T()"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "T",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "Thread",
          "container": "CCheckQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "126-128",
          "snippet": "void Thread() {\n        Loop();\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueue {\n  void Thread() {\n          Loop();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueue {\n  void Add(std::vector<T> &vChecks) {\n          boost::unique_lock<boost::mutex> lock(mutex);\n          BOOST_FOREACH(T &check, vChecks) {\n              queue.push_back(T());\n              check.swap(queue.back());\n          }\n          nTodo += vChecks.size();\n          if (vChecks.size() == 1)\n              condWorker.notify_one();\n          else if (vChecks.size() > 1)\n              condWorker.notify_all();\n      }\n}"
  },
  {
    "function_name": "Wait",
    "container": "CCheckQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "131-133",
    "snippet": "bool Wait() {\n        return Loop(true);\n    }",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Loop",
          "args": [
            "true"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueue {\n  bool Wait() {\n          return Loop(true);\n      }\n}"
  },
  {
    "function_name": "Thread",
    "container": "CCheckQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "126-128",
    "snippet": "void Thread() {\n        Loop();\n    }",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Loop",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "Loop",
          "container": "CCheckQueue",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "61-118",
          "snippet": "bool Loop(bool fMaster = false) {\n        boost::condition_variable &cond = fMaster ? condMaster : condWorker;\n        std::vector<T> vChecks;\n        vChecks.reserve(nBatchSize);\n        unsigned int nNow = 0;\n        bool fOk = true;\n        do {\n            {\n                boost::unique_lock<boost::mutex> lock(mutex);\n                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n                if (nNow) {\n                    fAllOk &= fOk;\n                    nTodo -= nNow;\n                    if (nTodo == 0 && !fMaster)\n                        // We processed the last element; inform the master he can exit and return the result\n                        condMaster.notify_one();\n                } else {\n                    // first iteration\n                    nTotal++;\n                }\n                // logically, the do loop starts here\n                while (queue.empty()) {\n                    if ((fMaster || fQuit) && nTodo == 0) {\n                        nTotal--;\n                        bool fRet = fAllOk;\n                        // reset the status for new work later\n                        if (fMaster)\n                            fAllOk = true;\n                        // return the current status\n                        return fRet;\n                    }\n                    nIdle++;\n                    cond.wait(lock); // wait\n                    nIdle--;\n                }\n                // Decide how many work units to process now.\n                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n                //   all workers finish approximately simultaneously.\n                // * Try to account for idle jobs which will instantly start helping.\n                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n                vChecks.resize(nNow);\n                for (unsigned int i = 0; i < nNow; i++) {\n                     // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n                     // queue to the local batch vector instead of copying.\n                     vChecks[i].swap(queue.back());\n                     queue.pop_back();\n                }\n                // Check whether we need to do work at all\n                fOk = fAllOk;\n            }\n            // execute work\n            BOOST_FOREACH(T &check, vChecks)\n                if (fOk)\n                    fOk = check();\n            vChecks.clear();\n        } while(true);\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueue {\n  bool Loop(bool fMaster = false) {\n          boost::condition_variable &cond = fMaster ? condMaster : condWorker;\n          std::vector<T> vChecks;\n          vChecks.reserve(nBatchSize);\n          unsigned int nNow = 0;\n          bool fOk = true;\n          do {\n              {\n                  boost::unique_lock<boost::mutex> lock(mutex);\n                  // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n                  if (nNow) {\n                      fAllOk &= fOk;\n                      nTodo -= nNow;\n                      if (nTodo == 0 && !fMaster)\n                          // We processed the last element; inform the master he can exit and return the result\n                          condMaster.notify_one();\n                  } else {\n                      // first iteration\n                      nTotal++;\n                  }\n                  // logically, the do loop starts here\n                  while (queue.empty()) {\n                      if ((fMaster || fQuit) && nTodo == 0) {\n                          nTotal--;\n                          bool fRet = fAllOk;\n                          // reset the status for new work later\n                          if (fMaster)\n                              fAllOk = true;\n                          // return the current status\n                          return fRet;\n                      }\n                      nIdle++;\n                      cond.wait(lock); // wait\n                      nIdle--;\n                  }\n                  // Decide how many work units to process now.\n                  // * Do not try to do everything at once, but aim for increasingly smaller batches so\n                  //   all workers finish approximately simultaneously.\n                  // * Try to account for idle jobs which will instantly start helping.\n                  // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n                  nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n                  vChecks.resize(nNow);\n                  for (unsigned int i = 0; i < nNow; i++) {\n                       // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n                       // queue to the local batch vector instead of copying.\n                       vChecks[i].swap(queue.back());\n                       queue.pop_back();\n                  }\n                  // Check whether we need to do work at all\n                  fOk = fAllOk;\n              }\n              // execute work\n              BOOST_FOREACH(T &check, vChecks)\n                  if (fOk)\n                      fOk = check();\n              vChecks.clear();\n          } while(true);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueue {\n  void Thread() {\n          Loop();\n      }\n}"
  },
  {
    "function_name": "CCheckQueue",
    "container": "CCheckQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "122-123",
    "snippet": "CCheckQueue(unsigned int nBatchSizeIn) :\n        nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueue {\n  CCheckQueue(unsigned int nBatchSizeIn) :\n          nIdle(0), nTotal(0), fAllOk(true), nTodo(0), fQuit(false), nBatchSize(nBatchSizeIn) {}\n}"
  },
  {
    "function_name": "Loop",
    "container": "CCheckQueue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
    "lines": "61-118",
    "snippet": "bool Loop(bool fMaster = false) {\n        boost::condition_variable &cond = fMaster ? condMaster : condWorker;\n        std::vector<T> vChecks;\n        vChecks.reserve(nBatchSize);\n        unsigned int nNow = 0;\n        bool fOk = true;\n        do {\n            {\n                boost::unique_lock<boost::mutex> lock(mutex);\n                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n                if (nNow) {\n                    fAllOk &= fOk;\n                    nTodo -= nNow;\n                    if (nTodo == 0 && !fMaster)\n                        // We processed the last element; inform the master he can exit and return the result\n                        condMaster.notify_one();\n                } else {\n                    // first iteration\n                    nTotal++;\n                }\n                // logically, the do loop starts here\n                while (queue.empty()) {\n                    if ((fMaster || fQuit) && nTodo == 0) {\n                        nTotal--;\n                        bool fRet = fAllOk;\n                        // reset the status for new work later\n                        if (fMaster)\n                            fAllOk = true;\n                        // return the current status\n                        return fRet;\n                    }\n                    nIdle++;\n                    cond.wait(lock); // wait\n                    nIdle--;\n                }\n                // Decide how many work units to process now.\n                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n                //   all workers finish approximately simultaneously.\n                // * Try to account for idle jobs which will instantly start helping.\n                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n                vChecks.resize(nNow);\n                for (unsigned int i = 0; i < nNow; i++) {\n                     // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n                     // queue to the local batch vector instead of copying.\n                     vChecks[i].swap(queue.back());\n                     queue.pop_back();\n                }\n                // Check whether we need to do work at all\n                fOk = fAllOk;\n            }\n            // execute work\n            BOOST_FOREACH(T &check, vChecks)\n                if (fOk)\n                    fOk = check();\n            vChecks.clear();\n        } while(true);\n    }",
    "includes": [
      "#include <algorithm>",
      "#include <vector>",
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vChecks.clear",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "check",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "checkBalanceChanged",
          "container": "WalletModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/walletmodel.cpp",
          "lines": "87-102",
          "snippet": "void WalletModel::checkBalanceChanged()\n{\n    qint64 newBalance = getBalance();\n    qint64 newStake = getStake();\n    qint64 newUnconfirmedBalance = getUnconfirmedBalance();\n    qint64 newImmatureBalance = getImmatureBalance();\n\n    if(cachedBalance != newBalance || cachedStake != newStake || cachedUnconfirmedBalance != newUnconfirmedBalance || cachedImmatureBalance != newImmatureBalance)\n    {\n        cachedBalance = newBalance;\n        cachedStake = newStake;\n        cachedUnconfirmedBalance = newUnconfirmedBalance;\n        cachedImmatureBalance = newImmatureBalance;\n        emit balanceChanged(newBalance, newStake, newUnconfirmedBalance, newImmatureBalance);\n    }\n}",
          "includes": [
            "#include <QTimer>",
            "#include <QSet>",
            "#include \"base58.h\"",
            "#include \"walletdb.h\" // for BackupWallet",
            "#include \"wallet.h\"",
            "#include \"ui_interface.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"guiconstants.h\"",
            "#include \"walletmodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QTimer>\n#include <QSet>\n#include \"base58.h\"\n#include \"walletdb.h\" // for BackupWallet\n#include \"wallet.h\"\n#include \"ui_interface.h\"\n#include \"transactiontablemodel.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"guiconstants.h\"\n#include \"walletmodel.h\"\n\nWalletModel {\n  void WalletModel::checkBalanceChanged()\n  {\n      qint64 newBalance = getBalance();\n      qint64 newStake = getStake();\n      qint64 newUnconfirmedBalance = getUnconfirmedBalance();\n      qint64 newImmatureBalance = getImmatureBalance();\n  \n      if(cachedBalance != newBalance || cachedStake != newStake || cachedUnconfirmedBalance != newUnconfirmedBalance || cachedImmatureBalance != newImmatureBalance)\n      {\n          cachedBalance = newBalance;\n          cachedStake = newStake;\n          cachedUnconfirmedBalance = newUnconfirmedBalance;\n          cachedImmatureBalance = newImmatureBalance;\n          emit balanceChanged(newBalance, newStake, newUnconfirmedBalance, newImmatureBalance);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue.pop_back",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vChecks[i].swap",
          "args": [
            "queue.back()"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue.back",
          "args": [],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vChecks.resize",
          "args": [
            "nNow"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::max",
          "args": [
            "1U",
            "std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1))"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "nBatchSize",
            "(unsigned int)queue.size() / (nTotal + nIdle + 1)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue.size",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond.wait",
          "args": [
            "lock"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "queue.empty",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "condMaster.notify_one",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vChecks.reserve",
          "args": [
            "nBatchSize"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueue {\n  bool Loop(bool fMaster = false) {\n          boost::condition_variable &cond = fMaster ? condMaster : condWorker;\n          std::vector<T> vChecks;\n          vChecks.reserve(nBatchSize);\n          unsigned int nNow = 0;\n          bool fOk = true;\n          do {\n              {\n                  boost::unique_lock<boost::mutex> lock(mutex);\n                  // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n                  if (nNow) {\n                      fAllOk &= fOk;\n                      nTodo -= nNow;\n                      if (nTodo == 0 && !fMaster)\n                          // We processed the last element; inform the master he can exit and return the result\n                          condMaster.notify_one();\n                  } else {\n                      // first iteration\n                      nTotal++;\n                  }\n                  // logically, the do loop starts here\n                  while (queue.empty()) {\n                      if ((fMaster || fQuit) && nTodo == 0) {\n                          nTotal--;\n                          bool fRet = fAllOk;\n                          // reset the status for new work later\n                          if (fMaster)\n                              fAllOk = true;\n                          // return the current status\n                          return fRet;\n                      }\n                      nIdle++;\n                      cond.wait(lock); // wait\n                      nIdle--;\n                  }\n                  // Decide how many work units to process now.\n                  // * Do not try to do everything at once, but aim for increasingly smaller batches so\n                  //   all workers finish approximately simultaneously.\n                  // * Try to account for idle jobs which will instantly start helping.\n                  // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n                  nNow = std::max(1U, std::min(nBatchSize, (unsigned int)queue.size() / (nTotal + nIdle + 1)));\n                  vChecks.resize(nNow);\n                  for (unsigned int i = 0; i < nNow; i++) {\n                       // We want the lock on the mutex to be as short as possible, so swap jobs from the global\n                       // queue to the local batch vector instead of copying.\n                       vChecks[i].swap(queue.back());\n                       queue.pop_back();\n                  }\n                  // Check whether we need to do work at all\n                  fOk = fAllOk;\n              }\n              // execute work\n              BOOST_FOREACH(T &check, vChecks)\n                  if (fOk)\n                      fOk = check();\n              vChecks.clear();\n          } while(true);\n      }\n}"
  }
]