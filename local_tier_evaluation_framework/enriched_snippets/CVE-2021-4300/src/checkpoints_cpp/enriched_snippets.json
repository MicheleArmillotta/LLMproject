[
  {
    "function_name": "ProcessSyncCheckpoint",
    "container": "CSyncCheckpoint",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "387-435",
    "snippet": "bool CSyncCheckpoint::ProcessSyncCheckpoint(CNode* pfrom)\n{\n    if (!CheckSignature())\n        return false;\n\n    LOCK(Checkpoints::cs_hashSyncCheckpoint);\n    if (!mapBlockIndex.count(hashCheckpoint))\n    {\n        // We haven't received the checkpoint chain, keep the checkpoint as pending\n        Checkpoints::hashPendingCheckpoint = hashCheckpoint;\n        Checkpoints::checkpointMessagePending = *this;\n        printf(\"ProcessSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashCheckpoint.ToString().c_str());\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, hashCheckpoint);\n            // ask directly as well in case rejected earlier by duplicate\n            // proof-of-stake because getblocks may not get it this time\n            pfrom->AskFor(CInv(MSG_BLOCK, mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint));\n        }\n        return false;\n    }\n\n    if (!Checkpoints::ValidateSyncCheckpoint(hashCheckpoint))\n        return false;\n\n    CTxDB txdb;\n    CBlockIndex* pindexCheckpoint = mapBlockIndex[hashCheckpoint];\n    if (!pindexCheckpoint->IsInMainChain())\n    {\n        // checkpoint chain received but not yet main chain\n        CBlock block;\n        if (!block.ReadFromDisk(pindexCheckpoint))\n            return error(\"ProcessSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        if (!block.SetBestChain(txdb, pindexCheckpoint))\n        {\n            Checkpoints::hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ProcessSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n    }\n\n    if (!Checkpoints::WriteSyncCheckpoint(hashCheckpoint))\n        return error(\"ProcessSyncCheckpoint(): failed to write sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n    Checkpoints::checkpointMessage = *this;\n    Checkpoints::hashPendingCheckpoint = 0;\n    Checkpoints::checkpointMessagePending.SetNull();\n    printf(\"ProcessSyncCheckpoint: sync-checkpoint at %s\\n\", hashCheckpoint.ToString().c_str());\n    return true;\n}",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessSyncCheckpoint: sync-checkpoint at %s\\n\"",
            "hashCheckpoint.ToString().c_str()"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashCheckpoint.ToString",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::checkpointMessagePending.SetNull",
          "args": [],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "126-131",
          "snippet": "void SetNull()\n    {\n        CUnsignedSyncCheckpoint::SetNull();\n        vchMsg.clear();\n        vchSig.clear();\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  void SetNull()\n      {\n          CUnsignedSyncCheckpoint::SetNull();\n          vchMsg.clear();\n          vchSig.clear();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ProcessSyncCheckpoint(): failed to write sync checkpoint %s\"",
            "hashCheckpoint.ToString().c_str()"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::WriteSyncCheckpoint",
          "args": [
            "hashCheckpoint"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "144-158",
          "snippet": "bool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "block.SetBestChain",
          "args": [
            "txdb",
            "pindexCheckpoint"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChain",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1854-1953",
          "snippet": "bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexGenesisBlock = NULL;",
            "int nBestHeight = -1;",
            "uint256 nBestChainTrust = 0;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;",
            "int64_t nTimeBestReceived = 0;",
            "static CBlockIndex* pblockindexFBBHLast;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nuint256 nBestChainTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\nstatic CBlockIndex* pblockindexFBBHLast;\n\nCBlock {\n  bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      if (!txdb.TxnBegin())\n          return error(\"SetBestChain() : TxnBegin failed\");\n  \n      if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n      {\n          txdb.WriteHashBestChain(hash);\n          if (!txdb.TxnCommit())\n              return error(\"SetBestChain() : TxnCommit failed\");\n          pindexGenesisBlock = pindexNew;\n      }\n      else if (hashPrevBlock == hashBestChain)\n      {\n          if (!SetBestChainInner(txdb, pindexNew))\n              return error(\"SetBestChain() : SetBestChainInner failed\");\n      }\n      else\n      {\n          // the first block in the new chain that will cause it to become the new best chain\n          CBlockIndex *pindexIntermediate = pindexNew;\n  \n          // list of blocks that need to be connected afterwards\n          std::vector<CBlockIndex*> vpindexSecondary;\n  \n          // Reorganize is costly in terms of db load, as it works in a single db transaction.\n          // Try to limit how much needs to be done inside\n          while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n          {\n              vpindexSecondary.push_back(pindexIntermediate);\n              pindexIntermediate = pindexIntermediate->pprev;\n          }\n  \n          if (!vpindexSecondary.empty())\n              printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n  \n          // Switch to new best branch\n          if (!Reorganize(txdb, pindexIntermediate))\n          {\n              txdb.TxnAbort();\n              InvalidChainFound(pindexNew);\n              return error(\"SetBestChain() : Reorganize failed\");\n          }\n  \n          // Connect further blocks\n          BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n          {\n              CBlock block;\n              if (!block.ReadFromDisk(pindex))\n              {\n                  printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                  break;\n              }\n              if (!txdb.TxnBegin()) {\n                  printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                  break;\n              }\n              // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n              if (!block.SetBestChainInner(txdb, pindex))\n                  break;\n          }\n      }\n  \n      // Update best block in wallet (so we can detect restored wallets)\n      bool fIsInitialDownload = IsInitialBlockDownload();\n      if (!fIsInitialDownload)\n      {\n          const CBlockLocator locator(pindexNew);\n          ::SetBestChain(locator);\n      }\n  \n      // New best block\n      hashBestChain = hash;\n      pindexBest = pindexNew;\n      pblockindexFBBHLast = NULL;\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexNew->nChainTrust;\n      nTimeBestReceived = GetTime();\n      nTransactionsUpdated++;\n  \n      uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n  \n      printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n        CBigNum(nBestChainTrust).ToString().c_str(),\n        nBestBlockTrust.Get64(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      std::string strCmd = GetArg(\"-blocknotify\", \"\");\n  \n      if (!fIsInitialDownload && !strCmd.empty())\n      {\n          boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n          boost::thread t(runCommand, strCmd); // thread runs free\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindexCheckpoint"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "601-626",
          "snippet": "bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n      {\n          CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n  \n          // Read transaction\n          if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n              return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n  \n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          // Return file pointer\n          if (pfileRet)\n          {\n              if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                  return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n              *pfileRet = filein.release();\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexCheckpoint->IsInMainChain",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::ValidateSyncCheckpoint",
          "args": [
            "hashCheckpoint"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "102-142",
          "snippet": "bool ValidateSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        if (!mapBlockIndex.count(hashSyncCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for current sync-checkpoint %s\", hashSyncCheckpoint.ToString().c_str());\n        if (!mapBlockIndex.count(hashCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        CBlockIndex* pindexSyncCheckpoint = mapBlockIndex[hashSyncCheckpoint];\n        CBlockIndex* pindexCheckpointRecv = mapBlockIndex[hashCheckpoint];\n\n        if (pindexCheckpointRecv->nHeight <= pindexSyncCheckpoint->nHeight)\n        {\n            // Received an older checkpoint, trace back from current checkpoint\n            // to the same height of the received checkpoint to verify\n            // that current checkpoint should be a descendant block\n            CBlockIndex* pindex = pindexSyncCheckpoint;\n            while (pindex->nHeight > pindexCheckpointRecv->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"ValidateSyncCheckpoint: pprev null - block index structure failure\");\n            if (pindex->GetBlockHash() != hashCheckpoint)\n            {\n                hashInvalidCheckpoint = hashCheckpoint;\n                return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is conflicting with current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n            }\n            return false; // ignore older checkpoint\n        }\n\n        // Received checkpoint should be a descendant block of the current\n        // checkpoint. Trace back to the same height of current checkpoint\n        // to verify.\n        CBlockIndex* pindex = pindexCheckpointRecv;\n        while (pindex->nHeight > pindexSyncCheckpoint->nHeight)\n            if (!(pindex = pindex->pprev))\n                return error(\"ValidateSyncCheckpoint: pprev2 null - block index structure failure\");\n        if (pindex->GetBlockHash() != hashSyncCheckpoint)\n        {\n            hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n        }\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool ValidateSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        if (!mapBlockIndex.count(hashSyncCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for current sync-checkpoint %s\", hashSyncCheckpoint.ToString().c_str());\n        if (!mapBlockIndex.count(hashCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        CBlockIndex* pindexSyncCheckpoint = mapBlockIndex[hashSyncCheckpoint];\n        CBlockIndex* pindexCheckpointRecv = mapBlockIndex[hashCheckpoint];\n\n        if (pindexCheckpointRecv->nHeight <= pindexSyncCheckpoint->nHeight)\n        {\n            // Received an older checkpoint, trace back from current checkpoint\n            // to the same height of the received checkpoint to verify\n            // that current checkpoint should be a descendant block\n            CBlockIndex* pindex = pindexSyncCheckpoint;\n            while (pindex->nHeight > pindexCheckpointRecv->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"ValidateSyncCheckpoint: pprev null - block index structure failure\");\n            if (pindex->GetBlockHash() != hashCheckpoint)\n            {\n                hashInvalidCheckpoint = hashCheckpoint;\n                return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is conflicting with current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n            }\n            return false; // ignore older checkpoint\n        }\n\n        // Received checkpoint should be a descendant block of the current\n        // checkpoint. Trace back to the same height of current checkpoint\n        // to verify.\n        CBlockIndex* pindex = pindexCheckpointRecv;\n        while (pindex->nHeight > pindexSyncCheckpoint->nHeight)\n            if (!(pindex = pindex->pprev))\n                return error(\"ValidateSyncCheckpoint: pprev2 null - block index structure failure\");\n        if (pindex->GetBlockHash() != hashSyncCheckpoint)\n        {\n            hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n        }\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->AskFor",
          "args": [
            "CInv(MSG_BLOCK, mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint)"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "AskFor",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "315-333",
          "snippet": "void AskFor(const CInv& inv)\n    {\n        // We're using mapAskFor as a priority queue,\n        // the key is the earliest time the request can be sent\n        int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n        if (fDebugNet)\n            printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n\n        // Make sure not to reuse time indexes to keep things in the same order\n        int64_t nNow = (GetTime() - 1) * 1000000;\n        static int64_t nLastTime;\n        ++nLastTime;\n        nNow = std::max(nNow, nLastTime);\n        nLastTime = nNow;\n\n        // Each retry is 2 minutes after the last\n        nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n        mapAskFor.insert(std::make_pair(nRequestTime, inv));\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void AskFor(const CInv& inv)\n      {\n          // We're using mapAskFor as a priority queue,\n          // the key is the earliest time the request can be sent\n          int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n          if (fDebugNet)\n              printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n  \n          // Make sure not to reuse time indexes to keep things in the same order\n          int64_t nNow = (GetTime() - 1) * 1000000;\n          static int64_t nLastTime;\n          ++nLastTime;\n          nNow = std::max(nNow, nLastTime);\n          nLastTime = nNow;\n  \n          // Each retry is 2 minutes after the last\n          nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n          mapAskFor.insert(std::make_pair(nRequestTime, inv));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CInv",
          "args": [
            "MSG_BLOCK",
            "mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "CInv",
          "container": "CInv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "108-122",
          "snippet": "CInv::CInv(const std::string& strType, const uint256& hashIn)\n{\n    unsigned int i;\n    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n    {\n        if (strType == ppszTypeName[i])\n        {\n            type = i;\n            break;\n        }\n    }\n    if (i == ARRAYLEN(ppszTypeName))\n        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n    hash = hashIn;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nstatic const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};\n\nCInv {\n  CInv::CInv(const std::string& strType, const uint256& hashIn)\n  {\n      unsigned int i;\n      for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n      {\n          if (strType == ppszTypeName[i])\n          {\n              type = i;\n              break;\n          }\n      }\n      if (i == ARRAYLEN(ppszTypeName))\n          throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n      hash = hashIn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WantedByOrphan",
          "args": [
            "mapOrphanBlocks[hashCheckpoint]"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "WantedByOrphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "968-974",
          "snippet": "uint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CBlock*> mapOrphanBlocks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CBlock*> mapOrphanBlocks;\n\nuint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocks.count",
          "args": [
            "hashCheckpoint"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->PushGetBlocks",
          "args": [
            "pindexBest",
            "hashCheckpoint"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "PushGetBlocks",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "94-103",
          "snippet": "void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n{\n    // Filter out duplicate requests\n    if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n        return;\n    pindexLastGetBlocksBegin = pindexBegin;\n    hashLastGetBlocksEnd = hashEnd;\n\n    PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n  {\n      // Filter out duplicate requests\n      if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n          return;\n      pindexLastGetBlocksBegin = pindexBegin;\n      hashLastGetBlocksEnd = hashEnd;\n  \n      PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "Checkpoints::cs_hashSyncCheckpoint"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckSignature",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "CheckSignature",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "372-384",
          "snippet": "bool CSyncCheckpoint::CheckSignature()\n{\n    CKey key;\n    if (!key.SetPubKey(ParseHex(CSyncCheckpoint::strMasterPubKey)))\n        return error(\"CSyncCheckpoint::CheckSignature() : SetPubKey failed\");\n    if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n        return error(\"CSyncCheckpoint::CheckSignature() : verify signature failed\");\n\n    // Now unserialize the data\n    CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n    sMsg >> *(CUnsignedSyncCheckpoint*)this;\n    return true;\n}",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [
            "const std::string CSyncCheckpoint::strMasterPubKey = \"045aedaf2058a4cb48beb4899daa560767a8f79f43cbead97c197feb45fc40a390e3ff54fcab33e196e66c694e0348bfacaf118d2cc705cae546b78d650ddb35e2\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nconst std::string CSyncCheckpoint::strMasterPubKey = \"045aedaf2058a4cb48beb4899daa560767a8f79f43cbead97c197feb45fc40a390e3ff54fcab33e196e66c694e0348bfacaf118d2cc705cae546b78d650ddb35e2\";\n\nCSyncCheckpoint {\n  bool CSyncCheckpoint::CheckSignature()\n  {\n      CKey key;\n      if (!key.SetPubKey(ParseHex(CSyncCheckpoint::strMasterPubKey)))\n          return error(\"CSyncCheckpoint::CheckSignature() : SetPubKey failed\");\n      if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n          return error(\"CSyncCheckpoint::CheckSignature() : verify signature failed\");\n  \n      // Now unserialize the data\n      CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n      sMsg >> *(CUnsignedSyncCheckpoint*)this;\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nCSyncCheckpoint {\n  bool CSyncCheckpoint::ProcessSyncCheckpoint(CNode* pfrom)\n  {\n      if (!CheckSignature())\n          return false;\n  \n      LOCK(Checkpoints::cs_hashSyncCheckpoint);\n      if (!mapBlockIndex.count(hashCheckpoint))\n      {\n          // We haven't received the checkpoint chain, keep the checkpoint as pending\n          Checkpoints::hashPendingCheckpoint = hashCheckpoint;\n          Checkpoints::checkpointMessagePending = *this;\n          printf(\"ProcessSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashCheckpoint.ToString().c_str());\n          // Ask this guy to fill in what we're missing\n          if (pfrom)\n          {\n              pfrom->PushGetBlocks(pindexBest, hashCheckpoint);\n              // ask directly as well in case rejected earlier by duplicate\n              // proof-of-stake because getblocks may not get it this time\n              pfrom->AskFor(CInv(MSG_BLOCK, mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint));\n          }\n          return false;\n      }\n  \n      if (!Checkpoints::ValidateSyncCheckpoint(hashCheckpoint))\n          return false;\n  \n      CTxDB txdb;\n      CBlockIndex* pindexCheckpoint = mapBlockIndex[hashCheckpoint];\n      if (!pindexCheckpoint->IsInMainChain())\n      {\n          // checkpoint chain received but not yet main chain\n          CBlock block;\n          if (!block.ReadFromDisk(pindexCheckpoint))\n              return error(\"ProcessSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n          if (!block.SetBestChain(txdb, pindexCheckpoint))\n          {\n              Checkpoints::hashInvalidCheckpoint = hashCheckpoint;\n              return error(\"ProcessSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n          }\n      }\n  \n      if (!Checkpoints::WriteSyncCheckpoint(hashCheckpoint))\n          return error(\"ProcessSyncCheckpoint(): failed to write sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n      Checkpoints::checkpointMessage = *this;\n      Checkpoints::hashPendingCheckpoint = 0;\n      Checkpoints::checkpointMessagePending.SetNull();\n      printf(\"ProcessSyncCheckpoint: sync-checkpoint at %s\\n\", hashCheckpoint.ToString().c_str());\n      return true;\n  }\n}"
  },
  {
    "function_name": "CheckSignature",
    "container": "CSyncCheckpoint",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "372-384",
    "snippet": "bool CSyncCheckpoint::CheckSignature()\n{\n    CKey key;\n    if (!key.SetPubKey(ParseHex(CSyncCheckpoint::strMasterPubKey)))\n        return error(\"CSyncCheckpoint::CheckSignature() : SetPubKey failed\");\n    if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n        return error(\"CSyncCheckpoint::CheckSignature() : verify signature failed\");\n\n    // Now unserialize the data\n    CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n    sMsg >> *(CUnsignedSyncCheckpoint*)this;\n    return true;\n}",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [
      "const std::string CSyncCheckpoint::strMasterPubKey = \"045aedaf2058a4cb48beb4899daa560767a8f79f43cbead97c197feb45fc40a390e3ff54fcab33e196e66c694e0348bfacaf118d2cc705cae546b78d650ddb35e2\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CSyncCheckpoint::CheckSignature() : verify signature failed\""
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.Verify",
          "args": [
            "Hash(vchMsg.begin(), vchMsg.end())",
            "vchSig"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "Verify",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "392-399",
          "snippet": "bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    // -1 = error, 0 = bad sig, 1 = good\n    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      // -1 = error, 0 = bad sig, 1 = good\n      if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n          return false;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "vchMsg.begin()",
            "vchMsg.end()"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchMsg.end",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchMsg.begin",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetPubKey",
          "args": [
            "ParseHex(CSyncCheckpoint::strMasterPubKey)"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "SetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "259-272",
          "snippet": "bool CKey::SetPubKey(const CPubKey& vchPubKey)\n{\n    const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n    {\n        fSet = true;\n        if (vchPubKey.vchPubKey.size() == 33)\n            SetCompressedPubKey();\n        return true;\n    }\n    pkey = NULL;\n    Reset();\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPubKey(const CPubKey& vchPubKey)\n  {\n      const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n      if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n      {\n          fSet = true;\n          if (vchPubKey.vchPubKey.size() == 33)\n              SetCompressedPubKey();\n          return true;\n      }\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "CSyncCheckpoint::strMasterPubKey"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nconst std::string CSyncCheckpoint::strMasterPubKey = \"045aedaf2058a4cb48beb4899daa560767a8f79f43cbead97c197feb45fc40a390e3ff54fcab33e196e66c694e0348bfacaf118d2cc705cae546b78d650ddb35e2\";\n\nCSyncCheckpoint {\n  bool CSyncCheckpoint::CheckSignature()\n  {\n      CKey key;\n      if (!key.SetPubKey(ParseHex(CSyncCheckpoint::strMasterPubKey)))\n          return error(\"CSyncCheckpoint::CheckSignature() : SetPubKey failed\");\n      if (!key.Verify(Hash(vchMsg.begin(), vchMsg.end()), vchSig))\n          return error(\"CSyncCheckpoint::CheckSignature() : verify signature failed\");\n  \n      // Now unserialize the data\n      CDataStream sMsg(vchMsg, SER_NETWORK, PROTOCOL_VERSION);\n      sMsg >> *(CUnsignedSyncCheckpoint*)this;\n      return true;\n  }\n}"
  },
  {
    "function_name": "IsMatureSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "355-363",
    "snippet": "bool IsMatureSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        // sync-checkpoint should always be accepted block\n        assert(mapBlockIndex.count(hashSyncCheckpoint));\n        const CBlockIndex* pindexSync = mapBlockIndex[hashSyncCheckpoint];\n        return (nBestHeight >= pindexSync->nHeight + nCoinbaseMaturity ||\n                pindexSync->GetBlockTime() + nStakeMinAge < GetAdjustedTime());\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexSync->GetBlockTime",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapBlockIndex.count(hashSyncCheckpoint)"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hashSyncCheckpoint"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_hashSyncCheckpoint"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool IsMatureSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        // sync-checkpoint should always be accepted block\n        assert(mapBlockIndex.count(hashSyncCheckpoint));\n        const CBlockIndex* pindexSync = mapBlockIndex[hashSyncCheckpoint];\n        return (nBestHeight >= pindexSync->nHeight + nCoinbaseMaturity ||\n                pindexSync->GetBlockTime() + nStakeMinAge < GetAdjustedTime());\n    }"
  },
  {
    "function_name": "SendSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "323-352",
    "snippet": "bool SendSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = hashCheckpoint;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        if (CSyncCheckpoint::strMasterPrivKey.empty())\n            return error(\"SendSyncCheckpoint: Checkpoint master key unavailable.\");\n        std::vector<unsigned char> vchPrivKey = ParseHex(CSyncCheckpoint::strMasterPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return error(\"SendSyncCheckpoint: Unable to sign checkpoint, check private key?\");\n\n        if(!checkpoint.ProcessSyncCheckpoint(NULL))\n        {\n            printf(\"WARNING: SendSyncCheckpoint: Failed to process checkpoint.\\n\");\n            return false;\n        }\n\n        // Relay checkpoint\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n        return true;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [
      "std::string CSyncCheckpoint::strMasterPrivKey = \"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkpoint.RelayTo",
          "args": [
            "pnode"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTo",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "143-153",
          "snippet": "bool RelayTo(CNode* pnode) const\n    {\n        // returns true if wasn't already sent\n        if (pnode->hashCheckpointKnown != hashCheckpoint)\n        {\n            pnode->hashCheckpointKnown = hashCheckpoint;\n            pnode->PushMessage(\"checkpoint\", *this);\n            return true;\n        }\n        return false;\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  bool RelayTo(CNode* pnode) const\n      {\n          // returns true if wasn't already sent\n          if (pnode->hashCheckpointKnown != hashCheckpoint)\n          {\n              pnode->hashCheckpointKnown = hashCheckpoint;\n              pnode->PushMessage(\"checkpoint\", *this);\n              return true;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARNING: SendSyncCheckpoint: Failed to process checkpoint.\\n\""
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkpoint.ProcessSyncCheckpoint",
          "args": [
            "NULL"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessSyncCheckpoint",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "387-435",
          "snippet": "bool CSyncCheckpoint::ProcessSyncCheckpoint(CNode* pfrom)\n{\n    if (!CheckSignature())\n        return false;\n\n    LOCK(Checkpoints::cs_hashSyncCheckpoint);\n    if (!mapBlockIndex.count(hashCheckpoint))\n    {\n        // We haven't received the checkpoint chain, keep the checkpoint as pending\n        Checkpoints::hashPendingCheckpoint = hashCheckpoint;\n        Checkpoints::checkpointMessagePending = *this;\n        printf(\"ProcessSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashCheckpoint.ToString().c_str());\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, hashCheckpoint);\n            // ask directly as well in case rejected earlier by duplicate\n            // proof-of-stake because getblocks may not get it this time\n            pfrom->AskFor(CInv(MSG_BLOCK, mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint));\n        }\n        return false;\n    }\n\n    if (!Checkpoints::ValidateSyncCheckpoint(hashCheckpoint))\n        return false;\n\n    CTxDB txdb;\n    CBlockIndex* pindexCheckpoint = mapBlockIndex[hashCheckpoint];\n    if (!pindexCheckpoint->IsInMainChain())\n    {\n        // checkpoint chain received but not yet main chain\n        CBlock block;\n        if (!block.ReadFromDisk(pindexCheckpoint))\n            return error(\"ProcessSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        if (!block.SetBestChain(txdb, pindexCheckpoint))\n        {\n            Checkpoints::hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ProcessSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n    }\n\n    if (!Checkpoints::WriteSyncCheckpoint(hashCheckpoint))\n        return error(\"ProcessSyncCheckpoint(): failed to write sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n    Checkpoints::checkpointMessage = *this;\n    Checkpoints::hashPendingCheckpoint = 0;\n    Checkpoints::checkpointMessagePending.SetNull();\n    printf(\"ProcessSyncCheckpoint: sync-checkpoint at %s\\n\", hashCheckpoint.ToString().c_str());\n    return true;\n}",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nCSyncCheckpoint {\n  bool CSyncCheckpoint::ProcessSyncCheckpoint(CNode* pfrom)\n  {\n      if (!CheckSignature())\n          return false;\n  \n      LOCK(Checkpoints::cs_hashSyncCheckpoint);\n      if (!mapBlockIndex.count(hashCheckpoint))\n      {\n          // We haven't received the checkpoint chain, keep the checkpoint as pending\n          Checkpoints::hashPendingCheckpoint = hashCheckpoint;\n          Checkpoints::checkpointMessagePending = *this;\n          printf(\"ProcessSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashCheckpoint.ToString().c_str());\n          // Ask this guy to fill in what we're missing\n          if (pfrom)\n          {\n              pfrom->PushGetBlocks(pindexBest, hashCheckpoint);\n              // ask directly as well in case rejected earlier by duplicate\n              // proof-of-stake because getblocks may not get it this time\n              pfrom->AskFor(CInv(MSG_BLOCK, mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint));\n          }\n          return false;\n      }\n  \n      if (!Checkpoints::ValidateSyncCheckpoint(hashCheckpoint))\n          return false;\n  \n      CTxDB txdb;\n      CBlockIndex* pindexCheckpoint = mapBlockIndex[hashCheckpoint];\n      if (!pindexCheckpoint->IsInMainChain())\n      {\n          // checkpoint chain received but not yet main chain\n          CBlock block;\n          if (!block.ReadFromDisk(pindexCheckpoint))\n              return error(\"ProcessSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n          if (!block.SetBestChain(txdb, pindexCheckpoint))\n          {\n              Checkpoints::hashInvalidCheckpoint = hashCheckpoint;\n              return error(\"ProcessSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n          }\n      }\n  \n      if (!Checkpoints::WriteSyncCheckpoint(hashCheckpoint))\n          return error(\"ProcessSyncCheckpoint(): failed to write sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n      Checkpoints::checkpointMessage = *this;\n      Checkpoints::hashPendingCheckpoint = 0;\n      Checkpoints::checkpointMessagePending.SetNull();\n      printf(\"ProcessSyncCheckpoint: sync-checkpoint at %s\\n\", hashCheckpoint.ToString().c_str());\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SendSyncCheckpoint: Unable to sign checkpoint, check private key?\""
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.Sign",
          "args": [
            "Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end())",
            "checkpoint.vchSig"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "Sign",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "286-312",
          "snippet": "bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n{\n    vchSig.clear();\n    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n    if (sig == NULL)\n        return false;\n    BN_CTX *ctx = BN_CTX_new();\n    BN_CTX_start(ctx);\n    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n    BIGNUM *order = BN_CTX_get(ctx);\n    BIGNUM *halforder = BN_CTX_get(ctx);\n    EC_GROUP_get_order(group, order, ctx);\n    BN_rshift1(halforder, order);\n    if (BN_cmp(sig->s, halforder) > 0) {\n        // enforce low S values, by negating the value (modulo the order) if above order/2.\n        BN_sub(sig->s, order, sig->s);\n    }\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    unsigned int nSize = ECDSA_size(pkey);\n    vchSig.resize(nSize); // Make sure it is big enough\n    unsigned char *pos = &vchSig[0];\n    nSize = i2d_ECDSA_SIG(sig, &pos);\n    ECDSA_SIG_free(sig);\n    vchSig.resize(nSize); // Shrink to fit actual size\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n  {\n      vchSig.clear();\n      ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n      if (sig == NULL)\n          return false;\n      BN_CTX *ctx = BN_CTX_new();\n      BN_CTX_start(ctx);\n      const EC_GROUP *group = EC_KEY_get0_group(pkey);\n      BIGNUM *order = BN_CTX_get(ctx);\n      BIGNUM *halforder = BN_CTX_get(ctx);\n      EC_GROUP_get_order(group, order, ctx);\n      BN_rshift1(halforder, order);\n      if (BN_cmp(sig->s, halforder) > 0) {\n          // enforce low S values, by negating the value (modulo the order) if above order/2.\n          BN_sub(sig->s, order, sig->s);\n      }\n      BN_CTX_end(ctx);\n      BN_CTX_free(ctx);\n      unsigned int nSize = ECDSA_size(pkey);\n      vchSig.resize(nSize); // Make sure it is big enough\n      unsigned char *pos = &vchSig[0];\n      nSize = i2d_ECDSA_SIG(sig, &pos);\n      ECDSA_SIG_free(sig);\n      vchSig.resize(nSize); // Shrink to fit actual size\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "checkpoint.vchMsg.begin()",
            "checkpoint.vchMsg.end()"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpoint.vchMsg.end",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpoint.vchMsg.begin",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetPrivKey",
          "args": [
            "CPrivKey(vchPrivKey.begin(), vchPrivKey.end())"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "SetPrivKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "186-207",
          "snippet": "bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n{\n    const unsigned char* pbegin = &vchPrivKey[0];\n    if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n    {\n        // In testing, d2i_ECPrivateKey can return true\n        // but fill in pkey with a key that fails\n        // EC_KEY_check_key, so:\n        if (EC_KEY_check_key(pkey))\n        {\n            fSet = true;\n            return true;\n        }\n    }\n    // If vchPrivKey data is bad d2i_ECPrivateKey() can\n    // leave pkey in a state where calling EC_KEY_free()\n    // crashes. To avoid that, set pkey to NULL and\n    // leak the memory (a leak is better than a crash)\n    pkey = NULL;\n    Reset();\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n  {\n      const unsigned char* pbegin = &vchPrivKey[0];\n      if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n      {\n          // In testing, d2i_ECPrivateKey can return true\n          // but fill in pkey with a key that fails\n          // EC_KEY_check_key, so:\n          if (EC_KEY_check_key(pkey))\n          {\n              fSet = true;\n              return true;\n          }\n      }\n      // If vchPrivKey data is bad d2i_ECPrivateKey() can\n      // leave pkey in a state where calling EC_KEY_free()\n      // crashes. To avoid that, set pkey to NULL and\n      // leak the memory (a leak is better than a crash)\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPrivKey",
          "args": [
            "vchPrivKey.begin()",
            "vchPrivKey.end()"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "CSyncCheckpoint::strMasterPrivKey"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "CSyncCheckpoint::strMasterPrivKey.empty",
          "args": [],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::vector<unsigned char>",
          "args": [
            "sMsg.begin()",
            "sMsg.end()"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nstd::string CSyncCheckpoint::strMasterPrivKey = \"\";\n\nbool SendSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = hashCheckpoint;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        if (CSyncCheckpoint::strMasterPrivKey.empty())\n            return error(\"SendSyncCheckpoint: Checkpoint master key unavailable.\");\n        std::vector<unsigned char> vchPrivKey = ParseHex(CSyncCheckpoint::strMasterPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return error(\"SendSyncCheckpoint: Unable to sign checkpoint, check private key?\");\n\n        if(!checkpoint.ProcessSyncCheckpoint(NULL))\n        {\n            printf(\"WARNING: SendSyncCheckpoint: Failed to process checkpoint.\\n\");\n            return false;\n        }\n\n        // Relay checkpoint\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n        return true;\n    }"
  },
  {
    "function_name": "SetCheckpointPrivKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "303-321",
    "snippet": "bool SetCheckpointPrivKey(std::string strPrivKey)\n    {\n        // Test signing a sync-checkpoint with genesis block\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = !fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        std::vector<unsigned char> vchPrivKey = ParseHex(strPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return false;\n\n        // Test signing successful, proceed\n        CSyncCheckpoint::strMasterPrivKey = strPrivKey;\n        return true;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [
      "std::string CSyncCheckpoint::strMasterPrivKey = \"\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key.Sign",
          "args": [
            "Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end())",
            "checkpoint.vchSig"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "Sign",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "286-312",
          "snippet": "bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n{\n    vchSig.clear();\n    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n    if (sig == NULL)\n        return false;\n    BN_CTX *ctx = BN_CTX_new();\n    BN_CTX_start(ctx);\n    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n    BIGNUM *order = BN_CTX_get(ctx);\n    BIGNUM *halforder = BN_CTX_get(ctx);\n    EC_GROUP_get_order(group, order, ctx);\n    BN_rshift1(halforder, order);\n    if (BN_cmp(sig->s, halforder) > 0) {\n        // enforce low S values, by negating the value (modulo the order) if above order/2.\n        BN_sub(sig->s, order, sig->s);\n    }\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    unsigned int nSize = ECDSA_size(pkey);\n    vchSig.resize(nSize); // Make sure it is big enough\n    unsigned char *pos = &vchSig[0];\n    nSize = i2d_ECDSA_SIG(sig, &pos);\n    ECDSA_SIG_free(sig);\n    vchSig.resize(nSize); // Shrink to fit actual size\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n  {\n      vchSig.clear();\n      ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n      if (sig == NULL)\n          return false;\n      BN_CTX *ctx = BN_CTX_new();\n      BN_CTX_start(ctx);\n      const EC_GROUP *group = EC_KEY_get0_group(pkey);\n      BIGNUM *order = BN_CTX_get(ctx);\n      BIGNUM *halforder = BN_CTX_get(ctx);\n      EC_GROUP_get_order(group, order, ctx);\n      BN_rshift1(halforder, order);\n      if (BN_cmp(sig->s, halforder) > 0) {\n          // enforce low S values, by negating the value (modulo the order) if above order/2.\n          BN_sub(sig->s, order, sig->s);\n      }\n      BN_CTX_end(ctx);\n      BN_CTX_free(ctx);\n      unsigned int nSize = ECDSA_size(pkey);\n      vchSig.resize(nSize); // Make sure it is big enough\n      unsigned char *pos = &vchSig[0];\n      nSize = i2d_ECDSA_SIG(sig, &pos);\n      ECDSA_SIG_free(sig);\n      vchSig.resize(nSize); // Shrink to fit actual size\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "checkpoint.vchMsg.begin()",
            "checkpoint.vchMsg.end()"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpoint.vchMsg.end",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpoint.vchMsg.begin",
          "args": [],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetPrivKey",
          "args": [
            "CPrivKey(vchPrivKey.begin(), vchPrivKey.end())"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "SetPrivKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "186-207",
          "snippet": "bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n{\n    const unsigned char* pbegin = &vchPrivKey[0];\n    if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n    {\n        // In testing, d2i_ECPrivateKey can return true\n        // but fill in pkey with a key that fails\n        // EC_KEY_check_key, so:\n        if (EC_KEY_check_key(pkey))\n        {\n            fSet = true;\n            return true;\n        }\n    }\n    // If vchPrivKey data is bad d2i_ECPrivateKey() can\n    // leave pkey in a state where calling EC_KEY_free()\n    // crashes. To avoid that, set pkey to NULL and\n    // leak the memory (a leak is better than a crash)\n    pkey = NULL;\n    Reset();\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n  {\n      const unsigned char* pbegin = &vchPrivKey[0];\n      if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n      {\n          // In testing, d2i_ECPrivateKey can return true\n          // but fill in pkey with a key that fails\n          // EC_KEY_check_key, so:\n          if (EC_KEY_check_key(pkey))\n          {\n              fSet = true;\n              return true;\n          }\n      }\n      // If vchPrivKey data is bad d2i_ECPrivateKey() can\n      // leave pkey in a state where calling EC_KEY_free()\n      // crashes. To avoid that, set pkey to NULL and\n      // leak the memory (a leak is better than a crash)\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPrivKey",
          "args": [
            "vchPrivKey.begin()",
            "vchPrivKey.end()"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "strPrivKey"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::vector<unsigned char>",
          "args": [
            "sMsg.begin()",
            "sMsg.end()"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nstd::string CSyncCheckpoint::strMasterPrivKey = \"\";\n\nbool SetCheckpointPrivKey(std::string strPrivKey)\n    {\n        // Test signing a sync-checkpoint with genesis block\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = !fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        std::vector<unsigned char> vchPrivKey = ParseHex(strPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return false;\n\n        // Test signing successful, proceed\n        CSyncCheckpoint::strMasterPrivKey = strPrivKey;\n        return true;\n    }"
  },
  {
    "function_name": "AskForPendingSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "296-301",
    "snippet": "void AskForPendingSyncCheckpoint(CNode* pfrom)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (pfrom && hashPendingCheckpoint != 0 && (!mapBlockIndex.count(hashPendingCheckpoint)) && (!mapOrphanBlocks.count(hashPendingCheckpoint)))\n            pfrom->AskFor(CInv(MSG_BLOCK, hashPendingCheckpoint));\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pfrom->AskFor",
          "args": [
            "CInv(MSG_BLOCK, hashPendingCheckpoint)"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "AskFor",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "315-333",
          "snippet": "void AskFor(const CInv& inv)\n    {\n        // We're using mapAskFor as a priority queue,\n        // the key is the earliest time the request can be sent\n        int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n        if (fDebugNet)\n            printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n\n        // Make sure not to reuse time indexes to keep things in the same order\n        int64_t nNow = (GetTime() - 1) * 1000000;\n        static int64_t nLastTime;\n        ++nLastTime;\n        nNow = std::max(nNow, nLastTime);\n        nLastTime = nNow;\n\n        // Each retry is 2 minutes after the last\n        nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n        mapAskFor.insert(std::make_pair(nRequestTime, inv));\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void AskFor(const CInv& inv)\n      {\n          // We're using mapAskFor as a priority queue,\n          // the key is the earliest time the request can be sent\n          int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n          if (fDebugNet)\n              printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n  \n          // Make sure not to reuse time indexes to keep things in the same order\n          int64_t nNow = (GetTime() - 1) * 1000000;\n          static int64_t nLastTime;\n          ++nLastTime;\n          nNow = std::max(nNow, nLastTime);\n          nLastTime = nNow;\n  \n          // Each retry is 2 minutes after the last\n          nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n          mapAskFor.insert(std::make_pair(nRequestTime, inv));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CInv",
          "args": [
            "MSG_BLOCK",
            "hashPendingCheckpoint"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "CInv",
          "container": "CInv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "108-122",
          "snippet": "CInv::CInv(const std::string& strType, const uint256& hashIn)\n{\n    unsigned int i;\n    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n    {\n        if (strType == ppszTypeName[i])\n        {\n            type = i;\n            break;\n        }\n    }\n    if (i == ARRAYLEN(ppszTypeName))\n        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n    hash = hashIn;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nstatic const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};\n\nCInv {\n  CInv::CInv(const std::string& strType, const uint256& hashIn)\n  {\n      unsigned int i;\n      for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n      {\n          if (strType == ppszTypeName[i])\n          {\n              type = i;\n              break;\n          }\n      }\n      if (i == ARRAYLEN(ppszTypeName))\n          throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n      hash = hashIn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocks.count",
          "args": [
            "hashPendingCheckpoint"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_hashSyncCheckpoint"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nvoid AskForPendingSyncCheckpoint(CNode* pfrom)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (pfrom && hashPendingCheckpoint != 0 && (!mapBlockIndex.count(hashPendingCheckpoint)) && (!mapOrphanBlocks.count(hashPendingCheckpoint)))\n            pfrom->AskFor(CInv(MSG_BLOCK, hashPendingCheckpoint));\n    }"
  },
  {
    "function_name": "ResetSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "256-294",
    "snippet": "bool ResetSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        const uint256& hash = mapCheckpoints.rbegin()->second;\n        if (mapBlockIndex.count(hash) && !mapBlockIndex[hash]->IsInMainChain())\n        {\n            // checkpoint block accepted but not yet in main chain\n            printf(\"ResetSyncCheckpoint: SetBestChain to hardened checkpoint %s\\n\", hash.ToString().c_str());\n            CTxDB txdb;\n            CBlock block;\n            if (!block.ReadFromDisk(mapBlockIndex[hash]))\n                return error(\"ResetSyncCheckpoint: ReadFromDisk failed for hardened checkpoint %s\", hash.ToString().c_str());\n            if (!block.SetBestChain(txdb, mapBlockIndex[hash]))\n            {\n                return error(\"ResetSyncCheckpoint: SetBestChain failed for hardened checkpoint %s\", hash.ToString().c_str());\n            }\n        }\n        else if(!mapBlockIndex.count(hash))\n        {\n            // checkpoint block not yet accepted\n            hashPendingCheckpoint = hash;\n            checkpointMessagePending.SetNull();\n            printf(\"ResetSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashPendingCheckpoint.ToString().c_str());\n        }\n\n        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, mapCheckpoints)\n        {\n            const uint256& hash = i.second;\n            if (mapBlockIndex.count(hash) && mapBlockIndex[hash]->IsInMainChain())\n            {\n                if (!WriteSyncCheckpoint(hash))\n                    return error(\"ResetSyncCheckpoint: failed to write sync checkpoint %s\", hash.ToString().c_str());\n                printf(\"ResetSyncCheckpoint: sync-checkpoint reset to %s\\n\", hashSyncCheckpoint.ToString().c_str());\n                return true;\n            }\n        }\n\n        return false;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ResetSyncCheckpoint: sync-checkpoint reset to %s\\n\"",
            "hashSyncCheckpoint.ToString().c_str()"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashSyncCheckpoint.ToString",
          "args": [],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ResetSyncCheckpoint: failed to write sync checkpoint %s\"",
            "hash.ToString().c_str()"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteSyncCheckpoint",
          "args": [
            "hash"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "144-158",
          "snippet": "bool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex[hash]->IsInMainChain",
          "args": [],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hash"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpointMessagePending.SetNull",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "126-131",
          "snippet": "void SetNull()\n    {\n        CUnsignedSyncCheckpoint::SetNull();\n        vchMsg.clear();\n        vchSig.clear();\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  void SetNull()\n      {\n          CUnsignedSyncCheckpoint::SetNull();\n          vchMsg.clear();\n          vchSig.clear();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.SetBestChain",
          "args": [
            "txdb",
            "mapBlockIndex[hash]"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChain",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1854-1953",
          "snippet": "bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexGenesisBlock = NULL;",
            "int nBestHeight = -1;",
            "uint256 nBestChainTrust = 0;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;",
            "int64_t nTimeBestReceived = 0;",
            "static CBlockIndex* pblockindexFBBHLast;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nuint256 nBestChainTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\nstatic CBlockIndex* pblockindexFBBHLast;\n\nCBlock {\n  bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      if (!txdb.TxnBegin())\n          return error(\"SetBestChain() : TxnBegin failed\");\n  \n      if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n      {\n          txdb.WriteHashBestChain(hash);\n          if (!txdb.TxnCommit())\n              return error(\"SetBestChain() : TxnCommit failed\");\n          pindexGenesisBlock = pindexNew;\n      }\n      else if (hashPrevBlock == hashBestChain)\n      {\n          if (!SetBestChainInner(txdb, pindexNew))\n              return error(\"SetBestChain() : SetBestChainInner failed\");\n      }\n      else\n      {\n          // the first block in the new chain that will cause it to become the new best chain\n          CBlockIndex *pindexIntermediate = pindexNew;\n  \n          // list of blocks that need to be connected afterwards\n          std::vector<CBlockIndex*> vpindexSecondary;\n  \n          // Reorganize is costly in terms of db load, as it works in a single db transaction.\n          // Try to limit how much needs to be done inside\n          while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n          {\n              vpindexSecondary.push_back(pindexIntermediate);\n              pindexIntermediate = pindexIntermediate->pprev;\n          }\n  \n          if (!vpindexSecondary.empty())\n              printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n  \n          // Switch to new best branch\n          if (!Reorganize(txdb, pindexIntermediate))\n          {\n              txdb.TxnAbort();\n              InvalidChainFound(pindexNew);\n              return error(\"SetBestChain() : Reorganize failed\");\n          }\n  \n          // Connect further blocks\n          BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n          {\n              CBlock block;\n              if (!block.ReadFromDisk(pindex))\n              {\n                  printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                  break;\n              }\n              if (!txdb.TxnBegin()) {\n                  printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                  break;\n              }\n              // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n              if (!block.SetBestChainInner(txdb, pindex))\n                  break;\n          }\n      }\n  \n      // Update best block in wallet (so we can detect restored wallets)\n      bool fIsInitialDownload = IsInitialBlockDownload();\n      if (!fIsInitialDownload)\n      {\n          const CBlockLocator locator(pindexNew);\n          ::SetBestChain(locator);\n      }\n  \n      // New best block\n      hashBestChain = hash;\n      pindexBest = pindexNew;\n      pblockindexFBBHLast = NULL;\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexNew->nChainTrust;\n      nTimeBestReceived = GetTime();\n      nTransactionsUpdated++;\n  \n      uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n  \n      printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n        CBigNum(nBestChainTrust).ToString().c_str(),\n        nBestBlockTrust.Get64(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      std::string strCmd = GetArg(\"-blocknotify\", \"\");\n  \n      if (!fIsInitialDownload && !strCmd.empty())\n      {\n          boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n          boost::thread t(runCommand, strCmd); // thread runs free\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "mapBlockIndex[hash]"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "601-626",
          "snippet": "bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n      {\n          CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n  \n          // Read transaction\n          if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n              return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n  \n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          // Return file pointer\n          if (pfileRet)\n          {\n              if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                  return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n              *pfileRet = filein.release();\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapCheckpoints.rbegin",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_hashSyncCheckpoint"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool ResetSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        const uint256& hash = mapCheckpoints.rbegin()->second;\n        if (mapBlockIndex.count(hash) && !mapBlockIndex[hash]->IsInMainChain())\n        {\n            // checkpoint block accepted but not yet in main chain\n            printf(\"ResetSyncCheckpoint: SetBestChain to hardened checkpoint %s\\n\", hash.ToString().c_str());\n            CTxDB txdb;\n            CBlock block;\n            if (!block.ReadFromDisk(mapBlockIndex[hash]))\n                return error(\"ResetSyncCheckpoint: ReadFromDisk failed for hardened checkpoint %s\", hash.ToString().c_str());\n            if (!block.SetBestChain(txdb, mapBlockIndex[hash]))\n            {\n                return error(\"ResetSyncCheckpoint: SetBestChain failed for hardened checkpoint %s\", hash.ToString().c_str());\n            }\n        }\n        else if(!mapBlockIndex.count(hash))\n        {\n            // checkpoint block not yet accepted\n            hashPendingCheckpoint = hash;\n            checkpointMessagePending.SetNull();\n            printf(\"ResetSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashPendingCheckpoint.ToString().c_str());\n        }\n\n        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, mapCheckpoints)\n        {\n            const uint256& hash = i.second;\n            if (mapBlockIndex.count(hash) && mapBlockIndex[hash]->IsInMainChain())\n            {\n                if (!WriteSyncCheckpoint(hash))\n                    return error(\"ResetSyncCheckpoint: failed to write sync checkpoint %s\", hash.ToString().c_str());\n                printf(\"ResetSyncCheckpoint: sync-checkpoint reset to %s\\n\", hashSyncCheckpoint.ToString().c_str());\n                return true;\n            }\n        }\n\n        return false;\n    }"
  },
  {
    "function_name": "WantedByPendingSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "242-253",
    "snippet": "bool WantedByPendingSyncCheckpoint(uint256 hashBlock)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint == 0)\n            return false;\n        if (hashBlock == hashPendingCheckpoint)\n            return true;\n        if (mapOrphanBlocks.count(hashPendingCheckpoint) \n            && hashBlock == WantedByOrphan(mapOrphanBlocks[hashPendingCheckpoint]))\n            return true;\n        return false;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WantedByOrphan",
          "args": [
            "mapOrphanBlocks[hashPendingCheckpoint]"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "WantedByOrphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "968-974",
          "snippet": "uint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CBlock*> mapOrphanBlocks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CBlock*> mapOrphanBlocks;\n\nuint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocks.count",
          "args": [
            "hashPendingCheckpoint"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_hashSyncCheckpoint"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool WantedByPendingSyncCheckpoint(uint256 hashBlock)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint == 0)\n            return false;\n        if (hashBlock == hashPendingCheckpoint)\n            return true;\n        if (mapOrphanBlocks.count(hashPendingCheckpoint) \n            && hashBlock == WantedByOrphan(mapOrphanBlocks[hashPendingCheckpoint]))\n            return true;\n        return false;\n    }"
  },
  {
    "function_name": "CheckSync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "215-240",
    "snippet": "bool CheckSync(const uint256& hashBlock, const CBlockIndex* pindexPrev)\n    {\n        if (fTestNet) return true; // Testnet has no checkpoints\n        int nHeight = pindexPrev->nHeight + 1;\n\n        LOCK(cs_hashSyncCheckpoint);\n        // sync-checkpoint should always be accepted block\n        assert(mapBlockIndex.count(hashSyncCheckpoint));\n        const CBlockIndex* pindexSync = mapBlockIndex[hashSyncCheckpoint];\n\n        if (nHeight > pindexSync->nHeight)\n        {\n            // trace back to same height as sync-checkpoint\n            const CBlockIndex* pindex = pindexPrev;\n            while (pindex->nHeight > pindexSync->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"CheckSync: pprev null - block index structure failure\");\n            if (pindex->nHeight < pindexSync->nHeight || pindex->GetBlockHash() != hashSyncCheckpoint)\n                return false; // only descendant of sync-checkpoint can pass check\n        }\n        if (nHeight == pindexSync->nHeight && hashBlock != hashSyncCheckpoint)\n            return false; // same height with sync-checkpoint\n        if (nHeight < pindexSync->nHeight && !mapBlockIndex.count(hashBlock))\n            return false; // lower height than sync-checkpoint\n        return true;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hashBlock"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckSync: pprev null - block index structure failure\""
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapBlockIndex.count(hashSyncCheckpoint)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_hashSyncCheckpoint"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool CheckSync(const uint256& hashBlock, const CBlockIndex* pindexPrev)\n    {\n        if (fTestNet) return true; // Testnet has no checkpoints\n        int nHeight = pindexPrev->nHeight + 1;\n\n        LOCK(cs_hashSyncCheckpoint);\n        // sync-checkpoint should always be accepted block\n        assert(mapBlockIndex.count(hashSyncCheckpoint));\n        const CBlockIndex* pindexSync = mapBlockIndex[hashSyncCheckpoint];\n\n        if (nHeight > pindexSync->nHeight)\n        {\n            // trace back to same height as sync-checkpoint\n            const CBlockIndex* pindex = pindexPrev;\n            while (pindex->nHeight > pindexSync->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"CheckSync: pprev null - block index structure failure\");\n            if (pindex->nHeight < pindexSync->nHeight || pindex->GetBlockHash() != hashSyncCheckpoint)\n                return false; // only descendant of sync-checkpoint can pass check\n        }\n        if (nHeight == pindexSync->nHeight && hashBlock != hashSyncCheckpoint)\n            return false; // same height with sync-checkpoint\n        if (nHeight < pindexSync->nHeight && !mapBlockIndex.count(hashBlock))\n            return false; // lower height than sync-checkpoint\n        return true;\n    }"
  },
  {
    "function_name": "AutoSelectSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "204-212",
    "snippet": "uint256 AutoSelectSyncCheckpoint() {\n        /* No immediate checkpointing on either PoW or PoS blocks,\n         * select by depth in the main chain rather than block time */\n        const CBlockIndex *pindex = pindexBest;\n        const int nCheckpointDepth = GetArg(\"-checkpointdepth\", CHECKPOINT_DEFAULT_DEPTH);\n        while(pindex->pprev && ((pindex->nHeight + nCheckpointDepth) > pindexBest->nHeight))\n          pindex = pindex->pprev;\n        return(pindex->GetBlockHash());\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-checkpointdepth\"",
            "CHECKPOINT_DEFAULT_DEPTH"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nuint256 AutoSelectSyncCheckpoint() {\n        /* No immediate checkpointing on either PoW or PoS blocks,\n         * select by depth in the main chain rather than block time */\n        const CBlockIndex *pindex = pindexBest;\n        const int nCheckpointDepth = GetArg(\"-checkpointdepth\", CHECKPOINT_DEFAULT_DEPTH);\n        while(pindex->pprev && ((pindex->nHeight + nCheckpointDepth) > pindexBest->nHeight))\n          pindex = pindex->pprev;\n        return(pindex->GetBlockHash());\n    }"
  },
  {
    "function_name": "AcceptPendingSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "160-201",
    "snippet": "bool AcceptPendingSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint != 0 && mapBlockIndex.count(hashPendingCheckpoint))\n        {\n            if (!ValidateSyncCheckpoint(hashPendingCheckpoint))\n            {\n                hashPendingCheckpoint = 0;\n                checkpointMessagePending.SetNull();\n                return false;\n            }\n\n            CTxDB txdb;\n            CBlockIndex* pindexCheckpoint = mapBlockIndex[hashPendingCheckpoint];\n            if (!pindexCheckpoint->IsInMainChain())\n            {\n                CBlock block;\n                if (!block.ReadFromDisk(pindexCheckpoint))\n                    return error(\"AcceptPendingSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                if (!block.SetBestChain(txdb, pindexCheckpoint))\n                {\n                    hashInvalidCheckpoint = hashPendingCheckpoint;\n                    return error(\"AcceptPendingSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                }\n            }\n\n            if (!WriteSyncCheckpoint(hashPendingCheckpoint))\n                return error(\"AcceptPendingSyncCheckpoint(): failed to write sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n            hashPendingCheckpoint = 0;\n            checkpointMessage = checkpointMessagePending;\n            checkpointMessagePending.SetNull();\n            printf(\"AcceptPendingSyncCheckpoint : sync-checkpoint at %s\\n\", hashSyncCheckpoint.ToString().c_str());\n            // relay the checkpoint\n            if (!checkpointMessage.IsNull())\n            {\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    checkpointMessage.RelayTo(pnode);\n            }\n            return true;\n        }\n        return false;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkpointMessage.RelayTo",
          "args": [
            "pnode"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTo",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "143-153",
          "snippet": "bool RelayTo(CNode* pnode) const\n    {\n        // returns true if wasn't already sent\n        if (pnode->hashCheckpointKnown != hashCheckpoint)\n        {\n            pnode->hashCheckpointKnown = hashCheckpoint;\n            pnode->PushMessage(\"checkpoint\", *this);\n            return true;\n        }\n        return false;\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  bool RelayTo(CNode* pnode) const\n      {\n          // returns true if wasn't already sent\n          if (pnode->hashCheckpointKnown != hashCheckpoint)\n          {\n              pnode->hashCheckpointKnown = hashCheckpoint;\n              pnode->PushMessage(\"checkpoint\", *this);\n              return true;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpointMessage.IsNull",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "IsNull",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "133-136",
          "snippet": "bool IsNull() const\n    {\n        return (hashCheckpoint == 0);\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  bool IsNull() const\n      {\n          return (hashCheckpoint == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AcceptPendingSyncCheckpoint : sync-checkpoint at %s\\n\"",
            "hashSyncCheckpoint.ToString().c_str()"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashSyncCheckpoint.ToString",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpointMessagePending.SetNull",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "126-131",
          "snippet": "void SetNull()\n    {\n        CUnsignedSyncCheckpoint::SetNull();\n        vchMsg.clear();\n        vchSig.clear();\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  void SetNull()\n      {\n          CUnsignedSyncCheckpoint::SetNull();\n          vchMsg.clear();\n          vchSig.clear();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AcceptPendingSyncCheckpoint(): failed to write sync checkpoint %s\"",
            "hashPendingCheckpoint.ToString().c_str()"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteSyncCheckpoint",
          "args": [
            "hashPendingCheckpoint"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "144-158",
          "snippet": "bool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "block.SetBestChain",
          "args": [
            "txdb",
            "pindexCheckpoint"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChain",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1854-1953",
          "snippet": "bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexGenesisBlock = NULL;",
            "int nBestHeight = -1;",
            "uint256 nBestChainTrust = 0;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;",
            "int64_t nTimeBestReceived = 0;",
            "static CBlockIndex* pblockindexFBBHLast;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nuint256 nBestChainTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\nstatic CBlockIndex* pblockindexFBBHLast;\n\nCBlock {\n  bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      if (!txdb.TxnBegin())\n          return error(\"SetBestChain() : TxnBegin failed\");\n  \n      if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n      {\n          txdb.WriteHashBestChain(hash);\n          if (!txdb.TxnCommit())\n              return error(\"SetBestChain() : TxnCommit failed\");\n          pindexGenesisBlock = pindexNew;\n      }\n      else if (hashPrevBlock == hashBestChain)\n      {\n          if (!SetBestChainInner(txdb, pindexNew))\n              return error(\"SetBestChain() : SetBestChainInner failed\");\n      }\n      else\n      {\n          // the first block in the new chain that will cause it to become the new best chain\n          CBlockIndex *pindexIntermediate = pindexNew;\n  \n          // list of blocks that need to be connected afterwards\n          std::vector<CBlockIndex*> vpindexSecondary;\n  \n          // Reorganize is costly in terms of db load, as it works in a single db transaction.\n          // Try to limit how much needs to be done inside\n          while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n          {\n              vpindexSecondary.push_back(pindexIntermediate);\n              pindexIntermediate = pindexIntermediate->pprev;\n          }\n  \n          if (!vpindexSecondary.empty())\n              printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n  \n          // Switch to new best branch\n          if (!Reorganize(txdb, pindexIntermediate))\n          {\n              txdb.TxnAbort();\n              InvalidChainFound(pindexNew);\n              return error(\"SetBestChain() : Reorganize failed\");\n          }\n  \n          // Connect further blocks\n          BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n          {\n              CBlock block;\n              if (!block.ReadFromDisk(pindex))\n              {\n                  printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                  break;\n              }\n              if (!txdb.TxnBegin()) {\n                  printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                  break;\n              }\n              // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n              if (!block.SetBestChainInner(txdb, pindex))\n                  break;\n          }\n      }\n  \n      // Update best block in wallet (so we can detect restored wallets)\n      bool fIsInitialDownload = IsInitialBlockDownload();\n      if (!fIsInitialDownload)\n      {\n          const CBlockLocator locator(pindexNew);\n          ::SetBestChain(locator);\n      }\n  \n      // New best block\n      hashBestChain = hash;\n      pindexBest = pindexNew;\n      pblockindexFBBHLast = NULL;\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexNew->nChainTrust;\n      nTimeBestReceived = GetTime();\n      nTransactionsUpdated++;\n  \n      uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n  \n      printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n        CBigNum(nBestChainTrust).ToString().c_str(),\n        nBestBlockTrust.Get64(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      std::string strCmd = GetArg(\"-blocknotify\", \"\");\n  \n      if (!fIsInitialDownload && !strCmd.empty())\n      {\n          boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n          boost::thread t(runCommand, strCmd); // thread runs free\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindexCheckpoint"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "601-626",
          "snippet": "bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n      {\n          CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n  \n          // Read transaction\n          if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n              return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n  \n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          // Return file pointer\n          if (pfileRet)\n          {\n              if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                  return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n              *pfileRet = filein.release();\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexCheckpoint->IsInMainChain",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ValidateSyncCheckpoint",
          "args": [
            "hashPendingCheckpoint"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ValidateSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "102-142",
          "snippet": "bool ValidateSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        if (!mapBlockIndex.count(hashSyncCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for current sync-checkpoint %s\", hashSyncCheckpoint.ToString().c_str());\n        if (!mapBlockIndex.count(hashCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        CBlockIndex* pindexSyncCheckpoint = mapBlockIndex[hashSyncCheckpoint];\n        CBlockIndex* pindexCheckpointRecv = mapBlockIndex[hashCheckpoint];\n\n        if (pindexCheckpointRecv->nHeight <= pindexSyncCheckpoint->nHeight)\n        {\n            // Received an older checkpoint, trace back from current checkpoint\n            // to the same height of the received checkpoint to verify\n            // that current checkpoint should be a descendant block\n            CBlockIndex* pindex = pindexSyncCheckpoint;\n            while (pindex->nHeight > pindexCheckpointRecv->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"ValidateSyncCheckpoint: pprev null - block index structure failure\");\n            if (pindex->GetBlockHash() != hashCheckpoint)\n            {\n                hashInvalidCheckpoint = hashCheckpoint;\n                return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is conflicting with current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n            }\n            return false; // ignore older checkpoint\n        }\n\n        // Received checkpoint should be a descendant block of the current\n        // checkpoint. Trace back to the same height of current checkpoint\n        // to verify.\n        CBlockIndex* pindex = pindexCheckpointRecv;\n        while (pindex->nHeight > pindexSyncCheckpoint->nHeight)\n            if (!(pindex = pindex->pprev))\n                return error(\"ValidateSyncCheckpoint: pprev2 null - block index structure failure\");\n        if (pindex->GetBlockHash() != hashSyncCheckpoint)\n        {\n            hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n        }\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool ValidateSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        if (!mapBlockIndex.count(hashSyncCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for current sync-checkpoint %s\", hashSyncCheckpoint.ToString().c_str());\n        if (!mapBlockIndex.count(hashCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        CBlockIndex* pindexSyncCheckpoint = mapBlockIndex[hashSyncCheckpoint];\n        CBlockIndex* pindexCheckpointRecv = mapBlockIndex[hashCheckpoint];\n\n        if (pindexCheckpointRecv->nHeight <= pindexSyncCheckpoint->nHeight)\n        {\n            // Received an older checkpoint, trace back from current checkpoint\n            // to the same height of the received checkpoint to verify\n            // that current checkpoint should be a descendant block\n            CBlockIndex* pindex = pindexSyncCheckpoint;\n            while (pindex->nHeight > pindexCheckpointRecv->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"ValidateSyncCheckpoint: pprev null - block index structure failure\");\n            if (pindex->GetBlockHash() != hashCheckpoint)\n            {\n                hashInvalidCheckpoint = hashCheckpoint;\n                return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is conflicting with current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n            }\n            return false; // ignore older checkpoint\n        }\n\n        // Received checkpoint should be a descendant block of the current\n        // checkpoint. Trace back to the same height of current checkpoint\n        // to verify.\n        CBlockIndex* pindex = pindexCheckpointRecv;\n        while (pindex->nHeight > pindexSyncCheckpoint->nHeight)\n            if (!(pindex = pindex->pprev))\n                return error(\"ValidateSyncCheckpoint: pprev2 null - block index structure failure\");\n        if (pindex->GetBlockHash() != hashSyncCheckpoint)\n        {\n            hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n        }\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hashPendingCheckpoint"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_hashSyncCheckpoint"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool AcceptPendingSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint != 0 && mapBlockIndex.count(hashPendingCheckpoint))\n        {\n            if (!ValidateSyncCheckpoint(hashPendingCheckpoint))\n            {\n                hashPendingCheckpoint = 0;\n                checkpointMessagePending.SetNull();\n                return false;\n            }\n\n            CTxDB txdb;\n            CBlockIndex* pindexCheckpoint = mapBlockIndex[hashPendingCheckpoint];\n            if (!pindexCheckpoint->IsInMainChain())\n            {\n                CBlock block;\n                if (!block.ReadFromDisk(pindexCheckpoint))\n                    return error(\"AcceptPendingSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                if (!block.SetBestChain(txdb, pindexCheckpoint))\n                {\n                    hashInvalidCheckpoint = hashPendingCheckpoint;\n                    return error(\"AcceptPendingSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                }\n            }\n\n            if (!WriteSyncCheckpoint(hashPendingCheckpoint))\n                return error(\"AcceptPendingSyncCheckpoint(): failed to write sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n            hashPendingCheckpoint = 0;\n            checkpointMessage = checkpointMessagePending;\n            checkpointMessagePending.SetNull();\n            printf(\"AcceptPendingSyncCheckpoint : sync-checkpoint at %s\\n\", hashSyncCheckpoint.ToString().c_str());\n            // relay the checkpoint\n            if (!checkpointMessage.IsNull())\n            {\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    checkpointMessage.RelayTo(pnode);\n            }\n            return true;\n        }\n        return false;\n    }"
  },
  {
    "function_name": "WriteSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "144-158",
    "snippet": "bool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\"",
            "hashCheckpoint.ToString().c_str()"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashCheckpoint.ToString",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnCommit",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "TxnCommit",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "282-289",
          "snippet": "bool TxnCommit()\n    {\n        if (!pdb || !activeTxn)\n            return false;\n        int ret = activeTxn->commit(0);\n        activeTxn = NULL;\n        return (ret == 0);\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnCommit()\n      {\n          if (!pdb || !activeTxn)\n              return false;\n          int ret = activeTxn->commit(0);\n          activeTxn = NULL;\n          return (ret == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnAbort",
          "args": [],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "TxnAbort",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "168-173",
          "snippet": "bool TxnAbort()\n    {\n        delete activeBatch;\n        activeBatch = NULL;\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool TxnAbort()\n      {\n          delete activeBatch;\n          activeBatch = NULL;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteSyncCheckpoint",
          "args": [
            "hashCheckpoint"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "144-158",
          "snippet": "bool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnBegin",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "TxnBegin",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "271-280",
          "snippet": "bool TxnBegin()\n    {\n        if (!pdb || activeTxn)\n            return false;\n        DbTxn* ptxn = bitdb.TxnBegin();\n        if (!ptxn)\n            return false;\n        activeTxn = ptxn;\n        return true;\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnBegin()\n      {\n          if (!pdb || activeTxn)\n              return false;\n          DbTxn* ptxn = bitdb.TxnBegin();\n          if (!ptxn)\n              return false;\n          activeTxn = ptxn;\n          return true;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }"
  },
  {
    "function_name": "ValidateSyncCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "102-142",
    "snippet": "bool ValidateSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        if (!mapBlockIndex.count(hashSyncCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for current sync-checkpoint %s\", hashSyncCheckpoint.ToString().c_str());\n        if (!mapBlockIndex.count(hashCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        CBlockIndex* pindexSyncCheckpoint = mapBlockIndex[hashSyncCheckpoint];\n        CBlockIndex* pindexCheckpointRecv = mapBlockIndex[hashCheckpoint];\n\n        if (pindexCheckpointRecv->nHeight <= pindexSyncCheckpoint->nHeight)\n        {\n            // Received an older checkpoint, trace back from current checkpoint\n            // to the same height of the received checkpoint to verify\n            // that current checkpoint should be a descendant block\n            CBlockIndex* pindex = pindexSyncCheckpoint;\n            while (pindex->nHeight > pindexCheckpointRecv->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"ValidateSyncCheckpoint: pprev null - block index structure failure\");\n            if (pindex->GetBlockHash() != hashCheckpoint)\n            {\n                hashInvalidCheckpoint = hashCheckpoint;\n                return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is conflicting with current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n            }\n            return false; // ignore older checkpoint\n        }\n\n        // Received checkpoint should be a descendant block of the current\n        // checkpoint. Trace back to the same height of current checkpoint\n        // to verify.\n        CBlockIndex* pindex = pindexCheckpointRecv;\n        while (pindex->nHeight > pindexSyncCheckpoint->nHeight)\n            if (!(pindex = pindex->pprev))\n                return error(\"ValidateSyncCheckpoint: pprev2 null - block index structure failure\");\n        if (pindex->GetBlockHash() != hashSyncCheckpoint)\n        {\n            hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n        }\n        return true;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s\"",
            "hashCheckpoint.ToString().c_str()",
            "hashSyncCheckpoint.ToString().c_str()"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashSyncCheckpoint.ToString",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ValidateSyncCheckpoint: pprev2 null - block index structure failure\""
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s\"",
            "hashCheckpoint.ToString().c_str()"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hashCheckpoint"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool ValidateSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        if (!mapBlockIndex.count(hashSyncCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for current sync-checkpoint %s\", hashSyncCheckpoint.ToString().c_str());\n        if (!mapBlockIndex.count(hashCheckpoint))\n            return error(\"ValidateSyncCheckpoint: block index missing for received sync-checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        CBlockIndex* pindexSyncCheckpoint = mapBlockIndex[hashSyncCheckpoint];\n        CBlockIndex* pindexCheckpointRecv = mapBlockIndex[hashCheckpoint];\n\n        if (pindexCheckpointRecv->nHeight <= pindexSyncCheckpoint->nHeight)\n        {\n            // Received an older checkpoint, trace back from current checkpoint\n            // to the same height of the received checkpoint to verify\n            // that current checkpoint should be a descendant block\n            CBlockIndex* pindex = pindexSyncCheckpoint;\n            while (pindex->nHeight > pindexCheckpointRecv->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"ValidateSyncCheckpoint: pprev null - block index structure failure\");\n            if (pindex->GetBlockHash() != hashCheckpoint)\n            {\n                hashInvalidCheckpoint = hashCheckpoint;\n                return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is conflicting with current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n            }\n            return false; // ignore older checkpoint\n        }\n\n        // Received checkpoint should be a descendant block of the current\n        // checkpoint. Trace back to the same height of current checkpoint\n        // to verify.\n        CBlockIndex* pindex = pindexCheckpointRecv;\n        while (pindex->nHeight > pindexSyncCheckpoint->nHeight)\n            if (!(pindex = pindex->pprev))\n                return error(\"ValidateSyncCheckpoint: pprev2 null - block index structure failure\");\n        if (pindex->GetBlockHash() != hashSyncCheckpoint)\n        {\n            hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ValidateSyncCheckpoint: new sync-checkpoint %s is not a descendant of current sync-checkpoint %s\", hashCheckpoint.ToString().c_str(), hashSyncCheckpoint.ToString().c_str());\n        }\n        return true;\n    }"
  },
  {
    "function_name": "GetTotalBlocksEstimate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "61-66",
    "snippet": "int GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkpoints.rbegin",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nint GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }"
  },
  {
    "function_name": "CheckHardened",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
    "lines": "52-59",
    "snippet": "bool CheckHardened(int nHeight, const uint256& hash)\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n        if (i == checkpoints.end()) return true;\n        return hash == i->second;\n    }",
    "includes": [
      "#include \"uint256.h\"",
      "#include \"main.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include <boost/foreach.hpp>",
      "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkpoints.end",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "checkpoints.find",
          "args": [
            "nHeight"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool CheckHardened(int nHeight, const uint256& hash)\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n        if (i == checkpoints.end()) return true;\n        return hash == i->second;\n    }"
  }
]