[
  {
    "function_name": "dumpwallet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "268-328",
    "snippet": "Value dumpwallet(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"dumpwallet <filename>\\n\"\n            \"Dumps all wallet keys in a human-readable format.\");\n\n    EnsureWalletIsUnlocked();\n\n    ofstream file;\n    file.open(params[0].get_str().c_str());\n    if (!file.is_open())\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n\n    std::map<CKeyID, int64_t> mapKeyBirth;\n\n    std::set<CKeyID> setKeyPool;\n\n    pwalletMain->GetKeyBirthTimes(mapKeyBirth);\n\n    pwalletMain->GetAllReserveKeys(setKeyPool);\n\n    // sort time/key pairs\n    std::vector<std::pair<int64_t, CKeyID> > vKeyBirth;\n    for (std::map<CKeyID, int64_t>::const_iterator it = mapKeyBirth.begin(); it != mapKeyBirth.end(); it++) {\n        vKeyBirth.push_back(std::make_pair(it->second, it->first));\n    }\n    mapKeyBirth.clear();\n    std::sort(vKeyBirth.begin(), vKeyBirth.end());\n\n    // produce output\n    file << strprintf(\"# Wallet dump created by Halcyon %s (%s)\\n\", CLIENT_BUILD.c_str(), CLIENT_DATE.c_str());\n    file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()).c_str());\n    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", nBestHeight, hashBestChain.ToString().c_str());\n    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(pindexBest->nTime).c_str());\n    file << \"\\n\";\n    for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n        const CKeyID &keyid = it->second;\n        std::string strTime = EncodeDumpTime(it->first);\n        std::string strAddr = CBitcoinAddress(keyid).ToString();\n        bool IsCompressed;\n\n        CKey key;\n        if (pwalletMain->GetKey(keyid, key)) {\n            if (pwalletMain->mapAddressBook.count(keyid)) {\n                CSecret secret = key.GetSecret(IsCompressed);\n                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(secret, IsCompressed).ToString().c_str(), strTime.c_str(), EncodeDumpString(pwalletMain->mapAddressBook[keyid]).c_str(), strAddr.c_str());\n            } else if (setKeyPool.count(keyid)) {\n                CSecret secret = key.GetSecret(IsCompressed);\n                file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(secret, IsCompressed).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n            } else {\n                CSecret secret = key.GetSecret(IsCompressed);\n                file << strprintf(\"%s %s change=1 # addr=%s\\n\", CBitcoinSecret(secret, IsCompressed).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n            }\n        }\n    }\n    file << \"\\n\";\n    file << \"# End of dump\\n\";\n    file.close();\n    return Value::null;\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [
      "void EnsureWalletIsUnlocked();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file.close",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "AcceptedConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "664-667",
          "snippet": "virtual void close()\n    {\n        _stream.close();\n    }",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nAcceptedConnectionImpl {\n  virtual void close()\n      {\n          _stream.close();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"%s %s change=1 # addr=%s\\n\"",
            "CBitcoinSecret(secret, IsCompressed).ToString().c_str()",
            "strTime.c_str()",
            "strAddr.c_str()"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strAddr.c_str",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTime.c_str",
          "args": [],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBitcoinSecret",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "CBitcoinSecret",
          "container": "CBitcoinSecret",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "455-457",
          "snippet": "CBitcoinSecret()\n    {\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinSecret {\n  CBitcoinSecret()\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.GetSecret",
          "args": [
            "IsCompressed"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "GetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "232-245",
          "snippet": "CSecret CKey::GetSecret(bool &fCompressed) const\n{\n    CSecret vchRet;\n    vchRet.resize(32);\n    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n    int nBytes = BN_num_bytes(bn);\n    if (bn == NULL)\n        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n    if (n != nBytes)\n        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n    fCompressed = fCompressedPubKey;\n    return vchRet;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CSecret CKey::GetSecret(bool &fCompressed) const\n  {\n      CSecret vchRet;\n      vchRet.resize(32);\n      const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n      int nBytes = BN_num_bytes(bn);\n      if (bn == NULL)\n          throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n      int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n      if (n != nBytes)\n          throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n      fCompressed = fCompressedPubKey;\n      return vchRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"%s %s reserve=1 # addr=%s\\n\"",
            "CBitcoinSecret(secret, IsCompressed).ToString().c_str()",
            "strTime.c_str()",
            "strAddr.c_str()"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strAddr.c_str",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTime.c_str",
          "args": [],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setKeyPool.count",
          "args": [
            "keyid"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"%s %s label=%s # addr=%s\\n\"",
            "CBitcoinSecret(secret, IsCompressed).ToString().c_str()",
            "strTime.c_str()",
            "EncodeDumpString(pwalletMain->mapAddressBook[keyid]).c_str()",
            "strAddr.c_str()"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strAddr.c_str",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeDumpString",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EncodeDumpString",
          "args": [
            "pwalletMain->mapAddressBook[keyid]"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDumpString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "64-74",
          "snippet": "std::string static EncodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    BOOST_FOREACH(unsigned char c, str) {\n        if (c <= 32 || c >= 128 || c == '%') {\n            ret << '%' << HexStr(&c, &c + 1);\n        } else {\n            ret << c;\n        }\n    }\n    return ret.str();\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::string static EncodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    BOOST_FOREACH(unsigned char c, str) {\n        if (c <= 32 || c >= 128 || c == '%') {\n            ret << '%' << HexStr(&c, &c + 1);\n        } else {\n            ret << c;\n        }\n    }\n    return ret.str();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strTime.c_str",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetKey",
          "args": [
            "keyid",
            "key"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "GetKey",
          "container": "CBasicKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "81-94",
          "snippet": "bool GetKey(const CKeyID &address, CKey &keyOut) const\n    {\n        {\n            LOCK(cs_KeyStore);\n            KeyMap::const_iterator mi = mapKeys.find(address);\n            if (mi != mapKeys.end())\n            {\n                keyOut.Reset();\n                keyOut.SetSecret((*mi).second.first, (*mi).second.second);\n                return true;\n            }\n        }\n        return false;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCBasicKeyStore {\n  bool GetKey(const CKeyID &address, CKey &keyOut) const\n      {\n          {\n              LOCK(cs_KeyStore);\n              KeyMap::const_iterator mi = mapKeys.find(address);\n              if (mi != mapKeys.end())\n              {\n                  keyOut.Reset();\n                  keyOut.SetSecret((*mi).second.first, (*mi).second.second);\n                  return true;\n              }\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "keyid"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDumpTime",
          "args": [
            "it->first"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeDumpTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "60-62",
          "snippet": "std::string static EncodeDumpTime(int64_t nTime) {\n    return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::string static EncodeDumpTime(int64_t nTime) {\n    return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vKeyBirth.end",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vKeyBirth.begin",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"#   mined on %s\\n\"",
            "EncodeDumpTime(pindexBest->nTime).c_str()"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDumpTime",
          "args": [],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"# * Best block at time of backup was %i (%s),\\n\"",
            "nBestHeight",
            "hashBestChain.ToString().c_str()"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashBestChain.ToString",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeDumpTime",
          "args": [],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"# Wallet dump created by Halcyon %s (%s)\\n\"",
            "CLIENT_BUILD.c_str()",
            "CLIENT_DATE.c_str()"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_DATE.c_str",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_BUILD.c_str",
          "args": [],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "vKeyBirth.begin()",
            "vKeyBirth.end()"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapKeyBirth.clear",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vKeyBirth.push_back",
          "args": [
            "std::make_pair(it->second, it->first)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "it->second",
            "it->first"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetAllReserveKeys",
          "args": [
            "setKeyPool"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetKeyBirthTimes",
          "args": [
            "mapKeyBirth"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_INVALID_PARAMETER",
            "\"Cannot open wallet dump file\""
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file.is_open",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "params[0].get_str().c_str()"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnsureWalletIsUnlocked",
          "args": [],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "EnsureWalletIsUnlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcwallet.cpp",
          "lines": "41-47",
          "snippet": "void EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"ntp.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"ntp.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n\nvoid EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"dumpwallet <filename>\\n\"\n            \"Dumps all wallet keys in a human-readable format.\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nvoid EnsureWalletIsUnlocked();\n\nValue dumpwallet(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"dumpwallet <filename>\\n\"\n            \"Dumps all wallet keys in a human-readable format.\");\n\n    EnsureWalletIsUnlocked();\n\n    ofstream file;\n    file.open(params[0].get_str().c_str());\n    if (!file.is_open())\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n\n    std::map<CKeyID, int64_t> mapKeyBirth;\n\n    std::set<CKeyID> setKeyPool;\n\n    pwalletMain->GetKeyBirthTimes(mapKeyBirth);\n\n    pwalletMain->GetAllReserveKeys(setKeyPool);\n\n    // sort time/key pairs\n    std::vector<std::pair<int64_t, CKeyID> > vKeyBirth;\n    for (std::map<CKeyID, int64_t>::const_iterator it = mapKeyBirth.begin(); it != mapKeyBirth.end(); it++) {\n        vKeyBirth.push_back(std::make_pair(it->second, it->first));\n    }\n    mapKeyBirth.clear();\n    std::sort(vKeyBirth.begin(), vKeyBirth.end());\n\n    // produce output\n    file << strprintf(\"# Wallet dump created by Halcyon %s (%s)\\n\", CLIENT_BUILD.c_str(), CLIENT_DATE.c_str());\n    file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()).c_str());\n    file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", nBestHeight, hashBestChain.ToString().c_str());\n    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(pindexBest->nTime).c_str());\n    file << \"\\n\";\n    for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n        const CKeyID &keyid = it->second;\n        std::string strTime = EncodeDumpTime(it->first);\n        std::string strAddr = CBitcoinAddress(keyid).ToString();\n        bool IsCompressed;\n\n        CKey key;\n        if (pwalletMain->GetKey(keyid, key)) {\n            if (pwalletMain->mapAddressBook.count(keyid)) {\n                CSecret secret = key.GetSecret(IsCompressed);\n                file << strprintf(\"%s %s label=%s # addr=%s\\n\", CBitcoinSecret(secret, IsCompressed).ToString().c_str(), strTime.c_str(), EncodeDumpString(pwalletMain->mapAddressBook[keyid]).c_str(), strAddr.c_str());\n            } else if (setKeyPool.count(keyid)) {\n                CSecret secret = key.GetSecret(IsCompressed);\n                file << strprintf(\"%s %s reserve=1 # addr=%s\\n\", CBitcoinSecret(secret, IsCompressed).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n            } else {\n                CSecret secret = key.GetSecret(IsCompressed);\n                file << strprintf(\"%s %s change=1 # addr=%s\\n\", CBitcoinSecret(secret, IsCompressed).ToString().c_str(), strTime.c_str(), strAddr.c_str());\n            }\n        }\n    }\n    file << \"\\n\";\n    file << \"# End of dump\\n\";\n    file.close();\n    return Value::null;\n}"
  },
  {
    "function_name": "dumpprivkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "243-266",
    "snippet": "Value dumpprivkey(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"dumpprivkey <halcyonaddress>\\n\"\n            \"Reveals the private key corresponding to <halcyonaddress>.\");\n\n    EnsureWalletIsUnlocked();\n\n    string strAddress = params[0].get_str();\n    CBitcoinAddress address;\n    if (!address.SetString(strAddress))\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Halcyon address\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Wallet is unlocked for staking only.\");\n    CKeyID keyID;\n    if (!address.GetKeyID(keyID))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to a key\");\n    CSecret vchSecret;\n    bool fCompressed;\n    if (!pwalletMain->GetSecret(keyID, vchSecret, fCompressed))\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n    return CBitcoinSecret(vchSecret, fCompressed).ToString();\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [
      "void EnsureWalletIsUnlocked();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CBitcoinSecret",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "CBitcoinSecret",
          "container": "CBitcoinSecret",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "455-457",
          "snippet": "CBitcoinSecret()\n    {\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinSecret {\n  CBitcoinSecret()\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_WALLET_ERROR",
            "\"Private key for address \" + strAddress + \" is not known\""
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetSecret",
          "args": [
            "keyID",
            "vchSecret",
            "fCompressed"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "GetSecret",
          "container": "CKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "37-44",
          "snippet": "virtual bool GetSecret(const CKeyID &address, CSecret& vchSecret, bool &fCompressed) const\n    {\n        CKey key;\n        if (!GetKey(address, key))\n            return false;\n        vchSecret = key.GetSecret(fCompressed);\n        return true;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCKeyStore {\n  virtual bool GetSecret(const CKeyID &address, CSecret& vchSecret, bool &fCompressed) const\n      {\n          CKey key;\n          if (!GetKey(address, key))\n              return false;\n          vchSecret = key.GetSecret(fCompressed);\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "address.GetKeyID",
          "args": [
            "keyID"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "GetKeyID",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "369-382",
          "snippet": "bool GetKeyID(CKeyID &keyID) const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case PUBKEY_ADDRESS:\n        case PUBKEY_ADDRESS_TEST: {\n            uint160 id;\n            memcpy(&id, &vchData[0], 20);\n            keyID = CKeyID(id);\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool GetKeyID(CKeyID &keyID) const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case PUBKEY_ADDRESS:\n          case PUBKEY_ADDRESS_TEST: {\n              uint160 id;\n              memcpy(&id, &vchData[0], 20);\n              keyID = CKeyID(id);\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "address.SetString",
          "args": [
            "strAddress"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "SetString",
          "container": "CBitcoinSecret",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "445-448",
          "snippet": "bool SetString(const std::string& strSecret)\n    {\n        return SetString(strSecret.c_str());\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinSecret {\n  bool SetString(const std::string& strSecret)\n      {\n          return SetString(strSecret.c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnsureWalletIsUnlocked",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "EnsureWalletIsUnlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcwallet.cpp",
          "lines": "41-47",
          "snippet": "void EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"ntp.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"ntp.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n\nvoid EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"dumpprivkey <halcyonaddress>\\n\"\n            \"Reveals the private key corresponding to <halcyonaddress>.\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nvoid EnsureWalletIsUnlocked();\n\nValue dumpprivkey(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"dumpprivkey <halcyonaddress>\\n\"\n            \"Reveals the private key corresponding to <halcyonaddress>.\");\n\n    EnsureWalletIsUnlocked();\n\n    string strAddress = params[0].get_str();\n    CBitcoinAddress address;\n    if (!address.SetString(strAddress))\n        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Halcyon address\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Wallet is unlocked for staking only.\");\n    CKeyID keyID;\n    if (!address.GetKeyID(keyID))\n        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to a key\");\n    CSecret vchSecret;\n    bool fCompressed;\n    if (!pwalletMain->GetSecret(keyID, vchSecret, fCompressed))\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Private key for address \" + strAddress + \" is not known\");\n    return CBitcoinSecret(vchSecret, fCompressed).ToString();\n}"
  },
  {
    "function_name": "importwallet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "155-240",
    "snippet": "Value importwallet(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"importwallet <filename>\\n\"\n            \"Imports keys from a wallet dump file (see dumpwallet).\");\n\n    EnsureWalletIsUnlocked();\n\n    ifstream file;\n    file.open(params[0].get_str().c_str());\n    if (!file.is_open())\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n\n    int64_t nTimeBegin = pindexBest->nTime;\n\n    bool fGood = true;\n\n    while (file.good()) {\n        std::string line;\n        std::getline(file, line);\n        if (line.empty() || line[0] == '#')\n            continue;\n\n        std::vector<std::string> vstr;\n        boost::split(vstr, line, boost::is_any_of(\" \"));\n        if (vstr.size() < 2)\n            continue;\n        CBitcoinSecret vchSecret;\n        if (!vchSecret.SetString(vstr[0]))\n            continue;\n\n        bool fCompressed;\n        CKey key;\n        CSecret secret = vchSecret.GetSecret(fCompressed);\n        key.SetSecret(secret, fCompressed);\n        CKeyID keyid = key.GetPubKey().GetID();\n\n        if (pwalletMain->HaveKey(keyid)) {\n            printf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString().c_str());\n            continue;\n        }\n        int64_t nTime = DecodeDumpTime(vstr[1]);\n        std::string strLabel;\n        bool fLabel = true;\n        for (unsigned int nStr = 2; nStr < vstr.size(); nStr++) {\n            if (boost::algorithm::starts_with(vstr[nStr], \"#\"))\n                break;\n            if (vstr[nStr] == \"change=1\")\n                fLabel = false;\n            if (vstr[nStr] == \"reserve=1\")\n                fLabel = false;\n            if (boost::algorithm::starts_with(vstr[nStr], \"label=\")) {\n                strLabel = DecodeDumpString(vstr[nStr].substr(6));\n                fLabel = true;\n            }\n        }\n        printf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString().c_str());\n        if (!pwalletMain->AddKey(key)) {\n            fGood = false;\n            continue;\n        }\n        pwalletMain->mapKeyMetadata[keyid].nCreateTime = nTime;\n        if (fLabel)\n            pwalletMain->SetAddressBookName(keyid, strLabel);\n        nTimeBegin = std::min(nTimeBegin, nTime);\n    }\n    file.close();\n\n    CBlockIndex *pindex = pindexBest;\n    while (pindex && pindex->pprev && pindex->nTime > nTimeBegin - 7200)\n        pindex = pindex->pprev;\n\n    if (!pwalletMain->nTimeFirstKey || nTimeBegin < pwalletMain->nTimeFirstKey)\n        pwalletMain->nTimeFirstKey = nTimeBegin;\n\n    printf(\"Rescanning last %i blocks\\n\", pindexBest->nHeight - pindex->nHeight + 1);\n    pwalletMain->ScanForWalletTransactions(pindex);\n    pwalletMain->ReacceptWalletTransactions();\n    pwalletMain->MarkDirty();\n\n    if (!fGood)\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding some keys to wallet\");\n\n    return Value::null;\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [
      "#define printf OutputDebugStringF"
    ],
    "globals_used": [
      "void EnsureWalletIsUnlocked();"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_WALLET_ERROR",
            "\"Error adding some keys to wallet\""
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->MarkDirty",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "MarkDirty",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "527-533",
          "snippet": "void MarkDirty()\n    {\n        fCreditCached = false;\n        fAvailableCreditCached = false;\n        fDebitCached = false;\n        fChangeCached = false;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void MarkDirty()\n      {\n          fCreditCached = false;\n          fAvailableCreditCached = false;\n          fDebitCached = false;\n          fChangeCached = false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->ReacceptWalletTransactions",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ReacceptWalletTransactions",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "876-2476",
          "snippet": "void CWallet::ReacceptWalletTransactions()\n{\n    CTxDB txdb(\"r\");\n    bool fRepeat = true;\n    while (fRepeat)\n    {\n        LOCK(cs_wallet);\n        fRepeat = false;\n        vector<CDiskTxPos> vMissingTx;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                continue;\n\n            CTxIndex txindex;\n            bool fUpdated = false;\n            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n            {\n                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                if (txindex.vSpent.size() != wtx.vout.size())\n                {\n                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                    continue;\n                }\n                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                {\n                    if (wtx.IsSpent(i))\n                        continue;\n                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                    {\n                        wtx.MarkSpent(i);\n                        fUpdated = true;\n                        vMissingTx.push_back(txindex.vSpent[i]);\n                    }\n                }\n                if (fUpdated)\n                {\n                    printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkDirty();\n                    wtx.WriteToDisk();\n                }\n            }\n            else\n            {\n                // Re-accept any txes of ours that aren't already in a block\n                if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                    wtx.AcceptWalletTransaction(txdb);\n            }\n        }\n        if (!vMissingTx.empty())\n        {\n            // TODO: optimize this to scan just part of the block chain?\n            if (ScanForWalletTransactions(pindexGenesisBlock))\n                fRepeat = true;  // Found missing transactions: re-do re-accept.\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n{\n    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n    {\n        if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n        {\n            uint256 hash = tx.GetHash();\n            if (!txdb.ContainsTx(hash))\n                RelayTransaction((CTransaction)tx, hash);\n        }\n    }\n    if (!(IsCoinBase() || IsCoinStake()))\n    {\n        uint256 hash = GetHash();\n        if (!txdb.ContainsTx(hash))\n        {\n            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n            RelayTransaction((CTransaction)*this, hash);\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction()\n{\n   CTxDB txdb(\"r\");\n   RelayWalletTransaction(txdb);\n}\n\nvoid CWallet::ResendWalletTransactions(bool fForce)\n{\n    if (!fForce)\n    {\n        // Do this infrequently and randomly to avoid giving away\n        // that these are our transactions.\n        static int64_t nNextTime;\n        if (GetTime() < nNextTime)\n            return;\n        bool fFirst = (nNextTime == 0);\n        nNextTime = GetTime() + GetRand(30 * 60);\n        if (fFirst)\n            return;\n\n        // Only do it if there's been a new block since last time\n        static int64_t nLastTime;\n        if (nTimeBestReceived < nLastTime)\n            return;\n        nLastTime = GetTime();\n    }\n\n    // Rebroadcast any of our txes that aren't in a block yet\n    printf(\"ResendWalletTransactions()\\n\");\n    CTxDB txdb(\"r\");\n    {\n        LOCK(cs_wallet);\n        // Sort them in chronological order\n        multimap<unsigned int, CWalletTx*> mapSorted;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            // Don't rebroadcast until it's had plenty of time that\n            // it should have gotten in already by now.\n            if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n        }\n        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n        {\n            CWalletTx& wtx = *item.second;\n            if (wtx.CheckTransaction())\n                wtx.RelayWalletTransaction(txdb);\n            else\n                printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n        }\n    }\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Actions\n//\n\n\nint64_t CWallet::GetBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nint64_t CWallet::GetUnconfirmedBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetImmatureBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx& pcoin = (*it).second;\n            if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                nTotal += GetCredit(pcoin);\n        }\n    }\n    return nTotal;\n}\n\n// populate vCoins with vector of spendable COutputs\nvoid CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if (fOnlyConfirmed && !pcoin->IsTrusted())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < 0)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                    vCoins.push_back(COutput(pcoin, i, nDepth));\n\n        }\n    }\n}\n\nvoid CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if(pcoin->GetDepthInMainChain() < nConf)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n        }\n    }\n}\n\nstatic void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                  vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n{\n    vector<char> vfIncluded;\n\n    vfBest.assign(vValue.size(), true);\n    nBest = nTotalLower;\n\n    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n    {\n        vfIncluded.assign(vValue.size(), false);\n        int64_t nTotal = 0;\n        bool fReachedTarget = false;\n        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n        {\n            for (unsigned int i = 0; i < vValue.size(); i++)\n            {\n                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                {\n                    nTotal += vValue[i].first;\n                    vfIncluded[i] = true;\n                    if (nTotal >= nTargetValue)\n                    {\n                        fReachedTarget = true;\n                        if (nTotal < nBest)\n                        {\n                            nBest = nTotal;\n                            vfBest = vfIncluded;\n                        }\n                        nTotal -= vValue[i].first;\n                        vfIncluded[i] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// ppcoin: total coins staked (non-spendable until maturity)\nint64_t CWallet::GetStake() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetNewMint() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nbool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    // List of values less than target\n    pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n    coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n    coinLowestLarger.second.first = NULL;\n    vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n    int64_t nTotalLower = 0;\n\n    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n\n        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n            continue;\n\n        int i = output.i;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n == nTargetValue)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            return true;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            vValue.push_back(coin);\n            nTotalLower += n;\n        }\n        else if (n < coinLowestLarger.first)\n        {\n            coinLowestLarger = coin;\n        }\n    }\n\n    if (nTotalLower == nTargetValue)\n    {\n        for (unsigned int i = 0; i < vValue.size(); ++i)\n        {\n            setCoinsRet.insert(vValue[i].second);\n            nValueRet += vValue[i].first;\n        }\n        return true;\n    }\n\n    if (nTotalLower < nTargetValue)\n    {\n        if (coinLowestLarger.second.first == NULL)\n            return false;\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n        return true;\n    }\n\n    // Solve subset sum by stochastic approximation\n    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n    vector<char> vfBest;\n    int64_t nBest;\n\n    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n\n    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n    //                                   or the next bigger coin is closer), return the bigger coin\n    if (coinLowestLarger.second.first &&\n        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n    {\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n    }\n    else {\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n            {\n                setCoinsRet.insert(vValue[i].second);\n                nValueRet += vValue[i].first;\n            }\n\n        if (fDebug && GetBoolArg(\"-printpriority\"))\n        {\n            //// debug print\n            printf(\"SelectCoins() best subset: \");\n            for (unsigned int i = 0; i < vValue.size(); i++)\n                if (vfBest[i])\n                    printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n            printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n{\n    vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n\n    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n    if (coinControl && coinControl->HasSelected())\n    {\n        BOOST_FOREACH(const COutput& out, vCoins)\n        {\n            nValueRet += out.tx->vout[out.i].nValue;\n            setCoinsRet.insert(make_pair(out.tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n}\n\n// Select some coins without random shuffle or best subset approximation\nbool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    vector<COutput> vCoins;\n    AvailableCoinsMinConf(vCoins, nMinConf);\n\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n        int i = output.i;\n\n        // Stop if we've chosen enough inputs\n        if (nValueRet >= nTargetValue)\n            break;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n >= nTargetValue)\n        {\n            // If input value is greater or equal to target then simply insert\n            //    it into the current subset and exit\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            break;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    int64_t nValue = 0;\n    BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n    {\n        if (nValue < 0)\n            return false;\n        nValue += s.second;\n    }\n    if (vecSend.empty() || nValue < 0)\n        return false;\n\n    wtxNew.BindWallet(this);\n\n    {\n        LOCK2(cs_main, cs_wallet);\n        // txdb must be opened before the mapWallet lock\n        CTxDB txdb(\"r\");\n        {\n            nFeeRet = nTransactionFee;\n            while (true)\n            {\n                wtxNew.vin.clear();\n                wtxNew.vout.clear();\n                wtxNew.fFromMe = true;\n\n                int64_t nTotalValue = nValue + nFeeRet;\n                double dPriority = 0;\n                // vouts to the payees\n                BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n\n                // Choose coins to use\n                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                int64_t nValueIn = 0;\n                if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                    return false;\n                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                {\n                    int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                }\n\n                int64_t nChange = nValueIn - nValue - nFeeRet;\n                // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                // or until nChange becomes zero\n                // NOTE: this depends on the exact behaviour of GetMinFee\n                if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                {\n                    int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                    nChange -= nMoveToFee;\n                    nFeeRet += nMoveToFee;\n                }\n\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    // TODO: pass in scriptChange instead of reservekey so\n                    // change transaction isn't always pay-to-bitcoin-address\n                    CScript scriptChange;\n\n                    // coin control: send change to custom address\n                    if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                        scriptChange.SetDestination(coinControl->destChange);\n\n                    // no coin control: send change to newly generated address\n                    else\n                    {\n                        // Note: We use a new key here to keep it from being obvious which side is the change.\n                        //  The drawback is that by not reusing a previous key, the change may be lost if a\n                        //  backup is restored, if the backup doesn't have the new private key for the change.\n                        //  If we reused the old key, it would be possible to add code to look for and\n                        //  rediscover unknown transactions that were written with keys of ours to recover\n                        //  post-backup change.\n\n                        // Reserve a new key pair from key pool\n                        CPubKey vchPubKey = reservekey.GetReservedKey();\n\n                        scriptChange.SetDestination(vchPubKey.GetID());\n                    }\n\n                    // Insert change txn at random position:\n                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                }\n                else\n                    reservekey.ReturnKey();\n\n                // Fill vin\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n\n                // Sign\n                int nIn = 0;\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                        return false;\n\n                // Limit size\n                unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                    return false;\n                dPriority /= nBytes;\n\n                // Check that enough fee is included\n                int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n\n                if (nFeeRet < max(nPayFee, nMinFee))\n                {\n                    nFeeRet = max(nPayFee, nMinFee);\n                    continue;\n                }\n\n                // Fill vtxPrev by copying from previous transactions vtxPrev\n                wtxNew.AddSupportingTransactions(txdb);\n                wtxNew.fTimeReceivedIsTxTime = true;\n\n                break;\n            }\n        }\n    }\n    return true;\n}\n\nbool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    vector< pair<CScript, int64_t> > vecSend;\n    vecSend.push_back(make_pair(scriptPubKey, nValue));\n    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n}\n\n// NovaCoin: get current stake weight\nbool CWallet::GetStakeWeight(const CKeyStore& keystore,\n  uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n        CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n\n        // Weight is greater than zero\n        if (nTimeWeight > 0)\n        {\n            nWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Weight is greater than zero, but the maximum value isn't reached yet\n        if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n        {\n            nMinWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Maximum weight was reached\n        if (nTimeWeight == nStakeMaxAge)\n        {\n            nMaxWeight += bnCoinDayWeight.getuint64();\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n  int64_t nFees, CTransaction& txNew, CKey& key) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    /* Don't split inputs above this age */\n    const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n    /* Time limit for searching a single input */\n    const uint nMaxStakeSearchInterval = 60;\n\n    CBlockIndex* pindexPrev = pindexBest;\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n\n    txNew.vin.clear();\n    txNew.vout.clear();\n\n    // Mark coin stake transaction\n    CScript scriptEmpty;\n    scriptEmpty.clear();\n    txNew.vout.push_back(CTxOut(0, scriptEmpty));\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    // Select coins with suitable depth\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    int64_t nCredit = 0;\n    CScript scriptPubKeyKernel;\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        // Read block header\n        CBlock block;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                continue;\n        }\n\n        if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n            continue; // only count coins meeting min age requirement\n\n        bool fKernelFound = false;\n        for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n        {\n            // Search backward in time from the given txNew timestamp \n            // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n            uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n            COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n            if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n            {\n                // Found a kernel\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : kernel found\\n\");\n                vector<valtype> vSolutions;\n                txnouttype whichType;\n                CScript scriptPubKeyOut;\n                scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                    break;\n                }\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                    break;  // only support pay to public key and pay to address\n                }\n                if (whichType == TX_PUBKEYHASH) // pay to address type\n                {\n                    // convert to pay to public key type\n                    if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n                    scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                }\n                if (whichType == TX_PUBKEY)\n                {\n                    valtype& vchPubKey = vSolutions[0];\n                    if (!keystore.GetKey(Hash160(vchPubKey), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                        break; // keys mismatch\n                    }\n\n                    scriptPubKeyOut = scriptPubKeyKernel;\n                }\n\n                txNew.nTime -= n;\n                txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                nCredit += pcoin.first->vout[pcoin.second].nValue;\n                vwtxPrev.push_back(pcoin.first);\n                txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                /* Split large inputs into two near halves;\n                 * exact amounts to be defined after reward processing */\n                if((nCredit >= nSplitThreshold) &&\n                  (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                fKernelFound = true;\n                break;\n            }\n        }\n\n        if (fKernelFound || fShutdown)\n            break; // if kernel is found stop searching\n    }\n\n    /* At this point, stake amount must be positive and within the stake limit if defined */\n    if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n      return(false);\n\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n\n        /* Make a larger stake by inserting additional inputs\n         * of the same public key (address) as the generating input */\n        if((txNew.vout.size() == 2) &&\n          (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n          (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n          (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n            int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n\n            /* Do not add too many inputs */\n            if(txNew.vin.size() >= 10)\n              break;\n            /* Do not add any inputs if reached or exceeded the threshold already */\n            if(nCredit >= nCombineThreshold)\n              break;\n            /* Do not add a new input exceeding the stake limit if defined */\n            if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n              break;\n            /* Do not add any large inputs capable of stake generation on their own */\n            if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n              continue;\n            /* Do not add any inputs under the min. age */\n            if(nTimeWeight < nStakeMinAge)\n              continue;\n\n            txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n            nCredit += pcoin.first->vout[pcoin.second].nValue;\n            vwtxPrev.push_back(pcoin.first);\n        }\n\n    }\n\n    // Calculate coin age reward\n    {\n        uint64_t nCoinAge;\n        CTxDB txdb(\"r\");\n        if (!txNew.GetCoinAge(txdb, nCoinAge))\n            return error(\"CreateCoinStake : failed to calculate coin age\");\n\n        int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n        if (nReward <= 0)\n            return false;\n\n        nCredit += nReward;\n    }\n\n    // Set output amount\n    if (txNew.vout.size() == 3)\n    {\n        txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n        txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n    }\n    else\n        txNew.vout[1].nValue = nCredit;\n\n    // Sign\n    int nIn = 0;\n    BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n    {\n        if (!SignSignature(*this, *pcoin, txNew, nIn++))\n            return error(\"CreateCoinStake : failed to sign coinstake\");\n    }\n\n    // Limit size\n    unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n    if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n        return error(\"CreateCoinStake : exceeded coinstake size limit\");\n\n    // Successfully generated coinstake\n    return true;\n}\n\n\n// Call after CreateTransaction unless you want to abort\nbool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}\n\n\n\n\nstring CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    CReserveKey reservekey(this);\n    int64_t nFeeRequired;\n\n    if (IsLocked())\n    {\n        string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (fWalletUnlockStakingOnly)\n    {\n        string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n    {\n        string strError;\n        if (nValue + nFeeRequired > GetBalance())\n            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n        else\n            strError = _(\"Error: Transaction creation failed  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n\n    if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n        return \"ABORTED\";\n\n    if (!CommitTransaction(wtxNew, reservekey))\n        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n\n    return \"\";\n}\n\n\n\nstring CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    // Check amount\n    if (nValue <= 0)\n        return _(\"Invalid amount\");\n    if (nValue + nTransactionFee > GetBalance())\n        return _(\"Insufficient funds\");\n\n    // Parse Bitcoin address\n    CScript scriptPubKey;\n    scriptPubKey.SetDestination(address);\n\n    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n}\n\n\n\n\nDBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    if (!fFileBacked)\n        return DB_LOAD_OK;\n    fFirstRunRet = false;\n    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n        {\n            setKeyPool.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // the requires a new key.\n        }\n    }\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n    fFirstRunRet = !vchDefaultKey.IsValid();\n\n    NewThread(ThreadFlushWalletDB, &strWalletFile);\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n{\n    std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n    mapAddressBook[address] = strName;\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n}\n\nbool CWallet::DelAddressBookName(const CTxDestination& address)\n{\n    mapAddressBook.erase(address);\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n}\n\n\nvoid CWallet::PrintWallet(const CBlock& block)\n{\n    {\n        LOCK(cs_wallet);\n        if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n            printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n        }\n        if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n            printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n         }\n\n    }\n    printf(\"\\n\");\n}\n\nbool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n        {\n            wtx = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n{\n    if (fFileBacked)\n    {\n        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n            return false;\n    }\n    vchDefaultKey = vchPubKey;\n    return true;\n}\n\nbool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n{\n    if (!pwallet->fFileBacked)\n        return false;\n    strWalletFileOut = pwallet->strWalletFile;\n    return true;\n}\n\n//\n// Mark old keypool keys as used,\n// and generate all new keys\n//\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n        BOOST_FOREACH(int64_t nIndex, setKeyPool)\n            walletdb.ErasePool(nIndex);\n        setKeyPool.clear();\n\n        if (IsLocked())\n            return false;\n\n        int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n        for (int i = 0; i < nKeys; i++)\n        {\n            int64_t nIndex = i+1;\n            walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n            setKeyPool.insert(nIndex);\n        }\n        printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n    }\n    return true;\n}\n\nbool CWallet::TopUpKeyPool(unsigned int nSize)\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        CWalletDB walletdb(strWalletFile);\n\n        // Top up key pool\n        unsigned int nTargetSize;\n        if (nSize > 0)\n            nTargetSize = nSize;\n        else\n            nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n\n        while (setKeyPool.size() < (nTargetSize + 1))\n        {\n            int64_t nEnd = 1;\n            if (!setKeyPool.empty())\n                nEnd = *(--setKeyPool.end()) + 1;\n            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n            setKeyPool.insert(nEnd);\n            printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(strWalletFile);\n\n        nIndex = *(setKeyPool.begin());\n        setKeyPool.erase(setKeyPool.begin());\n        if (!walletdb.ReadPool(nIndex, keypool))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n        if (!HaveKey(keypool.vchPubKey.GetID()))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n        assert(keypool.vchPubKey.IsValid());\n        if (fDebug && GetBoolArg(\"-printkeypool\"))\n            printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n    }\n}\n\nint64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n\n        int64_t nIndex = 1 + *(--setKeyPool.end());\n        if (!walletdb.WritePool(nIndex, keypool))\n            throw runtime_error(\"AddReserveKey() : writing added key failed\");\n        setKeyPool.insert(nIndex);\n        return nIndex;\n    }\n    return -1;\n}\n\nvoid CWallet::KeepKey(int64_t nIndex)\n{\n    // Remove from key pool\n    if (fFileBacked)\n    {\n        CWalletDB walletdb(strWalletFile);\n        walletdb.ErasePool(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64_t nIndex)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        setKeyPool.insert(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex == -1)\n        {\n            if (fAllowReuse && vchDefaultKey.IsValid())\n            {\n                result = vchDefaultKey;\n                return true;\n            }\n            if (IsLocked()) return false;\n            result = GenerateNewKey();\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nint64_t CWallet::GetOldestKeyPoolTime()\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    ReserveKeyFromKeyPool(nIndex, keypool);\n    if (nIndex == -1)\n        return GetTime();\n    ReturnKey(nIndex);\n    return keypool.nTime;\n}\n\nstd::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n{\n    map<CTxDestination, int64_t> balances;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n        {\n            CWalletTx *pcoin = &walletEntry.second;\n\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                continue;\n\n            if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            {\n                CTxDestination addr;\n                if (!IsMine(pcoin->vout[i]))\n                    continue;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                    continue;\n\n                int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n\n                if (!balances.count(addr))\n                    balances[addr] = 0;\n                balances[addr] += n;\n            }\n        }\n    }\n\n    return balances;\n}\n\nset< set<CTxDestination> > CWallet::GetAddressGroupings()\n{\n    set< set<CTxDestination> > groupings;\n    set<CTxDestination> grouping;\n\n    BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n    {\n        CWalletTx *pcoin = &walletEntry.second;\n\n        if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n        {\n            // group all input addresses with each other\n            BOOST_FOREACH(CTxIn txin, pcoin->vin)\n            {\n                CTxDestination address;\n                if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n            }\n\n            // group change with input addresses\n            BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                if (IsChange(txout))\n                {\n                    CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                    CTxDestination txoutAddr;\n                    if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                        continue;\n                    grouping.insert(txoutAddr);\n                }\n            groupings.insert(grouping);\n            grouping.clear();\n        }\n\n        // group lone addrs by themselves\n        for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            if (IsMine(pcoin->vout[i]))\n            {\n                CTxDestination address;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n    }\n\n    set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n    map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n    BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n    {\n        // make a set of all the groups hit by this new group\n        set< set<CTxDestination>* > hits;\n        map< CTxDestination, set<CTxDestination>* >::iterator it;\n        BOOST_FOREACH(CTxDestination address, grouping)\n            if ((it = setmap.find(address)) != setmap.end())\n                hits.insert((*it).second);\n\n        // merge all hit groups into a new single group and delete old groups\n        set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n        BOOST_FOREACH(set<CTxDestination>* hit, hits)\n        {\n            merged->insert(hit->begin(), hit->end());\n            uniqueGroupings.erase(hit);\n            delete hit;\n        }\n        uniqueGroupings.insert(merged);\n\n        // update setmap\n        BOOST_FOREACH(CTxDestination element, *merged)\n            setmap[element] = merged;\n    }\n\n    set< set<CTxDestination> > ret;\n    BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n    {\n        ret.insert(*uniqueGrouping);\n        delete uniqueGrouping;\n    }\n\n    return ret;\n}\n\n\n/* Checks for wallet vs. transaction index consistency;\n * reports any spent state inconsistency found and\n * (optionally) fixes the wallet according to the transaction index */\nvoid CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n  bool fCheckOnly) {\n    nMismatchFound = 0;\n    nOrphansFound = 0;\n    nBalanceInQuestion = 0;\n\n    LOCK(cs_wallet);\n    vector<CWalletTx*> vCoins;\n    vCoins.reserve(mapWallet.size());\n    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        vCoins.push_back(&(*it).second);\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n        uint256 hash = pcoin->GetHash();\n        CTxIndex txindex;\n        uint n;\n\n        if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n            continue;\n\n        for(n = 0; n < pcoin->vout.size(); n++) {\n            bool fUpdated = false;\n\n            if(IsMine(pcoin->vout[n])) {\n                if(pcoin->IsSpent(n) &&\n                  ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkUnspent(n);\n                        pcoin->WriteToDisk();\n                    }\n                } else if(!pcoin->IsSpent(n) &&\n                  (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkSpent(n);\n                        pcoin->WriteToDisk();\n                    }\n                }\n\n            }\n\n            if(fUpdated)\n              NotifyTransactionChanged(this, hash, CT_UPDATED);\n        }\n\n        if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n           nOrphansFound++;\n           if(!fCheckOnly) {\n               EraseFromWallet(hash);\n               NotifyTransactionChanged(this, hash, CT_DELETED);\n           }\n           printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n             fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n        }\n    }\n}\n\n\n// ppcoin: disable transaction (only for coinstake)\nvoid CWallet::DisableTransaction(const CTransaction &tx)\n{\n    if (!tx.IsCoinStake() || !IsFromMe(tx))\n        return; // only disconnecting coinstake requires marking input unspent\n\n    LOCK(cs_wallet);\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n            {\n                prev.MarkUnspent(txin.prevout.n);\n                prev.WriteToDisk();\n            }\n        }\n    }\n}\n\nCPubKey CReserveKey::GetReservedKey()\n{\n    if (nIndex == -1)\n    {\n        CKeyPool keypool;\n        pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex != -1)\n            vchPubKey = keypool.vchPubKey;\n        else\n        {\n            printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n            vchPubKey = pwallet->vchDefaultKey;\n        }\n    }\n    assert(vchPubKey.IsValid());\n    return vchPubKey;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1)\n        pwallet->ReturnKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n{\n    setAddress.clear();\n\n    CWalletDB walletdb(strWalletFile);\n\n    LOCK2(cs_main, cs_wallet);\n    BOOST_FOREACH(const int64_t& id, setKeyPool)\n    {\n        CKeyPool keypool;\n        if (!walletdb.ReadPool(id, keypool))\n            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n        assert(keypool.vchPubKey.IsValid());\n        CKeyID keyID = keypool.vchPubKey.GetID();\n        if (!HaveKey(keyID))\n            throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n        setAddress.insert(keyID);\n    }\n}\n\nvoid CWallet::UpdatedTransaction(const uint256 &hashTx)\n{\n    {\n        LOCK(cs_wallet);\n        // Only notify UI if this transaction is in this wallet\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n            NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n    }\n}\n\nvoid CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n    mapKeyBirth.clear();\n\n    // get birth times for keys with metadata\n    for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n        if (it->second.nCreateTime)\n            mapKeyBirth[it->first] = it->second.nCreateTime;\n\n    // map in which we'll infer heights of other keys\n    CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n    std::set<CKeyID> setKeys;\n    GetKeys(setKeys);\n    BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n        if (mapKeyBirth.count(keyid) == 0)\n            mapKeyFirstBlock[keyid] = pindexMax;\n    }\n    setKeys.clear();\n\n    // if there are no such keys, we're done\n    if (mapKeyFirstBlock.empty())\n        return;\n\n    // find first block that affects those keys, if there are any left\n    std::vector<CKeyID> vAffected;\n    for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n        // iterate over all wallet transactions...\n        const CWalletTx &wtx = (*it).second;\n        std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n        if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n            // ... which are already in a block\n            int nHeight = blit->second->nHeight;\n            BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                // iterate over all their outputs\n                ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                    // ... and all their affected keys\n                    std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                    if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                        rit->second = blit->second;\n                }\n                vAffected.clear();\n            }\n        }\n    }\n\n    // Extract block timestamps for those keys\n    for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n        mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int nStakeMaxAge;",
            "bool fWalletUnlockStakingOnly = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nextern unsigned int nStakeMaxAge;\nbool fWalletUnlockStakingOnly = false;\n\nCWallet {\n  void CWallet::ReacceptWalletTransactions()\n  {\n      CTxDB txdb(\"r\");\n      bool fRepeat = true;\n      while (fRepeat)\n      {\n          LOCK(cs_wallet);\n          fRepeat = false;\n          vector<CDiskTxPos> vMissingTx;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                  continue;\n  \n              CTxIndex txindex;\n              bool fUpdated = false;\n              if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n              {\n                  // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                  if (txindex.vSpent.size() != wtx.vout.size())\n                  {\n                      printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                      continue;\n                  }\n                  for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                  {\n                      if (wtx.IsSpent(i))\n                          continue;\n                      if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                      {\n                          wtx.MarkSpent(i);\n                          fUpdated = true;\n                          vMissingTx.push_back(txindex.vSpent[i]);\n                      }\n                  }\n                  if (fUpdated)\n                  {\n                      printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                      wtx.MarkDirty();\n                      wtx.WriteToDisk();\n                  }\n              }\n              else\n              {\n                  // Re-accept any txes of ours that aren't already in a block\n                  if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                      wtx.AcceptWalletTransaction(txdb);\n              }\n          }\n          if (!vMissingTx.empty())\n          {\n              // TODO: optimize this to scan just part of the block chain?\n              if (ScanForWalletTransactions(pindexGenesisBlock))\n                  fRepeat = true;  // Found missing transactions: re-do re-accept.\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n  {\n      BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n      {\n          if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n          {\n              uint256 hash = tx.GetHash();\n              if (!txdb.ContainsTx(hash))\n                  RelayTransaction((CTransaction)tx, hash);\n          }\n      }\n      if (!(IsCoinBase() || IsCoinStake()))\n      {\n          uint256 hash = GetHash();\n          if (!txdb.ContainsTx(hash))\n          {\n              printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n              RelayTransaction((CTransaction)*this, hash);\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction()\n  {\n     CTxDB txdb(\"r\");\n     RelayWalletTransaction(txdb);\n  }\n  \n  void CWallet::ResendWalletTransactions(bool fForce)\n  {\n      if (!fForce)\n      {\n          // Do this infrequently and randomly to avoid giving away\n          // that these are our transactions.\n          static int64_t nNextTime;\n          if (GetTime() < nNextTime)\n              return;\n          bool fFirst = (nNextTime == 0);\n          nNextTime = GetTime() + GetRand(30 * 60);\n          if (fFirst)\n              return;\n  \n          // Only do it if there's been a new block since last time\n          static int64_t nLastTime;\n          if (nTimeBestReceived < nLastTime)\n              return;\n          nLastTime = GetTime();\n      }\n  \n      // Rebroadcast any of our txes that aren't in a block yet\n      printf(\"ResendWalletTransactions()\\n\");\n      CTxDB txdb(\"r\");\n      {\n          LOCK(cs_wallet);\n          // Sort them in chronological order\n          multimap<unsigned int, CWalletTx*> mapSorted;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              // Don't rebroadcast until it's had plenty of time that\n              // it should have gotten in already by now.\n              if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                  mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n          }\n          BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n          {\n              CWalletTx& wtx = *item.second;\n              if (wtx.CheckTransaction())\n                  wtx.RelayWalletTransaction(txdb);\n              else\n                  printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n          }\n      }\n  }\n  \n  \n  \n  \n  \n  \n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // Actions\n  //\n  \n  \n  int64_t CWallet::GetBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n  \n      return nTotal;\n  }\n  \n  int64_t CWallet::GetUnconfirmedBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetImmatureBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx& pcoin = (*it).second;\n              if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                  nTotal += GetCredit(pcoin);\n          }\n      }\n      return nTotal;\n  }\n  \n  // populate vCoins with vector of spendable COutputs\n  void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if (fOnlyConfirmed && !pcoin->IsTrusted())\n                  continue;\n  \n              if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < 0)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                  (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                      vCoins.push_back(COutput(pcoin, i, nDepth));\n  \n          }\n      }\n  }\n  \n  void CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if(pcoin->GetDepthInMainChain() < nConf)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                      vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n          }\n      }\n  }\n  \n  static void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                    vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n  {\n      vector<char> vfIncluded;\n  \n      vfBest.assign(vValue.size(), true);\n      nBest = nTotalLower;\n  \n      for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n      {\n          vfIncluded.assign(vValue.size(), false);\n          int64_t nTotal = 0;\n          bool fReachedTarget = false;\n          for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n          {\n              for (unsigned int i = 0; i < vValue.size(); i++)\n              {\n                  if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                  {\n                      nTotal += vValue[i].first;\n                      vfIncluded[i] = true;\n                      if (nTotal >= nTargetValue)\n                      {\n                          fReachedTarget = true;\n                          if (nTotal < nBest)\n                          {\n                              nBest = nTotal;\n                              vfBest = vfIncluded;\n                          }\n                          nTotal -= vValue[i].first;\n                          vfIncluded[i] = false;\n                      }\n                  }\n              }\n          }\n      }\n  }\n  \n  // ppcoin: total coins staked (non-spendable until maturity)\n  int64_t CWallet::GetStake() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetNewMint() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  bool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      // List of values less than target\n      pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n      coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n      coinLowestLarger.second.first = NULL;\n      vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n      int64_t nTotalLower = 0;\n  \n      random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n  \n          if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n              continue;\n  \n          int i = output.i;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n == nTargetValue)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              return true;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              vValue.push_back(coin);\n              nTotalLower += n;\n          }\n          else if (n < coinLowestLarger.first)\n          {\n              coinLowestLarger = coin;\n          }\n      }\n  \n      if (nTotalLower == nTargetValue)\n      {\n          for (unsigned int i = 0; i < vValue.size(); ++i)\n          {\n              setCoinsRet.insert(vValue[i].second);\n              nValueRet += vValue[i].first;\n          }\n          return true;\n      }\n  \n      if (nTotalLower < nTargetValue)\n      {\n          if (coinLowestLarger.second.first == NULL)\n              return false;\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n          return true;\n      }\n  \n      // Solve subset sum by stochastic approximation\n      sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n      vector<char> vfBest;\n      int64_t nBest;\n  \n      ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n      if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n          ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n  \n      // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n      //                                   or the next bigger coin is closer), return the bigger coin\n      if (coinLowestLarger.second.first &&\n          ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n      {\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n      }\n      else {\n          for (unsigned int i = 0; i < vValue.size(); i++)\n              if (vfBest[i])\n              {\n                  setCoinsRet.insert(vValue[i].second);\n                  nValueRet += vValue[i].first;\n              }\n  \n          if (fDebug && GetBoolArg(\"-printpriority\"))\n          {\n              //// debug print\n              printf(\"SelectCoins() best subset: \");\n              for (unsigned int i = 0; i < vValue.size(); i++)\n                  if (vfBest[i])\n                      printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n              printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoins(vCoins, true, coinControl);\n  \n      // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n      if (coinControl && coinControl->HasSelected())\n      {\n          BOOST_FOREACH(const COutput& out, vCoins)\n          {\n              nValueRet += out.tx->vout[out.i].nValue;\n              setCoinsRet.insert(make_pair(out.tx, out.i));\n          }\n          return (nValueRet >= nTargetValue);\n      }\n  \n      return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n  }\n  \n  // Select some coins without random shuffle or best subset approximation\n  bool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoinsMinConf(vCoins, nMinConf);\n  \n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n          int i = output.i;\n  \n          // Stop if we've chosen enough inputs\n          if (nValueRet >= nTargetValue)\n              break;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n >= nTargetValue)\n          {\n              // If input value is greater or equal to target then simply insert\n              //    it into the current subset and exit\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              break;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      int64_t nValue = 0;\n      BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n      {\n          if (nValue < 0)\n              return false;\n          nValue += s.second;\n      }\n      if (vecSend.empty() || nValue < 0)\n          return false;\n  \n      wtxNew.BindWallet(this);\n  \n      {\n          LOCK2(cs_main, cs_wallet);\n          // txdb must be opened before the mapWallet lock\n          CTxDB txdb(\"r\");\n          {\n              nFeeRet = nTransactionFee;\n              while (true)\n              {\n                  wtxNew.vin.clear();\n                  wtxNew.vout.clear();\n                  wtxNew.fFromMe = true;\n  \n                  int64_t nTotalValue = nValue + nFeeRet;\n                  double dPriority = 0;\n                  // vouts to the payees\n                  BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                      wtxNew.vout.push_back(CTxOut(s.second, s.first));\n  \n                  // Choose coins to use\n                  set<pair<const CWalletTx*,unsigned int> > setCoins;\n                  int64_t nValueIn = 0;\n                  if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                      return false;\n                  BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                  {\n                      int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                      dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                  }\n  \n                  int64_t nChange = nValueIn - nValue - nFeeRet;\n                  // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                  // or until nChange becomes zero\n                  // NOTE: this depends on the exact behaviour of GetMinFee\n                  if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                  {\n                      int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                      nChange -= nMoveToFee;\n                      nFeeRet += nMoveToFee;\n                  }\n  \n                  if (nChange > 0)\n                  {\n                      // Fill a vout to ourself\n                      // TODO: pass in scriptChange instead of reservekey so\n                      // change transaction isn't always pay-to-bitcoin-address\n                      CScript scriptChange;\n  \n                      // coin control: send change to custom address\n                      if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                          scriptChange.SetDestination(coinControl->destChange);\n  \n                      // no coin control: send change to newly generated address\n                      else\n                      {\n                          // Note: We use a new key here to keep it from being obvious which side is the change.\n                          //  The drawback is that by not reusing a previous key, the change may be lost if a\n                          //  backup is restored, if the backup doesn't have the new private key for the change.\n                          //  If we reused the old key, it would be possible to add code to look for and\n                          //  rediscover unknown transactions that were written with keys of ours to recover\n                          //  post-backup change.\n  \n                          // Reserve a new key pair from key pool\n                          CPubKey vchPubKey = reservekey.GetReservedKey();\n  \n                          scriptChange.SetDestination(vchPubKey.GetID());\n                      }\n  \n                      // Insert change txn at random position:\n                      vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                      wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                  }\n                  else\n                      reservekey.ReturnKey();\n  \n                  // Fill vin\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n  \n                  // Sign\n                  int nIn = 0;\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                          return false;\n  \n                  // Limit size\n                  unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                  if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                      return false;\n                  dPriority /= nBytes;\n  \n                  // Check that enough fee is included\n                  int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                  int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n  \n                  if (nFeeRet < max(nPayFee, nMinFee))\n                  {\n                      nFeeRet = max(nPayFee, nMinFee);\n                      continue;\n                  }\n  \n                  // Fill vtxPrev by copying from previous transactions vtxPrev\n                  wtxNew.AddSupportingTransactions(txdb);\n                  wtxNew.fTimeReceivedIsTxTime = true;\n  \n                  break;\n              }\n          }\n      }\n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      vector< pair<CScript, int64_t> > vecSend;\n      vecSend.push_back(make_pair(scriptPubKey, nValue));\n      return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n  }\n  \n  // NovaCoin: get current stake weight\n  bool CWallet::GetStakeWeight(const CKeyStore& keystore,\n    uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n          CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n  \n          // Weight is greater than zero\n          if (nTimeWeight > 0)\n          {\n              nWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Weight is greater than zero, but the maximum value isn't reached yet\n          if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n          {\n              nMinWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Maximum weight was reached\n          if (nTimeWeight == nStakeMaxAge)\n          {\n              nMaxWeight += bnCoinDayWeight.getuint64();\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n    int64_t nFees, CTransaction& txNew, CKey& key) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      /* Don't split inputs above this age */\n      const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n      /* Time limit for searching a single input */\n      const uint nMaxStakeSearchInterval = 60;\n  \n      CBlockIndex* pindexPrev = pindexBest;\n  \n      CBigNum bnTargetPerCoinDay;\n      bnTargetPerCoinDay.SetCompact(nBits);\n  \n      txNew.vin.clear();\n      txNew.vout.clear();\n  \n      // Mark coin stake transaction\n      CScript scriptEmpty;\n      scriptEmpty.clear();\n      txNew.vout.push_back(CTxOut(0, scriptEmpty));\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      // Select coins with suitable depth\n      if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      int64_t nCredit = 0;\n      CScript scriptPubKeyKernel;\n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          // Read block header\n          CBlock block;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                  continue;\n          }\n  \n          if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n              continue; // only count coins meeting min age requirement\n  \n          bool fKernelFound = false;\n          for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n          {\n              // Search backward in time from the given txNew timestamp \n              // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n              uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n              COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n              if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n              {\n                  // Found a kernel\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : kernel found\\n\");\n                  vector<valtype> vSolutions;\n                  txnouttype whichType;\n                  CScript scriptPubKeyOut;\n                  scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                  if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                      break;\n                  }\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                  if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                      break;  // only support pay to public key and pay to address\n                  }\n                  if (whichType == TX_PUBKEYHASH) // pay to address type\n                  {\n                      // convert to pay to public key type\n                      if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n                      scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                  }\n                  if (whichType == TX_PUBKEY)\n                  {\n                      valtype& vchPubKey = vSolutions[0];\n                      if (!keystore.GetKey(Hash160(vchPubKey), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n  \n                  if (key.GetPubKey() != vchPubKey)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                          break; // keys mismatch\n                      }\n  \n                      scriptPubKeyOut = scriptPubKeyKernel;\n                  }\n  \n                  txNew.nTime -= n;\n                  txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                  nCredit += pcoin.first->vout[pcoin.second].nValue;\n                  vwtxPrev.push_back(pcoin.first);\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  /* Split large inputs into two near halves;\n                   * exact amounts to be defined after reward processing */\n                  if((nCredit >= nSplitThreshold) &&\n                    (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                    txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                  fKernelFound = true;\n                  break;\n              }\n          }\n  \n          if (fKernelFound || fShutdown)\n              break; // if kernel is found stop searching\n      }\n  \n      /* At this point, stake amount must be positive and within the stake limit if defined */\n      if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n        return(false);\n  \n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n  \n          /* Make a larger stake by inserting additional inputs\n           * of the same public key (address) as the generating input */\n          if((txNew.vout.size() == 2) &&\n            (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n            (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n            (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n              int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n  \n              /* Do not add too many inputs */\n              if(txNew.vin.size() >= 10)\n                break;\n              /* Do not add any inputs if reached or exceeded the threshold already */\n              if(nCredit >= nCombineThreshold)\n                break;\n              /* Do not add a new input exceeding the stake limit if defined */\n              if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n                break;\n              /* Do not add any large inputs capable of stake generation on their own */\n              if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n                continue;\n              /* Do not add any inputs under the min. age */\n              if(nTimeWeight < nStakeMinAge)\n                continue;\n  \n              txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n              nCredit += pcoin.first->vout[pcoin.second].nValue;\n              vwtxPrev.push_back(pcoin.first);\n          }\n  \n      }\n  \n      // Calculate coin age reward\n      {\n          uint64_t nCoinAge;\n          CTxDB txdb(\"r\");\n          if (!txNew.GetCoinAge(txdb, nCoinAge))\n              return error(\"CreateCoinStake : failed to calculate coin age\");\n  \n          int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n          if (nReward <= 0)\n              return false;\n  \n          nCredit += nReward;\n      }\n  \n      // Set output amount\n      if (txNew.vout.size() == 3)\n      {\n          txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n          txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n      }\n      else\n          txNew.vout[1].nValue = nCredit;\n  \n      // Sign\n      int nIn = 0;\n      BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n      {\n          if (!SignSignature(*this, *pcoin, txNew, nIn++))\n              return error(\"CreateCoinStake : failed to sign coinstake\");\n      }\n  \n      // Limit size\n      unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n      if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n          return error(\"CreateCoinStake : exceeded coinstake size limit\");\n  \n      // Successfully generated coinstake\n      return true;\n  }\n  \n  \n  // Call after CreateTransaction unless you want to abort\n  bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n          {\n              // This is only to keep the database open to defeat the auto-flush for the\n              // duration of this scope.  This is the only place where this optimization\n              // maybe makes sense; please don't do it anywhere else.\n              CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n  \n              // Take key pair from key pool so it won't be used again\n              reservekey.KeepKey();\n  \n              // Add tx to wallet, because if it has change it's also ours,\n              // otherwise just for transaction history.\n              AddToWallet(wtxNew);\n  \n              // Mark old coins as spent\n              set<CWalletTx*> setCoins;\n              BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n              {\n                  CWalletTx &coin = mapWallet[txin.prevout.hash];\n                  coin.BindWallet(this);\n                  coin.MarkSpent(txin.prevout.n);\n                  coin.WriteToDisk();\n                  NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n              }\n  \n              if (fFileBacked)\n                  delete pwalletdb;\n          }\n  \n          // Track how many getdata requests our transaction gets\n          mapRequestCount[wtxNew.GetHash()] = 0;\n  \n          // Broadcast\n          if (!wtxNew.AcceptToMemoryPool())\n          {\n              // This must not fail. The transaction has already been signed and recorded.\n              printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n              return false;\n          }\n          wtxNew.RelayWalletTransaction();\n      }\n      return true;\n  }\n  \n  \n  \n  \n  string CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      CReserveKey reservekey(this);\n      int64_t nFeeRequired;\n  \n      if (IsLocked())\n      {\n          string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (fWalletUnlockStakingOnly)\n      {\n          string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n      {\n          string strError;\n          if (nValue + nFeeRequired > GetBalance())\n              strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n          else\n              strError = _(\"Error: Transaction creation failed  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n  \n      if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n          return \"ABORTED\";\n  \n      if (!CommitTransaction(wtxNew, reservekey))\n          return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n  \n      return \"\";\n  }\n  \n  \n  \n  string CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      // Check amount\n      if (nValue <= 0)\n          return _(\"Invalid amount\");\n      if (nValue + nTransactionFee > GetBalance())\n          return _(\"Insufficient funds\");\n  \n      // Parse Bitcoin address\n      CScript scriptPubKey;\n      scriptPubKey.SetDestination(address);\n  \n      return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n  }\n  \n  \n  \n  \n  DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n  {\n      if (!fFileBacked)\n          return DB_LOAD_OK;\n      fFirstRunRet = false;\n      DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n      if (nLoadWalletRet == DB_NEED_REWRITE)\n      {\n          if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n          {\n              setKeyPool.clear();\n              // Note: can't top-up keypool here, because wallet is locked.\n              // User will be prompted to unlock wallet the next operation\n              // the requires a new key.\n          }\n      }\n  \n      if (nLoadWalletRet != DB_LOAD_OK)\n          return nLoadWalletRet;\n      fFirstRunRet = !vchDefaultKey.IsValid();\n  \n      NewThread(ThreadFlushWalletDB, &strWalletFile);\n      return DB_LOAD_OK;\n  }\n  \n  \n  bool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n  {\n      std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n      mapAddressBook[address] = strName;\n      NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n  }\n  \n  bool CWallet::DelAddressBookName(const CTxDestination& address)\n  {\n      mapAddressBook.erase(address);\n      NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n  }\n  \n  \n  void CWallet::PrintWallet(const CBlock& block)\n  {\n      {\n          LOCK(cs_wallet);\n          if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n              printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n          }\n          if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n              printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n           }\n  \n      }\n      printf(\"\\n\");\n  }\n  \n  bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n          {\n              wtx = (*mi).second;\n              return true;\n          }\n      }\n      return false;\n  }\n  \n  bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n  {\n      if (fFileBacked)\n      {\n          if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n              return false;\n      }\n      vchDefaultKey = vchPubKey;\n      return true;\n  }\n  \n  bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n  {\n      if (!pwallet->fFileBacked)\n          return false;\n      strWalletFileOut = pwallet->strWalletFile;\n      return true;\n  }\n  \n  //\n  // Mark old keypool keys as used,\n  // and generate all new keys\n  //\n  bool CWallet::NewKeyPool()\n  {\n      {\n          LOCK(cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n          BOOST_FOREACH(int64_t nIndex, setKeyPool)\n              walletdb.ErasePool(nIndex);\n          setKeyPool.clear();\n  \n          if (IsLocked())\n              return false;\n  \n          int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n          for (int i = 0; i < nKeys; i++)\n          {\n              int64_t nIndex = i+1;\n              walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n              setKeyPool.insert(nIndex);\n          }\n          printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n      }\n      return true;\n  }\n  \n  bool CWallet::TopUpKeyPool(unsigned int nSize)\n  {\n      {\n          LOCK(cs_wallet);\n  \n          if (IsLocked())\n              return false;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          // Top up key pool\n          unsigned int nTargetSize;\n          if (nSize > 0)\n              nTargetSize = nSize;\n          else\n              nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n  \n          while (setKeyPool.size() < (nTargetSize + 1))\n          {\n              int64_t nEnd = 1;\n              if (!setKeyPool.empty())\n                  nEnd = *(--setKeyPool.end()) + 1;\n              if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                  throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n              setKeyPool.insert(nEnd);\n              printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n          }\n      }\n      return true;\n  }\n  \n  void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n  {\n      nIndex = -1;\n      keypool.vchPubKey = CPubKey();\n      {\n          LOCK(cs_wallet);\n  \n          if (!IsLocked())\n              TopUpKeyPool();\n  \n          // Get the oldest key\n          if(setKeyPool.empty())\n              return;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          nIndex = *(setKeyPool.begin());\n          setKeyPool.erase(setKeyPool.begin());\n          if (!walletdb.ReadPool(nIndex, keypool))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n          if (!HaveKey(keypool.vchPubKey.GetID()))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n          assert(keypool.vchPubKey.IsValid());\n          if (fDebug && GetBoolArg(\"-printkeypool\"))\n              printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n      }\n  }\n  \n  int64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n  \n          int64_t nIndex = 1 + *(--setKeyPool.end());\n          if (!walletdb.WritePool(nIndex, keypool))\n              throw runtime_error(\"AddReserveKey() : writing added key failed\");\n          setKeyPool.insert(nIndex);\n          return nIndex;\n      }\n      return -1;\n  }\n  \n  void CWallet::KeepKey(int64_t nIndex)\n  {\n      // Remove from key pool\n      if (fFileBacked)\n      {\n          CWalletDB walletdb(strWalletFile);\n          walletdb.ErasePool(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n  }\n  \n  void CWallet::ReturnKey(int64_t nIndex)\n  {\n      // Return to key pool\n      {\n          LOCK(cs_wallet);\n          setKeyPool.insert(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n  }\n  \n  bool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      {\n          LOCK(cs_wallet);\n          ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex == -1)\n          {\n              if (fAllowReuse && vchDefaultKey.IsValid())\n              {\n                  result = vchDefaultKey;\n                  return true;\n              }\n              if (IsLocked()) return false;\n              result = GenerateNewKey();\n              return true;\n          }\n          KeepKey(nIndex);\n          result = keypool.vchPubKey;\n      }\n      return true;\n  }\n  \n  int64_t CWallet::GetOldestKeyPoolTime()\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      ReserveKeyFromKeyPool(nIndex, keypool);\n      if (nIndex == -1)\n          return GetTime();\n      ReturnKey(nIndex);\n      return keypool.nTime;\n  }\n  \n  std::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n  {\n      map<CTxDestination, int64_t> balances;\n  \n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n          {\n              CWalletTx *pcoin = &walletEntry.second;\n  \n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  continue;\n  \n              if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              {\n                  CTxDestination addr;\n                  if (!IsMine(pcoin->vout[i]))\n                      continue;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                      continue;\n  \n                  int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n  \n                  if (!balances.count(addr))\n                      balances[addr] = 0;\n                  balances[addr] += n;\n              }\n          }\n      }\n  \n      return balances;\n  }\n  \n  set< set<CTxDestination> > CWallet::GetAddressGroupings()\n  {\n      set< set<CTxDestination> > groupings;\n      set<CTxDestination> grouping;\n  \n      BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n      {\n          CWalletTx *pcoin = &walletEntry.second;\n  \n          if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n          {\n              // group all input addresses with each other\n              BOOST_FOREACH(CTxIn txin, pcoin->vin)\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n              }\n  \n              // group change with input addresses\n              BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                  if (IsChange(txout))\n                  {\n                      CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                      CTxDestination txoutAddr;\n                      if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                          continue;\n                      grouping.insert(txoutAddr);\n                  }\n              groupings.insert(grouping);\n              grouping.clear();\n          }\n  \n          // group lone addrs by themselves\n          for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              if (IsMine(pcoin->vout[i]))\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n                  groupings.insert(grouping);\n                  grouping.clear();\n              }\n      }\n  \n      set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n      map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n      BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n      {\n          // make a set of all the groups hit by this new group\n          set< set<CTxDestination>* > hits;\n          map< CTxDestination, set<CTxDestination>* >::iterator it;\n          BOOST_FOREACH(CTxDestination address, grouping)\n              if ((it = setmap.find(address)) != setmap.end())\n                  hits.insert((*it).second);\n  \n          // merge all hit groups into a new single group and delete old groups\n          set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n          BOOST_FOREACH(set<CTxDestination>* hit, hits)\n          {\n              merged->insert(hit->begin(), hit->end());\n              uniqueGroupings.erase(hit);\n              delete hit;\n          }\n          uniqueGroupings.insert(merged);\n  \n          // update setmap\n          BOOST_FOREACH(CTxDestination element, *merged)\n              setmap[element] = merged;\n      }\n  \n      set< set<CTxDestination> > ret;\n      BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n      {\n          ret.insert(*uniqueGrouping);\n          delete uniqueGrouping;\n      }\n  \n      return ret;\n  }\n  \n  \n  /* Checks for wallet vs. transaction index consistency;\n   * reports any spent state inconsistency found and\n   * (optionally) fixes the wallet according to the transaction index */\n  void CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n    bool fCheckOnly) {\n      nMismatchFound = 0;\n      nOrphansFound = 0;\n      nBalanceInQuestion = 0;\n  \n      LOCK(cs_wallet);\n      vector<CWalletTx*> vCoins;\n      vCoins.reserve(mapWallet.size());\n      for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          vCoins.push_back(&(*it).second);\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n          uint256 hash = pcoin->GetHash();\n          CTxIndex txindex;\n          uint n;\n  \n          if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n              continue;\n  \n          for(n = 0; n < pcoin->vout.size(); n++) {\n              bool fUpdated = false;\n  \n              if(IsMine(pcoin->vout[n])) {\n                  if(pcoin->IsSpent(n) &&\n                    ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkUnspent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  } else if(!pcoin->IsSpent(n) &&\n                    (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkSpent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  }\n  \n              }\n  \n              if(fUpdated)\n                NotifyTransactionChanged(this, hash, CT_UPDATED);\n          }\n  \n          if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n             nOrphansFound++;\n             if(!fCheckOnly) {\n                 EraseFromWallet(hash);\n                 NotifyTransactionChanged(this, hash, CT_DELETED);\n             }\n             printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n               fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n          }\n      }\n  }\n  \n  \n  // ppcoin: disable transaction (only for coinstake)\n  void CWallet::DisableTransaction(const CTransaction &tx)\n  {\n      if (!tx.IsCoinStake() || !IsFromMe(tx))\n          return; // only disconnecting coinstake requires marking input unspent\n  \n      LOCK(cs_wallet);\n      BOOST_FOREACH(const CTxIn& txin, tx.vin)\n      {\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n              {\n                  prev.MarkUnspent(txin.prevout.n);\n                  prev.WriteToDisk();\n              }\n          }\n      }\n  }\n  \n  CPubKey CReserveKey::GetReservedKey()\n  {\n      if (nIndex == -1)\n      {\n          CKeyPool keypool;\n          pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex != -1)\n              vchPubKey = keypool.vchPubKey;\n          else\n          {\n              printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n              vchPubKey = pwallet->vchDefaultKey;\n          }\n      }\n      assert(vchPubKey.IsValid());\n      return vchPubKey;\n  }\n  \n  void CReserveKey::KeepKey()\n  {\n      if (nIndex != -1)\n          pwallet->KeepKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CReserveKey::ReturnKey()\n  {\n      if (nIndex != -1)\n          pwallet->ReturnKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n  {\n      setAddress.clear();\n  \n      CWalletDB walletdb(strWalletFile);\n  \n      LOCK2(cs_main, cs_wallet);\n      BOOST_FOREACH(const int64_t& id, setKeyPool)\n      {\n          CKeyPool keypool;\n          if (!walletdb.ReadPool(id, keypool))\n              throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n          assert(keypool.vchPubKey.IsValid());\n          CKeyID keyID = keypool.vchPubKey.GetID();\n          if (!HaveKey(keyID))\n              throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n          setAddress.insert(keyID);\n      }\n  }\n  \n  void CWallet::UpdatedTransaction(const uint256 &hashTx)\n  {\n      {\n          LOCK(cs_wallet);\n          // Only notify UI if this transaction is in this wallet\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n              NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n      }\n  }\n  \n  void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n      mapKeyBirth.clear();\n  \n      // get birth times for keys with metadata\n      for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n          if (it->second.nCreateTime)\n              mapKeyBirth[it->first] = it->second.nCreateTime;\n  \n      // map in which we'll infer heights of other keys\n      CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n      std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n      std::set<CKeyID> setKeys;\n      GetKeys(setKeys);\n      BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n          if (mapKeyBirth.count(keyid) == 0)\n              mapKeyFirstBlock[keyid] = pindexMax;\n      }\n      setKeys.clear();\n  \n      // if there are no such keys, we're done\n      if (mapKeyFirstBlock.empty())\n          return;\n  \n      // find first block that affects those keys, if there are any left\n      std::vector<CKeyID> vAffected;\n      for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n          // iterate over all wallet transactions...\n          const CWalletTx &wtx = (*it).second;\n          std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n          if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n              // ... which are already in a block\n              int nHeight = blit->second->nHeight;\n              BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                  // iterate over all their outputs\n                  ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                  BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                      // ... and all their affected keys\n                      std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                      if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                          rit->second = blit->second;\n                  }\n                  vAffected.clear();\n              }\n          }\n      }\n  \n      // Extract block timestamps for those keys\n      for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n          mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->ScanForWalletTransactions",
          "args": [
            "pindex"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Rescanning last %i blocks\\n\"",
            "pindexBest->nHeight - pindex->nHeight + 1"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file.close",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "AcceptedConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "664-667",
          "snippet": "virtual void close()\n    {\n        _stream.close();\n    }",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nAcceptedConnectionImpl {\n  virtual void close()\n      {\n          _stream.close();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "nTimeBegin",
            "nTime"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->SetAddressBookName",
          "args": [
            "keyid",
            "strLabel"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->AddKey",
          "args": [
            "key"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "AddKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "120-140",
          "snippet": "bool CCryptoKeyStore::AddKey(const CKey& key)\n{\n    {\n        LOCK(cs_KeyStore);\n        if (!IsCrypted())\n            return CBasicKeyStore::AddKey(key);\n\n        if (IsLocked())\n            return false;\n\n        std::vector<unsigned char> vchCryptedSecret;\n        CPubKey vchPubKey = key.GetPubKey();\n        bool fCompressed;\n        if (!EncryptSecret(vMasterKey, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n            return false;\n\n        if (!AddCryptedKey(key.GetPubKey(), vchCryptedSecret))\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::AddKey(const CKey& key)\n  {\n      {\n          LOCK(cs_KeyStore);\n          if (!IsCrypted())\n              return CBasicKeyStore::AddKey(key);\n  \n          if (IsLocked())\n              return false;\n  \n          std::vector<unsigned char> vchCryptedSecret;\n          CPubKey vchPubKey = key.GetPubKey();\n          bool fCompressed;\n          if (!EncryptSecret(vMasterKey, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n              return false;\n  \n          if (!AddCryptedKey(key.GetPubKey(), vchCryptedSecret))\n              return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "keyid"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeDumpString",
          "args": [
            "vstr[nStr].substr(6)"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDumpString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "76-88",
          "snippet": "std::string DecodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    for (unsigned int pos = 0; pos < str.length(); pos++) {\n        unsigned char c = str[pos];\n        if (c == '%' && pos+2 < str.length()) {\n            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n                ((str[pos+2]>>6)*9+((str[pos+2]-'0')&15));\n            pos += 2;\n        }\n        ret << c;\n    }\n    return ret.str();\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::string DecodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    for (unsigned int pos = 0; pos < str.length(); pos++) {\n        unsigned char c = str[pos];\n        if (c == '%' && pos+2 < str.length()) {\n            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n                ((str[pos+2]>>6)*9+((str[pos+2]-'0')&15));\n            pos += 2;\n        }\n        ret << c;\n    }\n    return ret.str();\n}"
        }
      },
      {
        "call_info": {
          "callee": "vstr[nStr].substr",
          "args": [
            "6"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::algorithm::starts_with",
          "args": [
            "vstr[nStr]",
            "\"label=\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::algorithm::starts_with",
          "args": [
            "vstr[nStr]",
            "\"#\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vstr.size",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeDumpTime",
          "args": [
            "vstr[1]"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeDumpTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "45-58",
          "snippet": "int64_t DecodeDumpTime(const std::string& s)\n{\n    bt::ptime pt;\n\n    for(size_t i=0; i<formats_n; ++i)\n    {\n        std::istringstream is(s);\n        is.imbue(formats[i]);\n        is >> pt;\n        if(pt != bt::ptime()) break;\n    }\n\n    return pt_to_time_t(pt);\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [
            "const std::locale formats[] = {\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y/%m/%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%d.%m.%Y %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d\"))\n};",
            "const size_t formats_n = sizeof(formats)/sizeof(formats[0]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nconst std::locale formats[] = {\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y/%m/%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%d.%m.%Y %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d\"))\n};\nconst size_t formats_n = sizeof(formats)/sizeof(formats[0]);\n\nint64_t DecodeDumpTime(const std::string& s)\n{\n    bt::ptime pt;\n\n    for(size_t i=0; i<formats_n; ++i)\n    {\n        std::istringstream is(s);\n        is.imbue(formats[i]);\n        is >> pt;\n        if(pt != bt::ptime()) break;\n    }\n\n    return pt_to_time_t(pt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->HaveKey",
          "args": [
            "keyid"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "HaveKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "150-159",
          "snippet": "bool HaveKey(const CKeyID &address) const\n    {\n        {\n            LOCK(cs_KeyStore);\n            if (!IsCrypted())\n                return CBasicKeyStore::HaveKey(address);\n            return mapCryptedKeys.count(address) > 0;\n        }\n        return false;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool HaveKey(const CKeyID &address) const\n      {\n          {\n              LOCK(cs_KeyStore);\n              if (!IsCrypted())\n                  return CBasicKeyStore::HaveKey(address);\n              return mapCryptedKeys.count(address) > 0;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetSecret",
          "args": [
            "secret",
            "fCompressed"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "SetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "209-230",
          "snippet": "bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n{\n    EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n    if (vchSecret.size() != 32)\n        throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n    BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n    if (bn == NULL)\n        throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n    if (!EC_KEY_regenerate_key(pkey,bn))\n    {\n        BN_clear_free(bn);\n        throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n    }\n    BN_clear_free(bn);\n    fSet = true;\n    if (fCompressed || fCompressedPubKey)\n        SetCompressedPubKey();\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n  {\n      EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n      if (vchSecret.size() != 32)\n          throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n      BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n      if (bn == NULL)\n          throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n      if (!EC_KEY_regenerate_key(pkey,bn))\n      {\n          BN_clear_free(bn);\n          throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n      }\n      BN_clear_free(bn);\n      fSet = true;\n      if (fCompressed || fCompressedPubKey)\n          SetCompressedPubKey();\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSecret.GetSecret",
          "args": [
            "fCompressed"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "GetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "232-245",
          "snippet": "CSecret CKey::GetSecret(bool &fCompressed) const\n{\n    CSecret vchRet;\n    vchRet.resize(32);\n    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n    int nBytes = BN_num_bytes(bn);\n    if (bn == NULL)\n        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n    if (n != nBytes)\n        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n    fCompressed = fCompressedPubKey;\n    return vchRet;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CSecret CKey::GetSecret(bool &fCompressed) const\n  {\n      CSecret vchRet;\n      vchRet.resize(32);\n      const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n      int nBytes = BN_num_bytes(bn);\n      if (bn == NULL)\n          throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n      int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n      if (n != nBytes)\n          throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n      fCompressed = fCompressedPubKey;\n      return vchRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSecret.SetString",
          "args": [
            "vstr[0]"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "SetString",
          "container": "CBitcoinSecret",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "445-448",
          "snippet": "bool SetString(const std::string& strSecret)\n    {\n        return SetString(strSecret.c_str());\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinSecret {\n  bool SetString(const std::string& strSecret)\n      {\n          return SetString(strSecret.c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "boost::split",
          "args": [
            "vstr",
            "line",
            "boost::is_any_of(\" \")"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::is_any_of",
          "args": [
            "\" \""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "line.empty",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::getline",
          "args": [
            "file",
            "line"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.good",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "good",
          "container": "CAutoFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "1078-1078",
          "snippet": "bool good() const            { return state == 0; }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCAutoFile {\n  bool good() const            { return state == 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file.is_open",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file.open",
          "args": [
            "params[0].get_str().c_str()"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnsureWalletIsUnlocked",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "EnsureWalletIsUnlocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcwallet.cpp",
          "lines": "41-47",
          "snippet": "void EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"ntp.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"ntp.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n\nvoid EnsureWalletIsUnlocked()\n{\n    if (pwalletMain->IsLocked())\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Please enter the wallet passphrase with walletpassphrase first.\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Error: Wallet is unlocked for staking only.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"importwallet <filename>\\n\"\n            \"Imports keys from a wallet dump file (see dumpwallet).\""
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\n#define printf OutputDebugStringF\n\nvoid EnsureWalletIsUnlocked();\n\nValue importwallet(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 1)\n        throw runtime_error(\n            \"importwallet <filename>\\n\"\n            \"Imports keys from a wallet dump file (see dumpwallet).\");\n\n    EnsureWalletIsUnlocked();\n\n    ifstream file;\n    file.open(params[0].get_str().c_str());\n    if (!file.is_open())\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n\n    int64_t nTimeBegin = pindexBest->nTime;\n\n    bool fGood = true;\n\n    while (file.good()) {\n        std::string line;\n        std::getline(file, line);\n        if (line.empty() || line[0] == '#')\n            continue;\n\n        std::vector<std::string> vstr;\n        boost::split(vstr, line, boost::is_any_of(\" \"));\n        if (vstr.size() < 2)\n            continue;\n        CBitcoinSecret vchSecret;\n        if (!vchSecret.SetString(vstr[0]))\n            continue;\n\n        bool fCompressed;\n        CKey key;\n        CSecret secret = vchSecret.GetSecret(fCompressed);\n        key.SetSecret(secret, fCompressed);\n        CKeyID keyid = key.GetPubKey().GetID();\n\n        if (pwalletMain->HaveKey(keyid)) {\n            printf(\"Skipping import of %s (key already present)\\n\", CBitcoinAddress(keyid).ToString().c_str());\n            continue;\n        }\n        int64_t nTime = DecodeDumpTime(vstr[1]);\n        std::string strLabel;\n        bool fLabel = true;\n        for (unsigned int nStr = 2; nStr < vstr.size(); nStr++) {\n            if (boost::algorithm::starts_with(vstr[nStr], \"#\"))\n                break;\n            if (vstr[nStr] == \"change=1\")\n                fLabel = false;\n            if (vstr[nStr] == \"reserve=1\")\n                fLabel = false;\n            if (boost::algorithm::starts_with(vstr[nStr], \"label=\")) {\n                strLabel = DecodeDumpString(vstr[nStr].substr(6));\n                fLabel = true;\n            }\n        }\n        printf(\"Importing %s...\\n\", CBitcoinAddress(keyid).ToString().c_str());\n        if (!pwalletMain->AddKey(key)) {\n            fGood = false;\n            continue;\n        }\n        pwalletMain->mapKeyMetadata[keyid].nCreateTime = nTime;\n        if (fLabel)\n            pwalletMain->SetAddressBookName(keyid, strLabel);\n        nTimeBegin = std::min(nTimeBegin, nTime);\n    }\n    file.close();\n\n    CBlockIndex *pindex = pindexBest;\n    while (pindex && pindex->pprev && pindex->nTime > nTimeBegin - 7200)\n        pindex = pindex->pprev;\n\n    if (!pwalletMain->nTimeFirstKey || nTimeBegin < pwalletMain->nTimeFirstKey)\n        pwalletMain->nTimeFirstKey = nTimeBegin;\n\n    printf(\"Rescanning last %i blocks\\n\", pindexBest->nHeight - pindex->nHeight + 1);\n    pwalletMain->ScanForWalletTransactions(pindex);\n    pwalletMain->ReacceptWalletTransactions();\n    pwalletMain->MarkDirty();\n\n    if (!fGood)\n        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding some keys to wallet\");\n\n    return Value::null;\n}"
  },
  {
    "function_name": "importprivkey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "108-153",
    "snippet": "Value importprivkey(const Array& params, bool fHelp) {\n\n    if(fHelp || (params.size() < 1) || (params.size() > 3)) {\n        string msg = \"importprivkey <key> [label] [rescan]\\n\"\n          \"Adds a private <key> to your wallet in the format of RPC dumpprivkey.\\n\"\n          \"Block chain re-scanning is on (true) by default.\\n\";\n        throw(runtime_error(msg));\n    }\n\n    string strSecret = params[0].get_str();\n    string strLabel = \"\";\n    if (params.size() > 1)\n        strLabel = params[1].get_str();\n    CBitcoinSecret vchSecret;\n    bool fGood = vchSecret.SetString(strSecret);\n\n    bool fRescan = true;\n    if(params.size() > 2)\n      fRescan = params[2].get_bool();\n\n    if (!fGood) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Wallet is unlocked for staking only.\");\n\n    CKey key;\n    bool fCompressed;\n    CSecret secret = vchSecret.GetSecret(fCompressed);\n    key.SetSecret(secret, fCompressed);\n    CKeyID vchAddress = key.GetPubKey().GetID();\n    {\n        LOCK2(cs_main, pwalletMain->cs_wallet);\n\n        pwalletMain->MarkDirty();\n        pwalletMain->SetAddressBookName(vchAddress, strLabel);\n\n        if (!pwalletMain->AddKey(key))\n            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n\n        if(fRescan) {\n            pwalletMain->ScanForWalletTransactions(pindexGenesisBlock, true);\n            pwalletMain->ReacceptWalletTransactions();\n        }\n    }\n\n    return(Value::null);\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwalletMain->ReacceptWalletTransactions",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ReacceptWalletTransactions",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "876-2476",
          "snippet": "void CWallet::ReacceptWalletTransactions()\n{\n    CTxDB txdb(\"r\");\n    bool fRepeat = true;\n    while (fRepeat)\n    {\n        LOCK(cs_wallet);\n        fRepeat = false;\n        vector<CDiskTxPos> vMissingTx;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                continue;\n\n            CTxIndex txindex;\n            bool fUpdated = false;\n            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n            {\n                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                if (txindex.vSpent.size() != wtx.vout.size())\n                {\n                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                    continue;\n                }\n                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                {\n                    if (wtx.IsSpent(i))\n                        continue;\n                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                    {\n                        wtx.MarkSpent(i);\n                        fUpdated = true;\n                        vMissingTx.push_back(txindex.vSpent[i]);\n                    }\n                }\n                if (fUpdated)\n                {\n                    printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkDirty();\n                    wtx.WriteToDisk();\n                }\n            }\n            else\n            {\n                // Re-accept any txes of ours that aren't already in a block\n                if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                    wtx.AcceptWalletTransaction(txdb);\n            }\n        }\n        if (!vMissingTx.empty())\n        {\n            // TODO: optimize this to scan just part of the block chain?\n            if (ScanForWalletTransactions(pindexGenesisBlock))\n                fRepeat = true;  // Found missing transactions: re-do re-accept.\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n{\n    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n    {\n        if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n        {\n            uint256 hash = tx.GetHash();\n            if (!txdb.ContainsTx(hash))\n                RelayTransaction((CTransaction)tx, hash);\n        }\n    }\n    if (!(IsCoinBase() || IsCoinStake()))\n    {\n        uint256 hash = GetHash();\n        if (!txdb.ContainsTx(hash))\n        {\n            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n            RelayTransaction((CTransaction)*this, hash);\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction()\n{\n   CTxDB txdb(\"r\");\n   RelayWalletTransaction(txdb);\n}\n\nvoid CWallet::ResendWalletTransactions(bool fForce)\n{\n    if (!fForce)\n    {\n        // Do this infrequently and randomly to avoid giving away\n        // that these are our transactions.\n        static int64_t nNextTime;\n        if (GetTime() < nNextTime)\n            return;\n        bool fFirst = (nNextTime == 0);\n        nNextTime = GetTime() + GetRand(30 * 60);\n        if (fFirst)\n            return;\n\n        // Only do it if there's been a new block since last time\n        static int64_t nLastTime;\n        if (nTimeBestReceived < nLastTime)\n            return;\n        nLastTime = GetTime();\n    }\n\n    // Rebroadcast any of our txes that aren't in a block yet\n    printf(\"ResendWalletTransactions()\\n\");\n    CTxDB txdb(\"r\");\n    {\n        LOCK(cs_wallet);\n        // Sort them in chronological order\n        multimap<unsigned int, CWalletTx*> mapSorted;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            // Don't rebroadcast until it's had plenty of time that\n            // it should have gotten in already by now.\n            if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n        }\n        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n        {\n            CWalletTx& wtx = *item.second;\n            if (wtx.CheckTransaction())\n                wtx.RelayWalletTransaction(txdb);\n            else\n                printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n        }\n    }\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Actions\n//\n\n\nint64_t CWallet::GetBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nint64_t CWallet::GetUnconfirmedBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetImmatureBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx& pcoin = (*it).second;\n            if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                nTotal += GetCredit(pcoin);\n        }\n    }\n    return nTotal;\n}\n\n// populate vCoins with vector of spendable COutputs\nvoid CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if (fOnlyConfirmed && !pcoin->IsTrusted())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < 0)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                    vCoins.push_back(COutput(pcoin, i, nDepth));\n\n        }\n    }\n}\n\nvoid CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if(pcoin->GetDepthInMainChain() < nConf)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n        }\n    }\n}\n\nstatic void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                  vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n{\n    vector<char> vfIncluded;\n\n    vfBest.assign(vValue.size(), true);\n    nBest = nTotalLower;\n\n    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n    {\n        vfIncluded.assign(vValue.size(), false);\n        int64_t nTotal = 0;\n        bool fReachedTarget = false;\n        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n        {\n            for (unsigned int i = 0; i < vValue.size(); i++)\n            {\n                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                {\n                    nTotal += vValue[i].first;\n                    vfIncluded[i] = true;\n                    if (nTotal >= nTargetValue)\n                    {\n                        fReachedTarget = true;\n                        if (nTotal < nBest)\n                        {\n                            nBest = nTotal;\n                            vfBest = vfIncluded;\n                        }\n                        nTotal -= vValue[i].first;\n                        vfIncluded[i] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// ppcoin: total coins staked (non-spendable until maturity)\nint64_t CWallet::GetStake() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetNewMint() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nbool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    // List of values less than target\n    pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n    coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n    coinLowestLarger.second.first = NULL;\n    vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n    int64_t nTotalLower = 0;\n\n    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n\n        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n            continue;\n\n        int i = output.i;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n == nTargetValue)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            return true;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            vValue.push_back(coin);\n            nTotalLower += n;\n        }\n        else if (n < coinLowestLarger.first)\n        {\n            coinLowestLarger = coin;\n        }\n    }\n\n    if (nTotalLower == nTargetValue)\n    {\n        for (unsigned int i = 0; i < vValue.size(); ++i)\n        {\n            setCoinsRet.insert(vValue[i].second);\n            nValueRet += vValue[i].first;\n        }\n        return true;\n    }\n\n    if (nTotalLower < nTargetValue)\n    {\n        if (coinLowestLarger.second.first == NULL)\n            return false;\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n        return true;\n    }\n\n    // Solve subset sum by stochastic approximation\n    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n    vector<char> vfBest;\n    int64_t nBest;\n\n    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n\n    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n    //                                   or the next bigger coin is closer), return the bigger coin\n    if (coinLowestLarger.second.first &&\n        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n    {\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n    }\n    else {\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n            {\n                setCoinsRet.insert(vValue[i].second);\n                nValueRet += vValue[i].first;\n            }\n\n        if (fDebug && GetBoolArg(\"-printpriority\"))\n        {\n            //// debug print\n            printf(\"SelectCoins() best subset: \");\n            for (unsigned int i = 0; i < vValue.size(); i++)\n                if (vfBest[i])\n                    printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n            printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n{\n    vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n\n    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n    if (coinControl && coinControl->HasSelected())\n    {\n        BOOST_FOREACH(const COutput& out, vCoins)\n        {\n            nValueRet += out.tx->vout[out.i].nValue;\n            setCoinsRet.insert(make_pair(out.tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n}\n\n// Select some coins without random shuffle or best subset approximation\nbool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    vector<COutput> vCoins;\n    AvailableCoinsMinConf(vCoins, nMinConf);\n\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n        int i = output.i;\n\n        // Stop if we've chosen enough inputs\n        if (nValueRet >= nTargetValue)\n            break;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n >= nTargetValue)\n        {\n            // If input value is greater or equal to target then simply insert\n            //    it into the current subset and exit\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            break;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    int64_t nValue = 0;\n    BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n    {\n        if (nValue < 0)\n            return false;\n        nValue += s.second;\n    }\n    if (vecSend.empty() || nValue < 0)\n        return false;\n\n    wtxNew.BindWallet(this);\n\n    {\n        LOCK2(cs_main, cs_wallet);\n        // txdb must be opened before the mapWallet lock\n        CTxDB txdb(\"r\");\n        {\n            nFeeRet = nTransactionFee;\n            while (true)\n            {\n                wtxNew.vin.clear();\n                wtxNew.vout.clear();\n                wtxNew.fFromMe = true;\n\n                int64_t nTotalValue = nValue + nFeeRet;\n                double dPriority = 0;\n                // vouts to the payees\n                BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n\n                // Choose coins to use\n                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                int64_t nValueIn = 0;\n                if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                    return false;\n                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                {\n                    int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                }\n\n                int64_t nChange = nValueIn - nValue - nFeeRet;\n                // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                // or until nChange becomes zero\n                // NOTE: this depends on the exact behaviour of GetMinFee\n                if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                {\n                    int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                    nChange -= nMoveToFee;\n                    nFeeRet += nMoveToFee;\n                }\n\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    // TODO: pass in scriptChange instead of reservekey so\n                    // change transaction isn't always pay-to-bitcoin-address\n                    CScript scriptChange;\n\n                    // coin control: send change to custom address\n                    if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                        scriptChange.SetDestination(coinControl->destChange);\n\n                    // no coin control: send change to newly generated address\n                    else\n                    {\n                        // Note: We use a new key here to keep it from being obvious which side is the change.\n                        //  The drawback is that by not reusing a previous key, the change may be lost if a\n                        //  backup is restored, if the backup doesn't have the new private key for the change.\n                        //  If we reused the old key, it would be possible to add code to look for and\n                        //  rediscover unknown transactions that were written with keys of ours to recover\n                        //  post-backup change.\n\n                        // Reserve a new key pair from key pool\n                        CPubKey vchPubKey = reservekey.GetReservedKey();\n\n                        scriptChange.SetDestination(vchPubKey.GetID());\n                    }\n\n                    // Insert change txn at random position:\n                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                }\n                else\n                    reservekey.ReturnKey();\n\n                // Fill vin\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n\n                // Sign\n                int nIn = 0;\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                        return false;\n\n                // Limit size\n                unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                    return false;\n                dPriority /= nBytes;\n\n                // Check that enough fee is included\n                int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n\n                if (nFeeRet < max(nPayFee, nMinFee))\n                {\n                    nFeeRet = max(nPayFee, nMinFee);\n                    continue;\n                }\n\n                // Fill vtxPrev by copying from previous transactions vtxPrev\n                wtxNew.AddSupportingTransactions(txdb);\n                wtxNew.fTimeReceivedIsTxTime = true;\n\n                break;\n            }\n        }\n    }\n    return true;\n}\n\nbool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    vector< pair<CScript, int64_t> > vecSend;\n    vecSend.push_back(make_pair(scriptPubKey, nValue));\n    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n}\n\n// NovaCoin: get current stake weight\nbool CWallet::GetStakeWeight(const CKeyStore& keystore,\n  uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n        CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n\n        // Weight is greater than zero\n        if (nTimeWeight > 0)\n        {\n            nWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Weight is greater than zero, but the maximum value isn't reached yet\n        if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n        {\n            nMinWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Maximum weight was reached\n        if (nTimeWeight == nStakeMaxAge)\n        {\n            nMaxWeight += bnCoinDayWeight.getuint64();\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n  int64_t nFees, CTransaction& txNew, CKey& key) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    /* Don't split inputs above this age */\n    const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n    /* Time limit for searching a single input */\n    const uint nMaxStakeSearchInterval = 60;\n\n    CBlockIndex* pindexPrev = pindexBest;\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n\n    txNew.vin.clear();\n    txNew.vout.clear();\n\n    // Mark coin stake transaction\n    CScript scriptEmpty;\n    scriptEmpty.clear();\n    txNew.vout.push_back(CTxOut(0, scriptEmpty));\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    // Select coins with suitable depth\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    int64_t nCredit = 0;\n    CScript scriptPubKeyKernel;\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        // Read block header\n        CBlock block;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                continue;\n        }\n\n        if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n            continue; // only count coins meeting min age requirement\n\n        bool fKernelFound = false;\n        for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n        {\n            // Search backward in time from the given txNew timestamp \n            // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n            uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n            COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n            if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n            {\n                // Found a kernel\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : kernel found\\n\");\n                vector<valtype> vSolutions;\n                txnouttype whichType;\n                CScript scriptPubKeyOut;\n                scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                    break;\n                }\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                    break;  // only support pay to public key and pay to address\n                }\n                if (whichType == TX_PUBKEYHASH) // pay to address type\n                {\n                    // convert to pay to public key type\n                    if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n                    scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                }\n                if (whichType == TX_PUBKEY)\n                {\n                    valtype& vchPubKey = vSolutions[0];\n                    if (!keystore.GetKey(Hash160(vchPubKey), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                        break; // keys mismatch\n                    }\n\n                    scriptPubKeyOut = scriptPubKeyKernel;\n                }\n\n                txNew.nTime -= n;\n                txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                nCredit += pcoin.first->vout[pcoin.second].nValue;\n                vwtxPrev.push_back(pcoin.first);\n                txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                /* Split large inputs into two near halves;\n                 * exact amounts to be defined after reward processing */\n                if((nCredit >= nSplitThreshold) &&\n                  (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                fKernelFound = true;\n                break;\n            }\n        }\n\n        if (fKernelFound || fShutdown)\n            break; // if kernel is found stop searching\n    }\n\n    /* At this point, stake amount must be positive and within the stake limit if defined */\n    if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n      return(false);\n\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n\n        /* Make a larger stake by inserting additional inputs\n         * of the same public key (address) as the generating input */\n        if((txNew.vout.size() == 2) &&\n          (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n          (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n          (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n            int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n\n            /* Do not add too many inputs */\n            if(txNew.vin.size() >= 10)\n              break;\n            /* Do not add any inputs if reached or exceeded the threshold already */\n            if(nCredit >= nCombineThreshold)\n              break;\n            /* Do not add a new input exceeding the stake limit if defined */\n            if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n              break;\n            /* Do not add any large inputs capable of stake generation on their own */\n            if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n              continue;\n            /* Do not add any inputs under the min. age */\n            if(nTimeWeight < nStakeMinAge)\n              continue;\n\n            txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n            nCredit += pcoin.first->vout[pcoin.second].nValue;\n            vwtxPrev.push_back(pcoin.first);\n        }\n\n    }\n\n    // Calculate coin age reward\n    {\n        uint64_t nCoinAge;\n        CTxDB txdb(\"r\");\n        if (!txNew.GetCoinAge(txdb, nCoinAge))\n            return error(\"CreateCoinStake : failed to calculate coin age\");\n\n        int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n        if (nReward <= 0)\n            return false;\n\n        nCredit += nReward;\n    }\n\n    // Set output amount\n    if (txNew.vout.size() == 3)\n    {\n        txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n        txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n    }\n    else\n        txNew.vout[1].nValue = nCredit;\n\n    // Sign\n    int nIn = 0;\n    BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n    {\n        if (!SignSignature(*this, *pcoin, txNew, nIn++))\n            return error(\"CreateCoinStake : failed to sign coinstake\");\n    }\n\n    // Limit size\n    unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n    if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n        return error(\"CreateCoinStake : exceeded coinstake size limit\");\n\n    // Successfully generated coinstake\n    return true;\n}\n\n\n// Call after CreateTransaction unless you want to abort\nbool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}\n\n\n\n\nstring CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    CReserveKey reservekey(this);\n    int64_t nFeeRequired;\n\n    if (IsLocked())\n    {\n        string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (fWalletUnlockStakingOnly)\n    {\n        string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n    {\n        string strError;\n        if (nValue + nFeeRequired > GetBalance())\n            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n        else\n            strError = _(\"Error: Transaction creation failed  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n\n    if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n        return \"ABORTED\";\n\n    if (!CommitTransaction(wtxNew, reservekey))\n        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n\n    return \"\";\n}\n\n\n\nstring CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    // Check amount\n    if (nValue <= 0)\n        return _(\"Invalid amount\");\n    if (nValue + nTransactionFee > GetBalance())\n        return _(\"Insufficient funds\");\n\n    // Parse Bitcoin address\n    CScript scriptPubKey;\n    scriptPubKey.SetDestination(address);\n\n    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n}\n\n\n\n\nDBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    if (!fFileBacked)\n        return DB_LOAD_OK;\n    fFirstRunRet = false;\n    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n        {\n            setKeyPool.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // the requires a new key.\n        }\n    }\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n    fFirstRunRet = !vchDefaultKey.IsValid();\n\n    NewThread(ThreadFlushWalletDB, &strWalletFile);\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n{\n    std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n    mapAddressBook[address] = strName;\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n}\n\nbool CWallet::DelAddressBookName(const CTxDestination& address)\n{\n    mapAddressBook.erase(address);\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n}\n\n\nvoid CWallet::PrintWallet(const CBlock& block)\n{\n    {\n        LOCK(cs_wallet);\n        if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n            printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n        }\n        if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n            printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n         }\n\n    }\n    printf(\"\\n\");\n}\n\nbool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n        {\n            wtx = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n{\n    if (fFileBacked)\n    {\n        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n            return false;\n    }\n    vchDefaultKey = vchPubKey;\n    return true;\n}\n\nbool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n{\n    if (!pwallet->fFileBacked)\n        return false;\n    strWalletFileOut = pwallet->strWalletFile;\n    return true;\n}\n\n//\n// Mark old keypool keys as used,\n// and generate all new keys\n//\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n        BOOST_FOREACH(int64_t nIndex, setKeyPool)\n            walletdb.ErasePool(nIndex);\n        setKeyPool.clear();\n\n        if (IsLocked())\n            return false;\n\n        int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n        for (int i = 0; i < nKeys; i++)\n        {\n            int64_t nIndex = i+1;\n            walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n            setKeyPool.insert(nIndex);\n        }\n        printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n    }\n    return true;\n}\n\nbool CWallet::TopUpKeyPool(unsigned int nSize)\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        CWalletDB walletdb(strWalletFile);\n\n        // Top up key pool\n        unsigned int nTargetSize;\n        if (nSize > 0)\n            nTargetSize = nSize;\n        else\n            nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n\n        while (setKeyPool.size() < (nTargetSize + 1))\n        {\n            int64_t nEnd = 1;\n            if (!setKeyPool.empty())\n                nEnd = *(--setKeyPool.end()) + 1;\n            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n            setKeyPool.insert(nEnd);\n            printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(strWalletFile);\n\n        nIndex = *(setKeyPool.begin());\n        setKeyPool.erase(setKeyPool.begin());\n        if (!walletdb.ReadPool(nIndex, keypool))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n        if (!HaveKey(keypool.vchPubKey.GetID()))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n        assert(keypool.vchPubKey.IsValid());\n        if (fDebug && GetBoolArg(\"-printkeypool\"))\n            printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n    }\n}\n\nint64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n\n        int64_t nIndex = 1 + *(--setKeyPool.end());\n        if (!walletdb.WritePool(nIndex, keypool))\n            throw runtime_error(\"AddReserveKey() : writing added key failed\");\n        setKeyPool.insert(nIndex);\n        return nIndex;\n    }\n    return -1;\n}\n\nvoid CWallet::KeepKey(int64_t nIndex)\n{\n    // Remove from key pool\n    if (fFileBacked)\n    {\n        CWalletDB walletdb(strWalletFile);\n        walletdb.ErasePool(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64_t nIndex)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        setKeyPool.insert(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex == -1)\n        {\n            if (fAllowReuse && vchDefaultKey.IsValid())\n            {\n                result = vchDefaultKey;\n                return true;\n            }\n            if (IsLocked()) return false;\n            result = GenerateNewKey();\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nint64_t CWallet::GetOldestKeyPoolTime()\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    ReserveKeyFromKeyPool(nIndex, keypool);\n    if (nIndex == -1)\n        return GetTime();\n    ReturnKey(nIndex);\n    return keypool.nTime;\n}\n\nstd::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n{\n    map<CTxDestination, int64_t> balances;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n        {\n            CWalletTx *pcoin = &walletEntry.second;\n\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                continue;\n\n            if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            {\n                CTxDestination addr;\n                if (!IsMine(pcoin->vout[i]))\n                    continue;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                    continue;\n\n                int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n\n                if (!balances.count(addr))\n                    balances[addr] = 0;\n                balances[addr] += n;\n            }\n        }\n    }\n\n    return balances;\n}\n\nset< set<CTxDestination> > CWallet::GetAddressGroupings()\n{\n    set< set<CTxDestination> > groupings;\n    set<CTxDestination> grouping;\n\n    BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n    {\n        CWalletTx *pcoin = &walletEntry.second;\n\n        if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n        {\n            // group all input addresses with each other\n            BOOST_FOREACH(CTxIn txin, pcoin->vin)\n            {\n                CTxDestination address;\n                if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n            }\n\n            // group change with input addresses\n            BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                if (IsChange(txout))\n                {\n                    CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                    CTxDestination txoutAddr;\n                    if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                        continue;\n                    grouping.insert(txoutAddr);\n                }\n            groupings.insert(grouping);\n            grouping.clear();\n        }\n\n        // group lone addrs by themselves\n        for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            if (IsMine(pcoin->vout[i]))\n            {\n                CTxDestination address;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n    }\n\n    set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n    map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n    BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n    {\n        // make a set of all the groups hit by this new group\n        set< set<CTxDestination>* > hits;\n        map< CTxDestination, set<CTxDestination>* >::iterator it;\n        BOOST_FOREACH(CTxDestination address, grouping)\n            if ((it = setmap.find(address)) != setmap.end())\n                hits.insert((*it).second);\n\n        // merge all hit groups into a new single group and delete old groups\n        set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n        BOOST_FOREACH(set<CTxDestination>* hit, hits)\n        {\n            merged->insert(hit->begin(), hit->end());\n            uniqueGroupings.erase(hit);\n            delete hit;\n        }\n        uniqueGroupings.insert(merged);\n\n        // update setmap\n        BOOST_FOREACH(CTxDestination element, *merged)\n            setmap[element] = merged;\n    }\n\n    set< set<CTxDestination> > ret;\n    BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n    {\n        ret.insert(*uniqueGrouping);\n        delete uniqueGrouping;\n    }\n\n    return ret;\n}\n\n\n/* Checks for wallet vs. transaction index consistency;\n * reports any spent state inconsistency found and\n * (optionally) fixes the wallet according to the transaction index */\nvoid CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n  bool fCheckOnly) {\n    nMismatchFound = 0;\n    nOrphansFound = 0;\n    nBalanceInQuestion = 0;\n\n    LOCK(cs_wallet);\n    vector<CWalletTx*> vCoins;\n    vCoins.reserve(mapWallet.size());\n    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        vCoins.push_back(&(*it).second);\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n        uint256 hash = pcoin->GetHash();\n        CTxIndex txindex;\n        uint n;\n\n        if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n            continue;\n\n        for(n = 0; n < pcoin->vout.size(); n++) {\n            bool fUpdated = false;\n\n            if(IsMine(pcoin->vout[n])) {\n                if(pcoin->IsSpent(n) &&\n                  ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkUnspent(n);\n                        pcoin->WriteToDisk();\n                    }\n                } else if(!pcoin->IsSpent(n) &&\n                  (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkSpent(n);\n                        pcoin->WriteToDisk();\n                    }\n                }\n\n            }\n\n            if(fUpdated)\n              NotifyTransactionChanged(this, hash, CT_UPDATED);\n        }\n\n        if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n           nOrphansFound++;\n           if(!fCheckOnly) {\n               EraseFromWallet(hash);\n               NotifyTransactionChanged(this, hash, CT_DELETED);\n           }\n           printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n             fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n        }\n    }\n}\n\n\n// ppcoin: disable transaction (only for coinstake)\nvoid CWallet::DisableTransaction(const CTransaction &tx)\n{\n    if (!tx.IsCoinStake() || !IsFromMe(tx))\n        return; // only disconnecting coinstake requires marking input unspent\n\n    LOCK(cs_wallet);\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n            {\n                prev.MarkUnspent(txin.prevout.n);\n                prev.WriteToDisk();\n            }\n        }\n    }\n}\n\nCPubKey CReserveKey::GetReservedKey()\n{\n    if (nIndex == -1)\n    {\n        CKeyPool keypool;\n        pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex != -1)\n            vchPubKey = keypool.vchPubKey;\n        else\n        {\n            printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n            vchPubKey = pwallet->vchDefaultKey;\n        }\n    }\n    assert(vchPubKey.IsValid());\n    return vchPubKey;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1)\n        pwallet->ReturnKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n{\n    setAddress.clear();\n\n    CWalletDB walletdb(strWalletFile);\n\n    LOCK2(cs_main, cs_wallet);\n    BOOST_FOREACH(const int64_t& id, setKeyPool)\n    {\n        CKeyPool keypool;\n        if (!walletdb.ReadPool(id, keypool))\n            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n        assert(keypool.vchPubKey.IsValid());\n        CKeyID keyID = keypool.vchPubKey.GetID();\n        if (!HaveKey(keyID))\n            throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n        setAddress.insert(keyID);\n    }\n}\n\nvoid CWallet::UpdatedTransaction(const uint256 &hashTx)\n{\n    {\n        LOCK(cs_wallet);\n        // Only notify UI if this transaction is in this wallet\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n            NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n    }\n}\n\nvoid CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n    mapKeyBirth.clear();\n\n    // get birth times for keys with metadata\n    for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n        if (it->second.nCreateTime)\n            mapKeyBirth[it->first] = it->second.nCreateTime;\n\n    // map in which we'll infer heights of other keys\n    CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n    std::set<CKeyID> setKeys;\n    GetKeys(setKeys);\n    BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n        if (mapKeyBirth.count(keyid) == 0)\n            mapKeyFirstBlock[keyid] = pindexMax;\n    }\n    setKeys.clear();\n\n    // if there are no such keys, we're done\n    if (mapKeyFirstBlock.empty())\n        return;\n\n    // find first block that affects those keys, if there are any left\n    std::vector<CKeyID> vAffected;\n    for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n        // iterate over all wallet transactions...\n        const CWalletTx &wtx = (*it).second;\n        std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n        if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n            // ... which are already in a block\n            int nHeight = blit->second->nHeight;\n            BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                // iterate over all their outputs\n                ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                    // ... and all their affected keys\n                    std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                    if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                        rit->second = blit->second;\n                }\n                vAffected.clear();\n            }\n        }\n    }\n\n    // Extract block timestamps for those keys\n    for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n        mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int nStakeMaxAge;",
            "bool fWalletUnlockStakingOnly = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nextern unsigned int nStakeMaxAge;\nbool fWalletUnlockStakingOnly = false;\n\nCWallet {\n  void CWallet::ReacceptWalletTransactions()\n  {\n      CTxDB txdb(\"r\");\n      bool fRepeat = true;\n      while (fRepeat)\n      {\n          LOCK(cs_wallet);\n          fRepeat = false;\n          vector<CDiskTxPos> vMissingTx;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                  continue;\n  \n              CTxIndex txindex;\n              bool fUpdated = false;\n              if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n              {\n                  // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                  if (txindex.vSpent.size() != wtx.vout.size())\n                  {\n                      printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                      continue;\n                  }\n                  for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                  {\n                      if (wtx.IsSpent(i))\n                          continue;\n                      if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                      {\n                          wtx.MarkSpent(i);\n                          fUpdated = true;\n                          vMissingTx.push_back(txindex.vSpent[i]);\n                      }\n                  }\n                  if (fUpdated)\n                  {\n                      printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                      wtx.MarkDirty();\n                      wtx.WriteToDisk();\n                  }\n              }\n              else\n              {\n                  // Re-accept any txes of ours that aren't already in a block\n                  if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                      wtx.AcceptWalletTransaction(txdb);\n              }\n          }\n          if (!vMissingTx.empty())\n          {\n              // TODO: optimize this to scan just part of the block chain?\n              if (ScanForWalletTransactions(pindexGenesisBlock))\n                  fRepeat = true;  // Found missing transactions: re-do re-accept.\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n  {\n      BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n      {\n          if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n          {\n              uint256 hash = tx.GetHash();\n              if (!txdb.ContainsTx(hash))\n                  RelayTransaction((CTransaction)tx, hash);\n          }\n      }\n      if (!(IsCoinBase() || IsCoinStake()))\n      {\n          uint256 hash = GetHash();\n          if (!txdb.ContainsTx(hash))\n          {\n              printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n              RelayTransaction((CTransaction)*this, hash);\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction()\n  {\n     CTxDB txdb(\"r\");\n     RelayWalletTransaction(txdb);\n  }\n  \n  void CWallet::ResendWalletTransactions(bool fForce)\n  {\n      if (!fForce)\n      {\n          // Do this infrequently and randomly to avoid giving away\n          // that these are our transactions.\n          static int64_t nNextTime;\n          if (GetTime() < nNextTime)\n              return;\n          bool fFirst = (nNextTime == 0);\n          nNextTime = GetTime() + GetRand(30 * 60);\n          if (fFirst)\n              return;\n  \n          // Only do it if there's been a new block since last time\n          static int64_t nLastTime;\n          if (nTimeBestReceived < nLastTime)\n              return;\n          nLastTime = GetTime();\n      }\n  \n      // Rebroadcast any of our txes that aren't in a block yet\n      printf(\"ResendWalletTransactions()\\n\");\n      CTxDB txdb(\"r\");\n      {\n          LOCK(cs_wallet);\n          // Sort them in chronological order\n          multimap<unsigned int, CWalletTx*> mapSorted;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              // Don't rebroadcast until it's had plenty of time that\n              // it should have gotten in already by now.\n              if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                  mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n          }\n          BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n          {\n              CWalletTx& wtx = *item.second;\n              if (wtx.CheckTransaction())\n                  wtx.RelayWalletTransaction(txdb);\n              else\n                  printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n          }\n      }\n  }\n  \n  \n  \n  \n  \n  \n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // Actions\n  //\n  \n  \n  int64_t CWallet::GetBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n  \n      return nTotal;\n  }\n  \n  int64_t CWallet::GetUnconfirmedBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetImmatureBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx& pcoin = (*it).second;\n              if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                  nTotal += GetCredit(pcoin);\n          }\n      }\n      return nTotal;\n  }\n  \n  // populate vCoins with vector of spendable COutputs\n  void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if (fOnlyConfirmed && !pcoin->IsTrusted())\n                  continue;\n  \n              if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < 0)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                  (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                      vCoins.push_back(COutput(pcoin, i, nDepth));\n  \n          }\n      }\n  }\n  \n  void CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if(pcoin->GetDepthInMainChain() < nConf)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                      vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n          }\n      }\n  }\n  \n  static void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                    vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n  {\n      vector<char> vfIncluded;\n  \n      vfBest.assign(vValue.size(), true);\n      nBest = nTotalLower;\n  \n      for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n      {\n          vfIncluded.assign(vValue.size(), false);\n          int64_t nTotal = 0;\n          bool fReachedTarget = false;\n          for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n          {\n              for (unsigned int i = 0; i < vValue.size(); i++)\n              {\n                  if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                  {\n                      nTotal += vValue[i].first;\n                      vfIncluded[i] = true;\n                      if (nTotal >= nTargetValue)\n                      {\n                          fReachedTarget = true;\n                          if (nTotal < nBest)\n                          {\n                              nBest = nTotal;\n                              vfBest = vfIncluded;\n                          }\n                          nTotal -= vValue[i].first;\n                          vfIncluded[i] = false;\n                      }\n                  }\n              }\n          }\n      }\n  }\n  \n  // ppcoin: total coins staked (non-spendable until maturity)\n  int64_t CWallet::GetStake() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetNewMint() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  bool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      // List of values less than target\n      pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n      coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n      coinLowestLarger.second.first = NULL;\n      vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n      int64_t nTotalLower = 0;\n  \n      random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n  \n          if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n              continue;\n  \n          int i = output.i;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n == nTargetValue)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              return true;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              vValue.push_back(coin);\n              nTotalLower += n;\n          }\n          else if (n < coinLowestLarger.first)\n          {\n              coinLowestLarger = coin;\n          }\n      }\n  \n      if (nTotalLower == nTargetValue)\n      {\n          for (unsigned int i = 0; i < vValue.size(); ++i)\n          {\n              setCoinsRet.insert(vValue[i].second);\n              nValueRet += vValue[i].first;\n          }\n          return true;\n      }\n  \n      if (nTotalLower < nTargetValue)\n      {\n          if (coinLowestLarger.second.first == NULL)\n              return false;\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n          return true;\n      }\n  \n      // Solve subset sum by stochastic approximation\n      sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n      vector<char> vfBest;\n      int64_t nBest;\n  \n      ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n      if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n          ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n  \n      // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n      //                                   or the next bigger coin is closer), return the bigger coin\n      if (coinLowestLarger.second.first &&\n          ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n      {\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n      }\n      else {\n          for (unsigned int i = 0; i < vValue.size(); i++)\n              if (vfBest[i])\n              {\n                  setCoinsRet.insert(vValue[i].second);\n                  nValueRet += vValue[i].first;\n              }\n  \n          if (fDebug && GetBoolArg(\"-printpriority\"))\n          {\n              //// debug print\n              printf(\"SelectCoins() best subset: \");\n              for (unsigned int i = 0; i < vValue.size(); i++)\n                  if (vfBest[i])\n                      printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n              printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoins(vCoins, true, coinControl);\n  \n      // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n      if (coinControl && coinControl->HasSelected())\n      {\n          BOOST_FOREACH(const COutput& out, vCoins)\n          {\n              nValueRet += out.tx->vout[out.i].nValue;\n              setCoinsRet.insert(make_pair(out.tx, out.i));\n          }\n          return (nValueRet >= nTargetValue);\n      }\n  \n      return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n  }\n  \n  // Select some coins without random shuffle or best subset approximation\n  bool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoinsMinConf(vCoins, nMinConf);\n  \n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n          int i = output.i;\n  \n          // Stop if we've chosen enough inputs\n          if (nValueRet >= nTargetValue)\n              break;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n >= nTargetValue)\n          {\n              // If input value is greater or equal to target then simply insert\n              //    it into the current subset and exit\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              break;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      int64_t nValue = 0;\n      BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n      {\n          if (nValue < 0)\n              return false;\n          nValue += s.second;\n      }\n      if (vecSend.empty() || nValue < 0)\n          return false;\n  \n      wtxNew.BindWallet(this);\n  \n      {\n          LOCK2(cs_main, cs_wallet);\n          // txdb must be opened before the mapWallet lock\n          CTxDB txdb(\"r\");\n          {\n              nFeeRet = nTransactionFee;\n              while (true)\n              {\n                  wtxNew.vin.clear();\n                  wtxNew.vout.clear();\n                  wtxNew.fFromMe = true;\n  \n                  int64_t nTotalValue = nValue + nFeeRet;\n                  double dPriority = 0;\n                  // vouts to the payees\n                  BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                      wtxNew.vout.push_back(CTxOut(s.second, s.first));\n  \n                  // Choose coins to use\n                  set<pair<const CWalletTx*,unsigned int> > setCoins;\n                  int64_t nValueIn = 0;\n                  if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                      return false;\n                  BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                  {\n                      int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                      dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                  }\n  \n                  int64_t nChange = nValueIn - nValue - nFeeRet;\n                  // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                  // or until nChange becomes zero\n                  // NOTE: this depends on the exact behaviour of GetMinFee\n                  if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                  {\n                      int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                      nChange -= nMoveToFee;\n                      nFeeRet += nMoveToFee;\n                  }\n  \n                  if (nChange > 0)\n                  {\n                      // Fill a vout to ourself\n                      // TODO: pass in scriptChange instead of reservekey so\n                      // change transaction isn't always pay-to-bitcoin-address\n                      CScript scriptChange;\n  \n                      // coin control: send change to custom address\n                      if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                          scriptChange.SetDestination(coinControl->destChange);\n  \n                      // no coin control: send change to newly generated address\n                      else\n                      {\n                          // Note: We use a new key here to keep it from being obvious which side is the change.\n                          //  The drawback is that by not reusing a previous key, the change may be lost if a\n                          //  backup is restored, if the backup doesn't have the new private key for the change.\n                          //  If we reused the old key, it would be possible to add code to look for and\n                          //  rediscover unknown transactions that were written with keys of ours to recover\n                          //  post-backup change.\n  \n                          // Reserve a new key pair from key pool\n                          CPubKey vchPubKey = reservekey.GetReservedKey();\n  \n                          scriptChange.SetDestination(vchPubKey.GetID());\n                      }\n  \n                      // Insert change txn at random position:\n                      vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                      wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                  }\n                  else\n                      reservekey.ReturnKey();\n  \n                  // Fill vin\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n  \n                  // Sign\n                  int nIn = 0;\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                          return false;\n  \n                  // Limit size\n                  unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                  if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                      return false;\n                  dPriority /= nBytes;\n  \n                  // Check that enough fee is included\n                  int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                  int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n  \n                  if (nFeeRet < max(nPayFee, nMinFee))\n                  {\n                      nFeeRet = max(nPayFee, nMinFee);\n                      continue;\n                  }\n  \n                  // Fill vtxPrev by copying from previous transactions vtxPrev\n                  wtxNew.AddSupportingTransactions(txdb);\n                  wtxNew.fTimeReceivedIsTxTime = true;\n  \n                  break;\n              }\n          }\n      }\n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      vector< pair<CScript, int64_t> > vecSend;\n      vecSend.push_back(make_pair(scriptPubKey, nValue));\n      return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n  }\n  \n  // NovaCoin: get current stake weight\n  bool CWallet::GetStakeWeight(const CKeyStore& keystore,\n    uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n          CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n  \n          // Weight is greater than zero\n          if (nTimeWeight > 0)\n          {\n              nWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Weight is greater than zero, but the maximum value isn't reached yet\n          if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n          {\n              nMinWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Maximum weight was reached\n          if (nTimeWeight == nStakeMaxAge)\n          {\n              nMaxWeight += bnCoinDayWeight.getuint64();\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n    int64_t nFees, CTransaction& txNew, CKey& key) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      /* Don't split inputs above this age */\n      const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n      /* Time limit for searching a single input */\n      const uint nMaxStakeSearchInterval = 60;\n  \n      CBlockIndex* pindexPrev = pindexBest;\n  \n      CBigNum bnTargetPerCoinDay;\n      bnTargetPerCoinDay.SetCompact(nBits);\n  \n      txNew.vin.clear();\n      txNew.vout.clear();\n  \n      // Mark coin stake transaction\n      CScript scriptEmpty;\n      scriptEmpty.clear();\n      txNew.vout.push_back(CTxOut(0, scriptEmpty));\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      // Select coins with suitable depth\n      if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      int64_t nCredit = 0;\n      CScript scriptPubKeyKernel;\n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          // Read block header\n          CBlock block;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                  continue;\n          }\n  \n          if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n              continue; // only count coins meeting min age requirement\n  \n          bool fKernelFound = false;\n          for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n          {\n              // Search backward in time from the given txNew timestamp \n              // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n              uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n              COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n              if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n              {\n                  // Found a kernel\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : kernel found\\n\");\n                  vector<valtype> vSolutions;\n                  txnouttype whichType;\n                  CScript scriptPubKeyOut;\n                  scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                  if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                      break;\n                  }\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                  if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                      break;  // only support pay to public key and pay to address\n                  }\n                  if (whichType == TX_PUBKEYHASH) // pay to address type\n                  {\n                      // convert to pay to public key type\n                      if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n                      scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                  }\n                  if (whichType == TX_PUBKEY)\n                  {\n                      valtype& vchPubKey = vSolutions[0];\n                      if (!keystore.GetKey(Hash160(vchPubKey), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n  \n                  if (key.GetPubKey() != vchPubKey)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                          break; // keys mismatch\n                      }\n  \n                      scriptPubKeyOut = scriptPubKeyKernel;\n                  }\n  \n                  txNew.nTime -= n;\n                  txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                  nCredit += pcoin.first->vout[pcoin.second].nValue;\n                  vwtxPrev.push_back(pcoin.first);\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  /* Split large inputs into two near halves;\n                   * exact amounts to be defined after reward processing */\n                  if((nCredit >= nSplitThreshold) &&\n                    (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                    txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                  fKernelFound = true;\n                  break;\n              }\n          }\n  \n          if (fKernelFound || fShutdown)\n              break; // if kernel is found stop searching\n      }\n  \n      /* At this point, stake amount must be positive and within the stake limit if defined */\n      if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n        return(false);\n  \n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n  \n          /* Make a larger stake by inserting additional inputs\n           * of the same public key (address) as the generating input */\n          if((txNew.vout.size() == 2) &&\n            (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n            (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n            (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n              int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n  \n              /* Do not add too many inputs */\n              if(txNew.vin.size() >= 10)\n                break;\n              /* Do not add any inputs if reached or exceeded the threshold already */\n              if(nCredit >= nCombineThreshold)\n                break;\n              /* Do not add a new input exceeding the stake limit if defined */\n              if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n                break;\n              /* Do not add any large inputs capable of stake generation on their own */\n              if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n                continue;\n              /* Do not add any inputs under the min. age */\n              if(nTimeWeight < nStakeMinAge)\n                continue;\n  \n              txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n              nCredit += pcoin.first->vout[pcoin.second].nValue;\n              vwtxPrev.push_back(pcoin.first);\n          }\n  \n      }\n  \n      // Calculate coin age reward\n      {\n          uint64_t nCoinAge;\n          CTxDB txdb(\"r\");\n          if (!txNew.GetCoinAge(txdb, nCoinAge))\n              return error(\"CreateCoinStake : failed to calculate coin age\");\n  \n          int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n          if (nReward <= 0)\n              return false;\n  \n          nCredit += nReward;\n      }\n  \n      // Set output amount\n      if (txNew.vout.size() == 3)\n      {\n          txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n          txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n      }\n      else\n          txNew.vout[1].nValue = nCredit;\n  \n      // Sign\n      int nIn = 0;\n      BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n      {\n          if (!SignSignature(*this, *pcoin, txNew, nIn++))\n              return error(\"CreateCoinStake : failed to sign coinstake\");\n      }\n  \n      // Limit size\n      unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n      if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n          return error(\"CreateCoinStake : exceeded coinstake size limit\");\n  \n      // Successfully generated coinstake\n      return true;\n  }\n  \n  \n  // Call after CreateTransaction unless you want to abort\n  bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n          {\n              // This is only to keep the database open to defeat the auto-flush for the\n              // duration of this scope.  This is the only place where this optimization\n              // maybe makes sense; please don't do it anywhere else.\n              CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n  \n              // Take key pair from key pool so it won't be used again\n              reservekey.KeepKey();\n  \n              // Add tx to wallet, because if it has change it's also ours,\n              // otherwise just for transaction history.\n              AddToWallet(wtxNew);\n  \n              // Mark old coins as spent\n              set<CWalletTx*> setCoins;\n              BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n              {\n                  CWalletTx &coin = mapWallet[txin.prevout.hash];\n                  coin.BindWallet(this);\n                  coin.MarkSpent(txin.prevout.n);\n                  coin.WriteToDisk();\n                  NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n              }\n  \n              if (fFileBacked)\n                  delete pwalletdb;\n          }\n  \n          // Track how many getdata requests our transaction gets\n          mapRequestCount[wtxNew.GetHash()] = 0;\n  \n          // Broadcast\n          if (!wtxNew.AcceptToMemoryPool())\n          {\n              // This must not fail. The transaction has already been signed and recorded.\n              printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n              return false;\n          }\n          wtxNew.RelayWalletTransaction();\n      }\n      return true;\n  }\n  \n  \n  \n  \n  string CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      CReserveKey reservekey(this);\n      int64_t nFeeRequired;\n  \n      if (IsLocked())\n      {\n          string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (fWalletUnlockStakingOnly)\n      {\n          string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n      {\n          string strError;\n          if (nValue + nFeeRequired > GetBalance())\n              strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n          else\n              strError = _(\"Error: Transaction creation failed  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n  \n      if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n          return \"ABORTED\";\n  \n      if (!CommitTransaction(wtxNew, reservekey))\n          return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n  \n      return \"\";\n  }\n  \n  \n  \n  string CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      // Check amount\n      if (nValue <= 0)\n          return _(\"Invalid amount\");\n      if (nValue + nTransactionFee > GetBalance())\n          return _(\"Insufficient funds\");\n  \n      // Parse Bitcoin address\n      CScript scriptPubKey;\n      scriptPubKey.SetDestination(address);\n  \n      return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n  }\n  \n  \n  \n  \n  DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n  {\n      if (!fFileBacked)\n          return DB_LOAD_OK;\n      fFirstRunRet = false;\n      DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n      if (nLoadWalletRet == DB_NEED_REWRITE)\n      {\n          if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n          {\n              setKeyPool.clear();\n              // Note: can't top-up keypool here, because wallet is locked.\n              // User will be prompted to unlock wallet the next operation\n              // the requires a new key.\n          }\n      }\n  \n      if (nLoadWalletRet != DB_LOAD_OK)\n          return nLoadWalletRet;\n      fFirstRunRet = !vchDefaultKey.IsValid();\n  \n      NewThread(ThreadFlushWalletDB, &strWalletFile);\n      return DB_LOAD_OK;\n  }\n  \n  \n  bool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n  {\n      std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n      mapAddressBook[address] = strName;\n      NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n  }\n  \n  bool CWallet::DelAddressBookName(const CTxDestination& address)\n  {\n      mapAddressBook.erase(address);\n      NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n  }\n  \n  \n  void CWallet::PrintWallet(const CBlock& block)\n  {\n      {\n          LOCK(cs_wallet);\n          if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n              printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n          }\n          if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n              printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n           }\n  \n      }\n      printf(\"\\n\");\n  }\n  \n  bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n          {\n              wtx = (*mi).second;\n              return true;\n          }\n      }\n      return false;\n  }\n  \n  bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n  {\n      if (fFileBacked)\n      {\n          if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n              return false;\n      }\n      vchDefaultKey = vchPubKey;\n      return true;\n  }\n  \n  bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n  {\n      if (!pwallet->fFileBacked)\n          return false;\n      strWalletFileOut = pwallet->strWalletFile;\n      return true;\n  }\n  \n  //\n  // Mark old keypool keys as used,\n  // and generate all new keys\n  //\n  bool CWallet::NewKeyPool()\n  {\n      {\n          LOCK(cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n          BOOST_FOREACH(int64_t nIndex, setKeyPool)\n              walletdb.ErasePool(nIndex);\n          setKeyPool.clear();\n  \n          if (IsLocked())\n              return false;\n  \n          int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n          for (int i = 0; i < nKeys; i++)\n          {\n              int64_t nIndex = i+1;\n              walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n              setKeyPool.insert(nIndex);\n          }\n          printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n      }\n      return true;\n  }\n  \n  bool CWallet::TopUpKeyPool(unsigned int nSize)\n  {\n      {\n          LOCK(cs_wallet);\n  \n          if (IsLocked())\n              return false;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          // Top up key pool\n          unsigned int nTargetSize;\n          if (nSize > 0)\n              nTargetSize = nSize;\n          else\n              nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n  \n          while (setKeyPool.size() < (nTargetSize + 1))\n          {\n              int64_t nEnd = 1;\n              if (!setKeyPool.empty())\n                  nEnd = *(--setKeyPool.end()) + 1;\n              if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                  throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n              setKeyPool.insert(nEnd);\n              printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n          }\n      }\n      return true;\n  }\n  \n  void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n  {\n      nIndex = -1;\n      keypool.vchPubKey = CPubKey();\n      {\n          LOCK(cs_wallet);\n  \n          if (!IsLocked())\n              TopUpKeyPool();\n  \n          // Get the oldest key\n          if(setKeyPool.empty())\n              return;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          nIndex = *(setKeyPool.begin());\n          setKeyPool.erase(setKeyPool.begin());\n          if (!walletdb.ReadPool(nIndex, keypool))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n          if (!HaveKey(keypool.vchPubKey.GetID()))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n          assert(keypool.vchPubKey.IsValid());\n          if (fDebug && GetBoolArg(\"-printkeypool\"))\n              printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n      }\n  }\n  \n  int64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n  \n          int64_t nIndex = 1 + *(--setKeyPool.end());\n          if (!walletdb.WritePool(nIndex, keypool))\n              throw runtime_error(\"AddReserveKey() : writing added key failed\");\n          setKeyPool.insert(nIndex);\n          return nIndex;\n      }\n      return -1;\n  }\n  \n  void CWallet::KeepKey(int64_t nIndex)\n  {\n      // Remove from key pool\n      if (fFileBacked)\n      {\n          CWalletDB walletdb(strWalletFile);\n          walletdb.ErasePool(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n  }\n  \n  void CWallet::ReturnKey(int64_t nIndex)\n  {\n      // Return to key pool\n      {\n          LOCK(cs_wallet);\n          setKeyPool.insert(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n  }\n  \n  bool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      {\n          LOCK(cs_wallet);\n          ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex == -1)\n          {\n              if (fAllowReuse && vchDefaultKey.IsValid())\n              {\n                  result = vchDefaultKey;\n                  return true;\n              }\n              if (IsLocked()) return false;\n              result = GenerateNewKey();\n              return true;\n          }\n          KeepKey(nIndex);\n          result = keypool.vchPubKey;\n      }\n      return true;\n  }\n  \n  int64_t CWallet::GetOldestKeyPoolTime()\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      ReserveKeyFromKeyPool(nIndex, keypool);\n      if (nIndex == -1)\n          return GetTime();\n      ReturnKey(nIndex);\n      return keypool.nTime;\n  }\n  \n  std::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n  {\n      map<CTxDestination, int64_t> balances;\n  \n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n          {\n              CWalletTx *pcoin = &walletEntry.second;\n  \n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  continue;\n  \n              if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              {\n                  CTxDestination addr;\n                  if (!IsMine(pcoin->vout[i]))\n                      continue;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                      continue;\n  \n                  int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n  \n                  if (!balances.count(addr))\n                      balances[addr] = 0;\n                  balances[addr] += n;\n              }\n          }\n      }\n  \n      return balances;\n  }\n  \n  set< set<CTxDestination> > CWallet::GetAddressGroupings()\n  {\n      set< set<CTxDestination> > groupings;\n      set<CTxDestination> grouping;\n  \n      BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n      {\n          CWalletTx *pcoin = &walletEntry.second;\n  \n          if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n          {\n              // group all input addresses with each other\n              BOOST_FOREACH(CTxIn txin, pcoin->vin)\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n              }\n  \n              // group change with input addresses\n              BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                  if (IsChange(txout))\n                  {\n                      CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                      CTxDestination txoutAddr;\n                      if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                          continue;\n                      grouping.insert(txoutAddr);\n                  }\n              groupings.insert(grouping);\n              grouping.clear();\n          }\n  \n          // group lone addrs by themselves\n          for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              if (IsMine(pcoin->vout[i]))\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n                  groupings.insert(grouping);\n                  grouping.clear();\n              }\n      }\n  \n      set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n      map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n      BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n      {\n          // make a set of all the groups hit by this new group\n          set< set<CTxDestination>* > hits;\n          map< CTxDestination, set<CTxDestination>* >::iterator it;\n          BOOST_FOREACH(CTxDestination address, grouping)\n              if ((it = setmap.find(address)) != setmap.end())\n                  hits.insert((*it).second);\n  \n          // merge all hit groups into a new single group and delete old groups\n          set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n          BOOST_FOREACH(set<CTxDestination>* hit, hits)\n          {\n              merged->insert(hit->begin(), hit->end());\n              uniqueGroupings.erase(hit);\n              delete hit;\n          }\n          uniqueGroupings.insert(merged);\n  \n          // update setmap\n          BOOST_FOREACH(CTxDestination element, *merged)\n              setmap[element] = merged;\n      }\n  \n      set< set<CTxDestination> > ret;\n      BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n      {\n          ret.insert(*uniqueGrouping);\n          delete uniqueGrouping;\n      }\n  \n      return ret;\n  }\n  \n  \n  /* Checks for wallet vs. transaction index consistency;\n   * reports any spent state inconsistency found and\n   * (optionally) fixes the wallet according to the transaction index */\n  void CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n    bool fCheckOnly) {\n      nMismatchFound = 0;\n      nOrphansFound = 0;\n      nBalanceInQuestion = 0;\n  \n      LOCK(cs_wallet);\n      vector<CWalletTx*> vCoins;\n      vCoins.reserve(mapWallet.size());\n      for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          vCoins.push_back(&(*it).second);\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n          uint256 hash = pcoin->GetHash();\n          CTxIndex txindex;\n          uint n;\n  \n          if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n              continue;\n  \n          for(n = 0; n < pcoin->vout.size(); n++) {\n              bool fUpdated = false;\n  \n              if(IsMine(pcoin->vout[n])) {\n                  if(pcoin->IsSpent(n) &&\n                    ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkUnspent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  } else if(!pcoin->IsSpent(n) &&\n                    (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkSpent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  }\n  \n              }\n  \n              if(fUpdated)\n                NotifyTransactionChanged(this, hash, CT_UPDATED);\n          }\n  \n          if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n             nOrphansFound++;\n             if(!fCheckOnly) {\n                 EraseFromWallet(hash);\n                 NotifyTransactionChanged(this, hash, CT_DELETED);\n             }\n             printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n               fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n          }\n      }\n  }\n  \n  \n  // ppcoin: disable transaction (only for coinstake)\n  void CWallet::DisableTransaction(const CTransaction &tx)\n  {\n      if (!tx.IsCoinStake() || !IsFromMe(tx))\n          return; // only disconnecting coinstake requires marking input unspent\n  \n      LOCK(cs_wallet);\n      BOOST_FOREACH(const CTxIn& txin, tx.vin)\n      {\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n              {\n                  prev.MarkUnspent(txin.prevout.n);\n                  prev.WriteToDisk();\n              }\n          }\n      }\n  }\n  \n  CPubKey CReserveKey::GetReservedKey()\n  {\n      if (nIndex == -1)\n      {\n          CKeyPool keypool;\n          pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex != -1)\n              vchPubKey = keypool.vchPubKey;\n          else\n          {\n              printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n              vchPubKey = pwallet->vchDefaultKey;\n          }\n      }\n      assert(vchPubKey.IsValid());\n      return vchPubKey;\n  }\n  \n  void CReserveKey::KeepKey()\n  {\n      if (nIndex != -1)\n          pwallet->KeepKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CReserveKey::ReturnKey()\n  {\n      if (nIndex != -1)\n          pwallet->ReturnKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n  {\n      setAddress.clear();\n  \n      CWalletDB walletdb(strWalletFile);\n  \n      LOCK2(cs_main, cs_wallet);\n      BOOST_FOREACH(const int64_t& id, setKeyPool)\n      {\n          CKeyPool keypool;\n          if (!walletdb.ReadPool(id, keypool))\n              throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n          assert(keypool.vchPubKey.IsValid());\n          CKeyID keyID = keypool.vchPubKey.GetID();\n          if (!HaveKey(keyID))\n              throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n          setAddress.insert(keyID);\n      }\n  }\n  \n  void CWallet::UpdatedTransaction(const uint256 &hashTx)\n  {\n      {\n          LOCK(cs_wallet);\n          // Only notify UI if this transaction is in this wallet\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n              NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n      }\n  }\n  \n  void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n      mapKeyBirth.clear();\n  \n      // get birth times for keys with metadata\n      for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n          if (it->second.nCreateTime)\n              mapKeyBirth[it->first] = it->second.nCreateTime;\n  \n      // map in which we'll infer heights of other keys\n      CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n      std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n      std::set<CKeyID> setKeys;\n      GetKeys(setKeys);\n      BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n          if (mapKeyBirth.count(keyid) == 0)\n              mapKeyFirstBlock[keyid] = pindexMax;\n      }\n      setKeys.clear();\n  \n      // if there are no such keys, we're done\n      if (mapKeyFirstBlock.empty())\n          return;\n  \n      // find first block that affects those keys, if there are any left\n      std::vector<CKeyID> vAffected;\n      for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n          // iterate over all wallet transactions...\n          const CWalletTx &wtx = (*it).second;\n          std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n          if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n              // ... which are already in a block\n              int nHeight = blit->second->nHeight;\n              BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                  // iterate over all their outputs\n                  ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                  BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                      // ... and all their affected keys\n                      std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                      if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                          rit->second = blit->second;\n                  }\n                  vAffected.clear();\n              }\n          }\n      }\n  \n      // Extract block timestamps for those keys\n      for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n          mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->ScanForWalletTransactions",
          "args": [
            "pindexGenesisBlock",
            "true"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "ScanForWalletTransactions",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "838-865",
          "snippet": "int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n{\n    int ret = 0;\n\n    CBlockIndex* pindex = pindexStart;\n    {\n        LOCK(cs_wallet);\n        while (pindex)\n        {\n            // no need to read and scan block, if block was created before\n            // our wallet birthday (as adjusted for block time variability)\n            if (nTimeFirstKey && (pindex->nTime < (nTimeFirstKey - 7200))) {\n                pindex = pindex->pnext;\n                continue;\n            }\n\n            CBlock block;\n            block.ReadFromDisk(pindex, true);\n            BOOST_FOREACH(CTransaction& tx, block.vtx)\n            {\n                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                    ret++;\n            }\n            pindex = pindex->pnext;\n        }\n    }\n    return ret;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n  {\n      int ret = 0;\n  \n      CBlockIndex* pindex = pindexStart;\n      {\n          LOCK(cs_wallet);\n          while (pindex)\n          {\n              // no need to read and scan block, if block was created before\n              // our wallet birthday (as adjusted for block time variability)\n              if (nTimeFirstKey && (pindex->nTime < (nTimeFirstKey - 7200))) {\n                  pindex = pindex->pnext;\n                  continue;\n              }\n  \n              CBlock block;\n              block.ReadFromDisk(pindex, true);\n              BOOST_FOREACH(CTransaction& tx, block.vtx)\n              {\n                  if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                      ret++;\n              }\n              pindex = pindex->pnext;\n          }\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_WALLET_ERROR",
            "\"Error adding key to wallet\""
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->AddKey",
          "args": [
            "key"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "AddKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "120-140",
          "snippet": "bool CCryptoKeyStore::AddKey(const CKey& key)\n{\n    {\n        LOCK(cs_KeyStore);\n        if (!IsCrypted())\n            return CBasicKeyStore::AddKey(key);\n\n        if (IsLocked())\n            return false;\n\n        std::vector<unsigned char> vchCryptedSecret;\n        CPubKey vchPubKey = key.GetPubKey();\n        bool fCompressed;\n        if (!EncryptSecret(vMasterKey, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n            return false;\n\n        if (!AddCryptedKey(key.GetPubKey(), vchCryptedSecret))\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::AddKey(const CKey& key)\n  {\n      {\n          LOCK(cs_KeyStore);\n          if (!IsCrypted())\n              return CBasicKeyStore::AddKey(key);\n  \n          if (IsLocked())\n              return false;\n  \n          std::vector<unsigned char> vchCryptedSecret;\n          CPubKey vchPubKey = key.GetPubKey();\n          bool fCompressed;\n          if (!EncryptSecret(vMasterKey, key.GetSecret(fCompressed), vchPubKey.GetHash(), vchCryptedSecret))\n              return false;\n  \n          if (!AddCryptedKey(key.GetPubKey(), vchCryptedSecret))\n              return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->SetAddressBookName",
          "args": [
            "vchAddress",
            "strLabel"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->MarkDirty",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "MarkDirty",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "527-533",
          "snippet": "void MarkDirty()\n    {\n        fCreditCached = false;\n        fAvailableCreditCached = false;\n        fDebitCached = false;\n        fChangeCached = false;\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void MarkDirty()\n      {\n          fCreditCached = false;\n          fAvailableCreditCached = false;\n          fDebitCached = false;\n          fChangeCached = false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK2",
          "args": [
            "cs_main",
            "pwalletMain->cs_wallet"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetSecret",
          "args": [
            "secret",
            "fCompressed"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "SetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "209-230",
          "snippet": "bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n{\n    EC_KEY_free(pkey);\n    pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n    if (pkey == NULL)\n        throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n    if (vchSecret.size() != 32)\n        throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n    BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n    if (bn == NULL)\n        throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n    if (!EC_KEY_regenerate_key(pkey,bn))\n    {\n        BN_clear_free(bn);\n        throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n    }\n    BN_clear_free(bn);\n    fSet = true;\n    if (fCompressed || fCompressedPubKey)\n        SetCompressedPubKey();\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetSecret(const CSecret& vchSecret, bool fCompressed)\n  {\n      EC_KEY_free(pkey);\n      pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n      if (pkey == NULL)\n          throw key_error(\"CKey::SetSecret() : EC_KEY_new_by_curve_name failed\");\n      if (vchSecret.size() != 32)\n          throw key_error(\"CKey::SetSecret() : secret must be 32 bytes\");\n      BIGNUM *bn = BN_bin2bn(&vchSecret[0],32,BN_new());\n      if (bn == NULL)\n          throw key_error(\"CKey::SetSecret() : BN_bin2bn failed\");\n      if (!EC_KEY_regenerate_key(pkey,bn))\n      {\n          BN_clear_free(bn);\n          throw key_error(\"CKey::SetSecret() : EC_KEY_regenerate_key failed\");\n      }\n      BN_clear_free(bn);\n      fSet = true;\n      if (fCompressed || fCompressedPubKey)\n          SetCompressedPubKey();\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSecret.GetSecret",
          "args": [
            "fCompressed"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "GetSecret",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "232-245",
          "snippet": "CSecret CKey::GetSecret(bool &fCompressed) const\n{\n    CSecret vchRet;\n    vchRet.resize(32);\n    const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n    int nBytes = BN_num_bytes(bn);\n    if (bn == NULL)\n        throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n    int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n    if (n != nBytes)\n        throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n    fCompressed = fCompressedPubKey;\n    return vchRet;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CSecret CKey::GetSecret(bool &fCompressed) const\n  {\n      CSecret vchRet;\n      vchRet.resize(32);\n      const BIGNUM *bn = EC_KEY_get0_private_key(pkey);\n      int nBytes = BN_num_bytes(bn);\n      if (bn == NULL)\n          throw key_error(\"CKey::GetSecret() : EC_KEY_get0_private_key failed\");\n      int n=BN_bn2bin(bn,&vchRet[32 - nBytes]);\n      if (n != nBytes)\n          throw key_error(\"CKey::GetSecret(): BN_bn2bin failed\");\n      fCompressed = fCompressedPubKey;\n      return vchRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[2].get_bool",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "get_bool",
          "container": "Value_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "377-382",
          "snippet": "bool Value_impl< Config >::get_bool() const\n    {\n        check_type(  bool_type );\n\n        return boost::get< bool >( v_ );\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nValue_impl< Config > {\n  bool Value_impl< Config >::get_bool() const\n      {\n          check_type(  bool_type );\n  \n          return boost::get< bool >( v_ );\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSecret.SetString",
          "args": [
            "strSecret"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "SetString",
          "container": "CBitcoinSecret",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "445-448",
          "snippet": "bool SetString(const std::string& strSecret)\n    {\n        return SetString(strSecret.c_str());\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinSecret {\n  bool SetString(const std::string& strSecret)\n      {\n          return SetString(strSecret.c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[1].get_str",
          "args": [],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "msg"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nValue importprivkey(const Array& params, bool fHelp) {\n\n    if(fHelp || (params.size() < 1) || (params.size() > 3)) {\n        string msg = \"importprivkey <key> [label] [rescan]\\n\"\n          \"Adds a private <key> to your wallet in the format of RPC dumpprivkey.\\n\"\n          \"Block chain re-scanning is on (true) by default.\\n\";\n        throw(runtime_error(msg));\n    }\n\n    string strSecret = params[0].get_str();\n    string strLabel = \"\";\n    if (params.size() > 1)\n        strLabel = params[1].get_str();\n    CBitcoinSecret vchSecret;\n    bool fGood = vchSecret.SetString(strSecret);\n\n    bool fRescan = true;\n    if(params.size() > 2)\n      fRescan = params[2].get_bool();\n\n    if (!fGood) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n    if (fWalletUnlockStakingOnly)\n        throw JSONRPCError(RPC_WALLET_UNLOCK_NEEDED, \"Wallet is unlocked for staking only.\");\n\n    CKey key;\n    bool fCompressed;\n    CSecret secret = vchSecret.GetSecret(fCompressed);\n    key.SetSecret(secret, fCompressed);\n    CKeyID vchAddress = key.GetPubKey().GetID();\n    {\n        LOCK2(cs_main, pwalletMain->cs_wallet);\n\n        pwalletMain->MarkDirty();\n        pwalletMain->SetAddressBookName(vchAddress, strLabel);\n\n        if (!pwalletMain->AddKey(key))\n            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n\n        if(fRescan) {\n            pwalletMain->ScanForWalletTransactions(pindexGenesisBlock, true);\n            pwalletMain->ReacceptWalletTransactions();\n        }\n    }\n\n    return(Value::null);\n}"
  },
  {
    "function_name": "CTxDump",
    "container": "CTxDump",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "98-105",
    "snippet": "CTxDump(CWalletTx* ptx = NULL, int nOut = -1)\n    {\n        pindex = NULL;\n        nValue = 0;\n        fSpent = false;\n        this->ptx = ptx;\n        this->nOut = nOut;\n    }",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nCTxDump {\n  CTxDump(CWalletTx* ptx = NULL, int nOut = -1)\n      {\n          pindex = NULL;\n          nValue = 0;\n          fSpent = false;\n          this->ptx = ptx;\n          this->nOut = nOut;\n      }\n}"
  },
  {
    "function_name": "DecodeDumpString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "76-88",
    "snippet": "std::string DecodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    for (unsigned int pos = 0; pos < str.length(); pos++) {\n        unsigned char c = str[pos];\n        if (c == '%' && pos+2 < str.length()) {\n            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n                ((str[pos+2]>>6)*9+((str[pos+2]-'0')&15));\n            pos += 2;\n        }\n        ret << c;\n    }\n    return ret.str();\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret.str",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "789-792",
          "snippet": "std::string str() const\n    {\n        return (std::string(begin(), end()));\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  std::string str() const\n      {\n          return (std::string(begin(), end()));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "str.length",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "str.length",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::string DecodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    for (unsigned int pos = 0; pos < str.length(); pos++) {\n        unsigned char c = str[pos];\n        if (c == '%' && pos+2 < str.length()) {\n            c = (((str[pos+1]>>6)*9+((str[pos+1]-'0')&15)) << 4) | \n                ((str[pos+2]>>6)*9+((str[pos+2]-'0')&15));\n            pos += 2;\n        }\n        ret << c;\n    }\n    return ret.str();\n}"
  },
  {
    "function_name": "EncodeDumpString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "64-74",
    "snippet": "std::string static EncodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    BOOST_FOREACH(unsigned char c, str) {\n        if (c <= 32 || c >= 128 || c == '%') {\n            ret << '%' << HexStr(&c, &c + 1);\n        } else {\n            ret << c;\n        }\n    }\n    return ret.str();\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret.str",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "789-792",
          "snippet": "std::string str() const\n    {\n        return (std::string(begin(), end()));\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  std::string str() const\n      {\n          return (std::string(begin(), end()));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "&c",
            "&c + 1"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::string static EncodeDumpString(const std::string &str) {\n    std::stringstream ret;\n    BOOST_FOREACH(unsigned char c, str) {\n        if (c <= 32 || c >= 128 || c == '%') {\n            ret << '%' << HexStr(&c, &c + 1);\n        } else {\n            ret << c;\n        }\n    }\n    return ret.str();\n}"
  },
  {
    "function_name": "EncodeDumpTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "60-62",
    "snippet": "std::string static EncodeDumpTime(int64_t nTime) {\n    return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "\"%Y-%m-%dT%H:%M:%SZ\"",
            "nTime"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "376-383",
          "snippet": "inline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::string static EncodeDumpTime(int64_t nTime) {\n    return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n}"
  },
  {
    "function_name": "DecodeDumpTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "45-58",
    "snippet": "int64_t DecodeDumpTime(const std::string& s)\n{\n    bt::ptime pt;\n\n    for(size_t i=0; i<formats_n; ++i)\n    {\n        std::istringstream is(s);\n        is.imbue(formats[i]);\n        is >> pt;\n        if(pt != bt::ptime()) break;\n    }\n\n    return pt_to_time_t(pt);\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [
      "const std::locale formats[] = {\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y/%m/%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%d.%m.%Y %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d\"))\n};",
      "const size_t formats_n = sizeof(formats)/sizeof(formats[0]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pt_to_time_t",
          "args": [
            "pt"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "pt_to_time_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "38-43",
          "snippet": "std::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bt::ptime",
          "args": [],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is.imbue",
          "args": [
            "formats[i]"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nconst std::locale formats[] = {\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%dT%H:%M:%SZ\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y/%m/%d %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%d.%m.%Y %H:%M:%S\")),\n    std::locale(std::locale::classic(),new bt::time_input_facet(\"%Y-%m-%d\"))\n};\nconst size_t formats_n = sizeof(formats)/sizeof(formats[0]);\n\nint64_t DecodeDumpTime(const std::string& s)\n{\n    bt::ptime pt;\n\n    for(size_t i=0; i<formats_n; ++i)\n    {\n        std::istringstream is(s);\n        is.imbue(formats[i]);\n        is >> pt;\n        if(pt != bt::ptime()) break;\n    }\n\n    return pt_to_time_t(pt);\n}"
  },
  {
    "function_name": "pt_to_time_t",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
    "lines": "38-43",
    "snippet": "std::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}",
    "includes": [
      "#include <boost/algorithm/string.hpp>",
      "#include <boost/variant/get.hpp>",
      "#include <boost/date_time/posix_time/posix_time.hpp>",
      "#include \"base58.h\"",
      "#include \"ui_interface.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"init.h\" // for pwalletMain",
      "#include <fstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "diff.ticks",
          "args": [],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::gregorian::date",
          "args": [
            "1970",
            "1",
            "1"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}"
  }
]