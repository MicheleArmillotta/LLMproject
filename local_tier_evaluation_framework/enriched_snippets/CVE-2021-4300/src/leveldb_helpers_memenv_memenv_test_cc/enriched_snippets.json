[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "230-232",
    "snippet": "int main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leveldb::test::RunAllTests",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "RunAllTests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "36-58",
          "snippet": "int RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nint RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nint main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "185-226",
    "snippet": "TEST(MemEnvTest, DBTest) {\n  Options options;\n  options.create_if_missing = true;\n  options.env = env_;\n  DB* db;\n\n  const Slice keys[] = {Slice(\"aaa\"), Slice(\"bbb\"), Slice(\"ccc\")};\n  const Slice vals[] = {Slice(\"foo\"), Slice(\"bar\"), Slice(\"baz\")};\n\n  ASSERT_OK(DB::Open(options, \"/dir/db\", &db));\n  for (size_t i = 0; i < 3; ++i) {\n    ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]));\n  }\n\n  for (size_t i = 0; i < 3; ++i) {\n    std::string res;\n    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));\n    ASSERT_TRUE(res == vals[i]);\n  }\n\n  Iterator* iterator = db->NewIterator(ReadOptions());\n  iterator->SeekToFirst();\n  for (size_t i = 0; i < 3; ++i) {\n    ASSERT_TRUE(iterator->Valid());\n    ASSERT_TRUE(keys[i] == iterator->key());\n    ASSERT_TRUE(vals[i] == iterator->value());\n    iterator->Next();\n  }\n  ASSERT_TRUE(!iterator->Valid());\n  delete iterator;\n\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db);\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  for (size_t i = 0; i < 3; ++i) {\n    std::string res;\n    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));\n    ASSERT_TRUE(res == vals[i]);\n  }\n\n  delete db;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "res == vals[i]"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Get(ReadOptions(), keys[i], &res)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db->Get",
          "args": [
            "ReadOptions()",
            "keys[i]",
            "&res"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "CSignatureCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1211-1221",
          "snippet": "bool\n    Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n    {\n        LOCK(cs_sigcache);\n\n        sigdata_type k(hash, vchSig, pubKey);\n        std::set<sigdata_type>::iterator mi = setValid.find(k);\n        if (mi != setValid.end())\n            return true;\n        return false;\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCSignatureCache {\n  bool\n      Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n      {\n          LOCK(cs_sigcache);\n  \n          sigdata_type k(hash, vchSig, pubKey);\n          std::set<sigdata_type>::iterator mi = setValid.find(k);\n          if (mi != setValid.end())\n              return true;\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "dbi->TEST_CompactMemTable()"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!iterator->Valid()"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator->Valid",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "280-280",
          "snippet": "virtual bool Valid() const { return iter_->Valid(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual bool Valid() const { return iter_->Valid(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator->Next",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "vals[i] == iterator->value()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator->value",
          "args": [],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QValueComboBox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/qvaluecombobox.cpp",
          "lines": "9-12",
          "snippet": "QVariant QValueComboBox::value() const\n{\n    return itemData(currentIndex(), role);\n}",
          "includes": [
            "#include \"qvaluecombobox.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qvaluecombobox.h\"\n\nQValueComboBox {\n  QVariant QValueComboBox::value() const\n  {\n      return itemData(currentIndex(), role);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "keys[i] == iterator->key()"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator->key",
          "args": [],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "LRUHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "37-45",
          "snippet": "Slice key() const {\n    // For cheaper lookups, we allow a temporary Handle object\n    // to store a pointer to a key in \"value\".\n    if (next == this) {\n      return *(reinterpret_cast<Slice*>(value));\n    } else {\n      return Slice(key_data, key_length);\n    }\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUHandle {\n  Slice key() const {\n      // For cheaper lookups, we allow a temporary Handle object\n      // to store a pointer to a key in \"value\".\n      if (next == this) {\n        return *(reinterpret_cast<Slice*>(value));\n      } else {\n        return Slice(key_data, key_length);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "iterator->Valid()"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterator->SeekToFirst",
          "args": [],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "287-287",
          "snippet": "virtual void SeekToFirst() { iter_->SeekToFirst(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void SeekToFirst() { iter_->SeekToFirst(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db->NewIterator",
          "args": [
            "ReadOptions()"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "res == vals[i]"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Get(ReadOptions(), keys[i], &res)"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Put(WriteOptions(), keys[i], vals[i])"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db->Put",
          "args": [
            "WriteOptions()",
            "keys[i]",
            "vals[i]"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "DB::Open(options, \"/dir/db\", &db)"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DB::Open",
          "args": [
            "options",
            "\"/dir/db\"",
            "&db"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1445-1477",
          "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"baz\""
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nTEST(MemEnvTest, DBTest) {\n  Options options;\n  options.create_if_missing = true;\n  options.env = env_;\n  DB* db;\n\n  const Slice keys[] = {Slice(\"aaa\"), Slice(\"bbb\"), Slice(\"ccc\")};\n  const Slice vals[] = {Slice(\"foo\"), Slice(\"bar\"), Slice(\"baz\")};\n\n  ASSERT_OK(DB::Open(options, \"/dir/db\", &db));\n  for (size_t i = 0; i < 3; ++i) {\n    ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]));\n  }\n\n  for (size_t i = 0; i < 3; ++i) {\n    std::string res;\n    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));\n    ASSERT_TRUE(res == vals[i]);\n  }\n\n  Iterator* iterator = db->NewIterator(ReadOptions());\n  iterator->SeekToFirst();\n  for (size_t i = 0; i < 3; ++i) {\n    ASSERT_TRUE(iterator->Valid());\n    ASSERT_TRUE(keys[i] == iterator->key());\n    ASSERT_TRUE(vals[i] == iterator->value());\n    iterator->Next();\n  }\n  ASSERT_TRUE(!iterator->Valid());\n  delete iterator;\n\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db);\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  for (size_t i = 0; i < 3; ++i) {\n    std::string res;\n    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));\n    ASSERT_TRUE(res == vals[i]);\n  }\n\n  delete db;\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "152-183",
    "snippet": "TEST(MemEnvTest, LargeWrite) {\n  const size_t kWriteSize = 300 * 1024;\n  char* scratch = new char[kWriteSize * 2];\n\n  std::string write_data;\n  for (size_t i = 0; i < kWriteSize; ++i) {\n    write_data.append(1, static_cast<char>(i));\n  }\n\n  WritableFile* writable_file;\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  ASSERT_OK(writable_file->Append(\"foo\"));\n  ASSERT_OK(writable_file->Append(write_data));\n  delete writable_file;\n\n  SequentialFile* seq_file;\n  Slice result;\n  ASSERT_OK(env_->NewSequentialFile(\"/dir/f\", &seq_file));\n  ASSERT_OK(seq_file->Read(3, &result, scratch)); // Read \"foo\".\n  ASSERT_EQ(0, result.compare(\"foo\"));\n\n  size_t read = 0;\n  std::string read_data;\n  while (read < kWriteSize) {\n    ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch));\n    read_data.append(result.data(), result.size());\n    read += result.size();\n  }\n  ASSERT_TRUE(write_data == read_data);\n  delete seq_file;\n  delete [] scratch;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "write_data == read_data"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_data.append",
          "args": [
            "result.data()",
            "result.size()"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.data",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Read(kWriteSize - read, &result, scratch)"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_file->Read",
          "args": [
            "kWriteSize - read",
            "&result",
            "scratch"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "SequentialFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "158-164",
          "snippet": "virtual Status Read(size_t n, Slice* result, char* scratch) {\n    Status s = file_->Read(pos_, n, result, scratch);\n    if (s.ok()) {\n      pos_ += result->size();\n    }\n    return s;\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nSequentialFileImpl {\n  virtual Status Read(size_t n, Slice* result, char* scratch) {\n      Status s = file_->Read(pos_, n, result, scratch);\n      if (s.ok()) {\n        pos_ += result->size();\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.compare(\"foo\")"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.compare",
          "args": [
            "\"foo\""
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "compare",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "96-104",
          "snippet": "inline int Slice::compare(const Slice& b) const {\n  const int min_len = (size_ < b.size_) ? size_ : b.size_;\n  int r = memcmp(data_, b.data_, min_len);\n  if (r == 0) {\n    if (size_ < b.size_) r = -1;\n    else if (size_ > b.size_) r = +1;\n  }\n  return r;\n}",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  inline int Slice::compare(const Slice& b) const {\n    const int min_len = (size_ < b.size_) ? size_ : b.size_;\n    int r = memcmp(data_, b.data_, min_len);\n    if (r == 0) {\n      if (size_ < b.size_) r = -1;\n      else if (size_ > b.size_) r = +1;\n    }\n    return r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Read(3, &result, scratch)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewSequentialFile(\"/dir/f\", &seq_file)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewSequentialFile",
          "args": [
            "\"/dir/f\"",
            "&seq_file"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "240-250",
          "snippet": "virtual Status NewSequentialFile(const std::string& fname,\n                                   SequentialFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) == file_map_.end()) {\n      *result = NULL;\n      return Status::IOError(fname, \"File not found\");\n    }\n\n    *result = new SequentialFileImpl(file_map_[fname]);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewSequentialFile(const std::string& fname,\n                                     SequentialFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) == file_map_.end()) {\n        *result = NULL;\n        return Status::IOError(fname, \"File not found\");\n      }\n  \n      *result = new SequentialFileImpl(file_map_[fname]);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Append(write_data)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writable_file->Append",
          "args": [
            "write_data"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "Append",
          "container": "WritableFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "212-214",
          "snippet": "virtual Status Append(const Slice& data) {\n    return file_->Append(data);\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nWritableFileImpl {\n  virtual Status Append(const Slice& data) {\n      return file_->Append(data);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Append(\"foo\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewWritableFile(\"/dir/f\", &writable_file)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "\"/dir/f\"",
            "&writable_file"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "264-277",
          "snippet": "virtual Status NewWritableFile(const std::string& fname,\n                                 WritableFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) != file_map_.end()) {\n      DeleteFileInternal(fname);\n    }\n\n    FileState* file = new FileState();\n    file->Ref();\n    file_map_[fname] = file;\n\n    *result = new WritableFileImpl(file);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewWritableFile(const std::string& fname,\n                                   WritableFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) != file_map_.end()) {\n        DeleteFileInternal(fname);\n      }\n  \n      FileState* file = new FileState();\n      file->Ref();\n      file_map_[fname] = file;\n  \n      *result = new WritableFileImpl(file);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_data.append",
          "args": [
            "1",
            "static_cast<char>(i)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "i"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nTEST(MemEnvTest, LargeWrite) {\n  const size_t kWriteSize = 300 * 1024;\n  char* scratch = new char[kWriteSize * 2];\n\n  std::string write_data;\n  for (size_t i = 0; i < kWriteSize; ++i) {\n    write_data.append(1, static_cast<char>(i));\n  }\n\n  WritableFile* writable_file;\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  ASSERT_OK(writable_file->Append(\"foo\"));\n  ASSERT_OK(writable_file->Append(write_data));\n  delete writable_file;\n\n  SequentialFile* seq_file;\n  Slice result;\n  ASSERT_OK(env_->NewSequentialFile(\"/dir/f\", &seq_file));\n  ASSERT_OK(seq_file->Read(3, &result, scratch)); // Read \"foo\".\n  ASSERT_EQ(0, result.compare(\"foo\"));\n\n  size_t read = 0;\n  std::string read_data;\n  while (read < kWriteSize) {\n    ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch));\n    read_data.append(result.data(), result.size());\n    read += result.size();\n  }\n  ASSERT_TRUE(write_data == read_data);\n  delete seq_file;\n  delete [] scratch;\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "137-150",
    "snippet": "TEST(MemEnvTest, Misc) {\n  std::string test_dir;\n  ASSERT_OK(env_->GetTestDirectory(&test_dir));\n  ASSERT_TRUE(!test_dir.empty());\n\n  WritableFile* writable_file;\n  ASSERT_OK(env_->NewWritableFile(\"/a/b\", &writable_file));\n\n  // These are no-ops, but we test they return success.\n  ASSERT_OK(writable_file->Sync());\n  ASSERT_OK(writable_file->Flush());\n  ASSERT_OK(writable_file->Close());\n  delete writable_file;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Close()"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writable_file->Close",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "Close",
          "container": "WritableFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "216-216",
          "snippet": "virtual Status Close() { return Status::OK(); }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nWritableFileImpl {\n  virtual Status Close() { return Status::OK(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Flush()"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writable_file->Flush",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "Flush",
          "container": "WritableFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "217-217",
          "snippet": "virtual Status Flush() { return Status::OK(); }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nWritableFileImpl {\n  virtual Status Flush() { return Status::OK(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Sync()"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writable_file->Sync",
          "args": [],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "Sync",
          "container": "WritableFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "218-218",
          "snippet": "virtual Status Sync() { return Status::OK(); }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nWritableFileImpl {\n  virtual Status Sync() { return Status::OK(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewWritableFile(\"/a/b\", &writable_file)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "\"/a/b\"",
            "&writable_file"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "264-277",
          "snippet": "virtual Status NewWritableFile(const std::string& fname,\n                                 WritableFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) != file_map_.end()) {\n      DeleteFileInternal(fname);\n    }\n\n    FileState* file = new FileState();\n    file->Ref();\n    file_map_[fname] = file;\n\n    *result = new WritableFileImpl(file);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewWritableFile(const std::string& fname,\n                                   WritableFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) != file_map_.end()) {\n        DeleteFileInternal(fname);\n      }\n  \n      FileState* file = new FileState();\n      file->Ref();\n      file_map_[fname] = file;\n  \n      *result = new WritableFileImpl(file);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!test_dir.empty()"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_dir.empty",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->GetTestDirectory(&test_dir)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->GetTestDirectory",
          "args": [
            "&test_dir"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "GetTestDirectory",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "361-364",
          "snippet": "virtual Status GetTestDirectory(std::string* path) {\n    *path = \"/test\";\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status GetTestDirectory(std::string* path) {\n      *path = \"/test\";\n      return Status::OK();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nTEST(MemEnvTest, Misc) {\n  std::string test_dir;\n  ASSERT_OK(env_->GetTestDirectory(&test_dir));\n  ASSERT_TRUE(!test_dir.empty());\n\n  WritableFile* writable_file;\n  ASSERT_OK(env_->NewWritableFile(\"/a/b\", &writable_file));\n\n  // These are no-ops, but we test they return success.\n  ASSERT_OK(writable_file->Sync());\n  ASSERT_OK(writable_file->Flush());\n  ASSERT_OK(writable_file->Close());\n  delete writable_file;\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "129-135",
    "snippet": "TEST(MemEnvTest, Locks) {\n  FileLock* lock;\n\n  // These are no-ops, but we test they return success.\n  ASSERT_OK(env_->LockFile(\"some file\", &lock));\n  ASSERT_OK(env_->UnlockFile(lock));\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->UnlockFile(lock)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->UnlockFile",
          "args": [
            "lock"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "UnlockFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "356-359",
          "snippet": "virtual Status UnlockFile(FileLock* lock) {\n    delete lock;\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status UnlockFile(FileLock* lock) {\n      delete lock;\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->LockFile(\"some file\", &lock)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->LockFile",
          "args": [
            "\"some file\"",
            "&lock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "LockFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "351-354",
          "snippet": "virtual Status LockFile(const std::string& fname, FileLock** lock) {\n    *lock = new FileLock;\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status LockFile(const std::string& fname, FileLock** lock) {\n      *lock = new FileLock;\n      return Status::OK();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nTEST(MemEnvTest, Locks) {\n  FileLock* lock;\n\n  // These are no-ops, but we test they return success.\n  ASSERT_OK(env_->LockFile(\"some file\", &lock));\n  ASSERT_OK(env_->UnlockFile(lock));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "87-127",
    "snippet": "TEST(MemEnvTest, ReadWrite) {\n  WritableFile* writable_file;\n  SequentialFile* seq_file;\n  RandomAccessFile* rand_file;\n  Slice result;\n  char scratch[100];\n\n  ASSERT_OK(env_->CreateDir(\"/dir\"));\n\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  ASSERT_OK(writable_file->Append(\"hello \"));\n  ASSERT_OK(writable_file->Append(\"world\"));\n  delete writable_file;\n\n  // Read sequentially.\n  ASSERT_OK(env_->NewSequentialFile(\"/dir/f\", &seq_file));\n  ASSERT_OK(seq_file->Read(5, &result, scratch)); // Read \"hello\".\n  ASSERT_EQ(0, result.compare(\"hello\"));\n  ASSERT_OK(seq_file->Skip(1));\n  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Read \"world\".\n  ASSERT_EQ(0, result.compare(\"world\"));\n  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Try reading past EOF.\n  ASSERT_EQ(0, result.size());\n  ASSERT_OK(seq_file->Skip(100)); // Try to skip past end of file.\n  ASSERT_OK(seq_file->Read(1000, &result, scratch));\n  ASSERT_EQ(0, result.size());\n  delete seq_file;\n\n  // Random reads.\n  ASSERT_OK(env_->NewRandomAccessFile(\"/dir/f\", &rand_file));\n  ASSERT_OK(rand_file->Read(6, 5, &result, scratch)); // Read \"world\".\n  ASSERT_EQ(0, result.compare(\"world\"));\n  ASSERT_OK(rand_file->Read(0, 5, &result, scratch)); // Read \"hello\".\n  ASSERT_EQ(0, result.compare(\"hello\"));\n  ASSERT_OK(rand_file->Read(10, 100, &result, scratch)); // Read \"d\".\n  ASSERT_EQ(0, result.compare(\"d\"));\n\n  // Too high offset.\n  ASSERT_TRUE(!rand_file->Read(1000, 5, &result, scratch).ok());\n  delete rand_file;\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!rand_file->Read(1000, 5, &result, scratch).ok()"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand_file->Read",
          "args": [],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "AtomicCounter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "42-45",
          "snippet": "int Read() {\n    MutexLock l(&mu_);\n    return count_;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nAtomicCounter {\n  int Read() {\n      MutexLock l(&mu_);\n      return count_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rand_file->Read",
          "args": [
            "1000",
            "5",
            "&result",
            "scratch"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "RandomAccessFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "193-196",
          "snippet": "virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                      char* scratch) const {\n    return file_->Read(offset, n, result, scratch);\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nRandomAccessFileImpl {\n  virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                        char* scratch) const {\n      return file_->Read(offset, n, result, scratch);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.compare(\"d\")"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.compare",
          "args": [
            "\"d\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "compare",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "96-104",
          "snippet": "inline int Slice::compare(const Slice& b) const {\n  const int min_len = (size_ < b.size_) ? size_ : b.size_;\n  int r = memcmp(data_, b.data_, min_len);\n  if (r == 0) {\n    if (size_ < b.size_) r = -1;\n    else if (size_ > b.size_) r = +1;\n  }\n  return r;\n}",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  inline int Slice::compare(const Slice& b) const {\n    const int min_len = (size_ < b.size_) ? size_ : b.size_;\n    int r = memcmp(data_, b.data_, min_len);\n    if (r == 0) {\n      if (size_ < b.size_) r = -1;\n      else if (size_ > b.size_) r = +1;\n    }\n    return r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "rand_file->Read(10, 100, &result, scratch)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.compare(\"hello\")"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "rand_file->Read(0, 5, &result, scratch)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.compare(\"world\")"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "rand_file->Read(6, 5, &result, scratch)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewRandomAccessFile(\"/dir/f\", &rand_file)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewRandomAccessFile",
          "args": [
            "\"/dir/f\"",
            "&rand_file"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "NewRandomAccessFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "252-262",
          "snippet": "virtual Status NewRandomAccessFile(const std::string& fname,\n                                     RandomAccessFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) == file_map_.end()) {\n      *result = NULL;\n      return Status::IOError(fname, \"File not found\");\n    }\n\n    *result = new RandomAccessFileImpl(file_map_[fname]);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewRandomAccessFile(const std::string& fname,\n                                       RandomAccessFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) == file_map_.end()) {\n        *result = NULL;\n        return Status::IOError(fname, \"File not found\");\n      }\n  \n      *result = new RandomAccessFileImpl(file_map_[fname]);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.size()"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Read(1000, &result, scratch)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_file->Read",
          "args": [
            "1000",
            "&result",
            "scratch"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "SequentialFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "158-164",
          "snippet": "virtual Status Read(size_t n, Slice* result, char* scratch) {\n    Status s = file_->Read(pos_, n, result, scratch);\n    if (s.ok()) {\n      pos_ += result->size();\n    }\n    return s;\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nSequentialFileImpl {\n  virtual Status Read(size_t n, Slice* result, char* scratch) {\n      Status s = file_->Read(pos_, n, result, scratch);\n      if (s.ok()) {\n        pos_ += result->size();\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Skip(100)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_file->Skip",
          "args": [
            "100"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "Skip",
          "container": "SequentialFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "166-176",
          "snippet": "virtual Status Skip(uint64_t n) {\n    if (pos_ > file_->Size()) {\n      return Status::IOError(\"pos_ > file_->Size()\");\n    }\n    const size_t available = file_->Size() - pos_;\n    if (n > available) {\n      n = available;\n    }\n    pos_ += n;\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nSequentialFileImpl {\n  virtual Status Skip(uint64_t n) {\n      if (pos_ > file_->Size()) {\n        return Status::IOError(\"pos_ > file_->Size()\");\n      }\n      const size_t available = file_->Size() - pos_;\n      if (n > available) {\n        n = available;\n      }\n      pos_ += n;\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.size()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Read(1000, &result, scratch)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.compare(\"world\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Read(1000, &result, scratch)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Skip(1)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "result.compare(\"hello\")"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "seq_file->Read(5, &result, scratch)"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewSequentialFile(\"/dir/f\", &seq_file)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewSequentialFile",
          "args": [
            "\"/dir/f\"",
            "&seq_file"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "240-250",
          "snippet": "virtual Status NewSequentialFile(const std::string& fname,\n                                   SequentialFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) == file_map_.end()) {\n      *result = NULL;\n      return Status::IOError(fname, \"File not found\");\n    }\n\n    *result = new SequentialFileImpl(file_map_[fname]);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewSequentialFile(const std::string& fname,\n                                     SequentialFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) == file_map_.end()) {\n        *result = NULL;\n        return Status::IOError(fname, \"File not found\");\n      }\n  \n      *result = new SequentialFileImpl(file_map_[fname]);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Append(\"world\")"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writable_file->Append",
          "args": [
            "\"world\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "Append",
          "container": "WritableFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "212-214",
          "snippet": "virtual Status Append(const Slice& data) {\n    return file_->Append(data);\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nWritableFileImpl {\n  virtual Status Append(const Slice& data) {\n      return file_->Append(data);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Append(\"hello \")"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewWritableFile(\"/dir/f\", &writable_file)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "\"/dir/f\"",
            "&writable_file"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "264-277",
          "snippet": "virtual Status NewWritableFile(const std::string& fname,\n                                 WritableFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) != file_map_.end()) {\n      DeleteFileInternal(fname);\n    }\n\n    FileState* file = new FileState();\n    file->Ref();\n    file_map_[fname] = file;\n\n    *result = new WritableFileImpl(file);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewWritableFile(const std::string& fname,\n                                   WritableFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) != file_map_.end()) {\n        DeleteFileInternal(fname);\n      }\n  \n      FileState* file = new FileState();\n      file->Ref();\n      file_map_[fname] = file;\n  \n      *result = new WritableFileImpl(file);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->CreateDir(\"/dir\")"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->CreateDir",
          "args": [
            "\"/dir\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "CreateDir",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "320-322",
          "snippet": "virtual Status CreateDir(const std::string& dirname) {\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status CreateDir(const std::string& dirname) {\n      return Status::OK();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nTEST(MemEnvTest, ReadWrite) {\n  WritableFile* writable_file;\n  SequentialFile* seq_file;\n  RandomAccessFile* rand_file;\n  Slice result;\n  char scratch[100];\n\n  ASSERT_OK(env_->CreateDir(\"/dir\"));\n\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  ASSERT_OK(writable_file->Append(\"hello \"));\n  ASSERT_OK(writable_file->Append(\"world\"));\n  delete writable_file;\n\n  // Read sequentially.\n  ASSERT_OK(env_->NewSequentialFile(\"/dir/f\", &seq_file));\n  ASSERT_OK(seq_file->Read(5, &result, scratch)); // Read \"hello\".\n  ASSERT_EQ(0, result.compare(\"hello\"));\n  ASSERT_OK(seq_file->Skip(1));\n  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Read \"world\".\n  ASSERT_EQ(0, result.compare(\"world\"));\n  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Try reading past EOF.\n  ASSERT_EQ(0, result.size());\n  ASSERT_OK(seq_file->Skip(100)); // Try to skip past end of file.\n  ASSERT_OK(seq_file->Read(1000, &result, scratch));\n  ASSERT_EQ(0, result.size());\n  delete seq_file;\n\n  // Random reads.\n  ASSERT_OK(env_->NewRandomAccessFile(\"/dir/f\", &rand_file));\n  ASSERT_OK(rand_file->Read(6, 5, &result, scratch)); // Read \"world\".\n  ASSERT_EQ(0, result.compare(\"world\"));\n  ASSERT_OK(rand_file->Read(0, 5, &result, scratch)); // Read \"hello\".\n  ASSERT_EQ(0, result.compare(\"hello\"));\n  ASSERT_OK(rand_file->Read(10, 100, &result, scratch)); // Read \"d\".\n  ASSERT_EQ(0, result.compare(\"d\"));\n\n  // Too high offset.\n  ASSERT_TRUE(!rand_file->Read(1000, 5, &result, scratch).ok());\n  delete rand_file;\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "28-85",
    "snippet": "TEST(MemEnvTest, Basics) {\n  uint64_t file_size;\n  WritableFile* writable_file;\n  std::vector<std::string> children;\n\n  ASSERT_OK(env_->CreateDir(\"/dir\"));\n\n  // Check that the directory is empty.\n  ASSERT_TRUE(!env_->FileExists(\"/dir/non_existent\"));\n  ASSERT_TRUE(!env_->GetFileSize(\"/dir/non_existent\", &file_size).ok());\n  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n  ASSERT_EQ(0, children.size());\n\n  // Create a file.\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  delete writable_file;\n\n  // Check that the file exists.\n  ASSERT_TRUE(env_->FileExists(\"/dir/f\"));\n  ASSERT_OK(env_->GetFileSize(\"/dir/f\", &file_size));\n  ASSERT_EQ(0, file_size);\n  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n  ASSERT_EQ(1, children.size());\n  ASSERT_EQ(\"f\", children[0]);\n\n  // Write to the file.\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  ASSERT_OK(writable_file->Append(\"abc\"));\n  delete writable_file;\n\n  // Check for expected size.\n  ASSERT_OK(env_->GetFileSize(\"/dir/f\", &file_size));\n  ASSERT_EQ(3, file_size);\n\n  // Check that renaming works.\n  ASSERT_TRUE(!env_->RenameFile(\"/dir/non_existent\", \"/dir/g\").ok());\n  ASSERT_OK(env_->RenameFile(\"/dir/f\", \"/dir/g\"));\n  ASSERT_TRUE(!env_->FileExists(\"/dir/f\"));\n  ASSERT_TRUE(env_->FileExists(\"/dir/g\"));\n  ASSERT_OK(env_->GetFileSize(\"/dir/g\", &file_size));\n  ASSERT_EQ(3, file_size);\n\n  // Check that opening non-existent file fails.\n  SequentialFile* seq_file;\n  RandomAccessFile* rand_file;\n  ASSERT_TRUE(!env_->NewSequentialFile(\"/dir/non_existent\", &seq_file).ok());\n  ASSERT_TRUE(!seq_file);\n  ASSERT_TRUE(!env_->NewRandomAccessFile(\"/dir/non_existent\", &rand_file).ok());\n  ASSERT_TRUE(!rand_file);\n\n  // Check that deleting works.\n  ASSERT_TRUE(!env_->DeleteFile(\"/dir/non_existent\").ok());\n  ASSERT_OK(env_->DeleteFile(\"/dir/g\"));\n  ASSERT_TRUE(!env_->FileExists(\"/dir/g\"));\n  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n  ASSERT_EQ(0, children.size());\n  ASSERT_OK(env_->DeleteDir(\"/dir\"));\n}",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->DeleteDir(\"/dir\")"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->DeleteDir",
          "args": [
            "\"/dir\""
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteDir",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "324-326",
          "snippet": "virtual Status DeleteDir(const std::string& dirname) {\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status DeleteDir(const std::string& dirname) {\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "children.size()"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "children.size",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->GetChildren(\"/dir\", &children)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->GetChildren",
          "args": [
            "\"/dir\"",
            "&children"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "GetChildren",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "284-299",
          "snippet": "virtual Status GetChildren(const std::string& dir,\n                             std::vector<std::string>* result) {\n    MutexLock lock(&mutex_);\n    result->clear();\n\n    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){\n      const std::string& filename = i->first;\n\n      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&\n          Slice(filename).starts_with(Slice(dir))) {\n        result->push_back(filename.substr(dir.size() + 1));\n      }\n    }\n\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status GetChildren(const std::string& dir,\n                               std::vector<std::string>* result) {\n      MutexLock lock(&mutex_);\n      result->clear();\n  \n      for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){\n        const std::string& filename = i->first;\n  \n        if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&\n            Slice(filename).starts_with(Slice(dir))) {\n          result->push_back(filename.substr(dir.size() + 1));\n        }\n      }\n  \n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->FileExists(\"/dir/g\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->FileExists",
          "args": [
            "\"/dir/g\""
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "FileExists",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "279-282",
          "snippet": "virtual bool FileExists(const std::string& fname) {\n    MutexLock lock(&mutex_);\n    return file_map_.find(fname) != file_map_.end();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual bool FileExists(const std::string& fname) {\n      MutexLock lock(&mutex_);\n      return file_map_.find(fname) != file_map_.end();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->DeleteFile(\"/dir/g\")"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->DeleteFile",
          "args": [
            "\"/dir/g\""
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "310-318",
          "snippet": "virtual Status DeleteFile(const std::string& fname) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) == file_map_.end()) {\n      return Status::IOError(fname, \"File not found\");\n    }\n\n    DeleteFileInternal(fname);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status DeleteFile(const std::string& fname) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) == file_map_.end()) {\n        return Status::IOError(fname, \"File not found\");\n      }\n  \n      DeleteFileInternal(fname);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->DeleteFile(\"/dir/non_existent\").ok()"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->DeleteFile",
          "args": [],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!rand_file"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->NewRandomAccessFile(\"/dir/non_existent\", &rand_file).ok()"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewRandomAccessFile",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewRandomAccessFile",
          "args": [
            "\"/dir/non_existent\"",
            "&rand_file"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "NewRandomAccessFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "252-262",
          "snippet": "virtual Status NewRandomAccessFile(const std::string& fname,\n                                     RandomAccessFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) == file_map_.end()) {\n      *result = NULL;\n      return Status::IOError(fname, \"File not found\");\n    }\n\n    *result = new RandomAccessFileImpl(file_map_[fname]);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewRandomAccessFile(const std::string& fname,\n                                       RandomAccessFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) == file_map_.end()) {\n        *result = NULL;\n        return Status::IOError(fname, \"File not found\");\n      }\n  \n      *result = new RandomAccessFileImpl(file_map_[fname]);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!seq_file"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->NewSequentialFile(\"/dir/non_existent\", &seq_file).ok()"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewSequentialFile",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewSequentialFile",
          "args": [
            "\"/dir/non_existent\"",
            "&seq_file"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "240-250",
          "snippet": "virtual Status NewSequentialFile(const std::string& fname,\n                                   SequentialFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) == file_map_.end()) {\n      *result = NULL;\n      return Status::IOError(fname, \"File not found\");\n    }\n\n    *result = new SequentialFileImpl(file_map_[fname]);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewSequentialFile(const std::string& fname,\n                                     SequentialFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) == file_map_.end()) {\n        *result = NULL;\n        return Status::IOError(fname, \"File not found\");\n      }\n  \n      *result = new SequentialFileImpl(file_map_[fname]);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "3",
            "file_size"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->GetFileSize(\"/dir/g\", &file_size)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->GetFileSize",
          "args": [
            "\"/dir/g\"",
            "&file_size"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "GetFileSize",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "328-336",
          "snippet": "virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) == file_map_.end()) {\n      return Status::IOError(fname, \"File not found\");\n    }\n\n    *file_size = file_map_[fname]->Size();\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) == file_map_.end()) {\n        return Status::IOError(fname, \"File not found\");\n      }\n  \n      *file_size = file_map_[fname]->Size();\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "env_->FileExists(\"/dir/g\")"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->FileExists(\"/dir/f\")"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->RenameFile(\"/dir/f\", \"/dir/g\")"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->RenameFile",
          "args": [
            "\"/dir/f\"",
            "\"/dir/g\""
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "RenameFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "338-349",
          "snippet": "virtual Status RenameFile(const std::string& src,\n                            const std::string& target) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(src) == file_map_.end()) {\n      return Status::IOError(src, \"File not found\");\n    }\n\n    DeleteFileInternal(target);\n    file_map_[target] = file_map_[src];\n    file_map_.erase(src);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status RenameFile(const std::string& src,\n                              const std::string& target) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(src) == file_map_.end()) {\n        return Status::IOError(src, \"File not found\");\n      }\n  \n      DeleteFileInternal(target);\n      file_map_[target] = file_map_[src];\n      file_map_.erase(src);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->RenameFile(\"/dir/non_existent\", \"/dir/g\").ok()"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->RenameFile",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "3",
            "file_size"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->GetFileSize(\"/dir/f\", &file_size)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "writable_file->Append(\"abc\")"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "writable_file->Append",
          "args": [
            "\"abc\""
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "Append",
          "container": "WritableFileImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "212-214",
          "snippet": "virtual Status Append(const Slice& data) {\n    return file_->Append(data);\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nWritableFileImpl {\n  virtual Status Append(const Slice& data) {\n      return file_->Append(data);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewWritableFile(\"/dir/f\", &writable_file)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "\"/dir/f\"",
            "&writable_file"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "264-277",
          "snippet": "virtual Status NewWritableFile(const std::string& fname,\n                                 WritableFile** result) {\n    MutexLock lock(&mutex_);\n    if (file_map_.find(fname) != file_map_.end()) {\n      DeleteFileInternal(fname);\n    }\n\n    FileState* file = new FileState();\n    file->Ref();\n    file_map_[fname] = file;\n\n    *result = new WritableFileImpl(file);\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status NewWritableFile(const std::string& fname,\n                                   WritableFile** result) {\n      MutexLock lock(&mutex_);\n      if (file_map_.find(fname) != file_map_.end()) {\n        DeleteFileInternal(fname);\n      }\n  \n      FileState* file = new FileState();\n      file->Ref();\n      file_map_[fname] = file;\n  \n      *result = new WritableFileImpl(file);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"f\"",
            "children[0]"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "1",
            "children.size()"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->GetChildren(\"/dir\", &children)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "file_size"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->GetFileSize(\"/dir/f\", &file_size)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "env_->FileExists(\"/dir/f\")"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->NewWritableFile(\"/dir/f\", &writable_file)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "children.size()"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->GetChildren(\"/dir\", &children)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->GetFileSize(\"/dir/non_existent\", &file_size).ok()"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->GetFileSize",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "!env_->FileExists(\"/dir/non_existent\")"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "env_->CreateDir(\"/dir\")"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->CreateDir",
          "args": [
            "\"/dir\""
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "CreateDir",
          "container": "InMemoryEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv.cc",
          "lines": "320-322",
          "snippet": "virtual Status CreateDir(const std::string& dirname) {\n    return Status::OK();\n  }",
          "includes": [
            "#include <vector>",
            "#include <string>",
            "#include <string.h>",
            "#include <map>",
            "#include \"util/mutexlock.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"helpers/memenv/memenv.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <vector>\n#include <string>\n#include <string.h>\n#include <map>\n#include \"util/mutexlock.h\"\n#include \"port/port.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"helpers/memenv/memenv.h\"\n\nInMemoryEnv {\n  virtual Status CreateDir(const std::string& dirname) {\n      return Status::OK();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nTEST(MemEnvTest, Basics) {\n  uint64_t file_size;\n  WritableFile* writable_file;\n  std::vector<std::string> children;\n\n  ASSERT_OK(env_->CreateDir(\"/dir\"));\n\n  // Check that the directory is empty.\n  ASSERT_TRUE(!env_->FileExists(\"/dir/non_existent\"));\n  ASSERT_TRUE(!env_->GetFileSize(\"/dir/non_existent\", &file_size).ok());\n  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n  ASSERT_EQ(0, children.size());\n\n  // Create a file.\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  delete writable_file;\n\n  // Check that the file exists.\n  ASSERT_TRUE(env_->FileExists(\"/dir/f\"));\n  ASSERT_OK(env_->GetFileSize(\"/dir/f\", &file_size));\n  ASSERT_EQ(0, file_size);\n  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n  ASSERT_EQ(1, children.size());\n  ASSERT_EQ(\"f\", children[0]);\n\n  // Write to the file.\n  ASSERT_OK(env_->NewWritableFile(\"/dir/f\", &writable_file));\n  ASSERT_OK(writable_file->Append(\"abc\"));\n  delete writable_file;\n\n  // Check for expected size.\n  ASSERT_OK(env_->GetFileSize(\"/dir/f\", &file_size));\n  ASSERT_EQ(3, file_size);\n\n  // Check that renaming works.\n  ASSERT_TRUE(!env_->RenameFile(\"/dir/non_existent\", \"/dir/g\").ok());\n  ASSERT_OK(env_->RenameFile(\"/dir/f\", \"/dir/g\"));\n  ASSERT_TRUE(!env_->FileExists(\"/dir/f\"));\n  ASSERT_TRUE(env_->FileExists(\"/dir/g\"));\n  ASSERT_OK(env_->GetFileSize(\"/dir/g\", &file_size));\n  ASSERT_EQ(3, file_size);\n\n  // Check that opening non-existent file fails.\n  SequentialFile* seq_file;\n  RandomAccessFile* rand_file;\n  ASSERT_TRUE(!env_->NewSequentialFile(\"/dir/non_existent\", &seq_file).ok());\n  ASSERT_TRUE(!seq_file);\n  ASSERT_TRUE(!env_->NewRandomAccessFile(\"/dir/non_existent\", &rand_file).ok());\n  ASSERT_TRUE(!rand_file);\n\n  // Check that deleting works.\n  ASSERT_TRUE(!env_->DeleteFile(\"/dir/non_existent\").ok());\n  ASSERT_OK(env_->DeleteFile(\"/dir/g\"));\n  ASSERT_TRUE(!env_->FileExists(\"/dir/g\"));\n  ASSERT_OK(env_->GetChildren(\"/dir\", &children));\n  ASSERT_EQ(0, children.size());\n  ASSERT_OK(env_->DeleteDir(\"/dir\"));\n}"
  },
  {
    "function_name": "MemEnvTest",
    "container": "MemEnvTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/helpers/memenv/memenv_test.cc",
    "lines": "20-22",
    "snippet": "MemEnvTest()\n      : env_(NewMemEnv(Env::Default())) {\n  }",
    "includes": [
      "#include <vector>",
      "#include <string>",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"helpers/memenv/memenv.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NewMemEnv",
          "args": [
            "Env::Default()"
          ],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 21
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <vector>\n#include <string>\n#include \"util/testharness.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/db_impl.h\"\n#include \"helpers/memenv/memenv.h\"\n\nMemEnvTest {\n  MemEnvTest()\n        : env_(NewMemEnv(Env::Default())) {\n    }\n}"
  }
]