[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue200_test.cc",
    "lines": "57-59",
    "snippet": "int main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leveldb::test::RunAllTests",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "RunAllTests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "36-58",
          "snippet": "int RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nint RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/db.h\"\n\nint main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue200_test.cc",
    "lines": "16-53",
    "snippet": "TEST(Issue200, Test) {\n  // Get rid of any state from an old run.\n  std::string dbpath = test::TmpDir() + \"/leveldb_issue200_test\";\n  DestroyDB(dbpath, Options());\n\n  DB *db;\n  Options options;\n  options.create_if_missing = true;\n  ASSERT_OK(DB::Open(options, dbpath, &db));\n\n  WriteOptions write_options;\n  ASSERT_OK(db->Put(write_options, \"1\", \"b\"));\n  ASSERT_OK(db->Put(write_options, \"2\", \"c\"));\n  ASSERT_OK(db->Put(write_options, \"3\", \"d\"));\n  ASSERT_OK(db->Put(write_options, \"4\", \"e\"));\n  ASSERT_OK(db->Put(write_options, \"5\", \"f\"));\n\n  ReadOptions read_options;\n  Iterator *iter = db->NewIterator(read_options);\n\n  // Add an element that should not be reflected in the iterator.\n  ASSERT_OK(db->Put(write_options, \"25\", \"cd\"));\n\n  iter->Seek(\"5\");\n  ASSERT_EQ(iter->key().ToString(), \"5\");\n  iter->Prev();\n  ASSERT_EQ(iter->key().ToString(), \"4\");\n  iter->Prev();\n  ASSERT_EQ(iter->key().ToString(), \"3\");\n  iter->Next();\n  ASSERT_EQ(iter->key().ToString(), \"4\");\n  iter->Next();\n  ASSERT_EQ(iter->key().ToString(), \"5\");\n\n  delete iter;\n  delete db;\n  DestroyDB(dbpath, options);\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DestroyDB",
          "args": [
            "dbpath",
            "options"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "DestroyDB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1482-1511",
          "snippet": "Status DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nStatus DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "iter->key().ToString()",
            "\"5\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "LRUHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "37-45",
          "snippet": "Slice key() const {\n    // For cheaper lookups, we allow a temporary Handle object\n    // to store a pointer to a key in \"value\".\n    if (next == this) {\n      return *(reinterpret_cast<Slice*>(value));\n    } else {\n      return Slice(key_data, key_length);\n    }\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUHandle {\n  Slice key() const {\n      // For cheaper lookups, we allow a temporary Handle object\n      // to store a pointer to a key in \"value\".\n      if (next == this) {\n        return *(reinterpret_cast<Slice*>(value));\n      } else {\n        return Slice(key_data, key_length);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "iter->key().ToString()",
            "\"4\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "iter->key().ToString()",
            "\"3\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->Prev",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "Prev",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "290-290",
          "snippet": "virtual void Prev() { iter_->Prev(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void Prev() { iter_->Prev(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "iter->key().ToString()",
            "\"4\""
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "iter->key().ToString()",
            "\"5\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->Seek",
          "args": [
            "\"5\""
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "281-286",
          "snippet": "virtual void Seek(const Slice& target) {\n    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n    std::string encoded;\n    AppendInternalKey(&encoded, ikey);\n    iter_->Seek(encoded);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void Seek(const Slice& target) {\n      ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n      std::string encoded;\n      AppendInternalKey(&encoded, ikey);\n      iter_->Seek(encoded);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Put(write_options, \"25\", \"cd\")"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db->Put",
          "args": [
            "write_options",
            "\"25\"",
            "\"cd\""
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db->NewIterator",
          "args": [
            "read_options"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Put(write_options, \"5\", \"f\")"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Put(write_options, \"4\", \"e\")"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Put(write_options, \"3\", \"d\")"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Put(write_options, \"2\", \"c\")"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Put(write_options, \"1\", \"b\")"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "DB::Open(options, dbpath, &db)"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DB::Open",
          "args": [
            "options",
            "dbpath",
            "&db"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1445-1477",
          "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Options",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "GetOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "28-34",
          "snippet": "static leveldb::Options GetOptions() {\n    leveldb::Options options;\n    int nCacheSizeMB = GetArg(\"-dbcache\", 25);\n    options.block_cache = leveldb::NewLRUCache(nCacheSizeMB * 1048576);\n    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n    return options;\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nstatic leveldb::Options GetOptions() {\n    leveldb::Options options;\n    int nCacheSizeMB = GetArg(\"-dbcache\", 25);\n    options.block_cache = leveldb::NewLRUCache(nCacheSizeMB * 1048576);\n    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n    return options;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test::TmpDir",
          "args": [],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "TmpDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "60-65",
          "snippet": "std::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nstd::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/db.h\"\n\nTEST(Issue200, Test) {\n  // Get rid of any state from an old run.\n  std::string dbpath = test::TmpDir() + \"/leveldb_issue200_test\";\n  DestroyDB(dbpath, Options());\n\n  DB *db;\n  Options options;\n  options.create_if_missing = true;\n  ASSERT_OK(DB::Open(options, dbpath, &db));\n\n  WriteOptions write_options;\n  ASSERT_OK(db->Put(write_options, \"1\", \"b\"));\n  ASSERT_OK(db->Put(write_options, \"2\", \"c\"));\n  ASSERT_OK(db->Put(write_options, \"3\", \"d\"));\n  ASSERT_OK(db->Put(write_options, \"4\", \"e\"));\n  ASSERT_OK(db->Put(write_options, \"5\", \"f\"));\n\n  ReadOptions read_options;\n  Iterator *iter = db->NewIterator(read_options);\n\n  // Add an element that should not be reflected in the iterator.\n  ASSERT_OK(db->Put(write_options, \"25\", \"cd\"));\n\n  iter->Seek(\"5\");\n  ASSERT_EQ(iter->key().ToString(), \"5\");\n  iter->Prev();\n  ASSERT_EQ(iter->key().ToString(), \"4\");\n  iter->Prev();\n  ASSERT_EQ(iter->key().ToString(), \"3\");\n  iter->Next();\n  ASSERT_EQ(iter->key().ToString(), \"4\");\n  iter->Next();\n  ASSERT_EQ(iter->key().ToString(), \"5\");\n\n  delete iter;\n  delete db;\n  DestroyDB(dbpath, options);\n}"
  }
]