[
  {
    "function_name": "ParseNextKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "226-253",
    "snippet": "bool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetRestartPoint",
          "args": [
            "restart_index_ + 1"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "GetRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "99-102",
          "snippet": "uint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nuint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "p + non_shared",
            "value_length"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_.append",
          "args": [
            "p",
            "non_shared"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_.resize",
          "args": [
            "shared"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CorruptionError",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "CorruptionError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "218-224",
          "snippet": "void CorruptionError() {\n    current_ = restarts_;\n    restart_index_ = num_restarts_;\n    status_ = Status::Corruption(\"bad entry in block\");\n    key_.clear();\n    value_.clear();\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid CorruptionError() {\n    current_ = restarts_;\n    restart_index_ = num_restarts_;\n    status_ = Status::Corruption(\"bad entry in block\");\n    key_.clear();\n    value_.clear();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "key_.size",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Block",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.h",
          "lines": "24-24",
          "snippet": "size_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/iterator.h\"",
            "#include <stdint.h>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/iterator.h\"\n#include <stdint.h>\n#include <stddef.h>\n\nBlock {\n  size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeEntry",
          "args": [
            "p",
            "limit",
            "&shared",
            "&non_shared",
            "&value_length"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NextEntryOffset",
          "args": [],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "NextEntryOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "95-97",
          "snippet": "inline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\ninline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nbool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }"
  },
  {
    "function_name": "CorruptionError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "218-224",
    "snippet": "void CorruptionError() {\n    current_ = restarts_;\n    restart_index_ = num_restarts_;\n    status_ = Status::Corruption(\"bad entry in block\");\n    key_.clear();\n    value_.clear();\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value_.clear",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"bad entry in block\""
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid CorruptionError() {\n    current_ = restarts_;\n    restart_index_ = num_restarts_;\n    status_ = Status::Corruption(\"bad entry in block\");\n    key_.clear();\n    value_.clear();\n  }"
  },
  {
    "function_name": "SeekToLast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "210-215",
    "snippet": "virtual void SeekToLast() {\n    SeekToRestartPoint(num_restarts_ - 1);\n    while (ParseNextKey() && NextEntryOffset() < restarts_) {\n      // Keep skipping\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NextEntryOffset",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "NextEntryOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "95-97",
          "snippet": "inline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\ninline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "ParseNextKey",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ParseNextKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "226-253",
          "snippet": "bool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nbool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "SeekToRestartPoint",
          "args": [
            "num_restarts_ - 1"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "104-112",
          "snippet": "void SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual void SeekToLast() {\n    SeekToRestartPoint(num_restarts_ - 1);\n    while (ParseNextKey() && NextEntryOffset() < restarts_) {\n      // Keep skipping\n    }\n  }"
  },
  {
    "function_name": "SeekToFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "205-208",
    "snippet": "virtual void SeekToFirst() {\n    SeekToRestartPoint(0);\n    ParseNextKey();\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ParseNextKey",
          "args": [],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ParseNextKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "226-253",
          "snippet": "bool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nbool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "SeekToRestartPoint",
          "args": [
            "0"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "104-112",
          "snippet": "void SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual void SeekToFirst() {\n    SeekToRestartPoint(0);\n    ParseNextKey();\n  }"
  },
  {
    "function_name": "Seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "165-203",
    "snippet": "virtual void Seek(const Slice& target) {\n    // Binary search in restart array to find the last restart point\n    // with a key < target\n    uint32_t left = 0;\n    uint32_t right = num_restarts_ - 1;\n    while (left < right) {\n      uint32_t mid = (left + right + 1) / 2;\n      uint32_t region_offset = GetRestartPoint(mid);\n      uint32_t shared, non_shared, value_length;\n      const char* key_ptr = DecodeEntry(data_ + region_offset,\n                                        data_ + restarts_,\n                                        &shared, &non_shared, &value_length);\n      if (key_ptr == NULL || (shared != 0)) {\n        CorruptionError();\n        return;\n      }\n      Slice mid_key(key_ptr, non_shared);\n      if (Compare(mid_key, target) < 0) {\n        // Key at \"mid\" is smaller than \"target\".  Therefore all\n        // blocks before \"mid\" are uninteresting.\n        left = mid;\n      } else {\n        // Key at \"mid\" is >= \"target\".  Therefore all blocks at or\n        // after \"mid\" are uninteresting.\n        right = mid - 1;\n      }\n    }\n\n    // Linear search (within restart block) for first key >= target\n    SeekToRestartPoint(left);\n    while (true) {\n      if (!ParseNextKey()) {\n        return;\n      }\n      if (Compare(key_, target) >= 0) {\n        return;\n      }\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Compare",
          "args": [
            "key_",
            "target"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "90-92",
          "snippet": "inline int Compare(const Slice& a, const Slice& b) const {\n    return comparator_->Compare(a, b);\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\ninline int Compare(const Slice& a, const Slice& b) const {\n    return comparator_->Compare(a, b);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "ParseNextKey",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ParseNextKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "226-253",
          "snippet": "bool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nbool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "SeekToRestartPoint",
          "args": [
            "left"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "104-112",
          "snippet": "void SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "CorruptionError",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "CorruptionError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "218-224",
          "snippet": "void CorruptionError() {\n    current_ = restarts_;\n    restart_index_ = num_restarts_;\n    status_ = Status::Corruption(\"bad entry in block\");\n    key_.clear();\n    value_.clear();\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid CorruptionError() {\n    current_ = restarts_;\n    restart_index_ = num_restarts_;\n    status_ = Status::Corruption(\"bad entry in block\");\n    key_.clear();\n    value_.clear();\n  }"
        }
      },
      {
        "call_info": {
          "callee": "DecodeEntry",
          "args": [
            "data_ + region_offset",
            "data_ + restarts_",
            "&shared",
            "&non_shared",
            "&value_length"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRestartPoint",
          "args": [
            "mid"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "GetRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "99-102",
          "snippet": "uint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nuint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual void Seek(const Slice& target) {\n    // Binary search in restart array to find the last restart point\n    // with a key < target\n    uint32_t left = 0;\n    uint32_t right = num_restarts_ - 1;\n    while (left < right) {\n      uint32_t mid = (left + right + 1) / 2;\n      uint32_t region_offset = GetRestartPoint(mid);\n      uint32_t shared, non_shared, value_length;\n      const char* key_ptr = DecodeEntry(data_ + region_offset,\n                                        data_ + restarts_,\n                                        &shared, &non_shared, &value_length);\n      if (key_ptr == NULL || (shared != 0)) {\n        CorruptionError();\n        return;\n      }\n      Slice mid_key(key_ptr, non_shared);\n      if (Compare(mid_key, target) < 0) {\n        // Key at \"mid\" is smaller than \"target\".  Therefore all\n        // blocks before \"mid\" are uninteresting.\n        left = mid;\n      } else {\n        // Key at \"mid\" is >= \"target\".  Therefore all blocks at or\n        // after \"mid\" are uninteresting.\n        right = mid - 1;\n      }\n    }\n\n    // Linear search (within restart block) for first key >= target\n    SeekToRestartPoint(left);\n    while (true) {\n      if (!ParseNextKey()) {\n        return;\n      }\n      if (Compare(key_, target) >= 0) {\n        return;\n      }\n    }\n  }"
  },
  {
    "function_name": "Prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "144-163",
    "snippet": "virtual void Prev() {\n    assert(Valid());\n\n    // Scan backwards to a restart point before current_\n    const uint32_t original = current_;\n    while (GetRestartPoint(restart_index_) >= original) {\n      if (restart_index_ == 0) {\n        // No more entries\n        current_ = restarts_;\n        restart_index_ = num_restarts_;\n        return;\n      }\n      restart_index_--;\n    }\n\n    SeekToRestartPoint(restart_index_);\n    do {\n      // Loop until end of current entry hits the start of original entry\n    } while (ParseNextKey() && NextEntryOffset() < original);\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NextEntryOffset",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "NextEntryOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "95-97",
          "snippet": "inline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\ninline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }"
        }
      },
      {
        "call_info": {
          "callee": "ParseNextKey",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "ParseNextKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "226-253",
          "snippet": "bool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nbool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "SeekToRestartPoint",
          "args": [
            "restart_index_"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "104-112",
          "snippet": "void SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }"
        }
      },
      {
        "call_info": {
          "callee": "GetRestartPoint",
          "args": [
            "restart_index_"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "GetRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "99-102",
          "snippet": "uint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nuint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "128-128",
          "snippet": "virtual bool Valid() const { return current_ < restarts_; }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual bool Valid() const { return current_ < restarts_; }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual void Prev() {\n    assert(Valid());\n\n    // Scan backwards to a restart point before current_\n    const uint32_t original = current_;\n    while (GetRestartPoint(restart_index_) >= original) {\n      if (restart_index_ == 0) {\n        // No more entries\n        current_ = restarts_;\n        restart_index_ = num_restarts_;\n        return;\n      }\n      restart_index_--;\n    }\n\n    SeekToRestartPoint(restart_index_);\n    do {\n      // Loop until end of current entry hits the start of original entry\n    } while (ParseNextKey() && NextEntryOffset() < original);\n  }"
  },
  {
    "function_name": "Next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "139-142",
    "snippet": "virtual void Next() {\n    assert(Valid());\n    ParseNextKey();\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ParseNextKey",
          "args": [],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "ParseNextKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "226-253",
          "snippet": "bool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nbool ParseNextKey() {\n    current_ = NextEntryOffset();\n    const char* p = data_ + current_;\n    const char* limit = data_ + restarts_;  // Restarts come right after data\n    if (p >= limit) {\n      // No more entries to return.  Mark as invalid.\n      current_ = restarts_;\n      restart_index_ = num_restarts_;\n      return false;\n    }\n\n    // Decode next entry\n    uint32_t shared, non_shared, value_length;\n    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);\n    if (p == NULL || key_.size() < shared) {\n      CorruptionError();\n      return false;\n    } else {\n      key_.resize(shared);\n      key_.append(p, non_shared);\n      value_ = Slice(p + non_shared, value_length);\n      while (restart_index_ + 1 < num_restarts_ &&\n             GetRestartPoint(restart_index_ + 1) < current_) {\n        ++restart_index_;\n      }\n      return true;\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "128-128",
          "snippet": "virtual bool Valid() const { return current_ < restarts_; }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual bool Valid() const { return current_ < restarts_; }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual void Next() {\n    assert(Valid());\n    ParseNextKey();\n  }"
  },
  {
    "function_name": "value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "134-137",
    "snippet": "virtual Slice value() const {\n    assert(Valid());\n    return value_;\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "128-128",
          "snippet": "virtual bool Valid() const { return current_ < restarts_; }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual bool Valid() const { return current_ < restarts_; }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual Slice value() const {\n    assert(Valid());\n    return value_;\n  }"
  },
  {
    "function_name": "key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "130-133",
    "snippet": "virtual Slice key() const {\n    assert(Valid());\n    return key_;\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "128-128",
          "snippet": "virtual bool Valid() const { return current_ < restarts_; }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual bool Valid() const { return current_ < restarts_; }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual Slice key() const {\n    assert(Valid());\n    return key_;\n  }"
  },
  {
    "function_name": "status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "129-129",
    "snippet": "virtual Status status() const { return status_; }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual Status status() const { return status_; }"
  },
  {
    "function_name": "Valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "128-128",
    "snippet": "virtual bool Valid() const { return current_ < restarts_; }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvirtual bool Valid() const { return current_ < restarts_; }"
  },
  {
    "function_name": "Iter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "115-126",
    "snippet": "Iter(const Comparator* comparator,\n       const char* data,\n       uint32_t restarts,\n       uint32_t num_restarts)\n      : comparator_(comparator),\n        data_(data),\n        restarts_(restarts),\n        num_restarts_(num_restarts),\n        current_(restarts_),\n        restart_index_(num_restarts_) {\n    assert(num_restarts_ > 0);\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "num_restarts_ > 0"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nIter(const Comparator* comparator,\n       const char* data,\n       uint32_t restarts,\n       uint32_t num_restarts)\n      : comparator_(comparator),\n        data_(data),\n        restarts_(restarts),\n        num_restarts_(num_restarts),\n        current_(restarts_),\n        restart_index_(num_restarts_) {\n    assert(num_restarts_ > 0);\n  }"
  },
  {
    "function_name": "SeekToRestartPoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "104-112",
    "snippet": "void SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "data_ + offset",
            "0"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRestartPoint",
          "args": [
            "index"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "GetRestartPoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "99-102",
          "snippet": "uint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nuint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }"
        }
      },
      {
        "call_info": {
          "callee": "key_.clear",
          "args": [],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nvoid SeekToRestartPoint(uint32_t index) {\n    key_.clear();\n    restart_index_ = index;\n    // current_ will be fixed by ParseNextKey();\n\n    // ParseNextKey() starts at the end of value_, so set value_ accordingly\n    uint32_t offset = GetRestartPoint(index);\n    value_ = Slice(data_ + offset, 0);\n  }"
  },
  {
    "function_name": "GetRestartPoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "99-102",
    "snippet": "uint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecodeFixed32",
          "args": [
            "data_ + restarts_ + index * sizeof(uint32_t)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "58-70",
          "snippet": "inline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "index < num_restarts_"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nuint32_t GetRestartPoint(uint32_t index) {\n    assert(index < num_restarts_);\n    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));\n  }"
  },
  {
    "function_name": "NextEntryOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "95-97",
    "snippet": "inline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value_.size",
          "args": [],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Block",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.h",
          "lines": "24-24",
          "snippet": "size_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/iterator.h\"",
            "#include <stdint.h>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/iterator.h\"\n#include <stdint.h>\n#include <stddef.h>\n\nBlock {\n  size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "value_.data",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\ninline uint32_t NextEntryOffset() const {\n    return (value_.data() + value_.size()) - data_;\n  }"
  },
  {
    "function_name": "Compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "90-92",
    "snippet": "inline int Compare(const Slice& a, const Slice& b) const {\n    return comparator_->Compare(a, b);\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "comparator_->Compare",
          "args": [
            "a",
            "b"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "90-92",
          "snippet": "inline int Compare(const Slice& a, const Slice& b) const {\n    return comparator_->Compare(a, b);\n  }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\ninline int Compare(const Slice& a, const Slice& b) const {\n    return comparator_->Compare(a, b);\n  }"
  },
  {
    "function_name": "~Block",
    "container": "Block",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "40-44",
    "snippet": "Block::~Block() {\n  if (owned_) {\n    delete[] data_;\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nBlock {\n  Block::~Block() {\n    if (owned_) {\n      delete[] data_;\n    }\n  }\n}"
  },
  {
    "function_name": "Block",
    "container": "Block",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "23-38",
    "snippet": "Block::Block(const BlockContents& contents)\n    : data_(contents.data.data()),\n      size_(contents.data.size()),\n      owned_(contents.heap_allocated) {\n  if (size_ < sizeof(uint32_t)) {\n    size_ = 0;  // Error marker\n  } else {\n    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);\n    if (NumRestarts() > max_restarts_allowed) {\n      // The size is too small for NumRestarts()\n      size_ = 0;\n    } else {\n      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NumRestarts",
          "args": [],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "NumRestarts",
          "container": "Block",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
          "lines": "18-21",
          "snippet": "inline uint32_t Block::NumRestarts() const {\n  assert(size_ >= sizeof(uint32_t));\n  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <algorithm>",
            "#include <vector>",
            "#include \"table/block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nBlock {\n  inline uint32_t Block::NumRestarts() const {\n    assert(size_ >= sizeof(uint32_t));\n    return DecodeFixed32(data_ + size_ - sizeof(uint32_t));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.data.size",
          "args": [],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "Block",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.h",
          "lines": "24-24",
          "snippet": "size_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/iterator.h\"",
            "#include <stdint.h>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/iterator.h\"\n#include <stdint.h>\n#include <stddef.h>\n\nBlock {\n  size_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.data.data",
          "args": [],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nBlock {\n  Block::Block(const BlockContents& contents)\n      : data_(contents.data.data()),\n        size_(contents.data.size()),\n        owned_(contents.heap_allocated) {\n    if (size_ < sizeof(uint32_t)) {\n      size_ = 0;  // Error marker\n    } else {\n      size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);\n      if (NumRestarts() > max_restarts_allowed) {\n        // The size is too small for NumRestarts()\n        size_ = 0;\n      } else {\n        restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "NumRestarts",
    "container": "Block",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block.cc",
    "lines": "18-21",
    "snippet": "inline uint32_t Block::NumRestarts() const {\n  assert(size_ >= sizeof(uint32_t));\n  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/format.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include <algorithm>",
      "#include <vector>",
      "#include \"table/block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecodeFixed32",
          "args": [
            "data_ + size_ - sizeof(uint32_t)"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "58-70",
          "snippet": "inline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "size_ >= sizeof(uint32_t)"
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"leveldb/comparator.h\"\n#include <algorithm>\n#include <vector>\n#include \"table/block.h\"\n\nBlock {\n  inline uint32_t Block::NumRestarts() const {\n    assert(size_ >= sizeof(uint32_t));\n    return DecodeFixed32(data_ + size_ - sizeof(uint32_t));\n  }\n}"
  }
]