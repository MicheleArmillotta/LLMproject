[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "669-718",
    "snippet": "int main(int argc, char** argv) {\n  std::string default_db_path;\n  for (int i = 1; i < argc; i++) {\n    double d;\n    int n;\n    char junk;\n    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_histogram = n;\n    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n      FLAGS_compression_ratio = d;\n    } else if (sscanf(argv[i], \"--use_existing_db=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_use_existing_db = n;\n    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n      FLAGS_num = n;\n    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n      FLAGS_reads = n;\n    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_value_size = n;\n    } else if (leveldb::Slice(argv[i]) == leveldb::Slice(\"--no_transaction\")) {\n      FLAGS_transaction = false;\n    } else if (sscanf(argv[i], \"--page_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_page_size = n;\n    } else if (sscanf(argv[i], \"--num_pages=%d%c\", &n, &junk) == 1) {\n      FLAGS_num_pages = n;\n    } else if (sscanf(argv[i], \"--WAL_enabled=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_WAL_enabled = n;\n    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n      FLAGS_db = argv[i] + 5;\n    } else {\n      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n      exit(1);\n    }\n  }\n\n  // Choose a location for the test database if none given with --db=<path>\n  if (FLAGS_db == NULL) {\n      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n      default_db_path += \"/dbbench\";\n      FLAGS_db = default_db_path.c_str();\n  }\n\n  leveldb::Benchmark benchmark;\n  benchmark.Run();\n  return 0;\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillseqbatch,\"\n    \"fillrandom,\"\n    \"fillrandsync,\"\n    \"fillrandbatch,\"\n    \"overwrite,\"\n    \"overwritebatch,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq,\"\n    \"readrand100K,\"\n    ;",
      "static int FLAGS_num = 1000000;",
      "static int FLAGS_reads = -1;",
      "static int FLAGS_value_size = 100;",
      "static bool FLAGS_histogram = false;",
      "static double FLAGS_compression_ratio = 0.5;",
      "static int FLAGS_page_size = 1024;",
      "static int FLAGS_num_pages = 4096;",
      "static bool FLAGS_use_existing_db = false;",
      "static bool FLAGS_transaction = true;",
      "static bool FLAGS_WAL_enabled = true;",
      "static const char* FLAGS_db = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "benchmark.Run",
          "args": [],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "Run",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "343-415",
          "snippet": "void Run() {\n    PrintHeader();\n    Open();\n\n    const char* benchmarks = FLAGS_benchmarks;\n    while (benchmarks != NULL) {\n      const char* sep = strchr(benchmarks, ',');\n      Slice name;\n      if (sep == NULL) {\n        name = benchmarks;\n        benchmarks = NULL;\n      } else {\n        name = Slice(benchmarks, sep - benchmarks);\n        benchmarks = sep + 1;\n      }\n\n      bytes_ = 0;\n      Start();\n\n      bool known = true;\n      bool write_sync = false;\n      if (name == Slice(\"fillseq\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillseqbatch\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrandom\")) {\n        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrandbatch\")) {\n        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1000);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"overwrite\")) {\n        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"overwritebatch\")) {\n        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1000);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrandsync\")) {\n        write_sync = true;\n        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillseqsync\")) {\n        write_sync = true;\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrand100K\")) {\n        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillseq100K\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"readseq\")) {\n        ReadSequential();\n      } else if (name == Slice(\"readrandom\")) {\n        Read(RANDOM, 1);\n      } else if (name == Slice(\"readrand100K\")) {\n        int n = reads_;\n        reads_ /= 1000;\n        Read(RANDOM, 1);\n        reads_ = n;\n      } else {\n        known = false;\n        if (name != Slice()) {  // No error message for empty name\n          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n        }\n      }\n      if (known) {\n        Stop(name);\n      }\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillseqbatch,\"\n    \"fillrandom,\"\n    \"fillrandsync,\"\n    \"fillrandbatch,\"\n    \"overwrite,\"\n    \"overwritebatch,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq,\"\n    \"readrand100K,\"\n    ;",
            "static int FLAGS_value_size = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillseqbatch,\"\n    \"fillrandom,\"\n    \"fillrandsync,\"\n    \"fillrandbatch,\"\n    \"overwrite,\"\n    \"overwritebatch,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq,\"\n    \"readrand100K,\"\n    ;\nstatic int FLAGS_value_size = 100;\n\nBenchmark {\n  void Run() {\n      PrintHeader();\n      Open();\n  \n      const char* benchmarks = FLAGS_benchmarks;\n      while (benchmarks != NULL) {\n        const char* sep = strchr(benchmarks, ',');\n        Slice name;\n        if (sep == NULL) {\n          name = benchmarks;\n          benchmarks = NULL;\n        } else {\n          name = Slice(benchmarks, sep - benchmarks);\n          benchmarks = sep + 1;\n        }\n  \n        bytes_ = 0;\n        Start();\n  \n        bool known = true;\n        bool write_sync = false;\n        if (name == Slice(\"fillseq\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillseqbatch\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrandom\")) {\n          Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrandbatch\")) {\n          Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1000);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"overwrite\")) {\n          Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"overwritebatch\")) {\n          Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1000);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrandsync\")) {\n          write_sync = true;\n          Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillseqsync\")) {\n          write_sync = true;\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrand100K\")) {\n          Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillseq100K\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"readseq\")) {\n          ReadSequential();\n        } else if (name == Slice(\"readrandom\")) {\n          Read(RANDOM, 1);\n        } else if (name == Slice(\"readrand100K\")) {\n          int n = reads_;\n          reads_ /= 1000;\n          Read(RANDOM, 1);\n          reads_ = n;\n        } else {\n          known = false;\n          if (name != Slice()) {  // No error message for empty name\n            fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n          }\n        }\n        if (known) {\n          Stop(name);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "default_db_path.c_str",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Env::Default",
          "args": [
            "&default_db_path"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Env::Default",
          "args": [],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Invalid flag '%s'\\n\"",
            "argv[i]"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"--db=\"",
            "5"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--WAL_enabled=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--num_pages=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--page_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::Slice",
          "args": [
            "\"--no_transaction\""
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "Slice",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "37-37",
          "snippet": "Slice(const char* s) : data_(s), size_(strlen(s)) { }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  Slice(const char* s) : data_(s), size_(strlen(s)) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--value_size=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--reads=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--num=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--use_existing_db=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--compression_ratio=%lf%c\"",
            "&d",
            "&junk"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "argv[i]",
            "\"--histogram=%d%c\"",
            "&n",
            "&junk"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"--benchmarks=\""
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillseqbatch,\"\n    \"fillrandom,\"\n    \"fillrandsync,\"\n    \"fillrandbatch,\"\n    \"overwrite,\"\n    \"overwritebatch,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq,\"\n    \"readrand100K,\"\n    ;\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic int FLAGS_value_size = 100;\nstatic bool FLAGS_histogram = false;\nstatic double FLAGS_compression_ratio = 0.5;\nstatic int FLAGS_page_size = 1024;\nstatic int FLAGS_num_pages = 4096;\nstatic bool FLAGS_use_existing_db = false;\nstatic bool FLAGS_transaction = true;\nstatic bool FLAGS_WAL_enabled = true;\nstatic const char* FLAGS_db = NULL;\n\nint main(int argc, char** argv) {\n  std::string default_db_path;\n  for (int i = 1; i < argc; i++) {\n    double d;\n    int n;\n    char junk;\n    if (leveldb::Slice(argv[i]).starts_with(\"--benchmarks=\")) {\n      FLAGS_benchmarks = argv[i] + strlen(\"--benchmarks=\");\n    } else if (sscanf(argv[i], \"--histogram=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_histogram = n;\n    } else if (sscanf(argv[i], \"--compression_ratio=%lf%c\", &d, &junk) == 1) {\n      FLAGS_compression_ratio = d;\n    } else if (sscanf(argv[i], \"--use_existing_db=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_use_existing_db = n;\n    } else if (sscanf(argv[i], \"--num=%d%c\", &n, &junk) == 1) {\n      FLAGS_num = n;\n    } else if (sscanf(argv[i], \"--reads=%d%c\", &n, &junk) == 1) {\n      FLAGS_reads = n;\n    } else if (sscanf(argv[i], \"--value_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_value_size = n;\n    } else if (leveldb::Slice(argv[i]) == leveldb::Slice(\"--no_transaction\")) {\n      FLAGS_transaction = false;\n    } else if (sscanf(argv[i], \"--page_size=%d%c\", &n, &junk) == 1) {\n      FLAGS_page_size = n;\n    } else if (sscanf(argv[i], \"--num_pages=%d%c\", &n, &junk) == 1) {\n      FLAGS_num_pages = n;\n    } else if (sscanf(argv[i], \"--WAL_enabled=%d%c\", &n, &junk) == 1 &&\n               (n == 0 || n == 1)) {\n      FLAGS_WAL_enabled = n;\n    } else if (strncmp(argv[i], \"--db=\", 5) == 0) {\n      FLAGS_db = argv[i] + 5;\n    } else {\n      fprintf(stderr, \"Invalid flag '%s'\\n\", argv[i]);\n      exit(1);\n    }\n  }\n\n  // Choose a location for the test database if none given with --db=<path>\n  if (FLAGS_db == NULL) {\n      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n      default_db_path += \"/dbbench\";\n      FLAGS_db = default_db_path.c_str();\n  }\n\n  leveldb::Benchmark benchmark;\n  benchmark.Run();\n  return 0;\n}"
  },
  {
    "function_name": "ReadSequential",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "649-663",
    "snippet": "void ReadSequential() {\n    int status;\n    sqlite3_stmt *pStmt;\n    std::string read_str = \"SELECT * FROM test ORDER BY key\";\n\n    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &pStmt, NULL);\n    ErrorCheck(status);\n    for (int i = 0; i < reads_ && SQLITE_ROW == sqlite3_step(pStmt); i++) {\n      bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);\n      FinishedSingleOp();\n    }\n\n    status = sqlite3_finalize(pStmt);\n    ErrorCheck(status);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ErrorCheck",
          "args": [
            "status"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "ErrorCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "98-104",
          "snippet": "inline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_finalize",
          "args": [
            "pStmt"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FinishedSingleOp",
          "args": [],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "250-274",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_column_bytes",
          "args": [
            "pStmt",
            "2"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_column_bytes",
          "args": [
            "pStmt",
            "1"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_step",
          "args": [
            "pStmt"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_prepare_v2",
          "args": [
            "db_",
            "read_str.c_str()",
            "-1",
            "&pStmt",
            "NULL"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_str.c_str",
          "args": [],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void ReadSequential() {\n      int status;\n      sqlite3_stmt *pStmt;\n      std::string read_str = \"SELECT * FROM test ORDER BY key\";\n  \n      status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &pStmt, NULL);\n      ErrorCheck(status);\n      for (int i = 0; i < reads_ && SQLITE_ROW == sqlite3_step(pStmt); i++) {\n        bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);\n        FinishedSingleOp();\n      }\n  \n      status = sqlite3_finalize(pStmt);\n      ErrorCheck(status);\n    }\n}"
  },
  {
    "function_name": "Read",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "581-647",
    "snippet": "void Read(Order order, int entries_per_batch) {\n    int status;\n    sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;\n\n    std::string read_str = \"SELECT * FROM test WHERE key = ?\";\n    std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n    std::string end_trans_str = \"END TRANSACTION;\";\n\n    // Preparing sqlite3 statements\n    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                &begin_trans_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                &end_trans_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);\n    ErrorCheck(status);\n\n    bool transaction = (entries_per_batch > 1);\n    for (int i = 0; i < reads_; i += entries_per_batch) {\n      // Begin read transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(begin_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(begin_trans_stmt);\n        ErrorCheck(status);\n      }\n\n      // Create and execute SQL statements\n      for (int j = 0; j < entries_per_batch; j++) {\n        // Create key value\n        char key[100];\n        int k = (order == SEQUENTIAL) ? i + j : (rand_.Next() % reads_);\n        snprintf(key, sizeof(key), \"%016d\", k);\n\n        // Bind key value into read_stmt\n        status = sqlite3_bind_blob(read_stmt, 1, key, 16, SQLITE_STATIC);\n        ErrorCheck(status);\n\n        // Execute read statement\n        while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW) {}\n        StepErrorCheck(status);\n\n        // Reset SQLite statement for another use\n        status = sqlite3_clear_bindings(read_stmt);\n        ErrorCheck(status);\n        status = sqlite3_reset(read_stmt);\n        ErrorCheck(status);\n        FinishedSingleOp();\n      }\n\n      // End read transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(end_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(end_trans_stmt);\n        ErrorCheck(status);\n      }\n    }\n\n    status = sqlite3_finalize(read_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(begin_trans_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(end_trans_stmt);\n    ErrorCheck(status);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_transaction = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ErrorCheck",
          "args": [
            "status"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "ErrorCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "98-104",
          "snippet": "inline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_finalize",
          "args": [
            "end_trans_stmt"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_finalize",
          "args": [
            "begin_trans_stmt"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_finalize",
          "args": [
            "read_stmt"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_reset",
          "args": [
            "end_trans_stmt"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StepErrorCheck",
          "args": [
            "status"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "StepErrorCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "90-96",
          "snippet": "inline\nstatic void StepErrorCheck(int status) {\n  if (status != SQLITE_DONE) {\n    fprintf(stderr, \"SQL step error: status = %d\\n\", status);\n    exit(1);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void StepErrorCheck(int status) {\n  if (status != SQLITE_DONE) {\n    fprintf(stderr, \"SQL step error: status = %d\\n\", status);\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_step",
          "args": [
            "end_trans_stmt"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FinishedSingleOp",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "250-274",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_reset",
          "args": [
            "read_stmt"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_clear_bindings",
          "args": [
            "read_stmt"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_step",
          "args": [
            "read_stmt"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_bind_blob",
          "args": [
            "read_stmt",
            "1",
            "key",
            "16",
            "SQLITE_STATIC"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand_.Next",
          "args": [],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_reset",
          "args": [
            "begin_trans_stmt"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_step",
          "args": [
            "begin_trans_stmt"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_prepare_v2",
          "args": [
            "db_",
            "read_str.c_str()",
            "-1",
            "&read_stmt",
            "NULL"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_str.c_str",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_prepare_v2",
          "args": [
            "db_",
            "end_trans_str.c_str()",
            "-1",
            "&end_trans_stmt",
            "NULL"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_trans_str.c_str",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_prepare_v2",
          "args": [
            "db_",
            "begin_trans_str.c_str()",
            "-1",
            "&begin_trans_stmt",
            "NULL"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_trans_str.c_str",
          "args": [],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_transaction = true;\n\nBenchmark {\n  void Read(Order order, int entries_per_batch) {\n      int status;\n      sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;\n  \n      std::string read_str = \"SELECT * FROM test WHERE key = ?\";\n      std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n      std::string end_trans_str = \"END TRANSACTION;\";\n  \n      // Preparing sqlite3 statements\n      status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                  &begin_trans_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                  &end_trans_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);\n      ErrorCheck(status);\n  \n      bool transaction = (entries_per_batch > 1);\n      for (int i = 0; i < reads_; i += entries_per_batch) {\n        // Begin read transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(begin_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(begin_trans_stmt);\n          ErrorCheck(status);\n        }\n  \n        // Create and execute SQL statements\n        for (int j = 0; j < entries_per_batch; j++) {\n          // Create key value\n          char key[100];\n          int k = (order == SEQUENTIAL) ? i + j : (rand_.Next() % reads_);\n          snprintf(key, sizeof(key), \"%016d\", k);\n  \n          // Bind key value into read_stmt\n          status = sqlite3_bind_blob(read_stmt, 1, key, 16, SQLITE_STATIC);\n          ErrorCheck(status);\n  \n          // Execute read statement\n          while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW) {}\n          StepErrorCheck(status);\n  \n          // Reset SQLite statement for another use\n          status = sqlite3_clear_bindings(read_stmt);\n          ErrorCheck(status);\n          status = sqlite3_reset(read_stmt);\n          ErrorCheck(status);\n          FinishedSingleOp();\n        }\n  \n        // End read transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(end_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(end_trans_stmt);\n          ErrorCheck(status);\n        }\n      }\n  \n      status = sqlite3_finalize(read_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(begin_trans_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(end_trans_stmt);\n      ErrorCheck(status);\n    }\n}"
  },
  {
    "function_name": "Write",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "478-579",
    "snippet": "void Write(bool write_sync, Order order, DBState state,\n             int num_entries, int value_size, int entries_per_batch) {\n    // Create new database if state == FRESH\n    if (state == FRESH) {\n      if (FLAGS_use_existing_db) {\n        message_ = \"skipping (--use_existing_db is true)\";\n        return;\n      }\n      sqlite3_close(db_);\n      db_ = NULL;\n      Open();\n      Start();\n    }\n\n    if (num_entries != num_) {\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n      message_ = msg;\n    }\n\n    char* err_msg = NULL;\n    int status;\n\n    sqlite3_stmt *replace_stmt, *begin_trans_stmt, *end_trans_stmt;\n    std::string replace_str = \"REPLACE INTO test (key, value) VALUES (?, ?)\";\n    std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n    std::string end_trans_str = \"END TRANSACTION;\";\n\n    // Check for synchronous flag in options\n    std::string sync_stmt = (write_sync) ? \"PRAGMA synchronous = FULL\" :\n                                           \"PRAGMA synchronous = OFF\";\n    status = sqlite3_exec(db_, sync_stmt.c_str(), NULL, NULL, &err_msg);\n    ExecErrorCheck(status, err_msg);\n\n    // Preparing sqlite3 statements\n    status = sqlite3_prepare_v2(db_, replace_str.c_str(), -1,\n                                &replace_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                &begin_trans_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                &end_trans_stmt, NULL);\n    ErrorCheck(status);\n\n    bool transaction = (entries_per_batch > 1);\n    for (int i = 0; i < num_entries; i += entries_per_batch) {\n      // Begin write transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(begin_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(begin_trans_stmt);\n        ErrorCheck(status);\n      }\n\n      // Create and execute SQL statements\n      for (int j = 0; j < entries_per_batch; j++) {\n        const char* value = gen_.Generate(value_size).data();\n\n        // Create values for key-value pair\n        const int k = (order == SEQUENTIAL) ? i + j :\n                      (rand_.Next() % num_entries);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n\n        // Bind KV values into replace_stmt\n        status = sqlite3_bind_blob(replace_stmt, 1, key, 16, SQLITE_STATIC);\n        ErrorCheck(status);\n        status = sqlite3_bind_blob(replace_stmt, 2, value,\n                                   value_size, SQLITE_STATIC);\n        ErrorCheck(status);\n\n        // Execute replace_stmt\n        bytes_ += value_size + strlen(key);\n        status = sqlite3_step(replace_stmt);\n        StepErrorCheck(status);\n\n        // Reset SQLite statement for another use\n        status = sqlite3_clear_bindings(replace_stmt);\n        ErrorCheck(status);\n        status = sqlite3_reset(replace_stmt);\n        ErrorCheck(status);\n\n        FinishedSingleOp();\n      }\n\n      // End write transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(end_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(end_trans_stmt);\n        ErrorCheck(status);\n      }\n    }\n\n    status = sqlite3_finalize(replace_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(begin_trans_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(end_trans_stmt);\n    ErrorCheck(status);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_use_existing_db = false;",
      "static bool FLAGS_transaction = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ErrorCheck",
          "args": [
            "status"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "ErrorCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "98-104",
          "snippet": "inline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_finalize",
          "args": [
            "end_trans_stmt"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_finalize",
          "args": [
            "begin_trans_stmt"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_finalize",
          "args": [
            "replace_stmt"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_reset",
          "args": [
            "end_trans_stmt"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "StepErrorCheck",
          "args": [
            "status"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "StepErrorCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "90-96",
          "snippet": "inline\nstatic void StepErrorCheck(int status) {\n  if (status != SQLITE_DONE) {\n    fprintf(stderr, \"SQL step error: status = %d\\n\", status);\n    exit(1);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void StepErrorCheck(int status) {\n  if (status != SQLITE_DONE) {\n    fprintf(stderr, \"SQL step error: status = %d\\n\", status);\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_step",
          "args": [
            "end_trans_stmt"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FinishedSingleOp",
          "args": [],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "FinishedSingleOp",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "250-274",
          "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_reset",
          "args": [
            "replace_stmt"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_clear_bindings",
          "args": [
            "replace_stmt"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_step",
          "args": [
            "replace_stmt"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_bind_blob",
          "args": [
            "replace_stmt",
            "2",
            "value",
            "value_size",
            "SQLITE_STATIC"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_bind_blob",
          "args": [
            "replace_stmt",
            "1",
            "key",
            "16",
            "SQLITE_STATIC"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "key",
            "sizeof(key)",
            "\"%016d\"",
            "k"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rand_.Next",
          "args": [],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "gen_.Generate",
          "args": [],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gen_.Generate",
          "args": [
            "value_size"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "Generate",
          "container": "RandomGenerator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "139-146",
          "snippet": "Slice Generate(int len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nRandomGenerator {\n  Slice Generate(int len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_reset",
          "args": [
            "begin_trans_stmt"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_step",
          "args": [
            "begin_trans_stmt"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_prepare_v2",
          "args": [
            "db_",
            "end_trans_str.c_str()",
            "-1",
            "&end_trans_stmt",
            "NULL"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "end_trans_str.c_str",
          "args": [],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_prepare_v2",
          "args": [
            "db_",
            "begin_trans_str.c_str()",
            "-1",
            "&begin_trans_stmt",
            "NULL"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "begin_trans_str.c_str",
          "args": [],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_prepare_v2",
          "args": [
            "db_",
            "replace_str.c_str()",
            "-1",
            "&replace_stmt",
            "NULL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_str.c_str",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExecErrorCheck",
          "args": [
            "status",
            "err_msg"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ExecErrorCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "81-88",
          "snippet": "inline\nstatic void ExecErrorCheck(int status, char *err_msg) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"SQL error: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void ExecErrorCheck(int status, char *err_msg) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"SQL error: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_exec",
          "args": [
            "db_",
            "sync_stmt.c_str()",
            "NULL",
            "NULL",
            "&err_msg"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_stmt.c_str",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "msg",
            "sizeof(msg)",
            "\"(%d ops)\"",
            "num_entries"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Start",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "240-248",
          "snippet": "void Start() {\n    start_ = Env::Default()->NowMicros() * 1e-6;\n    bytes_ = 0;\n    message_.clear();\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    next_report_ = 100;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void Start() {\n      start_ = Env::Default()->NowMicros() * 1e-6;\n      bytes_ = 0;\n      message_.clear();\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      next_report_ = 100;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Open",
          "args": [],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "417-476",
          "snippet": "void Open() {\n    assert(db_ == NULL);\n\n    int status;\n    char file_name[100];\n    char* err_msg = NULL;\n    db_num_++;\n\n    // Open database\n    std::string tmp_dir;\n    Env::Default()->GetTestDirectory(&tmp_dir);\n    snprintf(file_name, sizeof(file_name),\n             \"%s/dbbench_sqlite3-%d.db\",\n             tmp_dir.c_str(),\n             db_num_);\n    status = sqlite3_open(file_name, &db_);\n    if (status) {\n      fprintf(stderr, \"open error: %s\\n\", sqlite3_errmsg(db_));\n      exit(1);\n    }\n\n    // Change SQLite cache size\n    char cache_size[100];\n    snprintf(cache_size, sizeof(cache_size), \"PRAGMA cache_size = %d\",\n             FLAGS_num_pages);\n    status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);\n    ExecErrorCheck(status, err_msg);\n\n    // FLAGS_page_size is defaulted to 1024\n    if (FLAGS_page_size != 1024) {\n      char page_size[100];\n      snprintf(page_size, sizeof(page_size), \"PRAGMA page_size = %d\",\n               FLAGS_page_size);\n      status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n\n    // Change journal mode to WAL if WAL enabled flag is on\n    if (FLAGS_WAL_enabled) {\n      std::string WAL_stmt = \"PRAGMA journal_mode = WAL\";\n\n      // LevelDB's default cache size is a combined 4 MB\n      std::string WAL_checkpoint = \"PRAGMA wal_autocheckpoint = 4096\";\n      status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n      status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n\n    // Change locking mode to exclusive and create tables/index for database\n    std::string locking_stmt = \"PRAGMA locking_mode = EXCLUSIVE\";\n    std::string create_stmt =\n          \"CREATE TABLE test (key blob, value blob, PRIMARY KEY(key))\";\n    std::string stmt_array[] = { locking_stmt, create_stmt };\n    int stmt_array_length = sizeof(stmt_array) / sizeof(std::string);\n    for (int i = 0; i < stmt_array_length; i++) {\n      status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_page_size = 1024;",
            "static int FLAGS_num_pages = 4096;",
            "static bool FLAGS_WAL_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_page_size = 1024;\nstatic int FLAGS_num_pages = 4096;\nstatic bool FLAGS_WAL_enabled = true;\n\nBenchmark {\n  void Open() {\n      assert(db_ == NULL);\n  \n      int status;\n      char file_name[100];\n      char* err_msg = NULL;\n      db_num_++;\n  \n      // Open database\n      std::string tmp_dir;\n      Env::Default()->GetTestDirectory(&tmp_dir);\n      snprintf(file_name, sizeof(file_name),\n               \"%s/dbbench_sqlite3-%d.db\",\n               tmp_dir.c_str(),\n               db_num_);\n      status = sqlite3_open(file_name, &db_);\n      if (status) {\n        fprintf(stderr, \"open error: %s\\n\", sqlite3_errmsg(db_));\n        exit(1);\n      }\n  \n      // Change SQLite cache size\n      char cache_size[100];\n      snprintf(cache_size, sizeof(cache_size), \"PRAGMA cache_size = %d\",\n               FLAGS_num_pages);\n      status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n  \n      // FLAGS_page_size is defaulted to 1024\n      if (FLAGS_page_size != 1024) {\n        char page_size[100];\n        snprintf(page_size, sizeof(page_size), \"PRAGMA page_size = %d\",\n                 FLAGS_page_size);\n        status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n  \n      // Change journal mode to WAL if WAL enabled flag is on\n      if (FLAGS_WAL_enabled) {\n        std::string WAL_stmt = \"PRAGMA journal_mode = WAL\";\n  \n        // LevelDB's default cache size is a combined 4 MB\n        std::string WAL_checkpoint = \"PRAGMA wal_autocheckpoint = 4096\";\n        status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n        status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n  \n      // Change locking mode to exclusive and create tables/index for database\n      std::string locking_stmt = \"PRAGMA locking_mode = EXCLUSIVE\";\n      std::string create_stmt =\n            \"CREATE TABLE test (key blob, value blob, PRIMARY KEY(key))\";\n      std::string stmt_array[] = { locking_stmt, create_stmt };\n      int stmt_array_length = sizeof(stmt_array) / sizeof(std::string);\n      for (int i = 0; i < stmt_array_length; i++) {\n        status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_close",
          "args": [
            "db_"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_use_existing_db = false;\nstatic bool FLAGS_transaction = true;\n\nBenchmark {\n  void Write(bool write_sync, Order order, DBState state,\n               int num_entries, int value_size, int entries_per_batch) {\n      // Create new database if state == FRESH\n      if (state == FRESH) {\n        if (FLAGS_use_existing_db) {\n          message_ = \"skipping (--use_existing_db is true)\";\n          return;\n        }\n        sqlite3_close(db_);\n        db_ = NULL;\n        Open();\n        Start();\n      }\n  \n      if (num_entries != num_) {\n        char msg[100];\n        snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n        message_ = msg;\n      }\n  \n      char* err_msg = NULL;\n      int status;\n  \n      sqlite3_stmt *replace_stmt, *begin_trans_stmt, *end_trans_stmt;\n      std::string replace_str = \"REPLACE INTO test (key, value) VALUES (?, ?)\";\n      std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n      std::string end_trans_str = \"END TRANSACTION;\";\n  \n      // Check for synchronous flag in options\n      std::string sync_stmt = (write_sync) ? \"PRAGMA synchronous = FULL\" :\n                                             \"PRAGMA synchronous = OFF\";\n      status = sqlite3_exec(db_, sync_stmt.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n  \n      // Preparing sqlite3 statements\n      status = sqlite3_prepare_v2(db_, replace_str.c_str(), -1,\n                                  &replace_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                  &begin_trans_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                  &end_trans_stmt, NULL);\n      ErrorCheck(status);\n  \n      bool transaction = (entries_per_batch > 1);\n      for (int i = 0; i < num_entries; i += entries_per_batch) {\n        // Begin write transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(begin_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(begin_trans_stmt);\n          ErrorCheck(status);\n        }\n  \n        // Create and execute SQL statements\n        for (int j = 0; j < entries_per_batch; j++) {\n          const char* value = gen_.Generate(value_size).data();\n  \n          // Create values for key-value pair\n          const int k = (order == SEQUENTIAL) ? i + j :\n                        (rand_.Next() % num_entries);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n  \n          // Bind KV values into replace_stmt\n          status = sqlite3_bind_blob(replace_stmt, 1, key, 16, SQLITE_STATIC);\n          ErrorCheck(status);\n          status = sqlite3_bind_blob(replace_stmt, 2, value,\n                                     value_size, SQLITE_STATIC);\n          ErrorCheck(status);\n  \n          // Execute replace_stmt\n          bytes_ += value_size + strlen(key);\n          status = sqlite3_step(replace_stmt);\n          StepErrorCheck(status);\n  \n          // Reset SQLite statement for another use\n          status = sqlite3_clear_bindings(replace_stmt);\n          ErrorCheck(status);\n          status = sqlite3_reset(replace_stmt);\n          ErrorCheck(status);\n  \n          FinishedSingleOp();\n        }\n  \n        // End write transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(end_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(end_trans_stmt);\n          ErrorCheck(status);\n        }\n      }\n  \n      status = sqlite3_finalize(replace_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(begin_trans_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(end_trans_stmt);\n      ErrorCheck(status);\n    }\n}"
  },
  {
    "function_name": "Open",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "417-476",
    "snippet": "void Open() {\n    assert(db_ == NULL);\n\n    int status;\n    char file_name[100];\n    char* err_msg = NULL;\n    db_num_++;\n\n    // Open database\n    std::string tmp_dir;\n    Env::Default()->GetTestDirectory(&tmp_dir);\n    snprintf(file_name, sizeof(file_name),\n             \"%s/dbbench_sqlite3-%d.db\",\n             tmp_dir.c_str(),\n             db_num_);\n    status = sqlite3_open(file_name, &db_);\n    if (status) {\n      fprintf(stderr, \"open error: %s\\n\", sqlite3_errmsg(db_));\n      exit(1);\n    }\n\n    // Change SQLite cache size\n    char cache_size[100];\n    snprintf(cache_size, sizeof(cache_size), \"PRAGMA cache_size = %d\",\n             FLAGS_num_pages);\n    status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);\n    ExecErrorCheck(status, err_msg);\n\n    // FLAGS_page_size is defaulted to 1024\n    if (FLAGS_page_size != 1024) {\n      char page_size[100];\n      snprintf(page_size, sizeof(page_size), \"PRAGMA page_size = %d\",\n               FLAGS_page_size);\n      status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n\n    // Change journal mode to WAL if WAL enabled flag is on\n    if (FLAGS_WAL_enabled) {\n      std::string WAL_stmt = \"PRAGMA journal_mode = WAL\";\n\n      // LevelDB's default cache size is a combined 4 MB\n      std::string WAL_checkpoint = \"PRAGMA wal_autocheckpoint = 4096\";\n      status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n      status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n\n    // Change locking mode to exclusive and create tables/index for database\n    std::string locking_stmt = \"PRAGMA locking_mode = EXCLUSIVE\";\n    std::string create_stmt =\n          \"CREATE TABLE test (key blob, value blob, PRIMARY KEY(key))\";\n    std::string stmt_array[] = { locking_stmt, create_stmt };\n    int stmt_array_length = sizeof(stmt_array) / sizeof(std::string);\n    for (int i = 0; i < stmt_array_length; i++) {\n      status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_page_size = 1024;",
      "static int FLAGS_num_pages = 4096;",
      "static bool FLAGS_WAL_enabled = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExecErrorCheck",
          "args": [
            "status",
            "err_msg"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ExecErrorCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "81-88",
          "snippet": "inline\nstatic void ExecErrorCheck(int status, char *err_msg) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"SQL error: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void ExecErrorCheck(int status, char *err_msg) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"SQL error: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sqlite3_exec",
          "args": [
            "db_",
            "stmt_array[i].c_str()",
            "NULL",
            "NULL",
            "&err_msg"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stmt_array[i].c_str",
          "args": [],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_exec",
          "args": [
            "db_",
            "WAL_checkpoint.c_str()",
            "NULL",
            "NULL",
            "&err_msg"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAL_checkpoint.c_str",
          "args": [],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_exec",
          "args": [
            "db_",
            "WAL_stmt.c_str()",
            "NULL",
            "NULL",
            "&err_msg"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WAL_stmt.c_str",
          "args": [],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_exec",
          "args": [
            "db_",
            "page_size",
            "NULL",
            "NULL",
            "&err_msg"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "page_size",
            "sizeof(page_size)",
            "\"PRAGMA page_size = %d\"",
            "FLAGS_page_size"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_exec",
          "args": [
            "db_",
            "cache_size",
            "NULL",
            "NULL",
            "&err_msg"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "cache_size",
            "sizeof(cache_size)",
            "\"PRAGMA cache_size = %d\"",
            "FLAGS_num_pages"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"open error: %s\\n\"",
            "sqlite3_errmsg(db_)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_errmsg",
          "args": [
            "db_"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_open",
          "args": [
            "file_name",
            "&db_"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "file_name",
            "sizeof(file_name)",
            "\"%s/dbbench_sqlite3-%d.db\"",
            "tmp_dir.c_str()",
            "db_num_"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp_dir.c_str",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "&tmp_dir"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "db_ == NULL"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_page_size = 1024;\nstatic int FLAGS_num_pages = 4096;\nstatic bool FLAGS_WAL_enabled = true;\n\nBenchmark {\n  void Open() {\n      assert(db_ == NULL);\n  \n      int status;\n      char file_name[100];\n      char* err_msg = NULL;\n      db_num_++;\n  \n      // Open database\n      std::string tmp_dir;\n      Env::Default()->GetTestDirectory(&tmp_dir);\n      snprintf(file_name, sizeof(file_name),\n               \"%s/dbbench_sqlite3-%d.db\",\n               tmp_dir.c_str(),\n               db_num_);\n      status = sqlite3_open(file_name, &db_);\n      if (status) {\n        fprintf(stderr, \"open error: %s\\n\", sqlite3_errmsg(db_));\n        exit(1);\n      }\n  \n      // Change SQLite cache size\n      char cache_size[100];\n      snprintf(cache_size, sizeof(cache_size), \"PRAGMA cache_size = %d\",\n               FLAGS_num_pages);\n      status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n  \n      // FLAGS_page_size is defaulted to 1024\n      if (FLAGS_page_size != 1024) {\n        char page_size[100];\n        snprintf(page_size, sizeof(page_size), \"PRAGMA page_size = %d\",\n                 FLAGS_page_size);\n        status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n  \n      // Change journal mode to WAL if WAL enabled flag is on\n      if (FLAGS_WAL_enabled) {\n        std::string WAL_stmt = \"PRAGMA journal_mode = WAL\";\n  \n        // LevelDB's default cache size is a combined 4 MB\n        std::string WAL_checkpoint = \"PRAGMA wal_autocheckpoint = 4096\";\n        status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n        status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n  \n      // Change locking mode to exclusive and create tables/index for database\n      std::string locking_stmt = \"PRAGMA locking_mode = EXCLUSIVE\";\n      std::string create_stmt =\n            \"CREATE TABLE test (key blob, value blob, PRIMARY KEY(key))\";\n      std::string stmt_array[] = { locking_stmt, create_stmt };\n      int stmt_array_length = sizeof(stmt_array) / sizeof(std::string);\n      for (int i = 0; i < stmt_array_length; i++) {\n        status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n    }\n}"
  },
  {
    "function_name": "Run",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "343-415",
    "snippet": "void Run() {\n    PrintHeader();\n    Open();\n\n    const char* benchmarks = FLAGS_benchmarks;\n    while (benchmarks != NULL) {\n      const char* sep = strchr(benchmarks, ',');\n      Slice name;\n      if (sep == NULL) {\n        name = benchmarks;\n        benchmarks = NULL;\n      } else {\n        name = Slice(benchmarks, sep - benchmarks);\n        benchmarks = sep + 1;\n      }\n\n      bytes_ = 0;\n      Start();\n\n      bool known = true;\n      bool write_sync = false;\n      if (name == Slice(\"fillseq\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillseqbatch\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrandom\")) {\n        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrandbatch\")) {\n        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1000);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"overwrite\")) {\n        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"overwritebatch\")) {\n        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1000);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrandsync\")) {\n        write_sync = true;\n        Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillseqsync\")) {\n        write_sync = true;\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillrand100K\")) {\n        Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"fillseq100K\")) {\n        Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n        WalCheckpoint(db_);\n      } else if (name == Slice(\"readseq\")) {\n        ReadSequential();\n      } else if (name == Slice(\"readrandom\")) {\n        Read(RANDOM, 1);\n      } else if (name == Slice(\"readrand100K\")) {\n        int n = reads_;\n        reads_ /= 1000;\n        Read(RANDOM, 1);\n        reads_ = n;\n      } else {\n        known = false;\n        if (name != Slice()) {  // No error message for empty name\n          fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n        }\n      }\n      if (known) {\n        Stop(name);\n      }\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillseqbatch,\"\n    \"fillrandom,\"\n    \"fillrandsync,\"\n    \"fillrandbatch,\"\n    \"overwrite,\"\n    \"overwritebatch,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq,\"\n    \"readrand100K,\"\n    ;",
      "static int FLAGS_value_size = 100;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Stop",
          "args": [
            "name"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "Stop",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "276-303",
          "snippet": "void Stop(const Slice& name) {\n    double finish = Env::Default()->NowMicros() * 1e-6;\n\n    // Pretend at least one op was done in case we are running a benchmark\n    // that does not call FinishedSingleOp().\n    if (done_ < 1) done_ = 1;\n\n    if (bytes_ > 0) {\n      char rate[100];\n      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n               (bytes_ / 1048576.0) / (finish - start_));\n      if (!message_.empty()) {\n        message_  = std::string(rate) + \" \" + message_;\n      } else {\n        message_ = rate;\n      }\n    }\n\n    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n            name.ToString().c_str(),\n            (finish - start_) * 1e6 / done_,\n            (message_.empty() ? \"\" : \" \"),\n            message_.c_str());\n    if (FLAGS_histogram) {\n      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n    }\n    fflush(stdout);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_histogram = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void Stop(const Slice& name) {\n      double finish = Env::Default()->NowMicros() * 1e-6;\n  \n      // Pretend at least one op was done in case we are running a benchmark\n      // that does not call FinishedSingleOp().\n      if (done_ < 1) done_ = 1;\n  \n      if (bytes_ > 0) {\n        char rate[100];\n        snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n                 (bytes_ / 1048576.0) / (finish - start_));\n        if (!message_.empty()) {\n          message_  = std::string(rate) + \" \" + message_;\n        } else {\n          message_ = rate;\n        }\n      }\n  \n      fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n              name.ToString().c_str(),\n              (finish - start_) * 1e6 / done_,\n              (message_.empty() ? \"\" : \" \"),\n              message_.c_str());\n      if (FLAGS_histogram) {\n        fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n      }\n      fflush(stdout);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unknown benchmark '%s'\\n\"",
            "name.ToString().c_str()"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name.ToString",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "66-66",
          "snippet": "std::string ToString() const { return std::string(data_, size_); }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  std::string ToString() const { return std::string(data_, size_); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "RANDOM",
            "1"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "581-647",
          "snippet": "void Read(Order order, int entries_per_batch) {\n    int status;\n    sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;\n\n    std::string read_str = \"SELECT * FROM test WHERE key = ?\";\n    std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n    std::string end_trans_str = \"END TRANSACTION;\";\n\n    // Preparing sqlite3 statements\n    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                &begin_trans_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                &end_trans_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);\n    ErrorCheck(status);\n\n    bool transaction = (entries_per_batch > 1);\n    for (int i = 0; i < reads_; i += entries_per_batch) {\n      // Begin read transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(begin_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(begin_trans_stmt);\n        ErrorCheck(status);\n      }\n\n      // Create and execute SQL statements\n      for (int j = 0; j < entries_per_batch; j++) {\n        // Create key value\n        char key[100];\n        int k = (order == SEQUENTIAL) ? i + j : (rand_.Next() % reads_);\n        snprintf(key, sizeof(key), \"%016d\", k);\n\n        // Bind key value into read_stmt\n        status = sqlite3_bind_blob(read_stmt, 1, key, 16, SQLITE_STATIC);\n        ErrorCheck(status);\n\n        // Execute read statement\n        while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW) {}\n        StepErrorCheck(status);\n\n        // Reset SQLite statement for another use\n        status = sqlite3_clear_bindings(read_stmt);\n        ErrorCheck(status);\n        status = sqlite3_reset(read_stmt);\n        ErrorCheck(status);\n        FinishedSingleOp();\n      }\n\n      // End read transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(end_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(end_trans_stmt);\n        ErrorCheck(status);\n      }\n    }\n\n    status = sqlite3_finalize(read_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(begin_trans_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(end_trans_stmt);\n    ErrorCheck(status);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_transaction = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_transaction = true;\n\nBenchmark {\n  void Read(Order order, int entries_per_batch) {\n      int status;\n      sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;\n  \n      std::string read_str = \"SELECT * FROM test WHERE key = ?\";\n      std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n      std::string end_trans_str = \"END TRANSACTION;\";\n  \n      // Preparing sqlite3 statements\n      status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                  &begin_trans_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                  &end_trans_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);\n      ErrorCheck(status);\n  \n      bool transaction = (entries_per_batch > 1);\n      for (int i = 0; i < reads_; i += entries_per_batch) {\n        // Begin read transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(begin_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(begin_trans_stmt);\n          ErrorCheck(status);\n        }\n  \n        // Create and execute SQL statements\n        for (int j = 0; j < entries_per_batch; j++) {\n          // Create key value\n          char key[100];\n          int k = (order == SEQUENTIAL) ? i + j : (rand_.Next() % reads_);\n          snprintf(key, sizeof(key), \"%016d\", k);\n  \n          // Bind key value into read_stmt\n          status = sqlite3_bind_blob(read_stmt, 1, key, 16, SQLITE_STATIC);\n          ErrorCheck(status);\n  \n          // Execute read statement\n          while ((status = sqlite3_step(read_stmt)) == SQLITE_ROW) {}\n          StepErrorCheck(status);\n  \n          // Reset SQLite statement for another use\n          status = sqlite3_clear_bindings(read_stmt);\n          ErrorCheck(status);\n          status = sqlite3_reset(read_stmt);\n          ErrorCheck(status);\n          FinishedSingleOp();\n        }\n  \n        // End read transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(end_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(end_trans_stmt);\n          ErrorCheck(status);\n        }\n      }\n  \n      status = sqlite3_finalize(read_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(begin_trans_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(end_trans_stmt);\n      ErrorCheck(status);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"readrand100K\""
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadSequential",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ReadSequential",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "649-663",
          "snippet": "void ReadSequential() {\n    int status;\n    sqlite3_stmt *pStmt;\n    std::string read_str = \"SELECT * FROM test ORDER BY key\";\n\n    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &pStmt, NULL);\n    ErrorCheck(status);\n    for (int i = 0; i < reads_ && SQLITE_ROW == sqlite3_step(pStmt); i++) {\n      bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);\n      FinishedSingleOp();\n    }\n\n    status = sqlite3_finalize(pStmt);\n    ErrorCheck(status);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void ReadSequential() {\n      int status;\n      sqlite3_stmt *pStmt;\n      std::string read_str = \"SELECT * FROM test ORDER BY key\";\n  \n      status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &pStmt, NULL);\n      ErrorCheck(status);\n      for (int i = 0; i < reads_ && SQLITE_ROW == sqlite3_step(pStmt); i++) {\n        bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);\n        FinishedSingleOp();\n      }\n  \n      status = sqlite3_finalize(pStmt);\n      ErrorCheck(status);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WalCheckpoint",
          "args": [
            "db_"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "WalCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "106-112",
          "snippet": "inline\nstatic void WalCheckpoint(sqlite3* db_) {\n  // Flush all writes to disk\n  if (FLAGS_WAL_enabled) {\n    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);\n  }\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_WAL_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_WAL_enabled = true;\n\ninline\nstatic void WalCheckpoint(sqlite3* db_) {\n  // Flush all writes to disk\n  if (FLAGS_WAL_enabled) {\n    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "write_sync",
            "SEQUENTIAL",
            "FRESH",
            "num_ / 1000",
            "100 * 1000",
            "1"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "478-579",
          "snippet": "void Write(bool write_sync, Order order, DBState state,\n             int num_entries, int value_size, int entries_per_batch) {\n    // Create new database if state == FRESH\n    if (state == FRESH) {\n      if (FLAGS_use_existing_db) {\n        message_ = \"skipping (--use_existing_db is true)\";\n        return;\n      }\n      sqlite3_close(db_);\n      db_ = NULL;\n      Open();\n      Start();\n    }\n\n    if (num_entries != num_) {\n      char msg[100];\n      snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n      message_ = msg;\n    }\n\n    char* err_msg = NULL;\n    int status;\n\n    sqlite3_stmt *replace_stmt, *begin_trans_stmt, *end_trans_stmt;\n    std::string replace_str = \"REPLACE INTO test (key, value) VALUES (?, ?)\";\n    std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n    std::string end_trans_str = \"END TRANSACTION;\";\n\n    // Check for synchronous flag in options\n    std::string sync_stmt = (write_sync) ? \"PRAGMA synchronous = FULL\" :\n                                           \"PRAGMA synchronous = OFF\";\n    status = sqlite3_exec(db_, sync_stmt.c_str(), NULL, NULL, &err_msg);\n    ExecErrorCheck(status, err_msg);\n\n    // Preparing sqlite3 statements\n    status = sqlite3_prepare_v2(db_, replace_str.c_str(), -1,\n                                &replace_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                &begin_trans_stmt, NULL);\n    ErrorCheck(status);\n    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                &end_trans_stmt, NULL);\n    ErrorCheck(status);\n\n    bool transaction = (entries_per_batch > 1);\n    for (int i = 0; i < num_entries; i += entries_per_batch) {\n      // Begin write transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(begin_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(begin_trans_stmt);\n        ErrorCheck(status);\n      }\n\n      // Create and execute SQL statements\n      for (int j = 0; j < entries_per_batch; j++) {\n        const char* value = gen_.Generate(value_size).data();\n\n        // Create values for key-value pair\n        const int k = (order == SEQUENTIAL) ? i + j :\n                      (rand_.Next() % num_entries);\n        char key[100];\n        snprintf(key, sizeof(key), \"%016d\", k);\n\n        // Bind KV values into replace_stmt\n        status = sqlite3_bind_blob(replace_stmt, 1, key, 16, SQLITE_STATIC);\n        ErrorCheck(status);\n        status = sqlite3_bind_blob(replace_stmt, 2, value,\n                                   value_size, SQLITE_STATIC);\n        ErrorCheck(status);\n\n        // Execute replace_stmt\n        bytes_ += value_size + strlen(key);\n        status = sqlite3_step(replace_stmt);\n        StepErrorCheck(status);\n\n        // Reset SQLite statement for another use\n        status = sqlite3_clear_bindings(replace_stmt);\n        ErrorCheck(status);\n        status = sqlite3_reset(replace_stmt);\n        ErrorCheck(status);\n\n        FinishedSingleOp();\n      }\n\n      // End write transaction\n      if (FLAGS_transaction && transaction) {\n        status = sqlite3_step(end_trans_stmt);\n        StepErrorCheck(status);\n        status = sqlite3_reset(end_trans_stmt);\n        ErrorCheck(status);\n      }\n    }\n\n    status = sqlite3_finalize(replace_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(begin_trans_stmt);\n    ErrorCheck(status);\n    status = sqlite3_finalize(end_trans_stmt);\n    ErrorCheck(status);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool FLAGS_use_existing_db = false;",
            "static bool FLAGS_transaction = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_use_existing_db = false;\nstatic bool FLAGS_transaction = true;\n\nBenchmark {\n  void Write(bool write_sync, Order order, DBState state,\n               int num_entries, int value_size, int entries_per_batch) {\n      // Create new database if state == FRESH\n      if (state == FRESH) {\n        if (FLAGS_use_existing_db) {\n          message_ = \"skipping (--use_existing_db is true)\";\n          return;\n        }\n        sqlite3_close(db_);\n        db_ = NULL;\n        Open();\n        Start();\n      }\n  \n      if (num_entries != num_) {\n        char msg[100];\n        snprintf(msg, sizeof(msg), \"(%d ops)\", num_entries);\n        message_ = msg;\n      }\n  \n      char* err_msg = NULL;\n      int status;\n  \n      sqlite3_stmt *replace_stmt, *begin_trans_stmt, *end_trans_stmt;\n      std::string replace_str = \"REPLACE INTO test (key, value) VALUES (?, ?)\";\n      std::string begin_trans_str = \"BEGIN TRANSACTION;\";\n      std::string end_trans_str = \"END TRANSACTION;\";\n  \n      // Check for synchronous flag in options\n      std::string sync_stmt = (write_sync) ? \"PRAGMA synchronous = FULL\" :\n                                             \"PRAGMA synchronous = OFF\";\n      status = sqlite3_exec(db_, sync_stmt.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n  \n      // Preparing sqlite3 statements\n      status = sqlite3_prepare_v2(db_, replace_str.c_str(), -1,\n                                  &replace_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,\n                                  &begin_trans_stmt, NULL);\n      ErrorCheck(status);\n      status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,\n                                  &end_trans_stmt, NULL);\n      ErrorCheck(status);\n  \n      bool transaction = (entries_per_batch > 1);\n      for (int i = 0; i < num_entries; i += entries_per_batch) {\n        // Begin write transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(begin_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(begin_trans_stmt);\n          ErrorCheck(status);\n        }\n  \n        // Create and execute SQL statements\n        for (int j = 0; j < entries_per_batch; j++) {\n          const char* value = gen_.Generate(value_size).data();\n  \n          // Create values for key-value pair\n          const int k = (order == SEQUENTIAL) ? i + j :\n                        (rand_.Next() % num_entries);\n          char key[100];\n          snprintf(key, sizeof(key), \"%016d\", k);\n  \n          // Bind KV values into replace_stmt\n          status = sqlite3_bind_blob(replace_stmt, 1, key, 16, SQLITE_STATIC);\n          ErrorCheck(status);\n          status = sqlite3_bind_blob(replace_stmt, 2, value,\n                                     value_size, SQLITE_STATIC);\n          ErrorCheck(status);\n  \n          // Execute replace_stmt\n          bytes_ += value_size + strlen(key);\n          status = sqlite3_step(replace_stmt);\n          StepErrorCheck(status);\n  \n          // Reset SQLite statement for another use\n          status = sqlite3_clear_bindings(replace_stmt);\n          ErrorCheck(status);\n          status = sqlite3_reset(replace_stmt);\n          ErrorCheck(status);\n  \n          FinishedSingleOp();\n        }\n  \n        // End write transaction\n        if (FLAGS_transaction && transaction) {\n          status = sqlite3_step(end_trans_stmt);\n          StepErrorCheck(status);\n          status = sqlite3_reset(end_trans_stmt);\n          ErrorCheck(status);\n        }\n      }\n  \n      status = sqlite3_finalize(replace_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(begin_trans_stmt);\n      ErrorCheck(status);\n      status = sqlite3_finalize(end_trans_stmt);\n      ErrorCheck(status);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Start",
          "args": [],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "Start",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "240-248",
          "snippet": "void Start() {\n    start_ = Env::Default()->NowMicros() * 1e-6;\n    bytes_ = 0;\n    message_.clear();\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    next_report_ = 100;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void Start() {\n      start_ = Env::Default()->NowMicros() * 1e-6;\n      bytes_ = 0;\n      message_.clear();\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      next_report_ = 100;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "benchmarks",
            "sep - benchmarks"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "benchmarks",
            "','"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Open",
          "args": [],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "417-476",
          "snippet": "void Open() {\n    assert(db_ == NULL);\n\n    int status;\n    char file_name[100];\n    char* err_msg = NULL;\n    db_num_++;\n\n    // Open database\n    std::string tmp_dir;\n    Env::Default()->GetTestDirectory(&tmp_dir);\n    snprintf(file_name, sizeof(file_name),\n             \"%s/dbbench_sqlite3-%d.db\",\n             tmp_dir.c_str(),\n             db_num_);\n    status = sqlite3_open(file_name, &db_);\n    if (status) {\n      fprintf(stderr, \"open error: %s\\n\", sqlite3_errmsg(db_));\n      exit(1);\n    }\n\n    // Change SQLite cache size\n    char cache_size[100];\n    snprintf(cache_size, sizeof(cache_size), \"PRAGMA cache_size = %d\",\n             FLAGS_num_pages);\n    status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);\n    ExecErrorCheck(status, err_msg);\n\n    // FLAGS_page_size is defaulted to 1024\n    if (FLAGS_page_size != 1024) {\n      char page_size[100];\n      snprintf(page_size, sizeof(page_size), \"PRAGMA page_size = %d\",\n               FLAGS_page_size);\n      status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n\n    // Change journal mode to WAL if WAL enabled flag is on\n    if (FLAGS_WAL_enabled) {\n      std::string WAL_stmt = \"PRAGMA journal_mode = WAL\";\n\n      // LevelDB's default cache size is a combined 4 MB\n      std::string WAL_checkpoint = \"PRAGMA wal_autocheckpoint = 4096\";\n      status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n      status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n\n    // Change locking mode to exclusive and create tables/index for database\n    std::string locking_stmt = \"PRAGMA locking_mode = EXCLUSIVE\";\n    std::string create_stmt =\n          \"CREATE TABLE test (key blob, value blob, PRIMARY KEY(key))\";\n    std::string stmt_array[] = { locking_stmt, create_stmt };\n    int stmt_array_length = sizeof(stmt_array) / sizeof(std::string);\n    for (int i = 0; i < stmt_array_length; i++) {\n      status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_page_size = 1024;",
            "static int FLAGS_num_pages = 4096;",
            "static bool FLAGS_WAL_enabled = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_page_size = 1024;\nstatic int FLAGS_num_pages = 4096;\nstatic bool FLAGS_WAL_enabled = true;\n\nBenchmark {\n  void Open() {\n      assert(db_ == NULL);\n  \n      int status;\n      char file_name[100];\n      char* err_msg = NULL;\n      db_num_++;\n  \n      // Open database\n      std::string tmp_dir;\n      Env::Default()->GetTestDirectory(&tmp_dir);\n      snprintf(file_name, sizeof(file_name),\n               \"%s/dbbench_sqlite3-%d.db\",\n               tmp_dir.c_str(),\n               db_num_);\n      status = sqlite3_open(file_name, &db_);\n      if (status) {\n        fprintf(stderr, \"open error: %s\\n\", sqlite3_errmsg(db_));\n        exit(1);\n      }\n  \n      // Change SQLite cache size\n      char cache_size[100];\n      snprintf(cache_size, sizeof(cache_size), \"PRAGMA cache_size = %d\",\n               FLAGS_num_pages);\n      status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);\n      ExecErrorCheck(status, err_msg);\n  \n      // FLAGS_page_size is defaulted to 1024\n      if (FLAGS_page_size != 1024) {\n        char page_size[100];\n        snprintf(page_size, sizeof(page_size), \"PRAGMA page_size = %d\",\n                 FLAGS_page_size);\n        status = sqlite3_exec(db_, page_size, NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n  \n      // Change journal mode to WAL if WAL enabled flag is on\n      if (FLAGS_WAL_enabled) {\n        std::string WAL_stmt = \"PRAGMA journal_mode = WAL\";\n  \n        // LevelDB's default cache size is a combined 4 MB\n        std::string WAL_checkpoint = \"PRAGMA wal_autocheckpoint = 4096\";\n        status = sqlite3_exec(db_, WAL_stmt.c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n        status = sqlite3_exec(db_, WAL_checkpoint.c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n  \n      // Change locking mode to exclusive and create tables/index for database\n      std::string locking_stmt = \"PRAGMA locking_mode = EXCLUSIVE\";\n      std::string create_stmt =\n            \"CREATE TABLE test (key blob, value blob, PRIMARY KEY(key))\";\n      std::string stmt_array[] = { locking_stmt, create_stmt };\n      int stmt_array_length = sizeof(stmt_array) / sizeof(std::string);\n      for (int i = 0; i < stmt_array_length; i++) {\n        status = sqlite3_exec(db_, stmt_array[i].c_str(), NULL, NULL, &err_msg);\n        ExecErrorCheck(status, err_msg);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintHeader",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "PrintHeader",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "181-192",
          "snippet": "void PrintHeader() {\n    const int kKeySize = 16;\n    PrintEnvironment();\n    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n    fprintf(stdout, \"Values:     %d bytes each\\n\", FLAGS_value_size);\n    fprintf(stdout, \"Entries:    %d\\n\", num_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0));\n    PrintWarnings();\n    fprintf(stdout, \"------------------------------------------------\\n\");\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int FLAGS_value_size = 100;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_value_size = 100;\n\nBenchmark {\n  void PrintHeader() {\n      const int kKeySize = 16;\n      PrintEnvironment();\n      fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n      fprintf(stdout, \"Values:     %d bytes each\\n\", FLAGS_value_size);\n      fprintf(stdout, \"Entries:    %d\\n\", num_);\n      fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n              ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n               / 1048576.0));\n      PrintWarnings();\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic const char* FLAGS_benchmarks =\n    \"fillseq,\"\n    \"fillseqsync,\"\n    \"fillseqbatch,\"\n    \"fillrandom,\"\n    \"fillrandsync,\"\n    \"fillrandbatch,\"\n    \"overwrite,\"\n    \"overwritebatch,\"\n    \"readrandom,\"\n    \"readseq,\"\n    \"fillrand100K,\"\n    \"fillseq100K,\"\n    \"readseq,\"\n    \"readrand100K,\"\n    ;\nstatic int FLAGS_value_size = 100;\n\nBenchmark {\n  void Run() {\n      PrintHeader();\n      Open();\n  \n      const char* benchmarks = FLAGS_benchmarks;\n      while (benchmarks != NULL) {\n        const char* sep = strchr(benchmarks, ',');\n        Slice name;\n        if (sep == NULL) {\n          name = benchmarks;\n          benchmarks = NULL;\n        } else {\n          name = Slice(benchmarks, sep - benchmarks);\n          benchmarks = sep + 1;\n        }\n  \n        bytes_ = 0;\n        Start();\n  \n        bool known = true;\n        bool write_sync = false;\n        if (name == Slice(\"fillseq\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillseqbatch\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrandom\")) {\n          Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrandbatch\")) {\n          Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1000);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"overwrite\")) {\n          Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"overwritebatch\")) {\n          Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1000);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrandsync\")) {\n          write_sync = true;\n          Write(write_sync, RANDOM, FRESH, num_ / 100, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillseqsync\")) {\n          write_sync = true;\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 100, FLAGS_value_size, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillrand100K\")) {\n          Write(write_sync, RANDOM, FRESH, num_ / 1000, 100 * 1000, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"fillseq100K\")) {\n          Write(write_sync, SEQUENTIAL, FRESH, num_ / 1000, 100 * 1000, 1);\n          WalCheckpoint(db_);\n        } else if (name == Slice(\"readseq\")) {\n          ReadSequential();\n        } else if (name == Slice(\"readrandom\")) {\n          Read(RANDOM, 1);\n        } else if (name == Slice(\"readrand100K\")) {\n          int n = reads_;\n          reads_ /= 1000;\n          Read(RANDOM, 1);\n          reads_ = n;\n        } else {\n          known = false;\n          if (name != Slice()) {  // No error message for empty name\n            fprintf(stderr, \"unknown benchmark '%s'\\n\", name.ToString().c_str());\n          }\n        }\n        if (known) {\n          Stop(name);\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "Benchmark",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "315-336",
    "snippet": "Benchmark()\n  : db_(NULL),\n    db_num_(0),\n    num_(FLAGS_num),\n    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n    bytes_(0),\n    rand_(301) {\n    std::vector<std::string> files;\n    std::string test_dir;\n    Env::Default()->GetTestDirectory(&test_dir);\n    Env::Default()->GetChildren(test_dir, &files);\n    if (!FLAGS_use_existing_db) {\n      for (int i = 0; i < files.size(); i++) {\n        if (Slice(files[i]).starts_with(\"dbbench_sqlite3\")) {\n          std::string file_name(test_dir);\n          file_name += \"/\";\n          file_name += files[i];\n          Env::Default()->DeleteFile(file_name.c_str());\n        }\n      }\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_num = 1000000;",
      "static int FLAGS_reads = -1;",
      "static bool FLAGS_use_existing_db = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "file_name.c_str()"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_name.c_str",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"dbbench_sqlite3\""
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "test_dir",
            "&files"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "&test_dir"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_num = 1000000;\nstatic int FLAGS_reads = -1;\nstatic bool FLAGS_use_existing_db = false;\n\nBenchmark {\n  Benchmark()\n    : db_(NULL),\n      db_num_(0),\n      num_(FLAGS_num),\n      reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n      bytes_(0),\n      rand_(301) {\n      std::vector<std::string> files;\n      std::string test_dir;\n      Env::Default()->GetTestDirectory(&test_dir);\n      Env::Default()->GetChildren(test_dir, &files);\n      if (!FLAGS_use_existing_db) {\n        for (int i = 0; i < files.size(); i++) {\n          if (Slice(files[i]).starts_with(\"dbbench_sqlite3\")) {\n            std::string file_name(test_dir);\n            file_name += \"/\";\n            file_name += files[i];\n            Env::Default()->DeleteFile(file_name.c_str());\n          }\n        }\n      }\n    }\n}"
  },
  {
    "function_name": "Stop",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "276-303",
    "snippet": "void Stop(const Slice& name) {\n    double finish = Env::Default()->NowMicros() * 1e-6;\n\n    // Pretend at least one op was done in case we are running a benchmark\n    // that does not call FinishedSingleOp().\n    if (done_ < 1) done_ = 1;\n\n    if (bytes_ > 0) {\n      char rate[100];\n      snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n               (bytes_ / 1048576.0) / (finish - start_));\n      if (!message_.empty()) {\n        message_  = std::string(rate) + \" \" + message_;\n      } else {\n        message_ = rate;\n      }\n    }\n\n    fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n            name.ToString().c_str(),\n            (finish - start_) * 1e6 / done_,\n            (message_.empty() ? \"\" : \" \"),\n            message_.c_str());\n    if (FLAGS_histogram) {\n      fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n    }\n    fflush(stdout);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_histogram = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Microseconds per op:\\n%s\\n\"",
            "hist_.ToString().c_str()"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_.ToString",
          "args": [],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%-12s : %11.3f micros/op;%s%s\\n\"",
            "name.ToString().c_str()",
            "(finish - start_) * 1e6 / done_",
            "(message_.empty() ? \"\" : \" \")",
            "message_.c_str()"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message_.c_str",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "message_.empty",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "rate"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "rate",
            "sizeof(rate)",
            "\"%6.1f MB/s\"",
            "(bytes_ / 1048576.0) / (finish - start_)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void Stop(const Slice& name) {\n      double finish = Env::Default()->NowMicros() * 1e-6;\n  \n      // Pretend at least one op was done in case we are running a benchmark\n      // that does not call FinishedSingleOp().\n      if (done_ < 1) done_ = 1;\n  \n      if (bytes_ > 0) {\n        char rate[100];\n        snprintf(rate, sizeof(rate), \"%6.1f MB/s\",\n                 (bytes_ / 1048576.0) / (finish - start_));\n        if (!message_.empty()) {\n          message_  = std::string(rate) + \" \" + message_;\n        } else {\n          message_ = rate;\n        }\n      }\n  \n      fprintf(stdout, \"%-12s : %11.3f micros/op;%s%s\\n\",\n              name.ToString().c_str(),\n              (finish - start_) * 1e6 / done_,\n              (message_.empty() ? \"\" : \" \"),\n              message_.c_str());\n      if (FLAGS_histogram) {\n        fprintf(stdout, \"Microseconds per op:\\n%s\\n\", hist_.ToString().c_str());\n      }\n      fflush(stdout);\n    }\n}"
  },
  {
    "function_name": "FinishedSingleOp",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "250-274",
    "snippet": "void FinishedSingleOp() {\n    if (FLAGS_histogram) {\n      double now = Env::Default()->NowMicros() * 1e-6;\n      double micros = (now - last_op_finish_) * 1e6;\n      hist_.Add(micros);\n      if (micros > 20000) {\n        fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n        fflush(stderr);\n      }\n      last_op_finish_ = now;\n    }\n\n    done_++;\n    if (done_ >= next_report_) {\n      if      (next_report_ < 1000)   next_report_ += 100;\n      else if (next_report_ < 5000)   next_report_ += 500;\n      else if (next_report_ < 10000)  next_report_ += 1000;\n      else if (next_report_ < 50000)  next_report_ += 5000;\n      else if (next_report_ < 100000) next_report_ += 10000;\n      else if (next_report_ < 500000) next_report_ += 50000;\n      else                            next_report_ += 100000;\n      fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n      fflush(stderr);\n    }\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_histogram = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"... finished %d ops%30s\\r\"",
            "done_",
            "\"\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stderr"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"long op: %.1f micros%30s\\r\"",
            "micros",
            "\"\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_.Add",
          "args": [
            "micros"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "CCheckQueueControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkqueue.h",
          "lines": "181-184",
          "snippet": "void Add(std::vector<T> &vChecks) {\n        if (pqueue != NULL)\n            pqueue->Add(vChecks);\n    }",
          "includes": [
            "#include <algorithm>",
            "#include <vector>",
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <vector>\n#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/mutex.hpp>\n\nCCheckQueueControl {\n  void Add(std::vector<T> &vChecks) {\n          if (pqueue != NULL)\n              pqueue->Add(vChecks);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_histogram = false;\n\nBenchmark {\n  void FinishedSingleOp() {\n      if (FLAGS_histogram) {\n        double now = Env::Default()->NowMicros() * 1e-6;\n        double micros = (now - last_op_finish_) * 1e6;\n        hist_.Add(micros);\n        if (micros > 20000) {\n          fprintf(stderr, \"long op: %.1f micros%30s\\r\", micros, \"\");\n          fflush(stderr);\n        }\n        last_op_finish_ = now;\n      }\n  \n      done_++;\n      if (done_ >= next_report_) {\n        if      (next_report_ < 1000)   next_report_ += 100;\n        else if (next_report_ < 5000)   next_report_ += 500;\n        else if (next_report_ < 10000)  next_report_ += 1000;\n        else if (next_report_ < 50000)  next_report_ += 5000;\n        else if (next_report_ < 100000) next_report_ += 10000;\n        else if (next_report_ < 500000) next_report_ += 50000;\n        else                            next_report_ += 100000;\n        fprintf(stderr, \"... finished %d ops%30s\\r\", done_, \"\");\n        fflush(stderr);\n      }\n    }\n}"
  },
  {
    "function_name": "Start",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "240-248",
    "snippet": "void Start() {\n    start_ = Env::Default()->NowMicros() * 1e-6;\n    bytes_ = 0;\n    message_.clear();\n    last_op_finish_ = start_;\n    hist_.Clear();\n    done_ = 0;\n    next_report_ = 100;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_.Clear",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "Histogram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/histogram.cc",
          "lines": "33-42",
          "snippet": "void Histogram::Clear() {\n  min_ = kBucketLimit[kNumBuckets-1];\n  max_ = 0;\n  num_ = 0;\n  sum_ = 0;\n  sum_squares_ = 0;\n  for (int i = 0; i < kNumBuckets; i++) {\n    buckets_[i] = 0;\n  }\n}",
          "includes": [
            "#include \"util/histogram.h\"",
            "#include \"port/port.h\"",
            "#include <stdio.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/histogram.h\"\n#include \"port/port.h\"\n#include <stdio.h>\n#include <math.h>\n\nHistogram {\n  void Histogram::Clear() {\n    min_ = kBucketLimit[kNumBuckets-1];\n    max_ = 0;\n    num_ = 0;\n    sum_ = 0;\n    sum_squares_ = 0;\n    for (int i = 0; i < kNumBuckets; i++) {\n      buckets_[i] = 0;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "message_.clear",
          "args": [],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void Start() {\n      start_ = Env::Default()->NowMicros() * 1e-6;\n      bytes_ = 0;\n      message_.clear();\n      last_op_finish_ = start_;\n      hist_.Clear();\n      done_ = 0;\n      next_report_ = 100;\n    }\n}"
  },
  {
    "function_name": "PrintEnvironment",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "206-238",
    "snippet": "void PrintEnvironment() {\n    fprintf(stderr, \"SQLite:     version %s\\n\", SQLITE_VERSION);\n\n#if defined(__linux)\n    time_t now = time(NULL);\n    fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n\n    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n    if (cpuinfo != NULL) {\n      char line[1000];\n      int num_cpus = 0;\n      std::string cpu_type;\n      std::string cache_size;\n      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        const char* sep = strchr(line, ':');\n        if (sep == NULL) {\n          continue;\n        }\n        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n        Slice val = TrimSpace(Slice(sep + 1));\n        if (key == \"model name\") {\n          ++num_cpus;\n          cpu_type = val.ToString();\n        } else if (key == \"cache size\") {\n          cache_size = val.ToString();\n        }\n      }\n      fclose(cpuinfo);\n      fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n      fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n    }\n#endif\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CPUCache:   %s\\n\"",
            "cache_size.c_str()"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_size.c_str",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"CPU:        %d * %s\\n\"",
            "num_cpus",
            "cpu_type.c_str()"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_type.c_str",
          "args": [],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "cpuinfo"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val.ToString",
          "args": [],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TrimSpace",
          "args": [
            "Slice(sep + 1)"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "TrimSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "149-159",
          "snippet": "static Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "sep + 1"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "line",
            "sep - 1 - line"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "line",
            "':'"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "sizeof(line)",
            "cpuinfo"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "\"/proc/cpuinfo\"",
            "\"r\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Date:       %s\"",
            "ctime(&now)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctime",
          "args": [
            "&now"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "pt_to_time_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcdump.cpp",
          "lines": "38-43",
          "snippet": "std::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}",
          "includes": [
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/variant/get.hpp>",
            "#include <boost/date_time/posix_time/posix_time.hpp>",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\" // for pwalletMain",
            "#include <fstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string.hpp>\n#include <boost/variant/get.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"bitcoinrpc.h\"\n#include \"init.h\" // for pwalletMain\n#include <fstream>\n#include <iostream>\n\nstd::time_t pt_to_time_t(const bt::ptime& pt)\n{\n    bt::ptime timet_start(boost::gregorian::date(1970,1,1));\n    bt::time_duration diff = pt - timet_start;\n    return diff.ticks()/bt::time_duration::rep_type::ticks_per_second;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SQLite:     version %s\\n\"",
            "SQLITE_VERSION"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintEnvironment() {\n      fprintf(stderr, \"SQLite:     version %s\\n\", SQLITE_VERSION);\n  \n  #if defined(__linux)\n      time_t now = time(NULL);\n      fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n  \n      FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n      if (cpuinfo != NULL) {\n        char line[1000];\n        int num_cpus = 0;\n        std::string cpu_type;\n        std::string cache_size;\n        while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n          const char* sep = strchr(line, ':');\n          if (sep == NULL) {\n            continue;\n          }\n          Slice key = TrimSpace(Slice(line, sep - 1 - line));\n          Slice val = TrimSpace(Slice(sep + 1));\n          if (key == \"model name\") {\n            ++num_cpus;\n            cpu_type = val.ToString();\n          } else if (key == \"cache size\") {\n            cache_size = val.ToString();\n          }\n        }\n        fclose(cpuinfo);\n        fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n        fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n      }\n  #endif\n    }\n}"
  },
  {
    "function_name": "PrintWarnings",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "194-204",
    "snippet": "void PrintWarnings() {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n    fprintf(stdout,\n            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n            );\n#endif\n#ifndef NDEBUG\n    fprintf(stdout,\n            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintWarnings() {\n  #if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(stdout,\n              \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n              );\n  #endif\n  #ifndef NDEBUG\n      fprintf(stdout,\n              \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n  #endif\n    }\n}"
  },
  {
    "function_name": "PrintHeader",
    "container": "Benchmark",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "181-192",
    "snippet": "void PrintHeader() {\n    const int kKeySize = 16;\n    PrintEnvironment();\n    fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n    fprintf(stdout, \"Values:     %d bytes each\\n\", FLAGS_value_size);\n    fprintf(stdout, \"Entries:    %d\\n\", num_);\n    fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0));\n    PrintWarnings();\n    fprintf(stdout, \"------------------------------------------------\\n\");\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int FLAGS_value_size = 100;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"------------------------------------------------\\n\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintWarnings",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "PrintWarnings",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "194-204",
          "snippet": "void PrintWarnings() {\n#if defined(__GNUC__) && !defined(__OPTIMIZE__)\n    fprintf(stdout,\n            \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n            );\n#endif\n#ifndef NDEBUG\n    fprintf(stdout,\n            \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n#endif\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintWarnings() {\n  #if defined(__GNUC__) && !defined(__OPTIMIZE__)\n      fprintf(stdout,\n              \"WARNING: Optimization is disabled: benchmarks unnecessarily slow\\n\"\n              );\n  #endif\n  #ifndef NDEBUG\n      fprintf(stdout,\n              \"WARNING: Assertions are enabled; benchmarks unnecessarily slow\\n\");\n  #endif\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"RawSize:    %.1f MB (estimated)\\n\"",
            "((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n             / 1048576.0)"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int64_t>",
          "args": [
            "kKeySize + FLAGS_value_size"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Entries:    %d\\n\"",
            "num_"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Values:     %d bytes each\\n\"",
            "FLAGS_value_size"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"Keys:       %d bytes each\\n\"",
            "kKeySize"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintEnvironment",
          "args": [],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "PrintEnvironment",
          "container": "Benchmark",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
          "lines": "206-238",
          "snippet": "void PrintEnvironment() {\n    fprintf(stderr, \"SQLite:     version %s\\n\", SQLITE_VERSION);\n\n#if defined(__linux)\n    time_t now = time(NULL);\n    fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n\n    FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n    if (cpuinfo != NULL) {\n      char line[1000];\n      int num_cpus = 0;\n      std::string cpu_type;\n      std::string cache_size;\n      while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n        const char* sep = strchr(line, ':');\n        if (sep == NULL) {\n          continue;\n        }\n        Slice key = TrimSpace(Slice(line, sep - 1 - line));\n        Slice val = TrimSpace(Slice(sep + 1));\n        if (key == \"model name\") {\n          ++num_cpus;\n          cpu_type = val.ToString();\n        } else if (key == \"cache size\") {\n          cache_size = val.ToString();\n        }\n      }\n      fclose(cpuinfo);\n      fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n      fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n    }\n#endif\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/random.h\"",
            "#include \"util/histogram.h\"",
            "#include <sqlite3.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nBenchmark {\n  void PrintEnvironment() {\n      fprintf(stderr, \"SQLite:     version %s\\n\", SQLITE_VERSION);\n  \n  #if defined(__linux)\n      time_t now = time(NULL);\n      fprintf(stderr, \"Date:       %s\", ctime(&now));  // ctime() adds newline\n  \n      FILE* cpuinfo = fopen(\"/proc/cpuinfo\", \"r\");\n      if (cpuinfo != NULL) {\n        char line[1000];\n        int num_cpus = 0;\n        std::string cpu_type;\n        std::string cache_size;\n        while (fgets(line, sizeof(line), cpuinfo) != NULL) {\n          const char* sep = strchr(line, ':');\n          if (sep == NULL) {\n            continue;\n          }\n          Slice key = TrimSpace(Slice(line, sep - 1 - line));\n          Slice val = TrimSpace(Slice(sep + 1));\n          if (key == \"model name\") {\n            ++num_cpus;\n            cpu_type = val.ToString();\n          } else if (key == \"cache size\") {\n            cache_size = val.ToString();\n          }\n        }\n        fclose(cpuinfo);\n        fprintf(stderr, \"CPU:        %d * %s\\n\", num_cpus, cpu_type.c_str());\n        fprintf(stderr, \"CPUCache:   %s\\n\", cache_size.c_str());\n      }\n  #endif\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int FLAGS_value_size = 100;\n\nBenchmark {\n  void PrintHeader() {\n      const int kKeySize = 16;\n      PrintEnvironment();\n      fprintf(stdout, \"Keys:       %d bytes each\\n\", kKeySize);\n      fprintf(stdout, \"Values:     %d bytes each\\n\", FLAGS_value_size);\n      fprintf(stdout, \"Entries:    %d\\n\", num_);\n      fprintf(stdout, \"RawSize:    %.1f MB (estimated)\\n\",\n              ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)\n               / 1048576.0));\n      PrintWarnings();\n      fprintf(stdout, \"------------------------------------------------\\n\");\n    }\n}"
  },
  {
    "function_name": "TrimSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "149-159",
    "snippet": "static Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "s.data() + start",
            "limit - start"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.data",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "s[limit-1]"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.size",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "s[start]"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic Slice TrimSpace(Slice s) {\n  int start = 0;\n  while (start < s.size() && isspace(s[start])) {\n    start++;\n  }\n  int limit = s.size();\n  while (limit > start && isspace(s[limit-1])) {\n    limit--;\n  }\n  return Slice(s.data() + start, limit - start);\n}"
  },
  {
    "function_name": "Generate",
    "container": "RandomGenerator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "139-146",
    "snippet": "Slice Generate(int len) {\n    if (pos_ + len > data_.size()) {\n      pos_ = 0;\n      assert(len < data_.size());\n    }\n    pos_ += len;\n    return Slice(data_.data() + pos_ - len, len);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "data_.data() + pos_ - len",
            "len"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_.data",
          "args": [],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "len < data_.size()"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "data_.size",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nRandomGenerator {\n  Slice Generate(int len) {\n      if (pos_ + len > data_.size()) {\n        pos_ = 0;\n        assert(len < data_.size());\n      }\n      pos_ += len;\n      return Slice(data_.data() + pos_ - len, len);\n    }\n}"
  },
  {
    "function_name": "RandomGenerator",
    "container": "RandomGenerator",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "124-137",
    "snippet": "RandomGenerator() {\n    // We use a limited amount of data over and over again and ensure\n    // that it is larger than the compression window (32KB), and also\n    // large enough to serve all typical value sizes we want to write.\n    Random rnd(301);\n    std::string piece;\n    while (data_.size() < 1048576) {\n      // Add a short fragment that is as compressible as specified\n      // by FLAGS_compression_ratio.\n      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n      data_.append(piece);\n    }\n    pos_ = 0;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static double FLAGS_compression_ratio = 0.5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "data_.append",
          "args": [
            "piece"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::CompressibleString",
          "args": [
            "&rnd",
            "FLAGS_compression_ratio",
            "100",
            "&piece"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "CompressibleString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testutil.cc",
          "lines": "34-48",
          "snippet": "extern Slice CompressibleString(Random* rnd, double compressed_fraction,\n                                size_t len, std::string* dst) {\n  int raw = static_cast<int>(len * compressed_fraction);\n  if (raw < 1) raw = 1;\n  std::string raw_data;\n  RandomString(rnd, raw, &raw_data);\n\n  // Duplicate the random data until we have filled \"len\" bytes\n  dst->clear();\n  while (dst->size() < len) {\n    dst->append(raw_data);\n  }\n  dst->resize(len);\n  return Slice(*dst);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/testutil.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/testutil.h\"\n\nextern Slice CompressibleString(Random* rnd, double compressed_fraction,\n                                size_t len, std::string* dst) {\n  int raw = static_cast<int>(len * compressed_fraction);\n  if (raw < 1) raw = 1;\n  std::string raw_data;\n  RandomString(rnd, raw, &raw_data);\n\n  // Duplicate the random data until we have filled \"len\" bytes\n  dst->clear();\n  while (dst->size() < len) {\n    dst->append(raw_data);\n  }\n  dst->resize(len);\n  return Slice(*dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_.size",
          "args": [],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic double FLAGS_compression_ratio = 0.5;\n\nRandomGenerator {\n  RandomGenerator() {\n      // We use a limited amount of data over and over again and ensure\n      // that it is larger than the compression window (32KB), and also\n      // large enough to serve all typical value sizes we want to write.\n      Random rnd(301);\n      std::string piece;\n      while (data_.size() < 1048576) {\n        // Add a short fragment that is as compressible as specified\n        // by FLAGS_compression_ratio.\n        test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);\n        data_.append(piece);\n      }\n      pos_ = 0;\n    }\n}"
  },
  {
    "function_name": "WalCheckpoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "106-112",
    "snippet": "inline\nstatic void WalCheckpoint(sqlite3* db_) {\n  // Flush all writes to disk\n  if (FLAGS_WAL_enabled) {\n    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);\n  }\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool FLAGS_WAL_enabled = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sqlite3_wal_checkpoint_v2",
          "args": [
            "db_",
            "NULL",
            "SQLITE_CHECKPOINT_FULL",
            "NULL",
            "NULL"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic bool FLAGS_WAL_enabled = true;\n\ninline\nstatic void WalCheckpoint(sqlite3* db_) {\n  // Flush all writes to disk\n  if (FLAGS_WAL_enabled) {\n    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);\n  }\n}"
  },
  {
    "function_name": "ErrorCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "98-104",
    "snippet": "inline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"sqlite3 error: status = %d\\n\"",
            "status"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void ErrorCheck(int status) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"sqlite3 error: status = %d\\n\", status);\n    exit(1);\n  }\n}"
  },
  {
    "function_name": "StepErrorCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "90-96",
    "snippet": "inline\nstatic void StepErrorCheck(int status) {\n  if (status != SQLITE_DONE) {\n    fprintf(stderr, \"SQL step error: status = %d\\n\", status);\n    exit(1);\n  }\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SQL step error: status = %d\\n\"",
            "status"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void StepErrorCheck(int status) {\n  if (status != SQLITE_DONE) {\n    fprintf(stderr, \"SQL step error: status = %d\\n\", status);\n    exit(1);\n  }\n}"
  },
  {
    "function_name": "ExecErrorCheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/doc/bench/db_bench_sqlite3.cc",
    "lines": "81-88",
    "snippet": "inline\nstatic void ExecErrorCheck(int status, char *err_msg) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"SQL error: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/random.h\"",
      "#include \"util/histogram.h\"",
      "#include <sqlite3.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqlite3_free",
          "args": [
            "err_msg"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"SQL error: %s\\n\"",
            "err_msg"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/random.h\"\n#include \"util/histogram.h\"\n#include <sqlite3.h>\n#include <stdlib.h>\n#include <stdio.h>\n\ninline\nstatic void ExecErrorCheck(int status, char *err_msg) {\n  if (status != SQLITE_OK) {\n    fprintf(stderr, \"SQL error: %s\\n\", err_msg);\n    sqlite3_free(err_msg);\n    exit(1);\n  }\n}"
  }
]