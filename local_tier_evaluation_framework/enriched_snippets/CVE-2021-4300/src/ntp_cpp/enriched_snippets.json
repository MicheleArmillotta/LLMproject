[
  {
    "function_name": "ThreadNtpPoller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
    "lines": "424-502",
    "snippet": "void ThreadNtpPoller(void *parg) {\n    int i;\n    int64 nTime, nSystemTime;\n\n    printf(\"ThreadNtpPoller started\\n\");\n    vnThreadsRunning[THREAD_NTP]++;\n\n    /* Make this thread recognisable */\n    RenameThread(\"orb-ntppoll\");\n\n    while(!fShutdown) {\n        if(strTrustedNTP != \"localhost\") {\n\n            /* Obtain a time sample from a trusted NTP server */\n            nTime = NtpGetTime(strTrustedNTP);\n\n            nSystemTime = GetTime();\n\n            /* Calculate a time offset */\n            if((nTime > 0) && (nTime != 2085978496))\n              nNtpOffset = nTime - nSystemTime;\n            else {\n                printf(\"ThreadNtpPoller() : invalid response from the trusted NTP server %s, \"\n                  \"fail over to a random NTP server\\n\", strTrustedNTP.c_str());\n                nNtpOffset = INT64_MAX;\n                strTrustedNTP = \"localhost\";\n                continue;\n            }\n\n        } else {\n\n            CNetAddr ip;\n\n            /* Obtain a time sample from a random NTP server */\n            nTime = NtpGetTime(ip);\n\n            nSystemTime = GetTime();\n\n            /* Calculate a time offset */\n            if((nTime > 0) && (nTime != 2085978496))\n              nNtpOffset = nTime - nSystemTime;\n            else {\n                int nSleepMinutes = 1 + GetRandInt(9);\n                for(i = 0; (i < nSleepMinutes * 60) && !fShutdown; i++)\n                  MilliSleep(1000);\n                continue;\n            }\n\n        }\n\n        /* Issue a warning if the system time is way off */\n        if(!fNtpWarning && (abs64(nNtpOffset) > 5 * 60)) {\n            fNtpWarning = true;\n            string strMessage = _(\"Warning: Please check your date and time! Halcyon will not work properly if they are incorrect.\");\n            strMiscWarning = strMessage;\n            printf(\"*** %s\\n\", strMessage.c_str());\n            uiInterface.ThreadSafeMessageBox(strMessage+\" \", string(\"Halcyon\"),\n              CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION);\n        }\n\n        /* Remove the warning if back to normal */\n        if(fNtpWarning && (abs64(nNtpOffset) <= 5 * 60)) {\n            strMiscWarning.clear();\n            fNtpWarning = false;\n        }\n\n        int nSleepHours = 1 + GetRandInt(5);\n\n        printf(\"ThreadNtpPoller() : nNtpOffset = %+\" PRI64d \" seconds, \"\n          \"the next sync in %d hours\\n\", nNtpOffset, nSleepHours);\n\n        for(i = 0; (i < nSleepHours * 60 * 60) && !fShutdown; i++)\n          MilliSleep(1000);\n\n    }\n\n    vnThreadsRunning[THREAD_NTP]--;\n    printf(\"ThreadNtpPoller exited\\n\");\n}",
    "includes": [
      "#include \"ui_interface.h\"",
      "#include \"net.h\"",
      "#include \"netbase.h\"",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <winsock2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadNtpPoller exited\\n\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "1000"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadNtpPoller() : nNtpOffset = %+\" PRI64d \" seconds, \"\n          \"the next sync in %d hours\\n\"",
            "nNtpOffset",
            "nSleepHours"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "5"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strMiscWarning.clear",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs64",
          "args": [
            "nNtpOffset"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "abs64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "307-310",
          "snippet": "inline int64_t abs64(int64_t n)\n{\n    return (n >= 0 ? n : -n);\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t abs64(int64_t n)\n{\n    return (n >= 0 ? n : -n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiInterface.ThreadSafeMessageBox",
          "args": [
            "strMessage+\" \"",
            "string(\"Halcyon\")",
            "CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadSafeMessageBox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "38-56",
          "snippet": "static void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BitcoinGUI *guiref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic BitcoinGUI *guiref;\n\nstatic void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"Halcyon\""
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"*** %s\\n\"",
            "strMessage.c_str()"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strMessage.c_str",
          "args": [],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Warning: Please check your date and time! Halcyon will not work properly if they are incorrect.\""
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "NtpGetTime",
          "args": [
            "ip"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "NtpGetTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
          "lines": "391-413",
          "snippet": "int64 NtpGetTime(const std::string &strHostName) {\n    int64 nTime;\n    SOCKET sockfd;\n    socklen_t servlen;\n    struct sockaddr cliaddr;\n\n    if(!InitWithHost(strHostName, sockfd, servlen, &cliaddr))\n      return(-1);\n\n    CNetAddr ip = ((sockaddr_in *) &cliaddr)->sin_addr;\n    printf(\"NtpGetTime() : querying an NTP server %s\\n\", ip.ToStringIP().c_str());\n\n    nTime = DoReq(sockfd, servlen, cliaddr);\n\n    closesocket(sockfd);\n\n    if((nTime > 0) && (nTime != 2085978496)) {\n        printf(\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\",\n          nTime, nTime - GetTime(), ip.ToStringIP().c_str());\n    }\n\n    return(nTime);\n}",
          "includes": [
            "#include \"ui_interface.h\"",
            "#include \"net.h\"",
            "#include \"netbase.h\"",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nint64 NtpGetTime(const std::string &strHostName) {\n    int64 nTime;\n    SOCKET sockfd;\n    socklen_t servlen;\n    struct sockaddr cliaddr;\n\n    if(!InitWithHost(strHostName, sockfd, servlen, &cliaddr))\n      return(-1);\n\n    CNetAddr ip = ((sockaddr_in *) &cliaddr)->sin_addr;\n    printf(\"NtpGetTime() : querying an NTP server %s\\n\", ip.ToStringIP().c_str());\n\n    nTime = DoReq(sockfd, servlen, cliaddr);\n\n    closesocket(sockfd);\n\n    if((nTime > 0) && (nTime != 2085978496)) {\n        printf(\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\",\n          nTime, nTime - GetTime(), ip.ToStringIP().c_str());\n    }\n\n    return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strTrustedNTP.c_str",
          "args": [],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"orb-ntppoll\""
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadNtpPoller started\\n\""
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nvoid ThreadNtpPoller(void *parg) {\n    int i;\n    int64 nTime, nSystemTime;\n\n    printf(\"ThreadNtpPoller started\\n\");\n    vnThreadsRunning[THREAD_NTP]++;\n\n    /* Make this thread recognisable */\n    RenameThread(\"orb-ntppoll\");\n\n    while(!fShutdown) {\n        if(strTrustedNTP != \"localhost\") {\n\n            /* Obtain a time sample from a trusted NTP server */\n            nTime = NtpGetTime(strTrustedNTP);\n\n            nSystemTime = GetTime();\n\n            /* Calculate a time offset */\n            if((nTime > 0) && (nTime != 2085978496))\n              nNtpOffset = nTime - nSystemTime;\n            else {\n                printf(\"ThreadNtpPoller() : invalid response from the trusted NTP server %s, \"\n                  \"fail over to a random NTP server\\n\", strTrustedNTP.c_str());\n                nNtpOffset = INT64_MAX;\n                strTrustedNTP = \"localhost\";\n                continue;\n            }\n\n        } else {\n\n            CNetAddr ip;\n\n            /* Obtain a time sample from a random NTP server */\n            nTime = NtpGetTime(ip);\n\n            nSystemTime = GetTime();\n\n            /* Calculate a time offset */\n            if((nTime > 0) && (nTime != 2085978496))\n              nNtpOffset = nTime - nSystemTime;\n            else {\n                int nSleepMinutes = 1 + GetRandInt(9);\n                for(i = 0; (i < nSleepMinutes * 60) && !fShutdown; i++)\n                  MilliSleep(1000);\n                continue;\n            }\n\n        }\n\n        /* Issue a warning if the system time is way off */\n        if(!fNtpWarning && (abs64(nNtpOffset) > 5 * 60)) {\n            fNtpWarning = true;\n            string strMessage = _(\"Warning: Please check your date and time! Halcyon will not work properly if they are incorrect.\");\n            strMiscWarning = strMessage;\n            printf(\"*** %s\\n\", strMessage.c_str());\n            uiInterface.ThreadSafeMessageBox(strMessage+\" \", string(\"Halcyon\"),\n              CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION);\n        }\n\n        /* Remove the warning if back to normal */\n        if(fNtpWarning && (abs64(nNtpOffset) <= 5 * 60)) {\n            strMiscWarning.clear();\n            fNtpWarning = false;\n        }\n\n        int nSleepHours = 1 + GetRandInt(5);\n\n        printf(\"ThreadNtpPoller() : nNtpOffset = %+\" PRI64d \" seconds, \"\n          \"the next sync in %d hours\\n\", nNtpOffset, nSleepHours);\n\n        for(i = 0; (i < nSleepHours * 60 * 60) && !fShutdown; i++)\n          MilliSleep(1000);\n\n    }\n\n    vnThreadsRunning[THREAD_NTP]--;\n    printf(\"ThreadNtpPoller exited\\n\");\n}"
  },
  {
    "function_name": "NtpGetTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
    "lines": "391-413",
    "snippet": "int64 NtpGetTime(const std::string &strHostName) {\n    int64 nTime;\n    SOCKET sockfd;\n    socklen_t servlen;\n    struct sockaddr cliaddr;\n\n    if(!InitWithHost(strHostName, sockfd, servlen, &cliaddr))\n      return(-1);\n\n    CNetAddr ip = ((sockaddr_in *) &cliaddr)->sin_addr;\n    printf(\"NtpGetTime() : querying an NTP server %s\\n\", ip.ToStringIP().c_str());\n\n    nTime = DoReq(sockfd, servlen, cliaddr);\n\n    closesocket(sockfd);\n\n    if((nTime > 0) && (nTime != 2085978496)) {\n        printf(\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\",\n          nTime, nTime - GetTime(), ip.ToStringIP().c_str());\n    }\n\n    return(nTime);\n}",
    "includes": [
      "#include \"ui_interface.h\"",
      "#include \"net.h\"",
      "#include \"netbase.h\"",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <winsock2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\"",
            "nTime",
            "nTime - GetTime()",
            "ip.ToStringIP().c_str()"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip.ToStringIP",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIP",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "783-809",
          "snippet": "std::string CNetAddr::ToStringIP() const\n{\n    if (IsTor())\n        return EncodeBase32(&ip[6], 10) + \".onion\";\n    if (IsI2P())\n        return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n    CService serv(*this, 0);\n#ifdef USE_IPV6\n    struct sockaddr_storage sockaddr;\n#else\n    struct sockaddr sockaddr;\n#endif\n    socklen_t socklen = sizeof(sockaddr);\n    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n        char name[1025] = \"\";\n        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n            return std::string(name);\n    }\n    if (IsIPv4())\n        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n    else\n        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::string CNetAddr::ToStringIP() const\n  {\n      if (IsTor())\n          return EncodeBase32(&ip[6], 10) + \".onion\";\n      if (IsI2P())\n          return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n      CService serv(*this, 0);\n  #ifdef USE_IPV6\n      struct sockaddr_storage sockaddr;\n  #else\n      struct sockaddr sockaddr;\n  #endif\n      socklen_t socklen = sizeof(sockaddr);\n      if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n          char name[1025] = \"\";\n          if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n              return std::string(name);\n      }\n      if (IsIPv4())\n          return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n      else\n          return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                           GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                           GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                           GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                           GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sockfd"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoReq",
          "args": [
            "sockfd",
            "servlen",
            "cliaddr"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"NtpGetTime() : querying an NTP server %s\\n\"",
            "ip.ToStringIP().c_str()"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitWithHost",
          "args": [
            "strHostName",
            "sockfd",
            "servlen",
            "&cliaddr"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "InitWithHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
          "lines": "253-287",
          "snippet": "bool InitWithHost(const std::string &strHostName, SOCKET &sockfd, socklen_t &servlen,\n  struct sockaddr *pcliaddr) {\n    uint i;\n\n    sockfd = INVALID_SOCKET;\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupHost(strHostName.c_str(), vIP, 10, true);\n    if(!fRet) return(false);\n\n    struct sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(123);\n\n    bool found = false;\n    for(i = 0; i < vIP.size(); i++) {\n        if((found = vIP[i].GetInAddr(&servaddr.sin_addr)) != false)\n          break;\n    }\n\n    if(!found) return(false);\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\n    if(sockfd == INVALID_SOCKET)\n      return(false);\n\n    if(connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) == -1)\n      return(false);\n\n    *pcliaddr = *((struct sockaddr *) &servaddr);\n    servlen = sizeof(servaddr);\n\n    return(true);\n}",
          "includes": [
            "#include \"ui_interface.h\"",
            "#include \"net.h\"",
            "#include \"netbase.h\"",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nbool InitWithHost(const std::string &strHostName, SOCKET &sockfd, socklen_t &servlen,\n  struct sockaddr *pcliaddr) {\n    uint i;\n\n    sockfd = INVALID_SOCKET;\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupHost(strHostName.c_str(), vIP, 10, true);\n    if(!fRet) return(false);\n\n    struct sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(123);\n\n    bool found = false;\n    for(i = 0; i < vIP.size(); i++) {\n        if((found = vIP[i].GetInAddr(&servaddr.sin_addr)) != false)\n          break;\n    }\n\n    if(!found) return(false);\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\n    if(sockfd == INVALID_SOCKET)\n      return(false);\n\n    if(connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) == -1)\n      return(false);\n\n    *pcliaddr = *((struct sockaddr *) &servaddr);\n    servlen = sizeof(servaddr);\n\n    return(true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nint64 NtpGetTime(const std::string &strHostName) {\n    int64 nTime;\n    SOCKET sockfd;\n    socklen_t servlen;\n    struct sockaddr cliaddr;\n\n    if(!InitWithHost(strHostName, sockfd, servlen, &cliaddr))\n      return(-1);\n\n    CNetAddr ip = ((sockaddr_in *) &cliaddr)->sin_addr;\n    printf(\"NtpGetTime() : querying an NTP server %s\\n\", ip.ToStringIP().c_str());\n\n    nTime = DoReq(sockfd, servlen, cliaddr);\n\n    closesocket(sockfd);\n\n    if((nTime > 0) && (nTime != 2085978496)) {\n        printf(\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\",\n          nTime, nTime - GetTime(), ip.ToStringIP().c_str());\n    }\n\n    return(nTime);\n}"
  },
  {
    "function_name": "NtpGetTime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
    "lines": "366-389",
    "snippet": "int64 NtpGetTime(CNetAddr &ip) {\n    int64 nTime;\n    SOCKET sockfd;\n    socklen_t servlen;\n    struct sockaddr cliaddr;\n\n    if(!InitWithRandom(sockfd, servlen, &cliaddr))\n      return(-1);\n\n    ip = CNetAddr(((sockaddr_in *) &cliaddr)->sin_addr);\n\n    printf(\"NtpGetTime() : querying an NTP server %s\\n\", ip.ToStringIP().c_str());\n\n    nTime = DoReq(sockfd, servlen, cliaddr);\n\n    closesocket(sockfd);\n\n    if((nTime > 0) && (nTime != 2085978496)) {\n        printf(\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\",\n          nTime, nTime - GetTime(), ip.ToStringIP().c_str());\n    }\n\n    return(nTime);\n}",
    "includes": [
      "#include \"ui_interface.h\"",
      "#include \"net.h\"",
      "#include \"netbase.h\"",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <winsock2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\"",
            "nTime",
            "nTime - GetTime()",
            "ip.ToStringIP().c_str()"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ip.ToStringIP",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIP",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "783-809",
          "snippet": "std::string CNetAddr::ToStringIP() const\n{\n    if (IsTor())\n        return EncodeBase32(&ip[6], 10) + \".onion\";\n    if (IsI2P())\n        return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n    CService serv(*this, 0);\n#ifdef USE_IPV6\n    struct sockaddr_storage sockaddr;\n#else\n    struct sockaddr sockaddr;\n#endif\n    socklen_t socklen = sizeof(sockaddr);\n    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n        char name[1025] = \"\";\n        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n            return std::string(name);\n    }\n    if (IsIPv4())\n        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n    else\n        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::string CNetAddr::ToStringIP() const\n  {\n      if (IsTor())\n          return EncodeBase32(&ip[6], 10) + \".onion\";\n      if (IsI2P())\n          return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n      CService serv(*this, 0);\n  #ifdef USE_IPV6\n      struct sockaddr_storage sockaddr;\n  #else\n      struct sockaddr sockaddr;\n  #endif\n      socklen_t socklen = sizeof(sockaddr);\n      if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n          char name[1025] = \"\";\n          if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n              return std::string(name);\n      }\n      if (IsIPv4())\n          return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n      else\n          return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                           GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                           GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                           GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                           GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "sockfd"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoReq",
          "args": [
            "sockfd",
            "servlen",
            "cliaddr"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"NtpGetTime() : querying an NTP server %s\\n\"",
            "ip.ToStringIP().c_str()"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CNetAddr",
          "args": [
            "((sockaddr_in *) &cliaddr)->sin_addr"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "GetReachabilityFrom",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "949-1011",
          "snippet": "int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n{\n    enum Reachability {\n        REACH_UNREACHABLE,\n        REACH_DEFAULT,\n        REACH_TEREDO,\n        REACH_IPV6_WEAK,\n        REACH_IPV4,\n        REACH_IPV6_STRONG,\n        REACH_PRIVATE\n    };\n\n    if (!IsRoutable())\n        return REACH_UNREACHABLE;\n\n    int ourNet = GetExtNetwork(this);\n    int theirNet = GetExtNetwork(paddrPartner);\n    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n\n    switch(theirNet) {\n    case NET_IPV4:\n        switch(ourNet) {\n        default:       return REACH_DEFAULT;\n        case NET_IPV4: return REACH_IPV4;\n        }\n    case NET_IPV6:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_TEREDO: return REACH_TEREDO;\n        case NET_IPV4:   return REACH_IPV4;\n        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n        }\n    case NET_TOR:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n        case NET_TOR:    return REACH_PRIVATE;\n        }\n    case NET_I2P:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_I2P:    return REACH_PRIVATE;\n        }\n    case NET_TEREDO:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        }\n    case NET_UNKNOWN:\n    case NET_UNROUTABLE:\n    default:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n        case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n        }\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n  {\n      enum Reachability {\n          REACH_UNREACHABLE,\n          REACH_DEFAULT,\n          REACH_TEREDO,\n          REACH_IPV6_WEAK,\n          REACH_IPV4,\n          REACH_IPV6_STRONG,\n          REACH_PRIVATE\n      };\n  \n      if (!IsRoutable())\n          return REACH_UNREACHABLE;\n  \n      int ourNet = GetExtNetwork(this);\n      int theirNet = GetExtNetwork(paddrPartner);\n      bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n  \n      switch(theirNet) {\n      case NET_IPV4:\n          switch(ourNet) {\n          default:       return REACH_DEFAULT;\n          case NET_IPV4: return REACH_IPV4;\n          }\n      case NET_IPV6:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_TEREDO: return REACH_TEREDO;\n          case NET_IPV4:   return REACH_IPV4;\n          case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n          }\n      case NET_TOR:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n          case NET_TOR:    return REACH_PRIVATE;\n          }\n      case NET_I2P:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_I2P:    return REACH_PRIVATE;\n          }\n      case NET_TEREDO:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          }\n      case NET_UNKNOWN:\n      case NET_UNROUTABLE:\n      default:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n          case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitWithRandom",
          "args": [
            "sockfd",
            "servlen",
            "&cliaddr"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "InitWithRandom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
          "lines": "289-299",
          "snippet": "bool InitWithRandom(SOCKET &sockfd, socklen_t &servlen, struct sockaddr *pcliaddr) {\n    uint i;\n\n    for(i = 0; i < nServersCount; i++) {\n        int nServerNum = GetRandInt(nServersCount);\n        if(InitWithHost(NtpServers[nServerNum], sockfd, servlen, pcliaddr))\n          return(true);\n    }\n\n    return(false);\n}",
          "includes": [
            "#include \"ui_interface.h\"",
            "#include \"net.h\"",
            "#include \"netbase.h\"",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const uint nServersCount = 135;",
            "std::string NtpServers[nServersCount] = {\n\n    \"time.apple.com\",\n    \"time.windows.com\",\n    \"time1.google.com\",\n    \"time2.google.com\",\n    \"time3.google.com\",\n    \"time4.google.com\",\n    \"clock.sjc.he.net\",\n    \"clock.nyc.he.net\",\n\n    /* Russia */\n    \"0.ru.pool.ntp.org\",\n    \"1.ru.pool.ntp.org\",\n    \"2.ru.pool.ntp.org\",\n    \"3.ru.pool.ntp.org\",\n    \"ntp1.stratum1.ru\",\n    \"ntp2.stratum1.ru\",\n    \"ntp3.stratum1.ru\",\n    \"ntp4.stratum1.ru\",\n    \"ntp5.stratum1.ru\",\n    \"ntp1.stratum2.ru\",\n    \"ntp2.stratum2.ru\",\n    \"ntp3.stratum2.ru\",\n    \"ntp4.stratum2.ru\",\n    \"ntp5.stratum2.ru\",\n    \"ntp1.vniiftri.ru\",\n    \"ntp2.vniiftri.ru\",\n    \"ntp3.vniiftri.ru\",\n    \"ntp4.vniiftri.ru\",\n    \"ntp21.vniiftri.ru\",\n    \"ntp1.niiftri.irkutsk.ru\",\n    \"ntp2.niiftri.irkutsk.ru\",\n    \"vniiftri.khv.ru\",\n    \"vniiftri2.khv.ru\",\n    \"ntp.ix.ru\",\n\n    /* United States */\n    \"0.us.pool.ntp.org\",\n    \"1.us.pool.ntp.org\",\n    \"2.us.pool.ntp.org\",\n    \"3.us.pool.ntp.org\",\n    \"time.nist.gov\",\n    \"time-a.nist.gov\",\n    \"time-b.nist.gov\",\n    \"time-c.nist.gov\",\n    \"time-d.nist.gov\",\n    \"time-nw.nist.gov\",\n    \"ntp1.bu.edu\",\n    \"ntp2.bu.edu\",\n    \"ntp3.bu.edu\",\n    \"ntp-1.ece.cmu.edu\",\n    \"ntp-2.ece.cmu.edu\",\n    \"ntp-3.ece.cmu.edu\",\n    \"ntp1.cs.wisc.edu\",\n    \"ntp2.cs.wisc.edu\",\n    \"ntp3.cs.wisc.edu\",\n    \"ntp4.cs.wisc.edu\",\n    \"ntp-01.caltech.edu\",\n    \"ntp-02.caltech.edu\",\n    \"ntp-03.caltech.edu\",\n    \"ntp-04.caltech.edu\",\n    \"utcnist.colorado.edu\",\n    \"utcnist2.colorado.edu\",\n    \"tick.cs.unlv.edu\",\n    \"tock.cs.unlv.edu\",\n    \"tick.cs.columbia.edu\",\n    \"tock.cs.columbia.edu\",\n    \"otc1.psu.edu\",\n    \"otc2.psu.edu\",\n    \"now.okstate.edu\",\n    \"ntp.colby.edu\",\n    \"bonehed.lcs.mit.edu\",\n    \"ntp-s1.cise.ufl.edu\",\n\n    /* South Africa */\n    \"0.za.pool.ntp.org\",\n    \"1.za.pool.ntp.org\",\n    \"2.za.pool.ntp.org\",\n    \"3.za.pool.ntp.org\",\n    \"tick.meraka.csir.co.za\",\n    \"tock.meraka.csir.co.za\",\n    \"ntp1.meraka.csir.co.za\",\n    \"ntp2.meraka.csir.co.za\",\n    \"ntp.is.co.za\",\n    \"ntp2.is.co.za\",\n\n    /* United Kingdom */\n    \"0.uk.pool.ntp.org\",\n    \"1.uk.pool.ntp.org\",\n    \"2.uk.pool.ntp.org\",\n    \"3.uk.pool.ntp.org\",\n    \"ntppub.le.ac.uk\",\n    \"ntp.cis.strath.ac.uk\",\n    \"ntp.exnet.com\",\n\n    /* Canada */\n    \"0.ca.pool.ntp.org\",\n    \"1.ca.pool.ntp.org\",\n    \"2.ca.pool.ntp.org\",\n    \"3.ca.pool.ntp.org\",\n    \"tick.utoronto.ca\",\n    \"tock.utoronto.ca\",\n    \"chime.utoronto.ca\",\n    \"time.nrc.ca\",\n    \"timelord.uregina.ca\",\n\n    /* Japan */\n    \"0.jp.pool.ntp.org\",\n    \"1.jp.pool.ntp.org\",\n    \"2.jp.pool.ntp.org\",\n    \"3.jp.pool.ntp.org\",\n    \"ntp.nict.jp\",\n\n    /* Australia */\n    \"0.au.pool.ntp.org\",\n    \"1.au.pool.ntp.org\",\n    \"2.au.pool.ntp.org\",\n    \"3.au.pool.ntp.org\",\n    \"ntp.unimelb.edu.au\",\n    \"ntp.adelaide.edu.au\",\n\n    /* Italy */\n    \"0.it.pool.ntp.org\",\n    \"1.it.pool.ntp.org\",\n    \"2.it.pool.ntp.org\",\n    \"3.it.pool.ntp.org\",\n    \"ntp0.inrim.it\",\n    \"ntp1.inrim.it\",\n    \"ntp2.inrim.it\",\n\n    /* Netherlands */\n    \"0.nl.pool.ntp.org\",\n    \"1.nl.pool.ntp.org\",\n    \"2.nl.pool.ntp.org\",\n    \"3.nl.pool.ntp.org\",\n    \"ntp.utwente.nl\",\n\n    /* Austria */\n    \"0.at.pool.ntp.org\",\n    \"1.at.pool.ntp.org\",\n    \"2.at.pool.ntp.org\",\n    \"3.at.pool.ntp.org\",\n\n    /* Germany */\n    \"0.de.pool.ntp.org\",\n    \"1.de.pool.ntp.org\",\n    \"2.de.pool.ntp.org\",\n    \"3.de.pool.ntp.org\",\n\n    /* Poland */\n    \"0.pl.pool.ntp.org\",\n    \"1.pl.pool.ntp.org\",\n    \"2.pl.pool.ntp.org\",\n    \"3.pl.pool.ntp.org\",\n\n    /* Mexico */\n    \"0.mx.pool.ntp.org\",\n    \"1.mx.pool.ntp.org\",\n    \"2.mx.pool.ntp.org\",\n\n    /* Brazil */\n    \"0.br.pool.ntp.org\",\n    \"1.br.pool.ntp.org\",\n    \"2.br.pool.ntp.org\",\n\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nconst uint nServersCount = 135;\nstd::string NtpServers[nServersCount] = {\n\n    \"time.apple.com\",\n    \"time.windows.com\",\n    \"time1.google.com\",\n    \"time2.google.com\",\n    \"time3.google.com\",\n    \"time4.google.com\",\n    \"clock.sjc.he.net\",\n    \"clock.nyc.he.net\",\n\n    /* Russia */\n    \"0.ru.pool.ntp.org\",\n    \"1.ru.pool.ntp.org\",\n    \"2.ru.pool.ntp.org\",\n    \"3.ru.pool.ntp.org\",\n    \"ntp1.stratum1.ru\",\n    \"ntp2.stratum1.ru\",\n    \"ntp3.stratum1.ru\",\n    \"ntp4.stratum1.ru\",\n    \"ntp5.stratum1.ru\",\n    \"ntp1.stratum2.ru\",\n    \"ntp2.stratum2.ru\",\n    \"ntp3.stratum2.ru\",\n    \"ntp4.stratum2.ru\",\n    \"ntp5.stratum2.ru\",\n    \"ntp1.vniiftri.ru\",\n    \"ntp2.vniiftri.ru\",\n    \"ntp3.vniiftri.ru\",\n    \"ntp4.vniiftri.ru\",\n    \"ntp21.vniiftri.ru\",\n    \"ntp1.niiftri.irkutsk.ru\",\n    \"ntp2.niiftri.irkutsk.ru\",\n    \"vniiftri.khv.ru\",\n    \"vniiftri2.khv.ru\",\n    \"ntp.ix.ru\",\n\n    /* United States */\n    \"0.us.pool.ntp.org\",\n    \"1.us.pool.ntp.org\",\n    \"2.us.pool.ntp.org\",\n    \"3.us.pool.ntp.org\",\n    \"time.nist.gov\",\n    \"time-a.nist.gov\",\n    \"time-b.nist.gov\",\n    \"time-c.nist.gov\",\n    \"time-d.nist.gov\",\n    \"time-nw.nist.gov\",\n    \"ntp1.bu.edu\",\n    \"ntp2.bu.edu\",\n    \"ntp3.bu.edu\",\n    \"ntp-1.ece.cmu.edu\",\n    \"ntp-2.ece.cmu.edu\",\n    \"ntp-3.ece.cmu.edu\",\n    \"ntp1.cs.wisc.edu\",\n    \"ntp2.cs.wisc.edu\",\n    \"ntp3.cs.wisc.edu\",\n    \"ntp4.cs.wisc.edu\",\n    \"ntp-01.caltech.edu\",\n    \"ntp-02.caltech.edu\",\n    \"ntp-03.caltech.edu\",\n    \"ntp-04.caltech.edu\",\n    \"utcnist.colorado.edu\",\n    \"utcnist2.colorado.edu\",\n    \"tick.cs.unlv.edu\",\n    \"tock.cs.unlv.edu\",\n    \"tick.cs.columbia.edu\",\n    \"tock.cs.columbia.edu\",\n    \"otc1.psu.edu\",\n    \"otc2.psu.edu\",\n    \"now.okstate.edu\",\n    \"ntp.colby.edu\",\n    \"bonehed.lcs.mit.edu\",\n    \"ntp-s1.cise.ufl.edu\",\n\n    /* South Africa */\n    \"0.za.pool.ntp.org\",\n    \"1.za.pool.ntp.org\",\n    \"2.za.pool.ntp.org\",\n    \"3.za.pool.ntp.org\",\n    \"tick.meraka.csir.co.za\",\n    \"tock.meraka.csir.co.za\",\n    \"ntp1.meraka.csir.co.za\",\n    \"ntp2.meraka.csir.co.za\",\n    \"ntp.is.co.za\",\n    \"ntp2.is.co.za\",\n\n    /* United Kingdom */\n    \"0.uk.pool.ntp.org\",\n    \"1.uk.pool.ntp.org\",\n    \"2.uk.pool.ntp.org\",\n    \"3.uk.pool.ntp.org\",\n    \"ntppub.le.ac.uk\",\n    \"ntp.cis.strath.ac.uk\",\n    \"ntp.exnet.com\",\n\n    /* Canada */\n    \"0.ca.pool.ntp.org\",\n    \"1.ca.pool.ntp.org\",\n    \"2.ca.pool.ntp.org\",\n    \"3.ca.pool.ntp.org\",\n    \"tick.utoronto.ca\",\n    \"tock.utoronto.ca\",\n    \"chime.utoronto.ca\",\n    \"time.nrc.ca\",\n    \"timelord.uregina.ca\",\n\n    /* Japan */\n    \"0.jp.pool.ntp.org\",\n    \"1.jp.pool.ntp.org\",\n    \"2.jp.pool.ntp.org\",\n    \"3.jp.pool.ntp.org\",\n    \"ntp.nict.jp\",\n\n    /* Australia */\n    \"0.au.pool.ntp.org\",\n    \"1.au.pool.ntp.org\",\n    \"2.au.pool.ntp.org\",\n    \"3.au.pool.ntp.org\",\n    \"ntp.unimelb.edu.au\",\n    \"ntp.adelaide.edu.au\",\n\n    /* Italy */\n    \"0.it.pool.ntp.org\",\n    \"1.it.pool.ntp.org\",\n    \"2.it.pool.ntp.org\",\n    \"3.it.pool.ntp.org\",\n    \"ntp0.inrim.it\",\n    \"ntp1.inrim.it\",\n    \"ntp2.inrim.it\",\n\n    /* Netherlands */\n    \"0.nl.pool.ntp.org\",\n    \"1.nl.pool.ntp.org\",\n    \"2.nl.pool.ntp.org\",\n    \"3.nl.pool.ntp.org\",\n    \"ntp.utwente.nl\",\n\n    /* Austria */\n    \"0.at.pool.ntp.org\",\n    \"1.at.pool.ntp.org\",\n    \"2.at.pool.ntp.org\",\n    \"3.at.pool.ntp.org\",\n\n    /* Germany */\n    \"0.de.pool.ntp.org\",\n    \"1.de.pool.ntp.org\",\n    \"2.de.pool.ntp.org\",\n    \"3.de.pool.ntp.org\",\n\n    /* Poland */\n    \"0.pl.pool.ntp.org\",\n    \"1.pl.pool.ntp.org\",\n    \"2.pl.pool.ntp.org\",\n    \"3.pl.pool.ntp.org\",\n\n    /* Mexico */\n    \"0.mx.pool.ntp.org\",\n    \"1.mx.pool.ntp.org\",\n    \"2.mx.pool.ntp.org\",\n\n    /* Brazil */\n    \"0.br.pool.ntp.org\",\n    \"1.br.pool.ntp.org\",\n    \"2.br.pool.ntp.org\",\n\n};\n\nbool InitWithRandom(SOCKET &sockfd, socklen_t &servlen, struct sockaddr *pcliaddr) {\n    uint i;\n\n    for(i = 0; i < nServersCount; i++) {\n        int nServerNum = GetRandInt(nServersCount);\n        if(InitWithHost(NtpServers[nServerNum], sockfd, servlen, pcliaddr))\n          return(true);\n    }\n\n    return(false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nint64 NtpGetTime(CNetAddr &ip) {\n    int64 nTime;\n    SOCKET sockfd;\n    socklen_t servlen;\n    struct sockaddr cliaddr;\n\n    if(!InitWithRandom(sockfd, servlen, &cliaddr))\n      return(-1);\n\n    ip = CNetAddr(((sockaddr_in *) &cliaddr)->sin_addr);\n\n    printf(\"NtpGetTime() : querying an NTP server %s\\n\", ip.ToStringIP().c_str());\n\n    nTime = DoReq(sockfd, servlen, cliaddr);\n\n    closesocket(sockfd);\n\n    if((nTime > 0) && (nTime != 2085978496)) {\n        printf(\"NtpGetTime() : time sample %\" PRI64d \" offset %+\" PRI64d \" received from %s\\n\",\n          nTime, nTime - GetTime(), ip.ToStringIP().c_str());\n    }\n\n    return(nTime);\n}"
  },
  {
    "function_name": "InitWithRandom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
    "lines": "289-299",
    "snippet": "bool InitWithRandom(SOCKET &sockfd, socklen_t &servlen, struct sockaddr *pcliaddr) {\n    uint i;\n\n    for(i = 0; i < nServersCount; i++) {\n        int nServerNum = GetRandInt(nServersCount);\n        if(InitWithHost(NtpServers[nServerNum], sockfd, servlen, pcliaddr))\n          return(true);\n    }\n\n    return(false);\n}",
    "includes": [
      "#include \"ui_interface.h\"",
      "#include \"net.h\"",
      "#include \"netbase.h\"",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <winsock2.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const uint nServersCount = 135;",
      "std::string NtpServers[nServersCount] = {\n\n    \"time.apple.com\",\n    \"time.windows.com\",\n    \"time1.google.com\",\n    \"time2.google.com\",\n    \"time3.google.com\",\n    \"time4.google.com\",\n    \"clock.sjc.he.net\",\n    \"clock.nyc.he.net\",\n\n    /* Russia */\n    \"0.ru.pool.ntp.org\",\n    \"1.ru.pool.ntp.org\",\n    \"2.ru.pool.ntp.org\",\n    \"3.ru.pool.ntp.org\",\n    \"ntp1.stratum1.ru\",\n    \"ntp2.stratum1.ru\",\n    \"ntp3.stratum1.ru\",\n    \"ntp4.stratum1.ru\",\n    \"ntp5.stratum1.ru\",\n    \"ntp1.stratum2.ru\",\n    \"ntp2.stratum2.ru\",\n    \"ntp3.stratum2.ru\",\n    \"ntp4.stratum2.ru\",\n    \"ntp5.stratum2.ru\",\n    \"ntp1.vniiftri.ru\",\n    \"ntp2.vniiftri.ru\",\n    \"ntp3.vniiftri.ru\",\n    \"ntp4.vniiftri.ru\",\n    \"ntp21.vniiftri.ru\",\n    \"ntp1.niiftri.irkutsk.ru\",\n    \"ntp2.niiftri.irkutsk.ru\",\n    \"vniiftri.khv.ru\",\n    \"vniiftri2.khv.ru\",\n    \"ntp.ix.ru\",\n\n    /* United States */\n    \"0.us.pool.ntp.org\",\n    \"1.us.pool.ntp.org\",\n    \"2.us.pool.ntp.org\",\n    \"3.us.pool.ntp.org\",\n    \"time.nist.gov\",\n    \"time-a.nist.gov\",\n    \"time-b.nist.gov\",\n    \"time-c.nist.gov\",\n    \"time-d.nist.gov\",\n    \"time-nw.nist.gov\",\n    \"ntp1.bu.edu\",\n    \"ntp2.bu.edu\",\n    \"ntp3.bu.edu\",\n    \"ntp-1.ece.cmu.edu\",\n    \"ntp-2.ece.cmu.edu\",\n    \"ntp-3.ece.cmu.edu\",\n    \"ntp1.cs.wisc.edu\",\n    \"ntp2.cs.wisc.edu\",\n    \"ntp3.cs.wisc.edu\",\n    \"ntp4.cs.wisc.edu\",\n    \"ntp-01.caltech.edu\",\n    \"ntp-02.caltech.edu\",\n    \"ntp-03.caltech.edu\",\n    \"ntp-04.caltech.edu\",\n    \"utcnist.colorado.edu\",\n    \"utcnist2.colorado.edu\",\n    \"tick.cs.unlv.edu\",\n    \"tock.cs.unlv.edu\",\n    \"tick.cs.columbia.edu\",\n    \"tock.cs.columbia.edu\",\n    \"otc1.psu.edu\",\n    \"otc2.psu.edu\",\n    \"now.okstate.edu\",\n    \"ntp.colby.edu\",\n    \"bonehed.lcs.mit.edu\",\n    \"ntp-s1.cise.ufl.edu\",\n\n    /* South Africa */\n    \"0.za.pool.ntp.org\",\n    \"1.za.pool.ntp.org\",\n    \"2.za.pool.ntp.org\",\n    \"3.za.pool.ntp.org\",\n    \"tick.meraka.csir.co.za\",\n    \"tock.meraka.csir.co.za\",\n    \"ntp1.meraka.csir.co.za\",\n    \"ntp2.meraka.csir.co.za\",\n    \"ntp.is.co.za\",\n    \"ntp2.is.co.za\",\n\n    /* United Kingdom */\n    \"0.uk.pool.ntp.org\",\n    \"1.uk.pool.ntp.org\",\n    \"2.uk.pool.ntp.org\",\n    \"3.uk.pool.ntp.org\",\n    \"ntppub.le.ac.uk\",\n    \"ntp.cis.strath.ac.uk\",\n    \"ntp.exnet.com\",\n\n    /* Canada */\n    \"0.ca.pool.ntp.org\",\n    \"1.ca.pool.ntp.org\",\n    \"2.ca.pool.ntp.org\",\n    \"3.ca.pool.ntp.org\",\n    \"tick.utoronto.ca\",\n    \"tock.utoronto.ca\",\n    \"chime.utoronto.ca\",\n    \"time.nrc.ca\",\n    \"timelord.uregina.ca\",\n\n    /* Japan */\n    \"0.jp.pool.ntp.org\",\n    \"1.jp.pool.ntp.org\",\n    \"2.jp.pool.ntp.org\",\n    \"3.jp.pool.ntp.org\",\n    \"ntp.nict.jp\",\n\n    /* Australia */\n    \"0.au.pool.ntp.org\",\n    \"1.au.pool.ntp.org\",\n    \"2.au.pool.ntp.org\",\n    \"3.au.pool.ntp.org\",\n    \"ntp.unimelb.edu.au\",\n    \"ntp.adelaide.edu.au\",\n\n    /* Italy */\n    \"0.it.pool.ntp.org\",\n    \"1.it.pool.ntp.org\",\n    \"2.it.pool.ntp.org\",\n    \"3.it.pool.ntp.org\",\n    \"ntp0.inrim.it\",\n    \"ntp1.inrim.it\",\n    \"ntp2.inrim.it\",\n\n    /* Netherlands */\n    \"0.nl.pool.ntp.org\",\n    \"1.nl.pool.ntp.org\",\n    \"2.nl.pool.ntp.org\",\n    \"3.nl.pool.ntp.org\",\n    \"ntp.utwente.nl\",\n\n    /* Austria */\n    \"0.at.pool.ntp.org\",\n    \"1.at.pool.ntp.org\",\n    \"2.at.pool.ntp.org\",\n    \"3.at.pool.ntp.org\",\n\n    /* Germany */\n    \"0.de.pool.ntp.org\",\n    \"1.de.pool.ntp.org\",\n    \"2.de.pool.ntp.org\",\n    \"3.de.pool.ntp.org\",\n\n    /* Poland */\n    \"0.pl.pool.ntp.org\",\n    \"1.pl.pool.ntp.org\",\n    \"2.pl.pool.ntp.org\",\n    \"3.pl.pool.ntp.org\",\n\n    /* Mexico */\n    \"0.mx.pool.ntp.org\",\n    \"1.mx.pool.ntp.org\",\n    \"2.mx.pool.ntp.org\",\n\n    /* Brazil */\n    \"0.br.pool.ntp.org\",\n    \"1.br.pool.ntp.org\",\n    \"2.br.pool.ntp.org\",\n\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitWithHost",
          "args": [
            "NtpServers[nServerNum]",
            "sockfd",
            "servlen",
            "pcliaddr"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "InitWithHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
          "lines": "253-287",
          "snippet": "bool InitWithHost(const std::string &strHostName, SOCKET &sockfd, socklen_t &servlen,\n  struct sockaddr *pcliaddr) {\n    uint i;\n\n    sockfd = INVALID_SOCKET;\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupHost(strHostName.c_str(), vIP, 10, true);\n    if(!fRet) return(false);\n\n    struct sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(123);\n\n    bool found = false;\n    for(i = 0; i < vIP.size(); i++) {\n        if((found = vIP[i].GetInAddr(&servaddr.sin_addr)) != false)\n          break;\n    }\n\n    if(!found) return(false);\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\n    if(sockfd == INVALID_SOCKET)\n      return(false);\n\n    if(connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) == -1)\n      return(false);\n\n    *pcliaddr = *((struct sockaddr *) &servaddr);\n    servlen = sizeof(servaddr);\n\n    return(true);\n}",
          "includes": [
            "#include \"ui_interface.h\"",
            "#include \"net.h\"",
            "#include \"netbase.h\"",
            "#include <unistd.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <netinet/in.h>",
            "#include <sys/time.h>",
            "#include <sys/socket.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nbool InitWithHost(const std::string &strHostName, SOCKET &sockfd, socklen_t &servlen,\n  struct sockaddr *pcliaddr) {\n    uint i;\n\n    sockfd = INVALID_SOCKET;\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupHost(strHostName.c_str(), vIP, 10, true);\n    if(!fRet) return(false);\n\n    struct sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(123);\n\n    bool found = false;\n    for(i = 0; i < vIP.size(); i++) {\n        if((found = vIP[i].GetInAddr(&servaddr.sin_addr)) != false)\n          break;\n    }\n\n    if(!found) return(false);\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\n    if(sockfd == INVALID_SOCKET)\n      return(false);\n\n    if(connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) == -1)\n      return(false);\n\n    *pcliaddr = *((struct sockaddr *) &servaddr);\n    servlen = sizeof(servaddr);\n\n    return(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "nServersCount"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nconst uint nServersCount = 135;\nstd::string NtpServers[nServersCount] = {\n\n    \"time.apple.com\",\n    \"time.windows.com\",\n    \"time1.google.com\",\n    \"time2.google.com\",\n    \"time3.google.com\",\n    \"time4.google.com\",\n    \"clock.sjc.he.net\",\n    \"clock.nyc.he.net\",\n\n    /* Russia */\n    \"0.ru.pool.ntp.org\",\n    \"1.ru.pool.ntp.org\",\n    \"2.ru.pool.ntp.org\",\n    \"3.ru.pool.ntp.org\",\n    \"ntp1.stratum1.ru\",\n    \"ntp2.stratum1.ru\",\n    \"ntp3.stratum1.ru\",\n    \"ntp4.stratum1.ru\",\n    \"ntp5.stratum1.ru\",\n    \"ntp1.stratum2.ru\",\n    \"ntp2.stratum2.ru\",\n    \"ntp3.stratum2.ru\",\n    \"ntp4.stratum2.ru\",\n    \"ntp5.stratum2.ru\",\n    \"ntp1.vniiftri.ru\",\n    \"ntp2.vniiftri.ru\",\n    \"ntp3.vniiftri.ru\",\n    \"ntp4.vniiftri.ru\",\n    \"ntp21.vniiftri.ru\",\n    \"ntp1.niiftri.irkutsk.ru\",\n    \"ntp2.niiftri.irkutsk.ru\",\n    \"vniiftri.khv.ru\",\n    \"vniiftri2.khv.ru\",\n    \"ntp.ix.ru\",\n\n    /* United States */\n    \"0.us.pool.ntp.org\",\n    \"1.us.pool.ntp.org\",\n    \"2.us.pool.ntp.org\",\n    \"3.us.pool.ntp.org\",\n    \"time.nist.gov\",\n    \"time-a.nist.gov\",\n    \"time-b.nist.gov\",\n    \"time-c.nist.gov\",\n    \"time-d.nist.gov\",\n    \"time-nw.nist.gov\",\n    \"ntp1.bu.edu\",\n    \"ntp2.bu.edu\",\n    \"ntp3.bu.edu\",\n    \"ntp-1.ece.cmu.edu\",\n    \"ntp-2.ece.cmu.edu\",\n    \"ntp-3.ece.cmu.edu\",\n    \"ntp1.cs.wisc.edu\",\n    \"ntp2.cs.wisc.edu\",\n    \"ntp3.cs.wisc.edu\",\n    \"ntp4.cs.wisc.edu\",\n    \"ntp-01.caltech.edu\",\n    \"ntp-02.caltech.edu\",\n    \"ntp-03.caltech.edu\",\n    \"ntp-04.caltech.edu\",\n    \"utcnist.colorado.edu\",\n    \"utcnist2.colorado.edu\",\n    \"tick.cs.unlv.edu\",\n    \"tock.cs.unlv.edu\",\n    \"tick.cs.columbia.edu\",\n    \"tock.cs.columbia.edu\",\n    \"otc1.psu.edu\",\n    \"otc2.psu.edu\",\n    \"now.okstate.edu\",\n    \"ntp.colby.edu\",\n    \"bonehed.lcs.mit.edu\",\n    \"ntp-s1.cise.ufl.edu\",\n\n    /* South Africa */\n    \"0.za.pool.ntp.org\",\n    \"1.za.pool.ntp.org\",\n    \"2.za.pool.ntp.org\",\n    \"3.za.pool.ntp.org\",\n    \"tick.meraka.csir.co.za\",\n    \"tock.meraka.csir.co.za\",\n    \"ntp1.meraka.csir.co.za\",\n    \"ntp2.meraka.csir.co.za\",\n    \"ntp.is.co.za\",\n    \"ntp2.is.co.za\",\n\n    /* United Kingdom */\n    \"0.uk.pool.ntp.org\",\n    \"1.uk.pool.ntp.org\",\n    \"2.uk.pool.ntp.org\",\n    \"3.uk.pool.ntp.org\",\n    \"ntppub.le.ac.uk\",\n    \"ntp.cis.strath.ac.uk\",\n    \"ntp.exnet.com\",\n\n    /* Canada */\n    \"0.ca.pool.ntp.org\",\n    \"1.ca.pool.ntp.org\",\n    \"2.ca.pool.ntp.org\",\n    \"3.ca.pool.ntp.org\",\n    \"tick.utoronto.ca\",\n    \"tock.utoronto.ca\",\n    \"chime.utoronto.ca\",\n    \"time.nrc.ca\",\n    \"timelord.uregina.ca\",\n\n    /* Japan */\n    \"0.jp.pool.ntp.org\",\n    \"1.jp.pool.ntp.org\",\n    \"2.jp.pool.ntp.org\",\n    \"3.jp.pool.ntp.org\",\n    \"ntp.nict.jp\",\n\n    /* Australia */\n    \"0.au.pool.ntp.org\",\n    \"1.au.pool.ntp.org\",\n    \"2.au.pool.ntp.org\",\n    \"3.au.pool.ntp.org\",\n    \"ntp.unimelb.edu.au\",\n    \"ntp.adelaide.edu.au\",\n\n    /* Italy */\n    \"0.it.pool.ntp.org\",\n    \"1.it.pool.ntp.org\",\n    \"2.it.pool.ntp.org\",\n    \"3.it.pool.ntp.org\",\n    \"ntp0.inrim.it\",\n    \"ntp1.inrim.it\",\n    \"ntp2.inrim.it\",\n\n    /* Netherlands */\n    \"0.nl.pool.ntp.org\",\n    \"1.nl.pool.ntp.org\",\n    \"2.nl.pool.ntp.org\",\n    \"3.nl.pool.ntp.org\",\n    \"ntp.utwente.nl\",\n\n    /* Austria */\n    \"0.at.pool.ntp.org\",\n    \"1.at.pool.ntp.org\",\n    \"2.at.pool.ntp.org\",\n    \"3.at.pool.ntp.org\",\n\n    /* Germany */\n    \"0.de.pool.ntp.org\",\n    \"1.de.pool.ntp.org\",\n    \"2.de.pool.ntp.org\",\n    \"3.de.pool.ntp.org\",\n\n    /* Poland */\n    \"0.pl.pool.ntp.org\",\n    \"1.pl.pool.ntp.org\",\n    \"2.pl.pool.ntp.org\",\n    \"3.pl.pool.ntp.org\",\n\n    /* Mexico */\n    \"0.mx.pool.ntp.org\",\n    \"1.mx.pool.ntp.org\",\n    \"2.mx.pool.ntp.org\",\n\n    /* Brazil */\n    \"0.br.pool.ntp.org\",\n    \"1.br.pool.ntp.org\",\n    \"2.br.pool.ntp.org\",\n\n};\n\nbool InitWithRandom(SOCKET &sockfd, socklen_t &servlen, struct sockaddr *pcliaddr) {\n    uint i;\n\n    for(i = 0; i < nServersCount; i++) {\n        int nServerNum = GetRandInt(nServersCount);\n        if(InitWithHost(NtpServers[nServerNum], sockfd, servlen, pcliaddr))\n          return(true);\n    }\n\n    return(false);\n}"
  },
  {
    "function_name": "InitWithHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
    "lines": "253-287",
    "snippet": "bool InitWithHost(const std::string &strHostName, SOCKET &sockfd, socklen_t &servlen,\n  struct sockaddr *pcliaddr) {\n    uint i;\n\n    sockfd = INVALID_SOCKET;\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupHost(strHostName.c_str(), vIP, 10, true);\n    if(!fRet) return(false);\n\n    struct sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(123);\n\n    bool found = false;\n    for(i = 0; i < vIP.size(); i++) {\n        if((found = vIP[i].GetInAddr(&servaddr.sin_addr)) != false)\n          break;\n    }\n\n    if(!found) return(false);\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\n    if(sockfd == INVALID_SOCKET)\n      return(false);\n\n    if(connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) == -1)\n      return(false);\n\n    *pcliaddr = *((struct sockaddr *) &servaddr);\n    servlen = sizeof(servaddr);\n\n    return(true);\n}",
    "includes": [
      "#include \"ui_interface.h\"",
      "#include \"net.h\"",
      "#include \"netbase.h\"",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <winsock2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "sockfd",
            "(struct sockaddr *) &servaddr",
            "sizeof(servaddr)"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vIP[i].GetInAddr",
          "args": [
            "&servaddr.sin_addr"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "GetInAddr",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "831-837",
          "snippet": "bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n{\n    if (!IsIPv4())\n        return false;\n    memcpy(pipv4Addr, ip+12, 4);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n  {\n      if (!IsIPv4())\n          return false;\n      memcpy(pipv4Addr, ip+12, 4);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vIP.size",
          "args": [],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "123"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LookupHost",
          "args": [
            "strHostName.c_str()",
            "vIP",
            "10",
            "true"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "LookupHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "120-134",
          "snippet": "bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strHostName.c_str",
          "args": [],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\nbool InitWithHost(const std::string &strHostName, SOCKET &sockfd, socklen_t &servlen,\n  struct sockaddr *pcliaddr) {\n    uint i;\n\n    sockfd = INVALID_SOCKET;\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupHost(strHostName.c_str(), vIP, 10, true);\n    if(!fRet) return(false);\n\n    struct sockaddr_in servaddr;\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_port = htons(123);\n\n    bool found = false;\n    for(i = 0; i < vIP.size(); i++) {\n        if((found = vIP[i].GetInAddr(&servaddr.sin_addr)) != false)\n          break;\n    }\n\n    if(!found) return(false);\n\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n\n    if(sockfd == INVALID_SOCKET)\n      return(false);\n\n    if(connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servaddr)) == -1)\n      return(false);\n\n    *pcliaddr = *((struct sockaddr *) &servaddr);\n    servlen = sizeof(servaddr);\n\n    return(true);\n}"
  },
  {
    "function_name": "ntohl_fp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
    "lines": "62-65",
    "snippet": "inline void ntohl_fp(l_fp *n, l_fp *h) {\n    (h)->Ul_i.Xl_ui = ntohl((n)->Ul_i.Xl_ui);\n    (h)->Ul_f.Xl_uf = ntohl((n)->Ul_f.Xl_uf);\n}",
    "includes": [
      "#include \"ui_interface.h\"",
      "#include \"net.h\"",
      "#include \"netbase.h\"",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <winsock2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "(n)->Ul_f.Xl_uf"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "(n)->Ul_i.Xl_ui"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\ninline void ntohl_fp(l_fp *n, l_fp *h) {\n    (h)->Ul_i.Xl_ui = ntohl((n)->Ul_i.Xl_ui);\n    (h)->Ul_f.Xl_uf = ntohl((n)->Ul_f.Xl_uf);\n}"
  },
  {
    "function_name": "Ntp2Unix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/ntp.cpp",
    "lines": "58-60",
    "snippet": "inline void Ntp2Unix(const uint32_t &n, time_t &u) {\n    u = n - 0x83AA7E80;\n}",
    "includes": [
      "#include \"ui_interface.h\"",
      "#include \"net.h\"",
      "#include \"netbase.h\"",
      "#include <unistd.h>",
      "#include <netdb.h>",
      "#include <arpa/inet.h>",
      "#include <netinet/in.h>",
      "#include <sys/time.h>",
      "#include <sys/socket.h>",
      "#include <winsock2.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ui_interface.h\"\n#include \"net.h\"\n#include \"netbase.h\"\n#include <unistd.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <sys/socket.h>\n#include <winsock2.h>\n\ninline void Ntp2Unix(const uint32_t &n, time_t &u) {\n    u = n - 0x83AA7E80;\n}"
  }
]