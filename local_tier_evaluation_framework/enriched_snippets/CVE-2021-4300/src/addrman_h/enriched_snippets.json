[
  {
    "function_name": "Connected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "492-500",
    "snippet": "void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Connected_(addr, nTime);\n            Check();\n        }\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "Check_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "434-490",
          "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Connected_",
          "args": [
            "addr",
            "nTime"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "Connected_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "509-527",
          "snippet": "void CAddrMan::Connected_(const CService &addr, int64_t nTime)\n{\n    CAddrInfo *pinfo = Find(addr);\n\n    // if not found, bail out\n    if (!pinfo)\n        return;\n\n    CAddrInfo &info = *pinfo;\n\n    // check whether we are talking about the exact same CService (including same port)\n    if (info != addr)\n        return;\n\n    // update info\n    int64_t nUpdateInterval = 20 * 60;\n    if (nTime - info.nTime > nUpdateInterval)\n        info.nTime = nTime;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::Connected_(const CService &addr, int64_t nTime)\n  {\n      CAddrInfo *pinfo = Find(addr);\n  \n      // if not found, bail out\n      if (!pinfo)\n          return;\n  \n      CAddrInfo &info = *pinfo;\n  \n      // check whether we are talking about the exact same CService (including same port)\n      if (info != addr)\n          return;\n  \n      // update info\n      int64_t nUpdateInterval = 20 * 60;\n      if (nTime - info.nTime > nUpdateInterval)\n          info.nTime = nTime;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nvoid Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Connected_(addr, nTime);\n            Check();\n        }\n    }"
  },
  {
    "function_name": "GetAddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "479-489",
    "snippet": "std::vector<CAddress> GetAddr()\n    {\n        Check();\n        std::vector<CAddress> vAddr;\n        {\n            LOCK(cs);\n            GetAddr_(vAddr);\n        }\n        Check();\n        return vAddr;\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "Check_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "434-490",
          "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAddr_",
          "args": [
            "vAddr"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "GetAddr_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "493-507",
          "snippet": "void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n{\n    int nNodes = ADAGSAN_GETADDR_MAX_PCT*vRandom.size()/100;\n    if (nNodes > ADAGSAN_GETADDR_MAX)\n        nNodes = ADAGSAN_GETADDR_MAX;\n\n    // perform a random shuffle over the first nNodes elements of vRandom (selecting from all)\n    for (int n = 0; n<nNodes; n++)\n    {\n        int nRndPos = GetRandInt(vRandom.size() - n) + n;\n        SwapRandom(n, nRndPos);\n        assert(mapInfo.count(vRandom[n]) == 1);\n        vAddr.push_back(mapInfo[vRandom[n]]);\n    }\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n  {\n      int nNodes = ADAGSAN_GETADDR_MAX_PCT*vRandom.size()/100;\n      if (nNodes > ADAGSAN_GETADDR_MAX)\n          nNodes = ADAGSAN_GETADDR_MAX;\n  \n      // perform a random shuffle over the first nNodes elements of vRandom (selecting from all)\n      for (int n = 0; n<nNodes; n++)\n      {\n          int nRndPos = GetRandInt(vRandom.size() - n) + n;\n          SwapRandom(n, nRndPos);\n          assert(mapInfo.count(vRandom[n]) == 1);\n          vAddr.push_back(mapInfo[vRandom[n]]);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nstd::vector<CAddress> GetAddr()\n    {\n        Check();\n        std::vector<CAddress> vAddr;\n        {\n            LOCK(cs);\n            GetAddr_(vAddr);\n        }\n        Check();\n        return vAddr;\n    }"
  },
  {
    "function_name": "Select",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "466-476",
    "snippet": "CAddress Select(int nUnkBias = 50)\n    {\n        CAddress addrRet;\n        {\n            LOCK(cs);\n            Check();\n            addrRet = Select_(nUnkBias);\n            Check();\n        }\n        return addrRet;\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "Check_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "434-490",
          "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Select_",
          "args": [
            "nUnkBias"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "Select_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "389-431",
          "snippet": "CAddress CAddrMan::Select_(int nUnkBias)\n{\n    if (size() == 0)\n        return CAddress();\n\n    double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n    double nCorNew = sqrt(nNew) * nUnkBias;\n    if ((nCorTried + nCorNew)*GetRandInt(1<<30)/(1<<30) < nCorTried)\n    {\n        // use a tried node\n        double fChanceFactor = 1.0;\n        while(1)\n        {\n            int nKBucket = GetRandInt(vvTried.size());\n            std::vector<int> &vTried = vvTried[nKBucket];\n            if (vTried.size() == 0) continue;\n            int nPos = GetRandInt(vTried.size());\n            assert(mapInfo.count(vTried[nPos]) == 1);\n            CAddrInfo &info = mapInfo[vTried[nPos]];\n            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                return info;\n            fChanceFactor *= 1.2;\n        }\n    } else {\n        // use a new node\n        double fChanceFactor = 1.0;\n        while(1)\n        {\n            int nUBucket = GetRandInt(vvNew.size());\n            std::set<int> &vNew = vvNew[nUBucket];\n            if (vNew.size() == 0) continue;\n            int nPos = GetRandInt(vNew.size());\n            std::set<int>::iterator it = vNew.begin();\n            while (nPos--)\n                it++;\n            assert(mapInfo.count(*it) == 1);\n            CAddrInfo &info = mapInfo[*it];\n            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                return info;\n            fChanceFactor *= 1.2;\n        }\n    }\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  CAddress CAddrMan::Select_(int nUnkBias)\n  {\n      if (size() == 0)\n          return CAddress();\n  \n      double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n      double nCorNew = sqrt(nNew) * nUnkBias;\n      if ((nCorTried + nCorNew)*GetRandInt(1<<30)/(1<<30) < nCorTried)\n      {\n          // use a tried node\n          double fChanceFactor = 1.0;\n          while(1)\n          {\n              int nKBucket = GetRandInt(vvTried.size());\n              std::vector<int> &vTried = vvTried[nKBucket];\n              if (vTried.size() == 0) continue;\n              int nPos = GetRandInt(vTried.size());\n              assert(mapInfo.count(vTried[nPos]) == 1);\n              CAddrInfo &info = mapInfo[vTried[nPos]];\n              if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                  return info;\n              fChanceFactor *= 1.2;\n          }\n      } else {\n          // use a new node\n          double fChanceFactor = 1.0;\n          while(1)\n          {\n              int nUBucket = GetRandInt(vvNew.size());\n              std::set<int> &vNew = vvNew[nUBucket];\n              if (vNew.size() == 0) continue;\n              int nPos = GetRandInt(vNew.size());\n              std::set<int>::iterator it = vNew.begin();\n              while (nPos--)\n                  it++;\n              assert(mapInfo.count(*it) == 1);\n              CAddrInfo &info = mapInfo[*it];\n              if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                  return info;\n              fChanceFactor *= 1.2;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddress Select(int nUnkBias = 50)\n    {\n        CAddress addrRet;\n        {\n            LOCK(cs);\n            Check();\n            addrRet = Select_(nUnkBias);\n            Check();\n        }\n        return addrRet;\n    }"
  },
  {
    "function_name": "Attempt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "454-462",
    "snippet": "void Attempt(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Attempt_(addr, nTime);\n            Check();\n        }\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "Check_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "434-490",
          "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Attempt_",
          "args": [
            "addr",
            "nTime"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "Attempt_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "370-387",
          "snippet": "void CAddrMan::Attempt_(const CService &addr, int64_t nTime)\n{\n    CAddrInfo *pinfo = Find(addr);\n\n    // if not found, bail out\n    if (!pinfo)\n        return;\n\n    CAddrInfo &info = *pinfo;\n\n    // check whether we are talking about the exact same CService (including same port)\n    if (info != addr)\n        return;\n\n    // update info\n    info.nLastTry = nTime;\n    info.nAttempts++;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::Attempt_(const CService &addr, int64_t nTime)\n  {\n      CAddrInfo *pinfo = Find(addr);\n  \n      // if not found, bail out\n      if (!pinfo)\n          return;\n  \n      CAddrInfo &info = *pinfo;\n  \n      // check whether we are talking about the exact same CService (including same port)\n      if (info != addr)\n          return;\n  \n      // update info\n      info.nLastTry = nTime;\n      info.nAttempts++;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nvoid Attempt(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Attempt_(addr, nTime);\n            Check();\n        }\n    }"
  },
  {
    "function_name": "Good",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "443-451",
    "snippet": "void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Good_(addr, nTime);\n            Check();\n        }\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Check",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "Check_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "434-490",
          "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Good_",
          "args": [
            "addr",
            "nTime"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "Good_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "261-310",
          "snippet": "void CAddrMan::Good_(const CService &addr, int64_t nTime)\n{\n//    printf(\"Good: addr=%s\\n\", addr.ToString().c_str());\n\n    int nId;\n    CAddrInfo *pinfo = Find(addr, &nId);\n\n    // if not found, bail out\n    if (!pinfo)\n        return;\n\n    CAddrInfo &info = *pinfo;\n\n    // check whether we are talking about the exact same CService (including same port)\n    if (info != addr)\n        return;\n\n    // update info\n    info.nLastSuccess = nTime;\n    info.nLastTry = nTime;\n    info.nTime = nTime;\n    info.nAttempts = 0;\n\n    // if it is already in the tried set, don't do anything else\n    if (info.fInTried)\n        return;\n\n    // find a bucket it is in now\n    int nRnd = GetRandInt(vvNew.size());\n    int nUBucket = -1;\n    for (unsigned int n = 0; n < vvNew.size(); n++)\n    {\n        int nB = (n+nRnd) % vvNew.size();\n        std::set<int> &vNew = vvNew[nB];\n        if (vNew.count(nId))\n        {\n            nUBucket = nB;\n            break;\n        }\n    }\n\n    // if no bucket is found, something bad happened;\n    // TODO: maybe re-add the node, but for now, just bail out\n    if (nUBucket == -1) return;\n\n    printf(\"Moving %s to tried\\n\", addr.ToString().c_str());\n\n    // move nId to the tried tables\n    MakeTried(info, nId, nUBucket);\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::Good_(const CService &addr, int64_t nTime)\n  {\n  //    printf(\"Good: addr=%s\\n\", addr.ToString().c_str());\n  \n      int nId;\n      CAddrInfo *pinfo = Find(addr, &nId);\n  \n      // if not found, bail out\n      if (!pinfo)\n          return;\n  \n      CAddrInfo &info = *pinfo;\n  \n      // check whether we are talking about the exact same CService (including same port)\n      if (info != addr)\n          return;\n  \n      // update info\n      info.nLastSuccess = nTime;\n      info.nLastTry = nTime;\n      info.nTime = nTime;\n      info.nAttempts = 0;\n  \n      // if it is already in the tried set, don't do anything else\n      if (info.fInTried)\n          return;\n  \n      // find a bucket it is in now\n      int nRnd = GetRandInt(vvNew.size());\n      int nUBucket = -1;\n      for (unsigned int n = 0; n < vvNew.size(); n++)\n      {\n          int nB = (n+nRnd) % vvNew.size();\n          std::set<int> &vNew = vvNew[nB];\n          if (vNew.count(nId))\n          {\n              nUBucket = nB;\n              break;\n          }\n      }\n  \n      // if no bucket is found, something bad happened;\n      // TODO: maybe re-add the node, but for now, just bail out\n      if (nUBucket == -1) return;\n  \n      printf(\"Moving %s to tried\\n\", addr.ToString().c_str());\n  \n      // move nId to the tried tables\n      MakeTried(info, nId, nUBucket);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nvoid Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Good_(addr, nTime);\n            Check();\n        }\n    }"
  },
  {
    "function_name": "Add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "427-440",
    "snippet": "bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Added %i addresses from %s: %i tried, %i new\\n\"",
            "nAdd",
            "source.ToString().c_str()",
            "nTried",
            "nNew"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source.ToString",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Check",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "Check_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "434-490",
          "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Add_",
          "args": [
            "*it",
            "source",
            "nTimePenalty"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "Add_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "312-368",
          "snippet": "bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n{\n    if (!addr.IsRoutable())\n        return false;\n\n    bool fNew = false;\n    int nId;\n    CAddrInfo *pinfo = Find(addr, &nId);\n\n    if (pinfo)\n    {\n        // periodically update nTime\n        bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n        int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n        if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n            pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);\n\n        // add services\n        pinfo->nServices |= addr.nServices;\n\n        // do not update if no new information is present\n        if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n            return false;\n\n        // do not update if the entry was already in the \"tried\" table\n        if (pinfo->fInTried)\n            return false;\n\n        // do not update if the max reference count is reached\n        if (pinfo->nRefCount == ADAGSAN_NEW_BUCKETS_PER_ADDRESS)\n            return false;\n\n        // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n        int nFactor = 1;\n        for (int n=0; n<pinfo->nRefCount; n++)\n            nFactor *= 2;\n        if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n            return false;\n    } else {\n        pinfo = Create(addr, source, &nId);\n        pinfo->nTime = max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n//        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n        nNew++;\n        fNew = true;\n    }\n\n    int nUBucket = pinfo->GetNewBucket(nKey, source);\n    std::set<int> &vNew = vvNew[nUBucket];\n    if (!vNew.count(nId))\n    {\n        pinfo->nRefCount++;\n        if (vNew.size() == ADAGSAN_NEW_BUCKET_SIZE)\n            ShrinkNew(nUBucket);\n        vvNew[nUBucket].insert(nId);\n    }\n    return fNew;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n  {\n      if (!addr.IsRoutable())\n          return false;\n  \n      bool fNew = false;\n      int nId;\n      CAddrInfo *pinfo = Find(addr, &nId);\n  \n      if (pinfo)\n      {\n          // periodically update nTime\n          bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n          int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n          if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n              pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);\n  \n          // add services\n          pinfo->nServices |= addr.nServices;\n  \n          // do not update if no new information is present\n          if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n              return false;\n  \n          // do not update if the entry was already in the \"tried\" table\n          if (pinfo->fInTried)\n              return false;\n  \n          // do not update if the max reference count is reached\n          if (pinfo->nRefCount == ADAGSAN_NEW_BUCKETS_PER_ADDRESS)\n              return false;\n  \n          // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n          int nFactor = 1;\n          for (int n=0; n<pinfo->nRefCount; n++)\n              nFactor *= 2;\n          if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n              return false;\n      } else {\n          pinfo = Create(addr, source, &nId);\n          pinfo->nTime = max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n  //        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n          nNew++;\n          fNew = true;\n      }\n  \n      int nUBucket = pinfo->GetNewBucket(nKey, source);\n      std::set<int> &vNew = vvNew[nUBucket];\n      if (!vNew.count(nId))\n      {\n          pinfo->nRefCount++;\n          if (vNew.size() == ADAGSAN_NEW_BUCKET_SIZE)\n              ShrinkNew(nUBucket);\n          vvNew[nUBucket].insert(nId);\n      }\n      return fNew;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vAddr.end",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vAddr.begin",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nbool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }"
  },
  {
    "function_name": "Add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "412-424",
    "snippet": "bool Add(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        bool fRet = false;\n        {\n            LOCK(cs);\n            Check();\n            fRet |= Add_(addr, source, nTimePenalty);\n            Check();\n        }\n        if (fRet)\n            printf(\"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort().c_str(), source.ToString().c_str(), nTried, nNew);\n        return fRet;\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Added %s from %s: %i tried, %i new\\n\"",
            "addr.ToStringIPPort().c_str()",
            "source.ToString().c_str()",
            "nTried",
            "nNew"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "source.ToString",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.ToStringIPPort",
          "args": [],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIPPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1163-1170",
          "snippet": "std::string CService::ToStringIPPort() const\n{\n    if (IsIPv4() || IsTor() || IsI2P()) {\n        return ToStringIP() + \":\" + ToStringPort();\n    } else {\n        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToStringIPPort() const\n  {\n      if (IsIPv4() || IsTor() || IsI2P()) {\n          return ToStringIP() + \":\" + ToStringPort();\n      } else {\n          return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Check",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "Check_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "434-490",
          "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Add_",
          "args": [
            "addr",
            "source",
            "nTimePenalty"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "Add_",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "312-368",
          "snippet": "bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n{\n    if (!addr.IsRoutable())\n        return false;\n\n    bool fNew = false;\n    int nId;\n    CAddrInfo *pinfo = Find(addr, &nId);\n\n    if (pinfo)\n    {\n        // periodically update nTime\n        bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n        int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n        if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n            pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);\n\n        // add services\n        pinfo->nServices |= addr.nServices;\n\n        // do not update if no new information is present\n        if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n            return false;\n\n        // do not update if the entry was already in the \"tried\" table\n        if (pinfo->fInTried)\n            return false;\n\n        // do not update if the max reference count is reached\n        if (pinfo->nRefCount == ADAGSAN_NEW_BUCKETS_PER_ADDRESS)\n            return false;\n\n        // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n        int nFactor = 1;\n        for (int n=0; n<pinfo->nRefCount; n++)\n            nFactor *= 2;\n        if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n            return false;\n    } else {\n        pinfo = Create(addr, source, &nId);\n        pinfo->nTime = max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n//        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n        nNew++;\n        fNew = true;\n    }\n\n    int nUBucket = pinfo->GetNewBucket(nKey, source);\n    std::set<int> &vNew = vvNew[nUBucket];\n    if (!vNew.count(nId))\n    {\n        pinfo->nRefCount++;\n        if (vNew.size() == ADAGSAN_NEW_BUCKET_SIZE)\n            ShrinkNew(nUBucket);\n        vvNew[nUBucket].insert(nId);\n    }\n    return fNew;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n  {\n      if (!addr.IsRoutable())\n          return false;\n  \n      bool fNew = false;\n      int nId;\n      CAddrInfo *pinfo = Find(addr, &nId);\n  \n      if (pinfo)\n      {\n          // periodically update nTime\n          bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n          int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n          if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n              pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);\n  \n          // add services\n          pinfo->nServices |= addr.nServices;\n  \n          // do not update if no new information is present\n          if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n              return false;\n  \n          // do not update if the entry was already in the \"tried\" table\n          if (pinfo->fInTried)\n              return false;\n  \n          // do not update if the max reference count is reached\n          if (pinfo->nRefCount == ADAGSAN_NEW_BUCKETS_PER_ADDRESS)\n              return false;\n  \n          // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n          int nFactor = 1;\n          for (int n=0; n<pinfo->nRefCount; n++)\n              nFactor *= 2;\n          if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n              return false;\n      } else {\n          pinfo = Create(addr, source, &nId);\n          pinfo->nTime = max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n  //        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n          nNew++;\n          fNew = true;\n      }\n  \n      int nUBucket = pinfo->GetNewBucket(nKey, source);\n      std::set<int> &vNew = vvNew[nUBucket];\n      if (!vNew.count(nId))\n      {\n          pinfo->nRefCount++;\n          if (vNew.size() == ADAGSAN_NEW_BUCKET_SIZE)\n              ShrinkNew(nUBucket);\n          vvNew[nUBucket].insert(nId);\n      }\n      return fNew;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nbool Add(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        bool fRet = false;\n        {\n            LOCK(cs);\n            Check();\n            fRet |= Add_(addr, source, nTimePenalty);\n            Check();\n        }\n        if (fRet)\n            printf(\"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort().c_str(), source.ToString().c_str(), nTried, nNew);\n        return fRet;\n    }"
  },
  {
    "function_name": "GetNewBucket",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "83-86",
    "snippet": "int GetNewBucket(const std::vector<unsigned char> &nKey) const\n    {\n        return GetNewBucket(nKey, source);\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetNewBucket",
          "args": [
            "nKey",
            "source"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "GetNewBucket",
          "container": "CAddrInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "23-35",
          "snippet": "int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n{\n    CDataStream ss1(SER_GETHASH, 0);\n    std::vector<unsigned char> vchGroupKey = GetGroup();\n    std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n\n    CDataStream ss2(SER_GETHASH, 0);\n    ss2 << nKey << vchSourceGroupKey << (hash1 % ADAGSAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n    return hash2 % ADAGSAN_NEW_BUCKET_COUNT;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddrInfo {\n  int GetNewBucket(const std::vector<unsigned char> &nKey) const\n      {\n          return GetNewBucket(nKey, source);\n      }\n}"
  },
  {
    "function_name": "CAddrInfo",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "71-74",
    "snippet": "CAddrInfo() : CAddress(), source()\n    {\n        Init();\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CAddrInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "56-64",
          "snippet": "void Init()\n    {\n        nLastSuccess = 0;\n        nLastTry = 0;\n        nAttempts = 0;\n        nRefCount = 0;\n        fInTried = false;\n        nRandomPos = -1;\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddrInfo {\n  void Init()\n      {\n          nLastSuccess = 0;\n          nLastTry = 0;\n          nAttempts = 0;\n          nRefCount = 0;\n          fInTried = false;\n          nRandomPos = -1;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddrInfo {\n  CAddrInfo() : CAddress(), source()\n      {\n          Init();\n      }\n}"
  },
  {
    "function_name": "CAddrInfo",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "66-69",
    "snippet": "CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n    {\n        Init();\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CAddrInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "56-64",
          "snippet": "void Init()\n    {\n        nLastSuccess = 0;\n        nLastTry = 0;\n        nAttempts = 0;\n        nRefCount = 0;\n        fInTried = false;\n        nRandomPos = -1;\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddrInfo {\n  void Init()\n      {\n          nLastSuccess = 0;\n          nLastTry = 0;\n          nAttempts = 0;\n          nRefCount = 0;\n          fInTried = false;\n          nRandomPos = -1;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddrInfo {\n  CAddrInfo(const CAddress &addrIn, const CNetAddr &addrSource) : CAddress(addrIn), source(addrSource)\n      {\n          Init();\n      }\n}"
  },
  {
    "function_name": "Init",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
    "lines": "56-64",
    "snippet": "void Init()\n    {\n        nLastSuccess = 0;\n        nLastTry = 0;\n        nAttempts = 0;\n        nRefCount = 0;\n        fInTried = false;\n        nRandomPos = -1;\n    }",
    "includes": [
      "#include <openssl/rand.h>",
      "#include <vector>",
      "#include <map>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"protocol.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddrInfo {\n  void Init()\n      {\n          nLastSuccess = 0;\n          nLastTry = 0;\n          nAttempts = 0;\n          nRefCount = 0;\n          fInTried = false;\n          nRandomPos = -1;\n      }\n}"
  }
]