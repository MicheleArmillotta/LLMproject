[
  {
    "function_name": "Evict",
    "container": "TableCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
    "lines": "121-125",
    "snippet": "void TableCache::Evict(uint64_t file_number) {\n  char buf[sizeof(file_number)];\n  EncodeFixed64(buf, file_number);\n  cache_->Erase(Slice(buf, sizeof(buf)));\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/table_cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_->Erase",
          "args": [
            "Slice(buf, sizeof(buf))"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "Erase",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "126-142",
          "snippet": "bool Erase(const K& key)\n    {\n        if (!pdb)\n            return false;\n        if (fReadOnly)\n            assert(!\"Erase called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        if (activeBatch) {\n            activeBatch->Delete(ssKey.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Delete(leveldb::WriteOptions(), ssKey.str());\n        return (status.ok() || status.IsNotFound());\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Erase(const K& key)\n      {\n          if (!pdb)\n              return false;\n          if (fReadOnly)\n              assert(!\"Erase called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          if (activeBatch) {\n              activeBatch->Delete(ssKey.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Delete(leveldb::WriteOptions(), ssKey.str());\n          return (status.ok() || status.IsNotFound());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "buf",
            "sizeof(buf)"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeFixed64",
          "args": [
            "buf",
            "file_number"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeFixed64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "20-33",
          "snippet": "void EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  void TableCache::Evict(uint64_t file_number) {\n    char buf[sizeof(file_number)];\n    EncodeFixed64(buf, file_number);\n    cache_->Erase(Slice(buf, sizeof(buf)));\n  }\n}"
  },
  {
    "function_name": "Get",
    "container": "TableCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
    "lines": "105-119",
    "snippet": "Status TableCache::Get(const ReadOptions& options,\n                       uint64_t file_number,\n                       uint64_t file_size,\n                       const Slice& k,\n                       void* arg,\n                       void (*saver)(void*, const Slice&, const Slice&)) {\n  Cache::Handle* handle = NULL;\n  Status s = FindTable(file_number, file_size, &handle);\n  if (s.ok()) {\n    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;\n    s = t->InternalGet(options, k, arg, saver);\n    cache_->Release(handle);\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/table_cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_->Release",
          "args": [
            "handle"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "Release",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "302-305",
          "snippet": "virtual void Release(Handle* handle) {\n    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n    shard_[Shard(h->hash)].Release(handle);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual void Release(Handle* handle) {\n      LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n      shard_[Shard(h->hash)].Release(handle);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "t->InternalGet",
          "args": [
            "options",
            "k",
            "arg",
            "saver"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "InternalGet",
          "container": "Table",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
          "lines": "216-245",
          "snippet": "Status Table::InternalGet(const ReadOptions& options, const Slice& k,\n                          void* arg,\n                          void (*saver)(void*, const Slice&, const Slice&)) {\n  Status s;\n  Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);\n  iiter->Seek(k);\n  if (iiter->Valid()) {\n    Slice handle_value = iiter->value();\n    FilterBlockReader* filter = rep_->filter;\n    BlockHandle handle;\n    if (filter != NULL &&\n        handle.DecodeFrom(&handle_value).ok() &&\n        !filter->KeyMayMatch(handle.offset(), k)) {\n      // Not found\n    } else {\n      Iterator* block_iter = BlockReader(this, options, iiter->value());\n      block_iter->Seek(k);\n      if (block_iter->Valid()) {\n        (*saver)(arg, block_iter->key(), block_iter->value());\n      }\n      s = block_iter->status();\n      delete block_iter;\n    }\n  }\n  if (s.ok()) {\n    s = iiter->status();\n  }\n  delete iiter;\n  return s;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  Status Table::InternalGet(const ReadOptions& options, const Slice& k,\n                            void* arg,\n                            void (*saver)(void*, const Slice&, const Slice&)) {\n    Status s;\n    Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);\n    iiter->Seek(k);\n    if (iiter->Valid()) {\n      Slice handle_value = iiter->value();\n      FilterBlockReader* filter = rep_->filter;\n      BlockHandle handle;\n      if (filter != NULL &&\n          handle.DecodeFrom(&handle_value).ok() &&\n          !filter->KeyMayMatch(handle.offset(), k)) {\n        // Not found\n      } else {\n        Iterator* block_iter = BlockReader(this, options, iiter->value());\n        block_iter->Seek(k);\n        if (block_iter->Valid()) {\n          (*saver)(arg, block_iter->key(), block_iter->value());\n        }\n        s = block_iter->status();\n        delete block_iter;\n      }\n    }\n    if (s.ok()) {\n      s = iiter->status();\n    }\n    delete iiter;\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<TableAndFile*>",
          "args": [
            "cache_->Value(handle)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_->Value",
          "args": [
            "handle"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindTable",
          "args": [
            "file_number",
            "file_size",
            "&handle"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "FindTable",
          "container": "TableCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
          "lines": "45-80",
          "snippet": "Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,\n                             Cache::Handle** handle) {\n  Status s;\n  char buf[sizeof(file_number)];\n  EncodeFixed64(buf, file_number);\n  Slice key(buf, sizeof(buf));\n  *handle = cache_->Lookup(key);\n  if (*handle == NULL) {\n    std::string fname = TableFileName(dbname_, file_number);\n    RandomAccessFile* file = NULL;\n    Table* table = NULL;\n    s = env_->NewRandomAccessFile(fname, &file);\n    if (!s.ok()) {\n      std::string old_fname = SSTTableFileName(dbname_, file_number);\n      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {\n        s = Status::OK();\n      }\n    }\n    if (s.ok()) {\n      s = Table::Open(*options_, file, file_size, &table);\n    }\n\n    if (!s.ok()) {\n      assert(table == NULL);\n      delete file;\n      // We do not cache error results so that if the error is transient,\n      // or somebody repairs the file, we recover automatically.\n    } else {\n      TableAndFile* tf = new TableAndFile;\n      tf->file = file;\n      tf->table = table;\n      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/table_cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,\n                               Cache::Handle** handle) {\n    Status s;\n    char buf[sizeof(file_number)];\n    EncodeFixed64(buf, file_number);\n    Slice key(buf, sizeof(buf));\n    *handle = cache_->Lookup(key);\n    if (*handle == NULL) {\n      std::string fname = TableFileName(dbname_, file_number);\n      RandomAccessFile* file = NULL;\n      Table* table = NULL;\n      s = env_->NewRandomAccessFile(fname, &file);\n      if (!s.ok()) {\n        std::string old_fname = SSTTableFileName(dbname_, file_number);\n        if (env_->NewRandomAccessFile(old_fname, &file).ok()) {\n          s = Status::OK();\n        }\n      }\n      if (s.ok()) {\n        s = Table::Open(*options_, file, file_size, &table);\n      }\n  \n      if (!s.ok()) {\n        assert(table == NULL);\n        delete file;\n        // We do not cache error results so that if the error is transient,\n        // or somebody repairs the file, we recover automatically.\n      } else {\n        TableAndFile* tf = new TableAndFile;\n        tf->file = file;\n        tf->table = table;\n        *handle = cache_->Insert(key, tf, 1, &DeleteEntry);\n      }\n    }\n    return s;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  Status TableCache::Get(const ReadOptions& options,\n                         uint64_t file_number,\n                         uint64_t file_size,\n                         const Slice& k,\n                         void* arg,\n                         void (*saver)(void*, const Slice&, const Slice&)) {\n    Cache::Handle* handle = NULL;\n    Status s = FindTable(file_number, file_size, &handle);\n    if (s.ok()) {\n      Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;\n      s = t->InternalGet(options, k, arg, saver);\n      cache_->Release(handle);\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "FindTable",
    "container": "TableCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
    "lines": "45-80",
    "snippet": "Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,\n                             Cache::Handle** handle) {\n  Status s;\n  char buf[sizeof(file_number)];\n  EncodeFixed64(buf, file_number);\n  Slice key(buf, sizeof(buf));\n  *handle = cache_->Lookup(key);\n  if (*handle == NULL) {\n    std::string fname = TableFileName(dbname_, file_number);\n    RandomAccessFile* file = NULL;\n    Table* table = NULL;\n    s = env_->NewRandomAccessFile(fname, &file);\n    if (!s.ok()) {\n      std::string old_fname = SSTTableFileName(dbname_, file_number);\n      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {\n        s = Status::OK();\n      }\n    }\n    if (s.ok()) {\n      s = Table::Open(*options_, file, file_size, &table);\n    }\n\n    if (!s.ok()) {\n      assert(table == NULL);\n      delete file;\n      // We do not cache error results so that if the error is transient,\n      // or somebody repairs the file, we recover automatically.\n    } else {\n      TableAndFile* tf = new TableAndFile;\n      tf->file = file;\n      tf->table = table;\n      *handle = cache_->Insert(key, tf, 1, &DeleteEntry);\n    }\n  }\n  return s;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/table_cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_->Insert",
          "args": [
            "key",
            "tf",
            "1",
            "&DeleteEntry"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "table == NULL"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Table::Open",
          "args": [
            "*options_",
            "file",
            "file_size",
            "&table"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "Table",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
          "lines": "38-85",
          "snippet": "Status Table::Open(const Options& options,\n                   RandomAccessFile* file,\n                   uint64_t size,\n                   Table** table) {\n  *table = NULL;\n  if (size < Footer::kEncodedLength) {\n    return Status::InvalidArgument(\"file is too short to be an sstable\");\n  }\n\n  char footer_space[Footer::kEncodedLength];\n  Slice footer_input;\n  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,\n                        &footer_input, footer_space);\n  if (!s.ok()) return s;\n\n  Footer footer;\n  s = footer.DecodeFrom(&footer_input);\n  if (!s.ok()) return s;\n\n  // Read the index block\n  BlockContents contents;\n  Block* index_block = NULL;\n  if (s.ok()) {\n    s = ReadBlock(file, ReadOptions(), footer.index_handle(), &contents);\n    if (s.ok()) {\n      index_block = new Block(contents);\n    }\n  }\n\n  if (s.ok()) {\n    // We've successfully read the footer and the index block: we're\n    // ready to serve requests.\n    Rep* rep = new Table::Rep;\n    rep->options = options;\n    rep->file = file;\n    rep->metaindex_handle = footer.metaindex_handle();\n    rep->index_block = index_block;\n    rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);\n    rep->filter_data = NULL;\n    rep->filter = NULL;\n    *table = new Table(rep);\n    (*table)->ReadMeta(footer);\n  } else {\n    if (index_block) delete index_block;\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  Status Table::Open(const Options& options,\n                     RandomAccessFile* file,\n                     uint64_t size,\n                     Table** table) {\n    *table = NULL;\n    if (size < Footer::kEncodedLength) {\n      return Status::InvalidArgument(\"file is too short to be an sstable\");\n    }\n  \n    char footer_space[Footer::kEncodedLength];\n    Slice footer_input;\n    Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,\n                          &footer_input, footer_space);\n    if (!s.ok()) return s;\n  \n    Footer footer;\n    s = footer.DecodeFrom(&footer_input);\n    if (!s.ok()) return s;\n  \n    // Read the index block\n    BlockContents contents;\n    Block* index_block = NULL;\n    if (s.ok()) {\n      s = ReadBlock(file, ReadOptions(), footer.index_handle(), &contents);\n      if (s.ok()) {\n        index_block = new Block(contents);\n      }\n    }\n  \n    if (s.ok()) {\n      // We've successfully read the footer and the index block: we're\n      // ready to serve requests.\n      Rep* rep = new Table::Rep;\n      rep->options = options;\n      rep->file = file;\n      rep->metaindex_handle = footer.metaindex_handle();\n      rep->index_block = index_block;\n      rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);\n      rep->filter_data = NULL;\n      rep->filter = NULL;\n      *table = new Table(rep);\n      (*table)->ReadMeta(footer);\n    } else {\n      if (index_block) delete index_block;\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NewRandomAccessFile",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_->NewRandomAccessFile",
          "args": [
            "old_fname",
            "&file"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "NewRandomAccessFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "164-186",
          "snippet": "Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {\n    class CountingFile : public RandomAccessFile {\n     private:\n      RandomAccessFile* target_;\n      AtomicCounter* counter_;\n     public:\n      CountingFile(RandomAccessFile* target, AtomicCounter* counter)\n          : target_(target), counter_(counter) {\n      }\n      virtual ~CountingFile() { delete target_; }\n      virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                          char* scratch) const {\n        counter_->Increment();\n        return target_->Read(offset, n, result, scratch);\n      }\n    };\n\n    Status s = target()->NewRandomAccessFile(f, r);\n    if (s.ok() && count_random_reads_) {\n      *r = new CountingFile(*r, &random_read_counter_);\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {\n      class CountingFile : public RandomAccessFile {\n       private:\n        RandomAccessFile* target_;\n        AtomicCounter* counter_;\n       public:\n        CountingFile(RandomAccessFile* target, AtomicCounter* counter)\n            : target_(target), counter_(counter) {\n        }\n        virtual ~CountingFile() { delete target_; }\n        virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                            char* scratch) const {\n          counter_->Increment();\n          return target_->Read(offset, n, result, scratch);\n        }\n      };\n  \n      Status s = target()->NewRandomAccessFile(f, r);\n      if (s.ok() && count_random_reads_) {\n        *r = new CountingFile(*r, &random_read_counter_);\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSTTableFileName",
          "args": [
            "dbname_",
            "file_number"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "SSTTableFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "42-45",
          "snippet": "std::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_->Lookup",
          "args": [
            "key"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": "CacheTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache_test.cc",
          "lines": "48-55",
          "snippet": "int Lookup(int key) {\n    Cache::Handle* handle = cache_->Lookup(EncodeKey(key));\n    const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));\n    if (handle != NULL) {\n      cache_->Release(handle);\n    }\n    return r;\n  }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/coding.h\"",
            "#include <vector>",
            "#include \"leveldb/cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/coding.h\"\n#include <vector>\n#include \"leveldb/cache.h\"\n\nCacheTest {\n  int Lookup(int key) {\n      Cache::Handle* handle = cache_->Lookup(EncodeKey(key));\n      const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));\n      if (handle != NULL) {\n        cache_->Release(handle);\n      }\n      return r;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeFixed64",
          "args": [
            "buf",
            "file_number"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeFixed64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "20-33",
          "snippet": "void EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,\n                               Cache::Handle** handle) {\n    Status s;\n    char buf[sizeof(file_number)];\n    EncodeFixed64(buf, file_number);\n    Slice key(buf, sizeof(buf));\n    *handle = cache_->Lookup(key);\n    if (*handle == NULL) {\n      std::string fname = TableFileName(dbname_, file_number);\n      RandomAccessFile* file = NULL;\n      Table* table = NULL;\n      s = env_->NewRandomAccessFile(fname, &file);\n      if (!s.ok()) {\n        std::string old_fname = SSTTableFileName(dbname_, file_number);\n        if (env_->NewRandomAccessFile(old_fname, &file).ok()) {\n          s = Status::OK();\n        }\n      }\n      if (s.ok()) {\n        s = Table::Open(*options_, file, file_size, &table);\n      }\n  \n      if (!s.ok()) {\n        assert(table == NULL);\n        delete file;\n        // We do not cache error results so that if the error is transient,\n        // or somebody repairs the file, we recover automatically.\n      } else {\n        TableAndFile* tf = new TableAndFile;\n        tf->file = file;\n        tf->table = table;\n        *handle = cache_->Insert(key, tf, 1, &DeleteEntry);\n      }\n    }\n    return s;\n  }\n}"
  },
  {
    "function_name": "~TableCache",
    "container": "TableCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
    "lines": "41-43",
    "snippet": "TableCache::~TableCache() {\n  delete cache_;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/table_cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  TableCache::~TableCache() {\n    delete cache_;\n  }\n}"
  },
  {
    "function_name": "TableCache",
    "container": "TableCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
    "lines": "32-39",
    "snippet": "TableCache::TableCache(const std::string& dbname,\n                       const Options* options,\n                       int entries)\n    : env_(options->env),\n      dbname_(dbname),\n      options_(options),\n      cache_(NewLRUCache(entries)) {\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/table_cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NewLRUCache",
          "args": [
            "entries"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  TableCache::TableCache(const std::string& dbname,\n                         const Options* options,\n                         int entries)\n      : env_(options->env),\n        dbname_(dbname),\n        options_(options),\n        cache_(NewLRUCache(entries)) {\n  }\n}"
  },
  {
    "function_name": "UnrefEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
    "lines": "26-30",
    "snippet": "static void UnrefEntry(void* arg1, void* arg2) {\n  Cache* cache = reinterpret_cast<Cache*>(arg1);\n  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);\n  cache->Release(h);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/table_cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache->Release",
          "args": [
            "h"
          ],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "Release",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "302-305",
          "snippet": "virtual void Release(Handle* handle) {\n    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n    shard_[Shard(h->hash)].Release(handle);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual void Release(Handle* handle) {\n      LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n      shard_[Shard(h->hash)].Release(handle);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Cache::Handle*>",
          "args": [
            "arg2"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Cache*>",
          "args": [
            "arg1"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nstatic void UnrefEntry(void* arg1, void* arg2) {\n  Cache* cache = reinterpret_cast<Cache*>(arg1);\n  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);\n  cache->Release(h);\n}"
  },
  {
    "function_name": "DeleteEntry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
    "lines": "19-24",
    "snippet": "static void DeleteEntry(const Slice& key, void* value) {\n  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);\n  delete tf->table;\n  delete tf->file;\n  delete tf;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/table_cache.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<TableAndFile*>",
          "args": [
            "value"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nstatic void DeleteEntry(const Slice& key, void* value) {\n  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);\n  delete tf->table;\n  delete tf->file;\n  delete tf;\n}"
  }
]