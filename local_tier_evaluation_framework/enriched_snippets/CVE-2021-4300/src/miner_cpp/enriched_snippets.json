[
  {
    "function_name": "StakeMiner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "476-536",
    "snippet": "void StakeMiner(CWallet *pwallet)\n{\n    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n\n    // Make this thread recognisable as the mining thread\n    RenameThread(\"hal-stakeminer\");\n\n    bool fTryToSync = true;\n\n    while (true)\n    {\n        if (fShutdown)\n            return;\n\n        while (pwallet->IsLocked())\n        {\n            nLastCoinStakeSearchInterval = 0;\n            MilliSleep(1000);\n            if (fShutdown)\n                return;\n        }\n\n        while (vNodes.empty() || IsInitialBlockDownload())\n        {\n            nLastCoinStakeSearchInterval = 0;\n            fTryToSync = true;\n            MilliSleep(1000);\n            if (fShutdown)\n                return;\n        }\n\n        if (fTryToSync)\n        {\n            fTryToSync = false;\n            if (vNodes.size() < 3 || nBestHeight < GetNumBlocksOfPeers())\n            {\n                MilliSleep(60000);\n                continue;\n            }\n        }\n\n        //\n        // Create new block\n        //\n        int64_t nFees;\n        auto_ptr<CBlock> pblock(CreateNewBlock(pwallet, true, &nFees));\n        if (!pblock.get())\n            return;\n\n        // Trying to sign a block\n        if (pblock->SignBlock(*pwallet, nFees))\n        {\n            SetThreadPriority(THREAD_PRIORITY_NORMAL);\n            CheckStake(pblock.get(), *pwallet);\n            SetThreadPriority(THREAD_PRIORITY_LOWEST);\n            MilliSleep(500);\n        }\n        else\n            MilliSleep(nMinerSleep);\n    }\n}",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern unsigned int nMinerSleep;",
      "int64_t nLastCoinStakeSearchInterval = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "nMinerSleep"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetThreadPriority",
          "args": [
            "THREAD_PRIORITY_LOWEST"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "SetThreadPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "648-657",
          "snippet": "inline void SetThreadPriority(int nPriority)\n{\n    // It's unclear if it's even possible to change thread priorities on Linux,\n    // but we really and truly need it for the generation threads.\n#ifdef PRIO_THREAD\n    setpriority(PRIO_THREAD, 0, nPriority);\n#else\n    setpriority(PRIO_PROCESS, 0, nPriority);\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void SetThreadPriority(int nPriority)\n{\n    // It's unclear if it's even possible to change thread priorities on Linux,\n    // but we really and truly need it for the generation threads.\n#ifdef PRIO_THREAD\n    setpriority(PRIO_THREAD, 0, nPriority);\n#else\n    setpriority(PRIO_PROCESS, 0, nPriority);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckStake",
          "args": [
            "pblock.get()",
            "*pwallet"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "CheckStake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
          "lines": "434-474",
          "snippet": "bool CheckStake(CBlock* pblock, CWallet& wallet) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = 0;\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfStake())\n      return(error(\"CheckStake() : %s is not a proof-of-stake block\",\n        hashBlock.GetHex().c_str()));\n\n    uint256 hashProof;\n\n    /* Verify hash target and coin stake signature */\n    if(!CheckProofOfStake(pblock->vtx[1], pblock->nBits, hashProof, hashTarget))\n      return(error(\"CheckStake() : proof-of-stake check failed\"));\n\n    printf(\"CheckStake() : new proof-of-stake block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"out %s\\n\", FormatMoney(pblock->vtx[1].GetValueOut()).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckStake() : generated block is stale\");\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckStake() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"kernel.h\"",
            "#include \"miner.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nbool CheckStake(CBlock* pblock, CWallet& wallet) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = 0;\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfStake())\n      return(error(\"CheckStake() : %s is not a proof-of-stake block\",\n        hashBlock.GetHex().c_str()));\n\n    uint256 hashProof;\n\n    /* Verify hash target and coin stake signature */\n    if(!CheckProofOfStake(pblock->vtx[1], pblock->nBits, hashProof, hashTarget))\n      return(error(\"CheckStake() : proof-of-stake check failed\"));\n\n    printf(\"CheckStake() : new proof-of-stake block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"out %s\\n\", FormatMoney(pblock->vtx[1].GetValueOut()).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckStake() : generated block is stale\");\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckStake() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock.get",
          "args": [],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pblock->SignBlock",
          "args": [
            "*pwallet",
            "nFees"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "SignBlock",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2515-2563",
          "snippet": "bool CBlock::SignBlock(CWallet& wallet, int64_t nFees)\n{\n    // if we are trying to sign\n    //    something except proof-of-stake block template\n    if (!vtx[0].vout[0].IsEmpty())\n        return false;\n\n    // if we are trying to sign\n    //    a complete proof-of-stake block\n    if (IsProofOfStake())\n        return true;\n\n    static int64_t nLastCoinStakeSearchTime = GetAdjustedTime(); // startup timestamp\n\n    CKey key;\n    CTransaction txCoinStake;\n    int64_t nSearchTime = txCoinStake.nTime; // search to current time\n\n    if (nSearchTime > nLastCoinStakeSearchTime)\n    {\n        if (wallet.CreateCoinStake(wallet, nBits, nSearchTime-nLastCoinStakeSearchTime, nFees, txCoinStake, key))\n        {\n            if(txCoinStake.nTime >= max((pindexBest->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1),\n              PastDrift(pindexBest->GetBlockTime()))) {\n\n                // make sure coinstake would meet timestamp protocol\n                //    as it would be the same as the block timestamp\n                vtx[0].nTime = nTime = txCoinStake.nTime;\n                nTime = max(pindexBest->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1, GetMaxTransactionTime());\n                nTime = max(GetBlockTime(), PastDrift(pindexBest->GetBlockTime()));\n\n                // we have to make sure that we have no future timestamps in\n                //    our transactions set\n                for (vector<CTransaction>::iterator it = vtx.begin(); it != vtx.end();)\n                    if (it->nTime > nTime) { it = vtx.erase(it); } else { ++it; }\n\n                vtx.insert(vtx.begin() + 1, txCoinStake);\n                hashMerkleRoot = BuildMerkleTree();\n\n                // append a signature to our block\n                return key.Sign(GetHash(), vchBlockSig);\n            }\n        }\n        nLastCoinStakeSearchInterval = nSearchTime - nLastCoinStakeSearchTime;\n        nLastCoinStakeSearchTime = nSearchTime;\n    }\n\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlockIndex* pindexBest = NULL;\n\nCBlock {\n  bool CBlock::SignBlock(CWallet& wallet, int64_t nFees)\n  {\n      // if we are trying to sign\n      //    something except proof-of-stake block template\n      if (!vtx[0].vout[0].IsEmpty())\n          return false;\n  \n      // if we are trying to sign\n      //    a complete proof-of-stake block\n      if (IsProofOfStake())\n          return true;\n  \n      static int64_t nLastCoinStakeSearchTime = GetAdjustedTime(); // startup timestamp\n  \n      CKey key;\n      CTransaction txCoinStake;\n      int64_t nSearchTime = txCoinStake.nTime; // search to current time\n  \n      if (nSearchTime > nLastCoinStakeSearchTime)\n      {\n          if (wallet.CreateCoinStake(wallet, nBits, nSearchTime-nLastCoinStakeSearchTime, nFees, txCoinStake, key))\n          {\n              if(txCoinStake.nTime >= max((pindexBest->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1),\n                PastDrift(pindexBest->GetBlockTime()))) {\n  \n                  // make sure coinstake would meet timestamp protocol\n                  //    as it would be the same as the block timestamp\n                  vtx[0].nTime = nTime = txCoinStake.nTime;\n                  nTime = max(pindexBest->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1, GetMaxTransactionTime());\n                  nTime = max(GetBlockTime(), PastDrift(pindexBest->GetBlockTime()));\n  \n                  // we have to make sure that we have no future timestamps in\n                  //    our transactions set\n                  for (vector<CTransaction>::iterator it = vtx.begin(); it != vtx.end();)\n                      if (it->nTime > nTime) { it = vtx.erase(it); } else { ++it; }\n  \n                  vtx.insert(vtx.begin() + 1, txCoinStake);\n                  hashMerkleRoot = BuildMerkleTree();\n  \n                  // append a signature to our block\n                  return key.Sign(GetHash(), vchBlockSig);\n              }\n          }\n          nLastCoinStakeSearchInterval = nSearchTime - nLastCoinStakeSearchTime;\n          nLastCoinStakeSearchTime = nSearchTime;\n      }\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock.get",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateNewBlock",
          "args": [
            "pwallet",
            "true",
            "&nFees"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetNumBlocksOfPeers",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "GetNumBlocksOfPeers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1215-1218",
          "snippet": "int GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CMedianFilter<int> cPeerBlockCounts(5, 0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCMedianFilter<int> cPeerBlockCounts(5, 0);\n\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNodes.size",
          "args": [],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInitialBlockDownload",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "IsInitialBlockDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1220-1233",
          "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nBestHeight = -1;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNodes.empty",
          "args": [],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->IsLocked",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocked",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "134-144",
          "snippet": "bool IsLocked() const\n    {\n        if (!IsCrypted())\n            return false;\n        bool result;\n        {\n            LOCK(cs_KeyStore);\n            result = vMasterKey.empty();\n        }\n        return result;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool IsLocked() const\n      {\n          if (!IsCrypted())\n              return false;\n          bool result;\n          {\n              LOCK(cs_KeyStore);\n              result = vMasterKey.empty();\n          }\n          return result;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-stakeminer\""
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nextern unsigned int nMinerSleep;\nint64_t nLastCoinStakeSearchInterval = 0;\n\nvoid StakeMiner(CWallet *pwallet)\n{\n    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n\n    // Make this thread recognisable as the mining thread\n    RenameThread(\"hal-stakeminer\");\n\n    bool fTryToSync = true;\n\n    while (true)\n    {\n        if (fShutdown)\n            return;\n\n        while (pwallet->IsLocked())\n        {\n            nLastCoinStakeSearchInterval = 0;\n            MilliSleep(1000);\n            if (fShutdown)\n                return;\n        }\n\n        while (vNodes.empty() || IsInitialBlockDownload())\n        {\n            nLastCoinStakeSearchInterval = 0;\n            fTryToSync = true;\n            MilliSleep(1000);\n            if (fShutdown)\n                return;\n        }\n\n        if (fTryToSync)\n        {\n            fTryToSync = false;\n            if (vNodes.size() < 3 || nBestHeight < GetNumBlocksOfPeers())\n            {\n                MilliSleep(60000);\n                continue;\n            }\n        }\n\n        //\n        // Create new block\n        //\n        int64_t nFees;\n        auto_ptr<CBlock> pblock(CreateNewBlock(pwallet, true, &nFees));\n        if (!pblock.get())\n            return;\n\n        // Trying to sign a block\n        if (pblock->SignBlock(*pwallet, nFees))\n        {\n            SetThreadPriority(THREAD_PRIORITY_NORMAL);\n            CheckStake(pblock.get(), *pwallet);\n            SetThreadPriority(THREAD_PRIORITY_LOWEST);\n            MilliSleep(500);\n        }\n        else\n            MilliSleep(nMinerSleep);\n    }\n}"
  },
  {
    "function_name": "CheckStake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "434-474",
    "snippet": "bool CheckStake(CBlock* pblock, CWallet& wallet) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = 0;\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfStake())\n      return(error(\"CheckStake() : %s is not a proof-of-stake block\",\n        hashBlock.GetHex().c_str()));\n\n    uint256 hashProof;\n\n    /* Verify hash target and coin stake signature */\n    if(!CheckProofOfStake(pblock->vtx[1], pblock->nBits, hashProof, hashTarget))\n      return(error(\"CheckStake() : proof-of-stake check failed\"));\n\n    printf(\"CheckStake() : new proof-of-stake block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"out %s\\n\", FormatMoney(pblock->vtx[1].GetValueOut()).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckStake() : generated block is stale\");\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckStake() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckStake() : ProcessBlock, block not accepted\""
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessBlock",
          "args": [
            "NULL",
            "pblock"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2428-2512",
          "snippet": "bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "set<pair<COutPoint, unsigned int> > setStakeSeen;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexBest = NULL;",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "multimap<uint256, CBlock*> mapOrphanBlocksByPrev;",
            "set<pair<COutPoint, unsigned int> > setStakeSeenOrphan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "wallet.cs_wallet"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_main"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"out %s\\n\"",
            "FormatMoney(pblock->vtx[1].GetValueOut()).c_str()"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "pblock->vtx[1].GetValueOut()"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pblock->vtx[1].GetValueOut",
          "args": [],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueOut",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "577-587",
          "snippet": "int64_t GetValueOut() const\n    {\n        int64_t nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  int64_t GetValueOut() const\n      {\n          int64_t nValueOut = 0;\n          BOOST_FOREACH(const CTxOut& txout, vout)\n          {\n              nValueOut += txout.nValue;\n              if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                  throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n          }\n          return nValueOut;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->print",
          "args": [],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "print",
          "container": "COrphan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
          "lines": "35-41",
          "snippet": "void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n               ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }",
          "includes": [
            "#include \"kernel.h\"",
            "#include \"miner.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nCOrphan {\n  void print() const\n      {\n          printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n                 ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n          BOOST_FOREACH(uint256 hash, setDependsOn)\n              printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CheckStake() : new proof-of-stake block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\"",
            "nBlockHeight",
            "hashBlock.GetHex().c_str()",
            "hashProof.GetHex().c_str()",
            "hashTarget.GetHex().c_str()"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashTarget.GetHex",
          "args": [],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "GetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "402-405",
          "snippet": "std::string GetHex() const\n    {\n        return ToString(16);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  std::string GetHex() const\n      {\n          return ToString(16);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckProofOfStake",
          "args": [
            "pblock->vtx[1]",
            "pblock->nBits",
            "hashProof",
            "hashTarget"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "CheckProofOfStake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "342-370",
          "snippet": "bool CheckProofOfStake(const CTransaction& tx, unsigned int nBits, uint256& hashProofOfStake, uint256& targetProofOfStake)\n{\n    if (!tx.IsCoinStake())\n        return error(\"CheckProofOfStake() : called on non-coinstake %s\", tx.GetHash().ToString().c_str());\n\n    // Kernel (input 0) must match the stake hash target per coin age (nBits)\n    const CTxIn& txin = tx.vin[0];\n\n    // First try finding the previous transaction in database\n    CTxDB txdb(\"r\");\n    CTransaction txPrev;\n    CTxIndex txindex;\n    if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: read txPrev failed\"));  // previous transaction not in main chain, may occur during initial download\n\n    // Verify signature\n    if (!VerifySignature(txPrev, tx, 0, 0))\n        return tx.DoS(100, error(\"CheckProofOfStake() : VerifySignature failed on coinstake %s\", tx.GetHash().ToString().c_str()));\n\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n        return fDebug? error(\"CheckProofOfStake() : read block failed\") : false; // unable to read block of previous transaction\n\n    if (!CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, txPrev, txin.prevout, tx.nTime, hashProofOfStake, targetProofOfStake, fDebug))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\", tx.GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str())); // may occur during initial download or if behind on block chain sync\n\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool CheckProofOfStake(const CTransaction& tx, unsigned int nBits, uint256& hashProofOfStake, uint256& targetProofOfStake)\n{\n    if (!tx.IsCoinStake())\n        return error(\"CheckProofOfStake() : called on non-coinstake %s\", tx.GetHash().ToString().c_str());\n\n    // Kernel (input 0) must match the stake hash target per coin age (nBits)\n    const CTxIn& txin = tx.vin[0];\n\n    // First try finding the previous transaction in database\n    CTxDB txdb(\"r\");\n    CTransaction txPrev;\n    CTxIndex txindex;\n    if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: read txPrev failed\"));  // previous transaction not in main chain, may occur during initial download\n\n    // Verify signature\n    if (!VerifySignature(txPrev, tx, 0, 0))\n        return tx.DoS(100, error(\"CheckProofOfStake() : VerifySignature failed on coinstake %s\", tx.GetHash().ToString().c_str()));\n\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n        return fDebug? error(\"CheckProofOfStake() : read block failed\") : false; // unable to read block of previous transaction\n\n    if (!CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, txPrev, txin.prevout, tx.nTime, hashProofOfStake, targetProofOfStake, fDebug))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\", tx.GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str())); // may occur during initial download or if behind on block chain sync\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckStake() : %s is not a proof-of-stake block\"",
            "hashBlock.GetHex().c_str()"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->IsProofOfStake",
          "args": [],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->GetBlockHeight",
          "args": [],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHeight",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "956-976",
          "snippet": "int GetBlockHeight() const {\n        /* Prevents a crash if called on a block header alone */\n        if(vtx.size()) {\n            /* Serialised CScript */\n            std::vector<uchar>::const_iterator scriptsig = vtx[0].vin[0].scriptSig.begin();\n            uchar i, scount = scriptsig[0];\n            /* Optimise: nTime is 4 bytes always,\n             * nHeight must be less for a long time;\n             * check against a threshold when the time comes */\n            if(scount < 4) {\n                int height = 0;\n                uchar *pheight = (uchar *) &height;\n                for(i = 0; i < scount; i++)\n                  pheight[i] = scriptsig[i + 1];\n                /* v2+ block with nHeight in coin base */\n                return(height);\n            }\n        }\n        /* Not found */\n        return(-1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  int GetBlockHeight() const {\n          /* Prevents a crash if called on a block header alone */\n          if(vtx.size()) {\n              /* Serialised CScript */\n              std::vector<uchar>::const_iterator scriptsig = vtx[0].vin[0].scriptSig.begin();\n              uchar i, scount = scriptsig[0];\n              /* Optimise: nTime is 4 bytes always,\n               * nHeight must be less for a long time;\n               * check against a threshold when the time comes */\n              if(scount < 4) {\n                  int height = 0;\n                  uchar *pheight = (uchar *) &height;\n                  for(i = 0; i < scount; i++)\n                    pheight[i] = scriptsig[i + 1];\n                  /* v2+ block with nHeight in coin base */\n                  return(height);\n              }\n          }\n          /* Not found */\n          return(-1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->GetHash",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nbool CheckStake(CBlock* pblock, CWallet& wallet) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = 0;\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfStake())\n      return(error(\"CheckStake() : %s is not a proof-of-stake block\",\n        hashBlock.GetHex().c_str()));\n\n    uint256 hashProof;\n\n    /* Verify hash target and coin stake signature */\n    if(!CheckProofOfStake(pblock->vtx[1], pblock->nBits, hashProof, hashTarget))\n      return(error(\"CheckStake() : proof-of-stake check failed\"));\n\n    printf(\"CheckStake() : new proof-of-stake block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"out %s\\n\", FormatMoney(pblock->vtx[1].GetValueOut()).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckStake() : generated block is stale\");\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckStake() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "CheckWork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "388-431",
    "snippet": "bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfWork())\n      return(error(\"CheckWork() : %s height %d is not a proof-of-work block\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    uint256 hashProof = pblock->GetHashPoW();\n\n    if(hashProof > hashTarget)\n      return(error(\"CheckWork() : block %s height %d proof-of-work not meeting target\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    printf(\"CheckWork() : new proof-of-work block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckWork() : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckWork() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckWork() : ProcessBlock, block not accepted\""
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessBlock",
          "args": [
            "NULL",
            "pblock"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2428-2512",
          "snippet": "bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "set<pair<COutPoint, unsigned int> > setStakeSeen;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexBest = NULL;",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "multimap<uint256, CBlock*> mapOrphanBlocksByPrev;",
            "set<pair<COutPoint, unsigned int> > setStakeSeenOrphan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "wallet.cs_wallet"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reservekey.KeepKey",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_main"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"generated %s\\n\"",
            "FormatMoney(pblock->vtx[0].vout[0].nValue).c_str()"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "pblock->vtx[0].vout[0].nValue"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pblock->print",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "print",
          "container": "COrphan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
          "lines": "35-41",
          "snippet": "void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n               ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }",
          "includes": [
            "#include \"kernel.h\"",
            "#include \"miner.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nCOrphan {\n  void print() const\n      {\n          printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n                 ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n          BOOST_FOREACH(uint256 hash, setDependsOn)\n              printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CheckWork() : new proof-of-work block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\"",
            "nBlockHeight",
            "hashBlock.GetHex().c_str()",
            "hashProof.GetHex().c_str()",
            "hashTarget.GetHex().c_str()"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashTarget.GetHex",
          "args": [],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "GetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "402-405",
          "snippet": "std::string GetHex() const\n    {\n        return ToString(16);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  std::string GetHex() const\n      {\n          return ToString(16);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckWork() : block %s height %d proof-of-work not meeting target\"",
            "hashBlock.GetHex().c_str()",
            "nBlockHeight"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->GetHashPoW",
          "args": [],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->IsProofOfWork",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->GetBlockHeight",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHeight",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "956-976",
          "snippet": "int GetBlockHeight() const {\n        /* Prevents a crash if called on a block header alone */\n        if(vtx.size()) {\n            /* Serialised CScript */\n            std::vector<uchar>::const_iterator scriptsig = vtx[0].vin[0].scriptSig.begin();\n            uchar i, scount = scriptsig[0];\n            /* Optimise: nTime is 4 bytes always,\n             * nHeight must be less for a long time;\n             * check against a threshold when the time comes */\n            if(scount < 4) {\n                int height = 0;\n                uchar *pheight = (uchar *) &height;\n                for(i = 0; i < scount; i++)\n                  pheight[i] = scriptsig[i + 1];\n                /* v2+ block with nHeight in coin base */\n                return(height);\n            }\n        }\n        /* Not found */\n        return(-1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  int GetBlockHeight() const {\n          /* Prevents a crash if called on a block header alone */\n          if(vtx.size()) {\n              /* Serialised CScript */\n              std::vector<uchar>::const_iterator scriptsig = vtx[0].vin[0].scriptSig.begin();\n              uchar i, scount = scriptsig[0];\n              /* Optimise: nTime is 4 bytes always,\n               * nHeight must be less for a long time;\n               * check against a threshold when the time comes */\n              if(scount < 4) {\n                  int height = 0;\n                  uchar *pheight = (uchar *) &height;\n                  for(i = 0; i < scount; i++)\n                    pheight[i] = scriptsig[i + 1];\n                  /* v2+ block with nHeight in coin base */\n                  return(height);\n              }\n          }\n          /* Not found */\n          return(-1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "pblock->nBits"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->GetHash",
          "args": [],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfWork())\n      return(error(\"CheckWork() : %s height %d is not a proof-of-work block\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    uint256 hashProof = pblock->GetHashPoW();\n\n    if(hashProof > hashTarget)\n      return(error(\"CheckWork() : block %s height %d proof-of-work not meeting target\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    printf(\"CheckWork() : new proof-of-work block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckWork() : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckWork() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "FormatDataBuffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "363-385",
    "snippet": "void FormatDataBuffer(CBlock *pblock, uint *pdata) {\n    uint i;\n\n    struct {\n        int nVersion;\n        uint256 hashPrevBlock;\n        uint256 hashMerkleRoot;\n        uint nTime;\n        uint nBits;\n        uint nNonce;\n    } data;\n\n    data.nVersion       = pblock->nVersion;\n    data.hashPrevBlock  = pblock->hashPrevBlock;\n    data.hashMerkleRoot = pblock->hashMerkleRoot;\n    data.nTime          = pblock->nTime;\n    data.nBits          = pblock->nBits;\n    data.nNonce         = pblock->nNonce;\n\n    /* Copy the LE data */\n    for(i = 0; i < 20; i++)\n      pdata[i] = ((uint *) &data)[i];\n}",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nvoid FormatDataBuffer(CBlock *pblock, uint *pdata) {\n    uint i;\n\n    struct {\n        int nVersion;\n        uint256 hashPrevBlock;\n        uint256 hashMerkleRoot;\n        uint nTime;\n        uint nBits;\n        uint nNonce;\n    } data;\n\n    data.nVersion       = pblock->nVersion;\n    data.hashPrevBlock  = pblock->hashPrevBlock;\n    data.hashMerkleRoot = pblock->hashMerkleRoot;\n    data.nTime          = pblock->nTime;\n    data.nBits          = pblock->nBits;\n    data.nNonce         = pblock->nNonce;\n\n    /* Copy the LE data */\n    for(i = 0; i < 20; i++)\n      pdata[i] = ((uint *) &data)[i];\n}"
  },
  {
    "function_name": "IncrementExtraNonce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "343-359",
    "snippet": "void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n\n    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pblock->BuildMerkleTree",
          "args": [],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "BuildMerkleTree",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1020-1037",
          "snippet": "uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 BuildMerkleTree() const\n      {\n          vMerkleTree.clear();\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              vMerkleTree.push_back(tx.GetHash());\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              for (int i = 0; i < nSize; i += 2)\n              {\n                  int i2 = std::min(i+1, nSize-1);\n                  vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                             BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n              }\n              j += nSize;\n          }\n          return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pblock->vtx[0].vin[0].scriptSig.size() <= 100"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pblock->vtx[0].vin[0].scriptSig.size",
          "args": [],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "nExtraNonce"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "CScriptID",
          "container": "CScriptID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "59-59",
          "snippet": "CScriptID() : uint160(0) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCScriptID {\n  CScriptID() : uint160(0) { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n\n    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}"
  },
  {
    "function_name": "TxPriorityCompare",
    "container": "TxPriorityCompare",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "55-55",
    "snippet": "TxPriorityCompare(bool _byFee) : byFee(_byFee) { }",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nTxPriorityCompare {\n  TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n}"
  },
  {
    "function_name": "print",
    "container": "COrphan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "35-41",
    "snippet": "void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n               ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"   setDependsOn %s\\n\"",
            "hash.ToString().substr(0,10).c_str()"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [
            "0",
            "10"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\"",
            "ptx->GetHash().ToString().substr(0,10).c_str()",
            "dPriority",
            "dFeePerKb"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptx->GetHash",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptx->GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nCOrphan {\n  void print() const\n      {\n          printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n                 ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n          BOOST_FOREACH(uint256 hash, setDependsOn)\n              printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n      }\n}"
  },
  {
    "function_name": "COrphan",
    "container": "COrphan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
    "lines": "29-33",
    "snippet": "COrphan(CTransaction* ptxIn)\n    {\n        ptx = ptxIn;\n        dPriority = dFeePerKb = 0;\n    }",
    "includes": [
      "#include \"kernel.h\"",
      "#include \"miner.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nCOrphan {\n  COrphan(CTransaction* ptxIn)\n      {\n          ptx = ptxIn;\n          dPriority = dFeePerKb = 0;\n      }\n}"
  }
]