[
  {
    "function_name": "~EnvWrapper",
    "container": "EnvWrapper",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "93-94",
    "snippet": "EnvWrapper::~EnvWrapper() {\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nEnvWrapper {\n  EnvWrapper::~EnvWrapper() {\n  }\n}"
  },
  {
    "function_name": "ReadFileToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "68-91",
    "snippet": "Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {\n  data->clear();\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  static const int kBufferSize = 8192;\n  char* space = new char[kBufferSize];\n  while (true) {\n    Slice fragment;\n    s = file->Read(kBufferSize, &fragment, space);\n    if (!s.ok()) {\n      break;\n    }\n    data->append(fragment.data(), fragment.size());\n    if (fragment.empty()) {\n      break;\n    }\n  }\n  delete[] space;\n  delete file;\n  return s;\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fragment.empty",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->append",
          "args": [
            "fragment.data()",
            "fragment.size()"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fragment.size",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fragment.data",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Read",
          "args": [
            "kBufferSize",
            "&fragment",
            "space"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "Win32SequentialFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "341-351",
          "snippet": "Status Win32SequentialFile::Read( size_t n, Slice* result, char* scratch )\n{\n    Status sRet;\n    DWORD hasRead = 0;\n    if(_hFile && ReadFile(_hFile,scratch,n,&hasRead,NULL) ){\n        *result = Slice(scratch,hasRead);\n    } else {\n        sRet = Status::IOError(_filename, Win32::GetLastErrSz() );\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32SequentialFile {\n  Status Win32SequentialFile::Read( size_t n, Slice* result, char* scratch )\n  {\n      Status sRet;\n      DWORD hasRead = 0;\n      if(_hFile && ReadFile(_hFile,scratch,n,&hasRead,NULL) ){\n          *result = Slice(scratch,hasRead);\n      } else {\n          sRet = Status::IOError(_filename, Win32::GetLastErrSz() );\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->NewSequentialFile",
          "args": [
            "fname",
            "&file"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "EnvWrapper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/env.h",
          "lines": "283-285",
          "snippet": "Status NewSequentialFile(const std::string& f, SequentialFile** r) {\n    return target_->NewSequentialFile(f, r);\n  }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include <stdint.h>\n#include <stdarg.h>\n#include <vector>\n#include <string>\n\nEnvWrapper {\n  Status NewSequentialFile(const std::string& f, SequentialFile** r) {\n      return target_->NewSequentialFile(f, r);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->clear",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nStatus ReadFileToString(Env* env, const std::string& fname, std::string* data) {\n  data->clear();\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  static const int kBufferSize = 8192;\n  char* space = new char[kBufferSize];\n  while (true) {\n    Slice fragment;\n    s = file->Read(kBufferSize, &fragment, space);\n    if (!s.ok()) {\n      break;\n    }\n    data->append(fragment.data(), fragment.size());\n    if (fragment.empty()) {\n      break;\n    }\n  }\n  delete[] space;\n  delete file;\n  return s;\n}"
  },
  {
    "function_name": "WriteStringToFileSync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "63-66",
    "snippet": "Status WriteStringToFileSync(Env* env, const Slice& data,\n                             const std::string& fname) {\n  return DoWriteStringToFile(env, data, fname, true);\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoWriteStringToFile",
          "args": [
            "env",
            "data",
            "fname",
            "true"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "DoWriteStringToFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
          "lines": "36-56",
          "snippet": "static Status DoWriteStringToFile(Env* env, const Slice& data,\n                                  const std::string& fname,\n                                  bool should_sync) {\n  WritableFile* file;\n  Status s = env->NewWritableFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  s = file->Append(data);\n  if (s.ok() && should_sync) {\n    s = file->Sync();\n  }\n  if (s.ok()) {\n    s = file->Close();\n  }\n  delete file;  // Will auto-close if we did not close above\n  if (!s.ok()) {\n    env->DeleteFile(fname);\n  }\n  return s;\n}",
          "includes": [
            "#include \"leveldb/env.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n\nstatic Status DoWriteStringToFile(Env* env, const Slice& data,\n                                  const std::string& fname,\n                                  bool should_sync) {\n  WritableFile* file;\n  Status s = env->NewWritableFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  s = file->Append(data);\n  if (s.ok() && should_sync) {\n    s = file->Sync();\n  }\n  if (s.ok()) {\n    s = file->Close();\n  }\n  delete file;  // Will auto-close if we did not close above\n  if (!s.ok()) {\n    env->DeleteFile(fname);\n  }\n  return s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nStatus WriteStringToFileSync(Env* env, const Slice& data,\n                             const std::string& fname) {\n  return DoWriteStringToFile(env, data, fname, true);\n}"
  },
  {
    "function_name": "WriteStringToFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "58-61",
    "snippet": "Status WriteStringToFile(Env* env, const Slice& data,\n                         const std::string& fname) {\n  return DoWriteStringToFile(env, data, fname, false);\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoWriteStringToFile",
          "args": [
            "env",
            "data",
            "fname",
            "false"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "DoWriteStringToFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
          "lines": "36-56",
          "snippet": "static Status DoWriteStringToFile(Env* env, const Slice& data,\n                                  const std::string& fname,\n                                  bool should_sync) {\n  WritableFile* file;\n  Status s = env->NewWritableFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  s = file->Append(data);\n  if (s.ok() && should_sync) {\n    s = file->Sync();\n  }\n  if (s.ok()) {\n    s = file->Close();\n  }\n  delete file;  // Will auto-close if we did not close above\n  if (!s.ok()) {\n    env->DeleteFile(fname);\n  }\n  return s;\n}",
          "includes": [
            "#include \"leveldb/env.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n\nstatic Status DoWriteStringToFile(Env* env, const Slice& data,\n                                  const std::string& fname,\n                                  bool should_sync) {\n  WritableFile* file;\n  Status s = env->NewWritableFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  s = file->Append(data);\n  if (s.ok() && should_sync) {\n    s = file->Sync();\n  }\n  if (s.ok()) {\n    s = file->Close();\n  }\n  delete file;  // Will auto-close if we did not close above\n  if (!s.ok()) {\n    env->DeleteFile(fname);\n  }\n  return s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nStatus WriteStringToFile(Env* env, const Slice& data,\n                         const std::string& fname) {\n  return DoWriteStringToFile(env, data, fname, false);\n}"
  },
  {
    "function_name": "DoWriteStringToFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "36-56",
    "snippet": "static Status DoWriteStringToFile(Env* env, const Slice& data,\n                                  const std::string& fname,\n                                  bool should_sync) {\n  WritableFile* file;\n  Status s = env->NewWritableFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  s = file->Append(data);\n  if (s.ok() && should_sync) {\n    s = file->Sync();\n  }\n  if (s.ok()) {\n    s = file->Close();\n  }\n  delete file;  // Will auto-close if we did not close above\n  if (!s.ok()) {\n    env->DeleteFile(fname);\n  }\n  return s;\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env->DeleteFile",
          "args": [
            "fname"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "EnvWrapper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/env.h",
          "lines": "296-296",
          "snippet": "Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include <stdint.h>\n#include <stdarg.h>\n#include <vector>\n#include <string>\n\nEnvWrapper {\n  Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Close",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "Close",
          "container": "Win32MapFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "559-585",
          "snippet": "Status Win32MapFile::Close()\n{\n    Status s;\n    size_t unused = _limit - _dst;\n    if (!_UnmapCurrentRegion()) {\n        s = Status::IOError(\"WinMmapFile.Close::UnmapCurrentRegion: \",Win32::GetLastErrSz());\n    } else if (unused > 0) {\n        // Trim the extra space at the end of the file\n        LARGE_INTEGER newSize;\n        newSize.QuadPart = _file_offset - unused;\n        if (!SetFilePointerEx(_hFile, newSize, NULL, FILE_BEGIN)) {\n            s = Status::IOError(\"WinMmapFile.Close::SetFilePointer: \",Win32::GetLastErrSz());\n        } else \n            SetEndOfFile(_hFile);\n    }\n    if (!CloseHandle(_hFile)) {\n        if (s.ok()) {\n            s = Status::IOError(\"WinMmapFile.Close::CloseHandle: \", Win32::GetLastErrSz());\n        }\n    }\n    _hFile = INVALID_HANDLE_VALUE;\n    _base = NULL;\n    _base_handle = NULL;\n    _limit = NULL;\n\n    return s;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32MapFile {\n  Status Win32MapFile::Close()\n  {\n      Status s;\n      size_t unused = _limit - _dst;\n      if (!_UnmapCurrentRegion()) {\n          s = Status::IOError(\"WinMmapFile.Close::UnmapCurrentRegion: \",Win32::GetLastErrSz());\n      } else if (unused > 0) {\n          // Trim the extra space at the end of the file\n          LARGE_INTEGER newSize;\n          newSize.QuadPart = _file_offset - unused;\n          if (!SetFilePointerEx(_hFile, newSize, NULL, FILE_BEGIN)) {\n              s = Status::IOError(\"WinMmapFile.Close::SetFilePointer: \",Win32::GetLastErrSz());\n          } else \n              SetEndOfFile(_hFile);\n      }\n      if (!CloseHandle(_hFile)) {\n          if (s.ok()) {\n              s = Status::IOError(\"WinMmapFile.Close::CloseHandle: \", Win32::GetLastErrSz());\n          }\n      }\n      _hFile = INVALID_HANDLE_VALUE;\n      _base = NULL;\n      _base_handle = NULL;\n      _limit = NULL;\n  \n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Sync",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "Sync",
          "container": "Win32MapFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "587-608",
          "snippet": "Status Win32MapFile::Sync()\n{\n    Status s;\n    if (_pending_sync) {\n        // Some unmapped data was not synced\n        _pending_sync = false;\n        if (!FlushFileBuffers(_hFile)) {\n            s = Status::IOError(\"WinMmapFile.Sync::FlushFileBuffers: \",Win32::GetLastErrSz());\n        }\n    }\n    if (_dst > _last_sync) {\n        // Find the beginnings of the pages that contain the first and last\n        // bytes to be synced.\n        size_t p1 = _TruncateToPageBoundary(_last_sync - _base);\n        size_t p2 = _TruncateToPageBoundary(_dst - _base - 1);\n        _last_sync = _dst;\n        if (!FlushViewOfFile(_base + p1, p2 - p1 + _page_size)) {\n            s = Status::IOError(\"WinMmapFile.Sync::FlushViewOfFile: \",Win32::GetLastErrSz());\n        }\n    }\n    return s;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32MapFile {\n  Status Win32MapFile::Sync()\n  {\n      Status s;\n      if (_pending_sync) {\n          // Some unmapped data was not synced\n          _pending_sync = false;\n          if (!FlushFileBuffers(_hFile)) {\n              s = Status::IOError(\"WinMmapFile.Sync::FlushFileBuffers: \",Win32::GetLastErrSz());\n          }\n      }\n      if (_dst > _last_sync) {\n          // Find the beginnings of the pages that contain the first and last\n          // bytes to be synced.\n          size_t p1 = _TruncateToPageBoundary(_last_sync - _base);\n          size_t p2 = _TruncateToPageBoundary(_dst - _base - 1);\n          _last_sync = _dst;\n          if (!FlushViewOfFile(_base + p1, p2 - p1 + _page_size)) {\n              s = Status::IOError(\"WinMmapFile.Sync::FlushViewOfFile: \",Win32::GetLastErrSz());\n          }\n      }\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Append",
          "args": [
            "data"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "Append",
          "container": "Win32MapFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "535-557",
          "snippet": "Status Win32MapFile::Append( const Slice& data )\n{\n    const char* src = data.data();\n    size_t left = data.size();\n    Status s;\n    while (left > 0) {\n        assert(_base <= _dst);\n        assert(_dst <= _limit);\n        size_t avail = _limit - _dst;\n        if (avail == 0) {\n            if (!_UnmapCurrentRegion() ||\n                !_MapNewRegion()) {\n                    return Status::IOError(\"WinMmapFile.Append::UnmapCurrentRegion or MapNewRegion: \", Win32::GetLastErrSz());\n            }\n        }\n        size_t n = (left <= avail) ? left : avail;\n        memcpy(_dst, src, n);\n        _dst += n;\n        src += n;\n        left -= n;\n    }\n    return s;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32MapFile {\n  Status Win32MapFile::Append( const Slice& data )\n  {\n      const char* src = data.data();\n      size_t left = data.size();\n      Status s;\n      while (left > 0) {\n          assert(_base <= _dst);\n          assert(_dst <= _limit);\n          size_t avail = _limit - _dst;\n          if (avail == 0) {\n              if (!_UnmapCurrentRegion() ||\n                  !_MapNewRegion()) {\n                      return Status::IOError(\"WinMmapFile.Append::UnmapCurrentRegion or MapNewRegion: \", Win32::GetLastErrSz());\n              }\n          }\n          size_t n = (left <= avail) ? left : avail;\n          memcpy(_dst, src, n);\n          _dst += n;\n          src += n;\n          left -= n;\n      }\n      return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->NewWritableFile",
          "args": [
            "fname",
            "&file"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "EnvWrapper",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/env.h",
          "lines": "289-291",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    return target_->NewWritableFile(f, r);\n  }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include <stdint.h>",
            "#include <stdarg.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include <stdint.h>\n#include <stdarg.h>\n#include <vector>\n#include <string>\n\nEnvWrapper {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      return target_->NewWritableFile(f, r);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nstatic Status DoWriteStringToFile(Env* env, const Slice& data,\n                                  const std::string& fname,\n                                  bool should_sync) {\n  WritableFile* file;\n  Status s = env->NewWritableFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  s = file->Append(data);\n  if (s.ok() && should_sync) {\n    s = file->Sync();\n  }\n  if (s.ok()) {\n    s = file->Close();\n  }\n  delete file;  // Will auto-close if we did not close above\n  if (!s.ok()) {\n    env->DeleteFile(fname);\n  }\n  return s;\n}"
  },
  {
    "function_name": "Log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "27-34",
    "snippet": "void Log(Logger* info_log, const char* format, ...) {\n  if (info_log != NULL) {\n    va_list ap;\n    va_start(ap, format);\n    info_log->Logv(format, ap);\n    va_end(ap);\n  }\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "ap"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info_log->Logv",
          "args": [
            "format",
            "ap"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "Logv",
          "container": "PosixLogger",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/posix_logger.h",
          "lines": "28-93",
          "snippet": "virtual void Logv(const char* format, va_list ap) {\n    const uint64_t thread_id = (*gettid_)();\n\n    // We try twice: the first time with a fixed-size stack allocated buffer,\n    // and the second time with a much larger dynamically allocated buffer.\n    char buffer[500];\n    for (int iter = 0; iter < 2; iter++) {\n      char* base;\n      int bufsize;\n      if (iter == 0) {\n        bufsize = sizeof(buffer);\n        base = buffer;\n      } else {\n        bufsize = 30000;\n        base = new char[bufsize];\n      }\n      char* p = base;\n      char* limit = base + bufsize;\n\n      struct timeval now_tv;\n      gettimeofday(&now_tv, NULL);\n      const time_t seconds = now_tv.tv_sec;\n      struct tm t;\n      localtime_r(&seconds, &t);\n      p += snprintf(p, limit - p,\n                    \"%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx \",\n                    t.tm_year + 1900,\n                    t.tm_mon + 1,\n                    t.tm_mday,\n                    t.tm_hour,\n                    t.tm_min,\n                    t.tm_sec,\n                    static_cast<int>(now_tv.tv_usec),\n                    static_cast<long long unsigned int>(thread_id));\n\n      // Print the message\n      if (p < limit) {\n        va_list backup_ap;\n        va_copy(backup_ap, ap);\n        p += vsnprintf(p, limit - p, format, backup_ap);\n        va_end(backup_ap);\n      }\n\n      // Truncate to available space if necessary\n      if (p >= limit) {\n        if (iter == 0) {\n          continue;       // Try again with larger buffer\n        } else {\n          p = limit - 1;\n        }\n      }\n\n      // Add newline if necessary\n      if (p == base || p[-1] != '\\n') {\n        *p++ = '\\n';\n      }\n\n      assert(p <= limit);\n      fwrite(base, 1, p - base, file_);\n      fflush(file_);\n      if (base != buffer) {\n        delete[] base;\n      }\n      break;\n    }\n  }",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include <time.h>",
            "#include <sys/time.h>",
            "#include <stdio.h>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include <time.h>\n#include <sys/time.h>\n#include <stdio.h>\n#include <algorithm>\n\nPosixLogger {\n  virtual void Logv(const char* format, va_list ap) {\n      const uint64_t thread_id = (*gettid_)();\n  \n      // We try twice: the first time with a fixed-size stack allocated buffer,\n      // and the second time with a much larger dynamically allocated buffer.\n      char buffer[500];\n      for (int iter = 0; iter < 2; iter++) {\n        char* base;\n        int bufsize;\n        if (iter == 0) {\n          bufsize = sizeof(buffer);\n          base = buffer;\n        } else {\n          bufsize = 30000;\n          base = new char[bufsize];\n        }\n        char* p = base;\n        char* limit = base + bufsize;\n  \n        struct timeval now_tv;\n        gettimeofday(&now_tv, NULL);\n        const time_t seconds = now_tv.tv_sec;\n        struct tm t;\n        localtime_r(&seconds, &t);\n        p += snprintf(p, limit - p,\n                      \"%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx \",\n                      t.tm_year + 1900,\n                      t.tm_mon + 1,\n                      t.tm_mday,\n                      t.tm_hour,\n                      t.tm_min,\n                      t.tm_sec,\n                      static_cast<int>(now_tv.tv_usec),\n                      static_cast<long long unsigned int>(thread_id));\n  \n        // Print the message\n        if (p < limit) {\n          va_list backup_ap;\n          va_copy(backup_ap, ap);\n          p += vsnprintf(p, limit - p, format, backup_ap);\n          va_end(backup_ap);\n        }\n  \n        // Truncate to available space if necessary\n        if (p >= limit) {\n          if (iter == 0) {\n            continue;       // Try again with larger buffer\n          } else {\n            p = limit - 1;\n          }\n        }\n  \n        // Add newline if necessary\n        if (p == base || p[-1] != '\\n') {\n          *p++ = '\\n';\n        }\n  \n        assert(p <= limit);\n        fwrite(base, 1, p - base, file_);\n        fflush(file_);\n        if (base != buffer) {\n          delete[] base;\n        }\n        break;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "ap",
            "format"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nvoid Log(Logger* info_log, const char* format, ...) {\n  if (info_log != NULL) {\n    va_list ap;\n    va_start(ap, format);\n    info_log->Logv(format, ap);\n    va_end(ap);\n  }\n}"
  },
  {
    "function_name": "~FileLock",
    "container": "FileLock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "24-25",
    "snippet": "FileLock::~FileLock() {\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nFileLock {\n  FileLock::~FileLock() {\n  }\n}"
  },
  {
    "function_name": "~Logger",
    "container": "Logger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "21-22",
    "snippet": "Logger::~Logger() {\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nLogger {\n  Logger::~Logger() {\n  }\n}"
  },
  {
    "function_name": "~WritableFile",
    "container": "WritableFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "18-19",
    "snippet": "WritableFile::~WritableFile() {\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nWritableFile {\n  WritableFile::~WritableFile() {\n  }\n}"
  },
  {
    "function_name": "~RandomAccessFile",
    "container": "RandomAccessFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "15-16",
    "snippet": "RandomAccessFile::~RandomAccessFile() {\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nRandomAccessFile {\n  RandomAccessFile::~RandomAccessFile() {\n  }\n}"
  },
  {
    "function_name": "~SequentialFile",
    "container": "SequentialFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "12-13",
    "snippet": "SequentialFile::~SequentialFile() {\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nSequentialFile {\n  SequentialFile::~SequentialFile() {\n  }\n}"
  },
  {
    "function_name": "~Env",
    "container": "Env",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
    "lines": "9-10",
    "snippet": "Env::~Env() {\n}",
    "includes": [
      "#include \"leveldb/env.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"leveldb/env.h\"\n\nEnv {\n  Env::~Env() {\n  }\n}"
  }
]