[
  {
    "function_name": "AppInit2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "322-942",
    "snippet": "bool AppInit2()\n{\n    // ********************************************************* Step 1: setup\n#ifdef _MSC_VER\n    // Turn off Microsoft heap dump noise\n    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n    _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n#endif\n#if _MSC_VER >= 1400\n    // Disable confusing \"helpful\" text message on abort, Ctrl-C\n    _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n#endif\n#ifdef WIN32\n    // Enable Data Execution Prevention (DEP)\n    // Minimum supported OS versions: WinXP SP3, WinVista >= SP1, Win Server 2008\n    // A failure is non-critical and needs no further attention!\n#ifndef PROCESS_DEP_ENABLE\n// We define this here, because GCCs winbase.h limits this to _WIN32_WINNT >= 0x0601 (Windows 7),\n// which is not correct. Can be removed, when GCCs winbase.h is fixed!\n#define PROCESS_DEP_ENABLE 0x00000001\n#endif\n    typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n    PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n#endif\n#ifndef WIN32\n    umask(077);\n\n    // Clean shutdown on SIGTERM\n    struct sigaction sa;\n    sa.sa_handler = HandleSIGTERM;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGTERM, &sa, NULL);\n    sigaction(SIGINT, &sa, NULL);\n\n    // Reopen debug.log on SIGHUP\n    struct sigaction sa_hup;\n    sa_hup.sa_handler = HandleSIGHUP;\n    sigemptyset(&sa_hup.sa_mask);\n    sa_hup.sa_flags = 0;\n    sigaction(SIGHUP, &sa_hup, NULL);\n#endif\n\n    // ********************************************************* Step 2: parameter interactions\n\n    if(GetBoolArg(\"-sse2\", false)) {\n        printf(\"SSE2 assembly optimisations enabled\\n\");\n        nNeoScryptOptions |= 0x1000;\n    }\n\n    nNodeLifespan = GetArg(\"-addrlifespan\", 7);\n\n    nMinerSleep = GetArg(\"-minersleep\", 500);\n\n    CheckpointsMode = Checkpoints::STRICT;\n    std::string strCpMode = GetArg(\"-cppolicy\", \"strict\");\n\n    if(strCpMode == \"strict\")\n        CheckpointsMode = Checkpoints::STRICT;\n\n    if(strCpMode == \"advisory\")\n        CheckpointsMode = Checkpoints::ADVISORY;\n\n    if(strCpMode == \"permissive\")\n        CheckpointsMode = Checkpoints::PERMISSIVE;\n\n    nDerivationMethodIndex = 0;\n\n    fTestNet = GetBoolArg(\"-testnet\");\n    //fTestNet = true;\n    if (fTestNet) {\n        SoftSetBoolArg(\"-irc\", true);\n    }\n\n    if (mapArgs.count(\"-bind\")) {\n        // when specifying an explicit binding address, you want to listen on it\n        // even when -connect or -proxy is specified\n        SoftSetBoolArg(\"-listen\", true);\n    }\n\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0) {\n        // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n        SoftSetBoolArg(\"-dnsseed\", false);\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (mapArgs.count(\"-proxy\")) {\n        // to protect privacy, do not listen by default if a proxy server is specified\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (!GetBoolArg(\"-listen\", true)) {\n        // do not map ports or try to retrieve public IP when not listening (pointless)\n        SoftSetBoolArg(\"-upnp\", false);\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (mapArgs.count(\"-externalip\")) {\n        // if an explicit public IP is specified, do not try to find others\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\")) {\n        // Rewrite just private keys: rescan to find transactions\n        SoftSetBoolArg(\"-rescan\", true);\n    }\n\n    // ********************************************************* Step 3: parameter-to-internal-flags\n\n    fDebug = GetBoolArg(\"-debug\");\n\n    // -debug implies fDebug*\n    if (fDebug)\n        fDebugNet = true;\n    else\n        fDebugNet = GetBoolArg(\"-debugnet\");\n\n    bitdb.SetDetach(GetBoolArg(\"-detachdb\", false));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    fDaemon = GetBoolArg(\"-daemon\");\n#else\n    fDaemon = false;\n#endif\n\n    if (fDaemon)\n        fServer = true;\n    else\n        fServer = GetBoolArg(\"-server\");\n\n    /* force fServer when running without GUI */\n#if !defined(QT_GUI)\n    fServer = true;\n#endif\n    fPrintToConsole = GetBoolArg(\"-printtoconsole\");\n    fPrintToDebugger = GetBoolArg(\"-printtodebugger\");\n    fLogTimestamps = GetBoolArg(\"-logtimestamps\");\n\n    if (mapArgs.count(\"-timeout\"))\n    {\n        int nNewTimeout = GetArg(\"-timeout\", 5000);\n        if (nNewTimeout > 0 && nNewTimeout < 600000)\n            nConnectTimeout = nNewTimeout;\n    }\n\n    if (mapArgs.count(\"-paytxfee\"))\n    {\n        if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"].c_str()));\n        if (nTransactionFee > 0.25 * COIN)\n            InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n    }\n\n    fConfChange = GetBoolArg(\"-confchange\", false);\n    fEnforceCanonical = GetBoolArg(\"-enforcecanonical\", true);\n\n    if (mapArgs.count(\"-mininput\"))\n    {\n        if (!ParseMoney(mapArgs[\"-mininput\"], nMinimumInputValue))\n            return InitError(strprintf(_(\"Invalid amount for -mininput=<amount>: '%s'\"), mapArgs[\"-mininput\"].c_str()));\n    }\n\n    /* Try to combine inputs while staking up to this limit */\n    if(mapArgs.count(\"-stakecombine\")) {\n        if(!ParseMoney(mapArgs[\"-stakecombine\"], nCombineThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakecombine=<amount>: '%s'\"),\n            mapArgs[\"-stakecombine\"].c_str())));\n        if(nCombineThreshold < 10 * COIN)\n          nCombineThreshold = 10 * COIN;\n        if(nCombineThreshold > 1000 * COIN)\n          nCombineThreshold = 1000 * COIN;\n    }\n\n    /* Don't split outputs while staking below this limit */\n    if(mapArgs.count(\"-stakesplit\")) {\n        if(!ParseMoney(mapArgs[\"-stakesplit\"], nSplitThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakesplit=<amount>: '%s'\"),\n            mapArgs[\"-stakesplit\"].c_str())));\n        if(nSplitThreshold < 20 * COIN)\n          nSplitThreshold = 20 * COIN;\n        if(nSplitThreshold > 2000 * COIN)\n          nSplitThreshold = 2000 * COIN;\n    }\n\n    // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n\n    std::string strDataDir = GetDataDir().string();\n    std::string strWalletFileName = GetArg(\"-wallet\", \"wallet.dat\");\n\n    // strWalletFileName must be a plain filename without a directory\n    if (strWalletFileName != boost::filesystem::basename(strWalletFileName) + boost::filesystem::extension(strWalletFileName))\n        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s.\"), strWalletFileName.c_str(), strDataDir.c_str()));\n\n    // Make sure only a single Bitcoin process is using the data directory.\n    boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n    FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n    if (file) fclose(file);\n    static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n    if (!lock.try_lock())\n        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Halcyon is probably already running.\"), strDataDir.c_str()));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    if (fDaemon)\n    {\n        // Daemonize\n        pid_t pid = fork();\n        if (pid < 0)\n        {\n            fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n            return false;\n        }\n        if (pid > 0)\n        {\n            CreatePidFile(GetPidFile(), pid);\n            return true;\n        }\n\n        pid_t sid = setsid();\n        if (sid < 0)\n            fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n    }\n#endif\n\n    if (GetBoolArg(\"-shrinkdebugfile\", !fDebug))\n        ShrinkDebugFile();\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n    printf(\"Halcyon version %s (%s)\\n\", FormatFullVersion().c_str(), CLIENT_DATE.c_str());\n    printf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n    if (!fLogTimestamps)\n        printf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n    printf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n    printf(\"Used data directory %s\\n\", strDataDir.c_str());\n    std::ostringstream strErrors;\n\n    int64_t nStart;\n\n    // ********************************************************* Step 5: verify database integrity\n\n    uiInterface.InitMessage(_(\"Verifying database integrity...\"));\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\"))\n    {\n        // Recover readable keypairs:\n        if (!CWalletDB::Recover(bitdb, strWalletFileName, true))\n            return false;\n    }\n\n    if (filesystem::exists(GetDataDir() / strWalletFileName))\n    {\n        CDBEnv::VerifyResult r = bitdb.Verify(strWalletFileName, CWalletDB::Recover);\n        if (r == CDBEnv::RECOVER_OK)\n        {\n            string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n                                     \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n                                     \" your balance or transactions are incorrect you should\"\n                                     \" restore from a backup.\"), strDataDir.c_str());\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        if (r == CDBEnv::RECOVER_FAIL)\n            return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n    }\n\n    // ********************************************************* Step 6: network initialization\n\n    int nSocksVersion = GetArg(\"-socks\", 5);\n\n    if (nSocksVersion != 4 && nSocksVersion != 5)\n        return InitError(strprintf(_(\"Unknown -socks proxy version requested: %i\"), nSocksVersion));\n\n    if (mapArgs.count(\"-onlynet\")) {\n        std::set<enum Network> nets;\n        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n            enum Network net = ParseNetwork(snet);\n            if (net == NET_UNROUTABLE)\n                return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet.c_str()));\n            nets.insert(net);\n        }\n        for (int n = 0; n < NET_MAX; n++) {\n            enum Network net = (enum Network)n;\n            if (!nets.count(net))\n                SetLimited(net);\n        }\n    }\n#if defined(USE_IPV6)\n#if ! USE_IPV6\n    else\n        SetLimited(NET_IPV6);\n#endif\n#endif\n\n    CService addrProxy;\n    bool fProxy = false;\n    if (mapArgs.count(\"-proxy\")) {\n        addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n        if (!addrProxy.IsValid())\n            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n\n        if (!IsLimited(NET_IPV4))\n            SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n        if (nSocksVersion > 4) {\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                SetProxy(NET_IPV6, addrProxy, nSocksVersion);\n#endif\n            SetNameProxy(addrProxy, nSocksVersion);\n        }\n        fProxy = true;\n    }\n\n    // -tor can override normal proxy, -notor disables tor entirely\n    if (!(mapArgs.count(\"-tor\") && mapArgs[\"-tor\"] == \"0\") && (fProxy || mapArgs.count(\"-tor\"))) {\n        CService addrOnion;\n        if (!mapArgs.count(\"-tor\"))\n            addrOnion = addrProxy;\n        else\n            addrOnion = CService(mapArgs[\"-tor\"], 9050);\n        if (!addrOnion.IsValid())\n            return InitError(strprintf(_(\"Invalid -tor address: '%s'\"), mapArgs[\"-tor\"].c_str()));\n        SetProxy(NET_TOR, addrOnion, 5);\n        SetReachable(NET_TOR);\n    }\n\n    // see Step 2: parameter interactions for more information about these\n    fNoListen = !GetBoolArg(\"-listen\", true);\n    fDiscover = GetBoolArg(\"-discover\", true);\n    fNameLookup = GetBoolArg(\"-dns\", true);\n#ifdef USE_UPNP\n    fUseUPnP = GetBoolArg(\"-upnp\", USE_UPNP);\n#endif\n\n    bool fBound = false;\n    if (!fNoListen)\n    {\n        std::string strError;\n        if (mapArgs.count(\"-bind\")) {\n            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n                CService addrBind;\n                if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                    return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind.c_str()));\n                fBound |= Bind(addrBind);\n            }\n        } else {\n            struct in_addr inaddr_any;\n            inaddr_any.s_addr = INADDR_ANY;\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                fBound |= Bind(CService(in6addr_any, GetListenPort()), false);\n#endif\n            if (!IsLimited(NET_IPV4))\n                fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound);\n        }\n        if (!fBound)\n            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n    }\n\n    if (mapArgs.count(\"-externalip\"))\n    {\n        BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n            CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n            if (!addrLocal.IsValid())\n                return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr.c_str()));\n            AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n        }\n    }\n\n    if (mapArgs.count(\"-reservebalance\")) // ppcoin: reserve balance amount\n    {\n        if (!ParseMoney(mapArgs[\"-reservebalance\"], nReserveBalance))\n        {\n            InitError(_(\"Invalid amount for -reservebalance=<amount>\"));\n            return false;\n        }\n    }\n\n    if (mapArgs.count(\"-checkpointkey\")) // ppcoin: checkpoint master priv key\n    {\n        if (!Checkpoints::SetCheckpointPrivKey(GetArg(\"-checkpointkey\", \"\")))\n            InitError(_(\"Unable to sign checkpoint, wrong checkpointkey?\\n\"));\n    }\n\n    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n        AddOneShot(strDest);\n\n    // ********************************************************* Step 7: load blockchain\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-loadblockindextest\"))\n    {\n        CTxDB txdb(\"r\");\n        txdb.LoadBlockIndex();\n        PrintBlockTree();\n        return false;\n    }\n\n    uiInterface.InitMessage(_(\"Loading block index...\"));\n    printf(\"Loading block index...\\n\");\n    nStart = GetTimeMillis();\n    if (!LoadBlockIndex())\n        return InitError(_(\"Error loading blkindex.dat\"));\n\n\n    // as LoadBlockIndex can take several minutes, it's possible the user\n    // requested to kill bitcoin-qt during the last operation. If so, exit.\n    // As the program has not fully started yet, Shutdown() is possibly overkill.\n    if (fRequestShutdown)\n    {\n        printf(\"Shutdown requested. Exiting.\\n\");\n        return false;\n    }\n    printf(\" block index %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    if (GetBoolArg(\"-printblockindex\") || GetBoolArg(\"-printblocktree\"))\n    {\n        PrintBlockTree();\n        return false;\n    }\n\n    if (mapArgs.count(\"-printblock\"))\n    {\n        string strMatch = mapArgs[\"-printblock\"];\n        int nFound = 0;\n        for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n        {\n            uint256 hash = (*mi).first;\n            if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n            {\n                CBlockIndex* pindex = (*mi).second;\n                CBlock block;\n                block.ReadFromDisk(pindex);\n                block.BuildMerkleTree();\n                block.print();\n                printf(\"\\n\");\n                nFound++;\n            }\n        }\n        if (nFound == 0)\n            printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n        return false;\n    }\n\n    // ********************************************************* Step 8: load wallet\n\n    uiInterface.InitMessage(_(\"Loading wallet...\"));\n    printf(\"Loading wallet...\\n\");\n    nStart = GetTimeMillis();\n    bool fFirstRun = true;\n    pwalletMain = new CWallet(strWalletFileName);\n    DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n    if (nLoadWalletRet != DB_LOAD_OK)\n    {\n        if (nLoadWalletRet == DB_CORRUPT)\n            strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n        {\n            string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n                         \" or address book entries might be missing or incorrect.\"));\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        else if (nLoadWalletRet == DB_TOO_NEW)\n            strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Halcyon\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NEED_REWRITE)\n        {\n            strErrors << _(\"Wallet needed to be rewritten: restart Halcyon to complete\") << \"\\n\";\n            printf(\"%s\", strErrors.str().c_str());\n            return InitError(strErrors.str());\n        }\n        else\n            strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n    }\n\n    if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n    {\n        int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n        if (nMaxVersion == 0) // the -upgradewallet without argument case\n        {\n            printf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n            nMaxVersion = CLIENT_VERSION;\n            pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n        }\n        else\n            printf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n        if (nMaxVersion < pwalletMain->GetVersion())\n            strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n        pwalletMain->SetMaxVersion(nMaxVersion);\n    }\n\n    if (fFirstRun)\n    {\n        // Create new keyUser and set as default key\n        RandAddSeedPerfmon();\n\n        CPubKey newDefaultKey;\n        if (!pwalletMain->GetKeyFromPool(newDefaultKey, false))\n            strErrors << _(\"Cannot initialize keypool\") << \"\\n\";\n        pwalletMain->SetDefaultKey(newDefaultKey);\n        if (!pwalletMain->SetAddressBookName(pwalletMain->vchDefaultKey.GetID(), \"\"))\n            strErrors << _(\"Cannot write default address\") << \"\\n\";\n    }\n\n    printf(\"%s\", strErrors.str().c_str());\n    printf(\" wallet      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    RegisterWallet(pwalletMain);\n\n    CBlockIndex *pindexRescan = pindexBest;\n    if (GetBoolArg(\"-rescan\"))\n        pindexRescan = pindexGenesisBlock;\n    else\n    {\n        CWalletDB walletdb(strWalletFileName);\n        CBlockLocator locator;\n        if (walletdb.ReadBestBlock(locator))\n            pindexRescan = locator.GetBlockIndex();\n    }\n    if (pindexBest != pindexRescan && pindexBest && pindexRescan && pindexBest->nHeight > pindexRescan->nHeight)\n    {\n        uiInterface.InitMessage(_(\"Rescanning...\"));\n        printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n        nStart = GetTimeMillis();\n        pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n        printf(\" rescan      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n    }\n\n    // ********************************************************* Step 9: import blocks\n\n    if (mapArgs.count(\"-loadblock\"))\n    {\n        uiInterface.InitMessage(_(\"Importing blockchain data file.\"));\n\n        BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n        {\n            FILE *file = fopen(strFile.c_str(), \"rb\");\n            if (file)\n                LoadExternalBlockFile(file);\n        }\n        exit(0);\n    }\n\n    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n    if (filesystem::exists(pathBootstrap)) {\n        uiInterface.InitMessage(_(\"Importing bootstrap blockchain data file.\"));\n\n        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n        if (file) {\n            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n            LoadExternalBlockFile(file);\n            RenameOver(pathBootstrap, pathBootstrapOld);\n        }\n    }\n\n    // ********************************************************* Step 10: load peers\n\n    uiInterface.InitMessage(_(\"Loading addresses...\"));\n    printf(\"Loading addresses...\\n\");\n    nStart = GetTimeMillis();\n\n    {\n        CAddrDB adb;\n        if (!adb.Read(addrman))\n            printf(\"Invalid or missing peers.dat; recreating\\n\");\n    }\n\n    printf(\"Loaded %i addresses from peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n\n    // ********************************************************* Step 11: start node\n\n    if (!CheckDiskSpace())\n        return false;\n\n    RandAddSeedPerfmon();\n\n    //// debug print\n    printf(\"mapBlockIndex.size() = %\"PRIszu\"\\n\",   mapBlockIndex.size());\n    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n    printf(\"setKeyPool.size() = %\"PRIszu\"\\n\",      pwalletMain->setKeyPool.size());\n    printf(\"mapWallet.size() = %\"PRIszu\"\\n\",       pwalletMain->mapWallet.size());\n    printf(\"mapAddressBook.size() = %\"PRIszu\"\\n\",  pwalletMain->mapAddressBook.size());\n\n    if (!NewThread(StartNode, NULL))\n        InitError(_(\"Error: could not start node\"));\n\n    if (fServer)\n        NewThread(ThreadRPCServer, NULL);\n\n    // ********************************************************* Step 12: finished\n\n    uiInterface.InitMessage(_(\"Done loading\"));\n    printf(\"Done loading\\n\");\n\n    if (!strErrors.str().empty())\n        return InitError(strErrors.str());\n\n     // Add wallet transactions that aren't already in a block to mapTransactions\n    pwalletMain->ReacceptWalletTransactions();\n\n#if !defined(QT_GUI)\n    // Loop until process is exit()ed from shutdown() function,\n    // called from ThreadRPCServer thread when a \"stop\" command is received.\n    while (1)\n        MilliSleep(5000);\n#endif\n\n    return true;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [
      "#define PROCESS_DEP_ENABLE 0x00000001"
    ],
    "globals_used": [
      "CWallet* pwalletMain;",
      "CClientUIInterface uiInterface;",
      "std::string strWalletFileName;",
      "bool fConfChange;",
      "bool fEnforceCanonical;",
      "unsigned int nNodeLifespan;",
      "unsigned int nDerivationMethodIndex;",
      "unsigned int nMinerSleep;",
      "enum Checkpoints::CPMode CheckpointsMode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "5000"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->ReacceptWalletTransactions",
          "args": [],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "ReacceptWalletTransactions",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "876-2476",
          "snippet": "void CWallet::ReacceptWalletTransactions()\n{\n    CTxDB txdb(\"r\");\n    bool fRepeat = true;\n    while (fRepeat)\n    {\n        LOCK(cs_wallet);\n        fRepeat = false;\n        vector<CDiskTxPos> vMissingTx;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                continue;\n\n            CTxIndex txindex;\n            bool fUpdated = false;\n            if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n            {\n                // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                if (txindex.vSpent.size() != wtx.vout.size())\n                {\n                    printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                    continue;\n                }\n                for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                {\n                    if (wtx.IsSpent(i))\n                        continue;\n                    if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                    {\n                        wtx.MarkSpent(i);\n                        fUpdated = true;\n                        vMissingTx.push_back(txindex.vSpent[i]);\n                    }\n                }\n                if (fUpdated)\n                {\n                    printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                    wtx.MarkDirty();\n                    wtx.WriteToDisk();\n                }\n            }\n            else\n            {\n                // Re-accept any txes of ours that aren't already in a block\n                if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                    wtx.AcceptWalletTransaction(txdb);\n            }\n        }\n        if (!vMissingTx.empty())\n        {\n            // TODO: optimize this to scan just part of the block chain?\n            if (ScanForWalletTransactions(pindexGenesisBlock))\n                fRepeat = true;  // Found missing transactions: re-do re-accept.\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n{\n    BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n    {\n        if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n        {\n            uint256 hash = tx.GetHash();\n            if (!txdb.ContainsTx(hash))\n                RelayTransaction((CTransaction)tx, hash);\n        }\n    }\n    if (!(IsCoinBase() || IsCoinStake()))\n    {\n        uint256 hash = GetHash();\n        if (!txdb.ContainsTx(hash))\n        {\n            printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n            RelayTransaction((CTransaction)*this, hash);\n        }\n    }\n}\n\nvoid CWalletTx::RelayWalletTransaction()\n{\n   CTxDB txdb(\"r\");\n   RelayWalletTransaction(txdb);\n}\n\nvoid CWallet::ResendWalletTransactions(bool fForce)\n{\n    if (!fForce)\n    {\n        // Do this infrequently and randomly to avoid giving away\n        // that these are our transactions.\n        static int64_t nNextTime;\n        if (GetTime() < nNextTime)\n            return;\n        bool fFirst = (nNextTime == 0);\n        nNextTime = GetTime() + GetRand(30 * 60);\n        if (fFirst)\n            return;\n\n        // Only do it if there's been a new block since last time\n        static int64_t nLastTime;\n        if (nTimeBestReceived < nLastTime)\n            return;\n        nLastTime = GetTime();\n    }\n\n    // Rebroadcast any of our txes that aren't in a block yet\n    printf(\"ResendWalletTransactions()\\n\");\n    CTxDB txdb(\"r\");\n    {\n        LOCK(cs_wallet);\n        // Sort them in chronological order\n        multimap<unsigned int, CWalletTx*> mapSorted;\n        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n        {\n            CWalletTx& wtx = item.second;\n            // Don't rebroadcast until it's had plenty of time that\n            // it should have gotten in already by now.\n            if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n        }\n        BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n        {\n            CWalletTx& wtx = *item.second;\n            if (wtx.CheckTransaction())\n                wtx.RelayWalletTransaction(txdb);\n            else\n                printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n        }\n    }\n}\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Actions\n//\n\n\nint64_t CWallet::GetBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n\n    return nTotal;\n}\n\nint64_t CWallet::GetUnconfirmedBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                nTotal += pcoin->GetAvailableCredit();\n        }\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetImmatureBalance() const\n{\n    int64_t nTotal = 0;\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx& pcoin = (*it).second;\n            if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                nTotal += GetCredit(pcoin);\n        }\n    }\n    return nTotal;\n}\n\n// populate vCoins with vector of spendable COutputs\nvoid CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if (fOnlyConfirmed && !pcoin->IsTrusted())\n                continue;\n\n            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < 0)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                    vCoins.push_back(COutput(pcoin, i, nDepth));\n\n        }\n    }\n}\n\nvoid CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n{\n    vCoins.clear();\n\n    {\n        LOCK(cs_wallet);\n        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        {\n            const CWalletTx* pcoin = &(*it).second;\n\n            if (!pcoin->IsFinal())\n                continue;\n\n            if(pcoin->GetDepthInMainChain() < nConf)\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n        }\n    }\n}\n\nstatic void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                  vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n{\n    vector<char> vfIncluded;\n\n    vfBest.assign(vValue.size(), true);\n    nBest = nTotalLower;\n\n    for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n    {\n        vfIncluded.assign(vValue.size(), false);\n        int64_t nTotal = 0;\n        bool fReachedTarget = false;\n        for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n        {\n            for (unsigned int i = 0; i < vValue.size(); i++)\n            {\n                if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                {\n                    nTotal += vValue[i].first;\n                    vfIncluded[i] = true;\n                    if (nTotal >= nTargetValue)\n                    {\n                        fReachedTarget = true;\n                        if (nTotal < nBest)\n                        {\n                            nBest = nTotal;\n                            vfBest = vfIncluded;\n                        }\n                        nTotal -= vValue[i].first;\n                        vfIncluded[i] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// ppcoin: total coins staked (non-spendable until maturity)\nint64_t CWallet::GetStake() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nint64_t CWallet::GetNewMint() const\n{\n    int64_t nTotal = 0;\n    LOCK(cs_wallet);\n    for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n    {\n        const CWalletTx* pcoin = &(*it).second;\n        if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n            nTotal += CWallet::GetCredit(*pcoin);\n    }\n    return nTotal;\n}\n\nbool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    // List of values less than target\n    pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n    coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n    coinLowestLarger.second.first = NULL;\n    vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n    int64_t nTotalLower = 0;\n\n    random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n\n        if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n            continue;\n\n        int i = output.i;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n == nTargetValue)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            return true;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            vValue.push_back(coin);\n            nTotalLower += n;\n        }\n        else if (n < coinLowestLarger.first)\n        {\n            coinLowestLarger = coin;\n        }\n    }\n\n    if (nTotalLower == nTargetValue)\n    {\n        for (unsigned int i = 0; i < vValue.size(); ++i)\n        {\n            setCoinsRet.insert(vValue[i].second);\n            nValueRet += vValue[i].first;\n        }\n        return true;\n    }\n\n    if (nTotalLower < nTargetValue)\n    {\n        if (coinLowestLarger.second.first == NULL)\n            return false;\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n        return true;\n    }\n\n    // Solve subset sum by stochastic approximation\n    sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n    vector<char> vfBest;\n    int64_t nBest;\n\n    ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n    if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n        ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n\n    // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n    //                                   or the next bigger coin is closer), return the bigger coin\n    if (coinLowestLarger.second.first &&\n        ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n    {\n        setCoinsRet.insert(coinLowestLarger.second);\n        nValueRet += coinLowestLarger.first;\n    }\n    else {\n        for (unsigned int i = 0; i < vValue.size(); i++)\n            if (vfBest[i])\n            {\n                setCoinsRet.insert(vValue[i].second);\n                nValueRet += vValue[i].first;\n            }\n\n        if (fDebug && GetBoolArg(\"-printpriority\"))\n        {\n            //// debug print\n            printf(\"SelectCoins() best subset: \");\n            for (unsigned int i = 0; i < vValue.size(); i++)\n                if (vfBest[i])\n                    printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n            printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n{\n    vector<COutput> vCoins;\n    AvailableCoins(vCoins, true, coinControl);\n\n    // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n    if (coinControl && coinControl->HasSelected())\n    {\n        BOOST_FOREACH(const COutput& out, vCoins)\n        {\n            nValueRet += out.tx->vout[out.i].nValue;\n            setCoinsRet.insert(make_pair(out.tx, out.i));\n        }\n        return (nValueRet >= nTargetValue);\n    }\n\n    return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n            SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n}\n\n// Select some coins without random shuffle or best subset approximation\nbool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n{\n    vector<COutput> vCoins;\n    AvailableCoinsMinConf(vCoins, nMinConf);\n\n    setCoinsRet.clear();\n    nValueRet = 0;\n\n    BOOST_FOREACH(COutput output, vCoins)\n    {\n        const CWalletTx *pcoin = output.tx;\n        int i = output.i;\n\n        // Stop if we've chosen enough inputs\n        if (nValueRet >= nTargetValue)\n            break;\n\n        // Follow the timestamp rules\n        if (pcoin->nTime > nSpendTime)\n            continue;\n\n        int64_t n = pcoin->vout[i].nValue;\n\n        pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n\n        if (n >= nTargetValue)\n        {\n            // If input value is greater or equal to target then simply insert\n            //    it into the current subset and exit\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n            break;\n        }\n        else if (n < nTargetValue + CENT)\n        {\n            setCoinsRet.insert(coin.second);\n            nValueRet += coin.first;\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    int64_t nValue = 0;\n    BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n    {\n        if (nValue < 0)\n            return false;\n        nValue += s.second;\n    }\n    if (vecSend.empty() || nValue < 0)\n        return false;\n\n    wtxNew.BindWallet(this);\n\n    {\n        LOCK2(cs_main, cs_wallet);\n        // txdb must be opened before the mapWallet lock\n        CTxDB txdb(\"r\");\n        {\n            nFeeRet = nTransactionFee;\n            while (true)\n            {\n                wtxNew.vin.clear();\n                wtxNew.vout.clear();\n                wtxNew.fFromMe = true;\n\n                int64_t nTotalValue = nValue + nFeeRet;\n                double dPriority = 0;\n                // vouts to the payees\n                BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                    wtxNew.vout.push_back(CTxOut(s.second, s.first));\n\n                // Choose coins to use\n                set<pair<const CWalletTx*,unsigned int> > setCoins;\n                int64_t nValueIn = 0;\n                if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                    return false;\n                BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                {\n                    int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                    dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                }\n\n                int64_t nChange = nValueIn - nValue - nFeeRet;\n                // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                // or until nChange becomes zero\n                // NOTE: this depends on the exact behaviour of GetMinFee\n                if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                {\n                    int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                    nChange -= nMoveToFee;\n                    nFeeRet += nMoveToFee;\n                }\n\n                if (nChange > 0)\n                {\n                    // Fill a vout to ourself\n                    // TODO: pass in scriptChange instead of reservekey so\n                    // change transaction isn't always pay-to-bitcoin-address\n                    CScript scriptChange;\n\n                    // coin control: send change to custom address\n                    if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                        scriptChange.SetDestination(coinControl->destChange);\n\n                    // no coin control: send change to newly generated address\n                    else\n                    {\n                        // Note: We use a new key here to keep it from being obvious which side is the change.\n                        //  The drawback is that by not reusing a previous key, the change may be lost if a\n                        //  backup is restored, if the backup doesn't have the new private key for the change.\n                        //  If we reused the old key, it would be possible to add code to look for and\n                        //  rediscover unknown transactions that were written with keys of ours to recover\n                        //  post-backup change.\n\n                        // Reserve a new key pair from key pool\n                        CPubKey vchPubKey = reservekey.GetReservedKey();\n\n                        scriptChange.SetDestination(vchPubKey.GetID());\n                    }\n\n                    // Insert change txn at random position:\n                    vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                    wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                }\n                else\n                    reservekey.ReturnKey();\n\n                // Fill vin\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n\n                // Sign\n                int nIn = 0;\n                BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                    if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                        return false;\n\n                // Limit size\n                unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                    return false;\n                dPriority /= nBytes;\n\n                // Check that enough fee is included\n                int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n\n                if (nFeeRet < max(nPayFee, nMinFee))\n                {\n                    nFeeRet = max(nPayFee, nMinFee);\n                    continue;\n                }\n\n                // Fill vtxPrev by copying from previous transactions vtxPrev\n                wtxNew.AddSupportingTransactions(txdb);\n                wtxNew.fTimeReceivedIsTxTime = true;\n\n                break;\n            }\n        }\n    }\n    return true;\n}\n\nbool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n{\n    vector< pair<CScript, int64_t> > vecSend;\n    vecSend.push_back(make_pair(scriptPubKey, nValue));\n    return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n}\n\n// NovaCoin: get current stake weight\nbool CWallet::GetStakeWeight(const CKeyStore& keystore,\n  uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n        CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n\n        // Weight is greater than zero\n        if (nTimeWeight > 0)\n        {\n            nWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Weight is greater than zero, but the maximum value isn't reached yet\n        if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n        {\n            nMinWeight += bnCoinDayWeight.getuint64();\n        }\n\n        // Maximum weight was reached\n        if (nTimeWeight == nStakeMaxAge)\n        {\n            nMaxWeight += bnCoinDayWeight.getuint64();\n        }\n    }\n\n    return true;\n}\n\nbool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n  int64_t nFees, CTransaction& txNew, CKey& key) {\n    uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n\n    /* Don't split inputs above this age */\n    const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n    /* Time limit for searching a single input */\n    const uint nMaxStakeSearchInterval = 60;\n\n    CBlockIndex* pindexPrev = pindexBest;\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n\n    txNew.vin.clear();\n    txNew.vout.clear();\n\n    // Mark coin stake transaction\n    CScript scriptEmpty;\n    scriptEmpty.clear();\n    txNew.vout.push_back(CTxOut(0, scriptEmpty));\n\n    // Choose coins to use\n    int64_t nBalance = GetBalance();\n\n    if (nBalance <= nReserveBalance)\n        return false;\n\n    vector<const CWalletTx*> vwtxPrev;\n\n    set<pair<const CWalletTx*,unsigned int> > setCoins;\n    int64_t nValueIn = 0;\n\n    // Select coins with suitable depth\n    if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n        return false;\n\n    if (setCoins.empty())\n        return false;\n\n    int64_t nCredit = 0;\n    CScript scriptPubKeyKernel;\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n    {\n        CTxIndex txindex;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                continue;\n        }\n\n        // Read block header\n        CBlock block;\n        {\n            LOCK2(cs_main, cs_wallet);\n            if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                continue;\n        }\n\n        if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n            continue; // only count coins meeting min age requirement\n\n        bool fKernelFound = false;\n        for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n        {\n            // Search backward in time from the given txNew timestamp \n            // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n            uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n            COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n            if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n            {\n                // Found a kernel\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : kernel found\\n\");\n                vector<valtype> vSolutions;\n                txnouttype whichType;\n                CScript scriptPubKeyOut;\n                scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                    break;\n                }\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                    break;  // only support pay to public key and pay to address\n                }\n                if (whichType == TX_PUBKEYHASH) // pay to address type\n                {\n                    // convert to pay to public key type\n                    if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n                    scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                }\n                if (whichType == TX_PUBKEY)\n                {\n                    valtype& vchPubKey = vSolutions[0];\n                    if (!keystore.GetKey(Hash160(vchPubKey), key))\n                    {\n                        if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                            printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                        break;  // unable to find corresponding public key\n                    }\n\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                        printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                        break; // keys mismatch\n                    }\n\n                    scriptPubKeyOut = scriptPubKeyKernel;\n                }\n\n                txNew.nTime -= n;\n                txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                nCredit += pcoin.first->vout[pcoin.second].nValue;\n                vwtxPrev.push_back(pcoin.first);\n                txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                /* Split large inputs into two near halves;\n                 * exact amounts to be defined after reward processing */\n                if((nCredit >= nSplitThreshold) &&\n                  (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n\n                if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                    printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                fKernelFound = true;\n                break;\n            }\n        }\n\n        if (fKernelFound || fShutdown)\n            break; // if kernel is found stop searching\n    }\n\n    /* At this point, stake amount must be positive and within the stake limit if defined */\n    if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n      return(false);\n\n    BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n\n        /* Make a larger stake by inserting additional inputs\n         * of the same public key (address) as the generating input */\n        if((txNew.vout.size() == 2) &&\n          (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n          (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n          (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n            int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n\n            /* Do not add too many inputs */\n            if(txNew.vin.size() >= 10)\n              break;\n            /* Do not add any inputs if reached or exceeded the threshold already */\n            if(nCredit >= nCombineThreshold)\n              break;\n            /* Do not add a new input exceeding the stake limit if defined */\n            if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n              break;\n            /* Do not add any large inputs capable of stake generation on their own */\n            if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n              continue;\n            /* Do not add any inputs under the min. age */\n            if(nTimeWeight < nStakeMinAge)\n              continue;\n\n            txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n            nCredit += pcoin.first->vout[pcoin.second].nValue;\n            vwtxPrev.push_back(pcoin.first);\n        }\n\n    }\n\n    // Calculate coin age reward\n    {\n        uint64_t nCoinAge;\n        CTxDB txdb(\"r\");\n        if (!txNew.GetCoinAge(txdb, nCoinAge))\n            return error(\"CreateCoinStake : failed to calculate coin age\");\n\n        int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n        if (nReward <= 0)\n            return false;\n\n        nCredit += nReward;\n    }\n\n    // Set output amount\n    if (txNew.vout.size() == 3)\n    {\n        txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n        txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n    }\n    else\n        txNew.vout[1].nValue = nCredit;\n\n    // Sign\n    int nIn = 0;\n    BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n    {\n        if (!SignSignature(*this, *pcoin, txNew, nIn++))\n            return error(\"CreateCoinStake : failed to sign coinstake\");\n    }\n\n    // Limit size\n    unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n    if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n        return error(\"CreateCoinStake : exceeded coinstake size limit\");\n\n    // Successfully generated coinstake\n    return true;\n}\n\n\n// Call after CreateTransaction unless you want to abort\nbool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            // This is only to keep the database open to defeat the auto-flush for the\n            // duration of this scope.  This is the only place where this optimization\n            // maybe makes sense; please don't do it anywhere else.\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n\n            // Take key pair from key pool so it won't be used again\n            reservekey.KeepKey();\n\n            // Add tx to wallet, because if it has change it's also ours,\n            // otherwise just for transaction history.\n            AddToWallet(wtxNew);\n\n            // Mark old coins as spent\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n\n        // Track how many getdata requests our transaction gets\n        mapRequestCount[wtxNew.GetHash()] = 0;\n\n        // Broadcast\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            // This must not fail. The transaction has already been signed and recorded.\n            printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}\n\n\n\n\nstring CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    CReserveKey reservekey(this);\n    int64_t nFeeRequired;\n\n    if (IsLocked())\n    {\n        string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (fWalletUnlockStakingOnly)\n    {\n        string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n    if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n    {\n        string strError;\n        if (nValue + nFeeRequired > GetBalance())\n            strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n        else\n            strError = _(\"Error: Transaction creation failed  \");\n        printf(\"SendMoney() : %s\", strError.c_str());\n        return strError;\n    }\n\n    if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n        return \"ABORTED\";\n\n    if (!CommitTransaction(wtxNew, reservekey))\n        return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n\n    return \"\";\n}\n\n\n\nstring CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n{\n    // Check amount\n    if (nValue <= 0)\n        return _(\"Invalid amount\");\n    if (nValue + nTransactionFee > GetBalance())\n        return _(\"Insufficient funds\");\n\n    // Parse Bitcoin address\n    CScript scriptPubKey;\n    scriptPubKey.SetDestination(address);\n\n    return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n}\n\n\n\n\nDBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n{\n    if (!fFileBacked)\n        return DB_LOAD_OK;\n    fFirstRunRet = false;\n    DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n    if (nLoadWalletRet == DB_NEED_REWRITE)\n    {\n        if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n        {\n            setKeyPool.clear();\n            // Note: can't top-up keypool here, because wallet is locked.\n            // User will be prompted to unlock wallet the next operation\n            // the requires a new key.\n        }\n    }\n\n    if (nLoadWalletRet != DB_LOAD_OK)\n        return nLoadWalletRet;\n    fFirstRunRet = !vchDefaultKey.IsValid();\n\n    NewThread(ThreadFlushWalletDB, &strWalletFile);\n    return DB_LOAD_OK;\n}\n\n\nbool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n{\n    std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n    mapAddressBook[address] = strName;\n    NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n}\n\nbool CWallet::DelAddressBookName(const CTxDestination& address)\n{\n    mapAddressBook.erase(address);\n    NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n    if (!fFileBacked)\n        return false;\n    return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n}\n\n\nvoid CWallet::PrintWallet(const CBlock& block)\n{\n    {\n        LOCK(cs_wallet);\n        if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n            printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n        }\n        if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n        {\n            CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n            printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n         }\n\n    }\n    printf(\"\\n\");\n}\n\nbool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n{\n    {\n        LOCK(cs_wallet);\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n        {\n            wtx = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n{\n    if (fFileBacked)\n    {\n        if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n            return false;\n    }\n    vchDefaultKey = vchPubKey;\n    return true;\n}\n\nbool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n{\n    if (!pwallet->fFileBacked)\n        return false;\n    strWalletFileOut = pwallet->strWalletFile;\n    return true;\n}\n\n//\n// Mark old keypool keys as used,\n// and generate all new keys\n//\nbool CWallet::NewKeyPool()\n{\n    {\n        LOCK(cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n        BOOST_FOREACH(int64_t nIndex, setKeyPool)\n            walletdb.ErasePool(nIndex);\n        setKeyPool.clear();\n\n        if (IsLocked())\n            return false;\n\n        int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n        for (int i = 0; i < nKeys; i++)\n        {\n            int64_t nIndex = i+1;\n            walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n            setKeyPool.insert(nIndex);\n        }\n        printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n    }\n    return true;\n}\n\nbool CWallet::TopUpKeyPool(unsigned int nSize)\n{\n    {\n        LOCK(cs_wallet);\n\n        if (IsLocked())\n            return false;\n\n        CWalletDB walletdb(strWalletFile);\n\n        // Top up key pool\n        unsigned int nTargetSize;\n        if (nSize > 0)\n            nTargetSize = nSize;\n        else\n            nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n\n        while (setKeyPool.size() < (nTargetSize + 1))\n        {\n            int64_t nEnd = 1;\n            if (!setKeyPool.empty())\n                nEnd = *(--setKeyPool.end()) + 1;\n            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n            setKeyPool.insert(nEnd);\n            printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n        }\n    }\n    return true;\n}\n\nvoid CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n{\n    nIndex = -1;\n    keypool.vchPubKey = CPubKey();\n    {\n        LOCK(cs_wallet);\n\n        if (!IsLocked())\n            TopUpKeyPool();\n\n        // Get the oldest key\n        if(setKeyPool.empty())\n            return;\n\n        CWalletDB walletdb(strWalletFile);\n\n        nIndex = *(setKeyPool.begin());\n        setKeyPool.erase(setKeyPool.begin());\n        if (!walletdb.ReadPool(nIndex, keypool))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n        if (!HaveKey(keypool.vchPubKey.GetID()))\n            throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n        assert(keypool.vchPubKey.IsValid());\n        if (fDebug && GetBoolArg(\"-printkeypool\"))\n            printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n    }\n}\n\nint64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        CWalletDB walletdb(strWalletFile);\n\n        int64_t nIndex = 1 + *(--setKeyPool.end());\n        if (!walletdb.WritePool(nIndex, keypool))\n            throw runtime_error(\"AddReserveKey() : writing added key failed\");\n        setKeyPool.insert(nIndex);\n        return nIndex;\n    }\n    return -1;\n}\n\nvoid CWallet::KeepKey(int64_t nIndex)\n{\n    // Remove from key pool\n    if (fFileBacked)\n    {\n        CWalletDB walletdb(strWalletFile);\n        walletdb.ErasePool(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n}\n\nvoid CWallet::ReturnKey(int64_t nIndex)\n{\n    // Return to key pool\n    {\n        LOCK(cs_wallet);\n        setKeyPool.insert(nIndex);\n    }\n    if(fDebug)\n        printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n}\n\nbool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    {\n        LOCK(cs_wallet);\n        ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex == -1)\n        {\n            if (fAllowReuse && vchDefaultKey.IsValid())\n            {\n                result = vchDefaultKey;\n                return true;\n            }\n            if (IsLocked()) return false;\n            result = GenerateNewKey();\n            return true;\n        }\n        KeepKey(nIndex);\n        result = keypool.vchPubKey;\n    }\n    return true;\n}\n\nint64_t CWallet::GetOldestKeyPoolTime()\n{\n    int64_t nIndex = 0;\n    CKeyPool keypool;\n    ReserveKeyFromKeyPool(nIndex, keypool);\n    if (nIndex == -1)\n        return GetTime();\n    ReturnKey(nIndex);\n    return keypool.nTime;\n}\n\nstd::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n{\n    map<CTxDestination, int64_t> balances;\n\n    {\n        LOCK(cs_wallet);\n        BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n        {\n            CWalletTx *pcoin = &walletEntry.second;\n\n            if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                continue;\n\n            if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                continue;\n\n            int nDepth = pcoin->GetDepthInMainChain();\n            if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                continue;\n\n            for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            {\n                CTxDestination addr;\n                if (!IsMine(pcoin->vout[i]))\n                    continue;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                    continue;\n\n                int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n\n                if (!balances.count(addr))\n                    balances[addr] = 0;\n                balances[addr] += n;\n            }\n        }\n    }\n\n    return balances;\n}\n\nset< set<CTxDestination> > CWallet::GetAddressGroupings()\n{\n    set< set<CTxDestination> > groupings;\n    set<CTxDestination> grouping;\n\n    BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n    {\n        CWalletTx *pcoin = &walletEntry.second;\n\n        if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n        {\n            // group all input addresses with each other\n            BOOST_FOREACH(CTxIn txin, pcoin->vin)\n            {\n                CTxDestination address;\n                if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n            }\n\n            // group change with input addresses\n            BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                if (IsChange(txout))\n                {\n                    CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                    CTxDestination txoutAddr;\n                    if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                        continue;\n                    grouping.insert(txoutAddr);\n                }\n            groupings.insert(grouping);\n            grouping.clear();\n        }\n\n        // group lone addrs by themselves\n        for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n            if (IsMine(pcoin->vout[i]))\n            {\n                CTxDestination address;\n                if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                    continue;\n                grouping.insert(address);\n                groupings.insert(grouping);\n                grouping.clear();\n            }\n    }\n\n    set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n    map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n    BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n    {\n        // make a set of all the groups hit by this new group\n        set< set<CTxDestination>* > hits;\n        map< CTxDestination, set<CTxDestination>* >::iterator it;\n        BOOST_FOREACH(CTxDestination address, grouping)\n            if ((it = setmap.find(address)) != setmap.end())\n                hits.insert((*it).second);\n\n        // merge all hit groups into a new single group and delete old groups\n        set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n        BOOST_FOREACH(set<CTxDestination>* hit, hits)\n        {\n            merged->insert(hit->begin(), hit->end());\n            uniqueGroupings.erase(hit);\n            delete hit;\n        }\n        uniqueGroupings.insert(merged);\n\n        // update setmap\n        BOOST_FOREACH(CTxDestination element, *merged)\n            setmap[element] = merged;\n    }\n\n    set< set<CTxDestination> > ret;\n    BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n    {\n        ret.insert(*uniqueGrouping);\n        delete uniqueGrouping;\n    }\n\n    return ret;\n}\n\n\n/* Checks for wallet vs. transaction index consistency;\n * reports any spent state inconsistency found and\n * (optionally) fixes the wallet according to the transaction index */\nvoid CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n  bool fCheckOnly) {\n    nMismatchFound = 0;\n    nOrphansFound = 0;\n    nBalanceInQuestion = 0;\n\n    LOCK(cs_wallet);\n    vector<CWalletTx*> vCoins;\n    vCoins.reserve(mapWallet.size());\n    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n        vCoins.push_back(&(*it).second);\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n        uint256 hash = pcoin->GetHash();\n        CTxIndex txindex;\n        uint n;\n\n        if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n            continue;\n\n        for(n = 0; n < pcoin->vout.size(); n++) {\n            bool fUpdated = false;\n\n            if(IsMine(pcoin->vout[n])) {\n                if(pcoin->IsSpent(n) &&\n                  ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkUnspent(n);\n                        pcoin->WriteToDisk();\n                    }\n                } else if(!pcoin->IsSpent(n) &&\n                  (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                    printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                      FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                        fCheckOnly? \"repair not attempted\" : \"repairing\");\n                    nMismatchFound++;\n                    nBalanceInQuestion += pcoin->vout[n].nValue;\n                    if(!fCheckOnly) {\n                        fUpdated = true;\n                        pcoin->MarkSpent(n);\n                        pcoin->WriteToDisk();\n                    }\n                }\n\n            }\n\n            if(fUpdated)\n              NotifyTransactionChanged(this, hash, CT_UPDATED);\n        }\n\n        if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n           nOrphansFound++;\n           if(!fCheckOnly) {\n               EraseFromWallet(hash);\n               NotifyTransactionChanged(this, hash, CT_DELETED);\n           }\n           printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n             fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n        }\n    }\n}\n\n\n// ppcoin: disable transaction (only for coinstake)\nvoid CWallet::DisableTransaction(const CTransaction &tx)\n{\n    if (!tx.IsCoinStake() || !IsFromMe(tx))\n        return; // only disconnecting coinstake requires marking input unspent\n\n    LOCK(cs_wallet);\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n        if (mi != mapWallet.end())\n        {\n            CWalletTx& prev = (*mi).second;\n            if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n            {\n                prev.MarkUnspent(txin.prevout.n);\n                prev.WriteToDisk();\n            }\n        }\n    }\n}\n\nCPubKey CReserveKey::GetReservedKey()\n{\n    if (nIndex == -1)\n    {\n        CKeyPool keypool;\n        pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n        if (nIndex != -1)\n            vchPubKey = keypool.vchPubKey;\n        else\n        {\n            printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n            vchPubKey = pwallet->vchDefaultKey;\n        }\n    }\n    assert(vchPubKey.IsValid());\n    return vchPubKey;\n}\n\nvoid CReserveKey::KeepKey()\n{\n    if (nIndex != -1)\n        pwallet->KeepKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CReserveKey::ReturnKey()\n{\n    if (nIndex != -1)\n        pwallet->ReturnKey(nIndex);\n    nIndex = -1;\n    vchPubKey = CPubKey();\n}\n\nvoid CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n{\n    setAddress.clear();\n\n    CWalletDB walletdb(strWalletFile);\n\n    LOCK2(cs_main, cs_wallet);\n    BOOST_FOREACH(const int64_t& id, setKeyPool)\n    {\n        CKeyPool keypool;\n        if (!walletdb.ReadPool(id, keypool))\n            throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n        assert(keypool.vchPubKey.IsValid());\n        CKeyID keyID = keypool.vchPubKey.GetID();\n        if (!HaveKey(keyID))\n            throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n        setAddress.insert(keyID);\n    }\n}\n\nvoid CWallet::UpdatedTransaction(const uint256 &hashTx)\n{\n    {\n        LOCK(cs_wallet);\n        // Only notify UI if this transaction is in this wallet\n        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n        if (mi != mapWallet.end())\n            NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n    }\n}\n\nvoid CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n    mapKeyBirth.clear();\n\n    // get birth times for keys with metadata\n    for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n        if (it->second.nCreateTime)\n            mapKeyBirth[it->first] = it->second.nCreateTime;\n\n    // map in which we'll infer heights of other keys\n    CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n    std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n    std::set<CKeyID> setKeys;\n    GetKeys(setKeys);\n    BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n        if (mapKeyBirth.count(keyid) == 0)\n            mapKeyFirstBlock[keyid] = pindexMax;\n    }\n    setKeys.clear();\n\n    // if there are no such keys, we're done\n    if (mapKeyFirstBlock.empty())\n        return;\n\n    // find first block that affects those keys, if there are any left\n    std::vector<CKeyID> vAffected;\n    for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n        // iterate over all wallet transactions...\n        const CWalletTx &wtx = (*it).second;\n        std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n        if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n            // ... which are already in a block\n            int nHeight = blit->second->nHeight;\n            BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                // iterate over all their outputs\n                ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                    // ... and all their affected keys\n                    std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                    if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                        rit->second = blit->second;\n                }\n                vAffected.clear();\n            }\n        }\n    }\n\n    // Extract block timestamps for those keys\n    for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n        mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern unsigned int nStakeMaxAge;",
            "bool fWalletUnlockStakingOnly = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nextern unsigned int nStakeMaxAge;\nbool fWalletUnlockStakingOnly = false;\n\nCWallet {\n  void CWallet::ReacceptWalletTransactions()\n  {\n      CTxDB txdb(\"r\");\n      bool fRepeat = true;\n      while (fRepeat)\n      {\n          LOCK(cs_wallet);\n          fRepeat = false;\n          vector<CDiskTxPos> vMissingTx;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              if ((wtx.IsCoinBase() && wtx.IsSpent(0)) || (wtx.IsCoinStake() && wtx.IsSpent(1)))\n                  continue;\n  \n              CTxIndex txindex;\n              bool fUpdated = false;\n              if (txdb.ReadTxIndex(wtx.GetHash(), txindex))\n              {\n                  // Update fSpent if a tx got spent somewhere else by a copy of wallet.dat\n                  if (txindex.vSpent.size() != wtx.vout.size())\n                  {\n                      printf(\"ERROR: ReacceptWalletTransactions() : txindex.vSpent.size() %\"PRIszu\" != wtx.vout.size() %\"PRIszu\"\\n\", txindex.vSpent.size(), wtx.vout.size());\n                      continue;\n                  }\n                  for (unsigned int i = 0; i < txindex.vSpent.size(); i++)\n                  {\n                      if (wtx.IsSpent(i))\n                          continue;\n                      if (!txindex.vSpent[i].IsNull() && IsMine(wtx.vout[i]))\n                      {\n                          wtx.MarkSpent(i);\n                          fUpdated = true;\n                          vMissingTx.push_back(txindex.vSpent[i]);\n                      }\n                  }\n                  if (fUpdated)\n                  {\n                      printf(\"ReacceptWalletTransactions found spent coin %s SUM %s\\n\", FormatMoney(wtx.GetCredit()).c_str(), wtx.GetHash().ToString().c_str());\n                      wtx.MarkDirty();\n                      wtx.WriteToDisk();\n                  }\n              }\n              else\n              {\n                  // Re-accept any txes of ours that aren't already in a block\n                  if (!(wtx.IsCoinBase() || wtx.IsCoinStake()))\n                      wtx.AcceptWalletTransaction(txdb);\n              }\n          }\n          if (!vMissingTx.empty())\n          {\n              // TODO: optimize this to scan just part of the block chain?\n              if (ScanForWalletTransactions(pindexGenesisBlock))\n                  fRepeat = true;  // Found missing transactions: re-do re-accept.\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction(CTxDB& txdb)\n  {\n      BOOST_FOREACH(const CMerkleTx& tx, vtxPrev)\n      {\n          if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n          {\n              uint256 hash = tx.GetHash();\n              if (!txdb.ContainsTx(hash))\n                  RelayTransaction((CTransaction)tx, hash);\n          }\n      }\n      if (!(IsCoinBase() || IsCoinStake()))\n      {\n          uint256 hash = GetHash();\n          if (!txdb.ContainsTx(hash))\n          {\n              printf(\"Relaying wtx %s\\n\", hash.ToString().substr(0,10).c_str());\n              RelayTransaction((CTransaction)*this, hash);\n          }\n      }\n  }\n  \n  void CWalletTx::RelayWalletTransaction()\n  {\n     CTxDB txdb(\"r\");\n     RelayWalletTransaction(txdb);\n  }\n  \n  void CWallet::ResendWalletTransactions(bool fForce)\n  {\n      if (!fForce)\n      {\n          // Do this infrequently and randomly to avoid giving away\n          // that these are our transactions.\n          static int64_t nNextTime;\n          if (GetTime() < nNextTime)\n              return;\n          bool fFirst = (nNextTime == 0);\n          nNextTime = GetTime() + GetRand(30 * 60);\n          if (fFirst)\n              return;\n  \n          // Only do it if there's been a new block since last time\n          static int64_t nLastTime;\n          if (nTimeBestReceived < nLastTime)\n              return;\n          nLastTime = GetTime();\n      }\n  \n      // Rebroadcast any of our txes that aren't in a block yet\n      printf(\"ResendWalletTransactions()\\n\");\n      CTxDB txdb(\"r\");\n      {\n          LOCK(cs_wallet);\n          // Sort them in chronological order\n          multimap<unsigned int, CWalletTx*> mapSorted;\n          BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n          {\n              CWalletTx& wtx = item.second;\n              // Don't rebroadcast until it's had plenty of time that\n              // it should have gotten in already by now.\n              if (fForce || nTimeBestReceived - (int64_t)wtx.nTimeReceived > 5 * 60)\n                  mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n          }\n          BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n          {\n              CWalletTx& wtx = *item.second;\n              if (wtx.CheckTransaction())\n                  wtx.RelayWalletTransaction(txdb);\n              else\n                  printf(\"ResendWalletTransactions() : CheckTransaction failed for transaction %s\\n\", wtx.GetHash().ToString().c_str());\n          }\n      }\n  }\n  \n  \n  \n  \n  \n  \n  //////////////////////////////////////////////////////////////////////////////\n  //\n  // Actions\n  //\n  \n  \n  int64_t CWallet::GetBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n  \n      return nTotal;\n  }\n  \n  int64_t CWallet::GetUnconfirmedBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  nTotal += pcoin->GetAvailableCredit();\n          }\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetImmatureBalance() const\n  {\n      int64_t nTotal = 0;\n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx& pcoin = (*it).second;\n              if (pcoin.IsCoinBase() && pcoin.GetBlocksToMaturity() > 0 && pcoin.IsInMainChain())\n                  nTotal += GetCredit(pcoin);\n          }\n      }\n      return nTotal;\n  }\n  \n  // populate vCoins with vector of spendable COutputs\n  void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if (fOnlyConfirmed && !pcoin->IsTrusted())\n                  continue;\n  \n              if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              if(pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < 0)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue &&\n                  (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))\n                      vCoins.push_back(COutput(pcoin, i, nDepth));\n  \n          }\n      }\n  }\n  \n  void CWallet::AvailableCoinsMinConf(vector<COutput>& vCoins, int nConf) const\n  {\n      vCoins.clear();\n  \n      {\n          LOCK(cs_wallet);\n          for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          {\n              const CWalletTx* pcoin = &(*it).second;\n  \n              if (!pcoin->IsFinal())\n                  continue;\n  \n              if(pcoin->GetDepthInMainChain() < nConf)\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n                  if (!(pcoin->IsSpent(i)) && IsMine(pcoin->vout[i]) && pcoin->vout[i].nValue >= nMinimumInputValue)\n                      vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));\n          }\n      }\n  }\n  \n  static void ApproximateBestSubset(vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > >vValue, int64_t nTotalLower, int64_t nTargetValue,\n                                    vector<char>& vfBest, int64_t& nBest, int iterations = 1000)\n  {\n      vector<char> vfIncluded;\n  \n      vfBest.assign(vValue.size(), true);\n      nBest = nTotalLower;\n  \n      for (int nRep = 0; nRep < iterations && nBest != nTargetValue; nRep++)\n      {\n          vfIncluded.assign(vValue.size(), false);\n          int64_t nTotal = 0;\n          bool fReachedTarget = false;\n          for (int nPass = 0; nPass < 2 && !fReachedTarget; nPass++)\n          {\n              for (unsigned int i = 0; i < vValue.size(); i++)\n              {\n                  if (nPass == 0 ? rand() % 2 : !vfIncluded[i])\n                  {\n                      nTotal += vValue[i].first;\n                      vfIncluded[i] = true;\n                      if (nTotal >= nTargetValue)\n                      {\n                          fReachedTarget = true;\n                          if (nTotal < nBest)\n                          {\n                              nBest = nTotal;\n                              vfBest = vfIncluded;\n                          }\n                          nTotal -= vValue[i].first;\n                          vfIncluded[i] = false;\n                      }\n                  }\n              }\n          }\n      }\n  }\n  \n  // ppcoin: total coins staked (non-spendable until maturity)\n  int64_t CWallet::GetStake() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinStake() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  int64_t CWallet::GetNewMint() const\n  {\n      int64_t nTotal = 0;\n      LOCK(cs_wallet);\n      for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n      {\n          const CWalletTx* pcoin = &(*it).second;\n          if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0 && pcoin->GetDepthInMainChain() > 0)\n              nTotal += CWallet::GetCredit(*pcoin);\n      }\n      return nTotal;\n  }\n  \n  bool CWallet::SelectCoinsMinConf(int64_t nTargetValue, unsigned int nSpendTime, int nConfMine, int nConfTheirs, vector<COutput> vCoins, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      // List of values less than target\n      pair<int64_t, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n      coinLowestLarger.first = std::numeric_limits<int64_t>::max();\n      coinLowestLarger.second.first = NULL;\n      vector<pair<int64_t, pair<const CWalletTx*,unsigned int> > > vValue;\n      int64_t nTotalLower = 0;\n  \n      random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n  \n          if (output.nDepth < (pcoin->IsFromMe() ? nConfMine : nConfTheirs))\n              continue;\n  \n          int i = output.i;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n == nTargetValue)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              return true;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              vValue.push_back(coin);\n              nTotalLower += n;\n          }\n          else if (n < coinLowestLarger.first)\n          {\n              coinLowestLarger = coin;\n          }\n      }\n  \n      if (nTotalLower == nTargetValue)\n      {\n          for (unsigned int i = 0; i < vValue.size(); ++i)\n          {\n              setCoinsRet.insert(vValue[i].second);\n              nValueRet += vValue[i].first;\n          }\n          return true;\n      }\n  \n      if (nTotalLower < nTargetValue)\n      {\n          if (coinLowestLarger.second.first == NULL)\n              return false;\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n          return true;\n      }\n  \n      // Solve subset sum by stochastic approximation\n      sort(vValue.rbegin(), vValue.rend(), CompareValueOnly());\n      vector<char> vfBest;\n      int64_t nBest;\n  \n      ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest, 1000);\n      if (nBest != nTargetValue && nTotalLower >= nTargetValue + CENT)\n          ApproximateBestSubset(vValue, nTotalLower, nTargetValue + CENT, vfBest, nBest, 1000);\n  \n      // If we have a bigger coin and (either the stochastic approximation didn't find a good solution,\n      //                                   or the next bigger coin is closer), return the bigger coin\n      if (coinLowestLarger.second.first &&\n          ((nBest != nTargetValue && nBest < nTargetValue + CENT) || coinLowestLarger.first <= nBest))\n      {\n          setCoinsRet.insert(coinLowestLarger.second);\n          nValueRet += coinLowestLarger.first;\n      }\n      else {\n          for (unsigned int i = 0; i < vValue.size(); i++)\n              if (vfBest[i])\n              {\n                  setCoinsRet.insert(vValue[i].second);\n                  nValueRet += vValue[i].first;\n              }\n  \n          if (fDebug && GetBoolArg(\"-printpriority\"))\n          {\n              //// debug print\n              printf(\"SelectCoins() best subset: \");\n              for (unsigned int i = 0; i < vValue.size(); i++)\n                  if (vfBest[i])\n                      printf(\"%s \", FormatMoney(vValue[i].first).c_str());\n              printf(\"total %s\\n\", FormatMoney(nBest).c_str());\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::SelectCoins(int64_t nTargetValue, unsigned int nSpendTime, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet, const CCoinControl* coinControl) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoins(vCoins, true, coinControl);\n  \n      // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n      if (coinControl && coinControl->HasSelected())\n      {\n          BOOST_FOREACH(const COutput& out, vCoins)\n          {\n              nValueRet += out.tx->vout[out.i].nValue;\n              setCoinsRet.insert(make_pair(out.tx, out.i));\n          }\n          return (nValueRet >= nTargetValue);\n      }\n  \n      return (SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 6, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 1, 1, vCoins, setCoinsRet, nValueRet) ||\n              SelectCoinsMinConf(nTargetValue, nSpendTime, 0, 1, vCoins, setCoinsRet, nValueRet));\n  }\n  \n  // Select some coins without random shuffle or best subset approximation\n  bool CWallet::SelectCoinsSimple(int64_t nTargetValue, unsigned int nSpendTime, int nMinConf, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, int64_t& nValueRet) const\n  {\n      vector<COutput> vCoins;\n      AvailableCoinsMinConf(vCoins, nMinConf);\n  \n      setCoinsRet.clear();\n      nValueRet = 0;\n  \n      BOOST_FOREACH(COutput output, vCoins)\n      {\n          const CWalletTx *pcoin = output.tx;\n          int i = output.i;\n  \n          // Stop if we've chosen enough inputs\n          if (nValueRet >= nTargetValue)\n              break;\n  \n          // Follow the timestamp rules\n          if (pcoin->nTime > nSpendTime)\n              continue;\n  \n          int64_t n = pcoin->vout[i].nValue;\n  \n          pair<int64_t,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n  \n          if (n >= nTargetValue)\n          {\n              // If input value is greater or equal to target then simply insert\n              //    it into the current subset and exit\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n              break;\n          }\n          else if (n < nTargetValue + CENT)\n          {\n              setCoinsRet.insert(coin.second);\n              nValueRet += coin.first;\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(const vector<pair<CScript, int64_t> >& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      int64_t nValue = 0;\n      BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n      {\n          if (nValue < 0)\n              return false;\n          nValue += s.second;\n      }\n      if (vecSend.empty() || nValue < 0)\n          return false;\n  \n      wtxNew.BindWallet(this);\n  \n      {\n          LOCK2(cs_main, cs_wallet);\n          // txdb must be opened before the mapWallet lock\n          CTxDB txdb(\"r\");\n          {\n              nFeeRet = nTransactionFee;\n              while (true)\n              {\n                  wtxNew.vin.clear();\n                  wtxNew.vout.clear();\n                  wtxNew.fFromMe = true;\n  \n                  int64_t nTotalValue = nValue + nFeeRet;\n                  double dPriority = 0;\n                  // vouts to the payees\n                  BOOST_FOREACH (const PAIRTYPE(CScript, int64_t)& s, vecSend)\n                      wtxNew.vout.push_back(CTxOut(s.second, s.first));\n  \n                  // Choose coins to use\n                  set<pair<const CWalletTx*,unsigned int> > setCoins;\n                  int64_t nValueIn = 0;\n                  if (!SelectCoins(nTotalValue, wtxNew.nTime, setCoins, nValueIn, coinControl))\n                      return false;\n                  BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n                  {\n                      int64_t nCredit = pcoin.first->vout[pcoin.second].nValue;\n                      dPriority += (double)nCredit * pcoin.first->GetDepthInMainChain();\n                  }\n  \n                  int64_t nChange = nValueIn - nValue - nFeeRet;\n                  // if sub-cent change is required, the fee must be raised to at least MIN_TX_FEE\n                  // or until nChange becomes zero\n                  // NOTE: this depends on the exact behaviour of GetMinFee\n                  if (nFeeRet < MIN_TX_FEE && nChange > 0 && nChange < CENT)\n                  {\n                      int64_t nMoveToFee = min(nChange, MIN_TX_FEE - nFeeRet);\n                      nChange -= nMoveToFee;\n                      nFeeRet += nMoveToFee;\n                  }\n  \n                  if (nChange > 0)\n                  {\n                      // Fill a vout to ourself\n                      // TODO: pass in scriptChange instead of reservekey so\n                      // change transaction isn't always pay-to-bitcoin-address\n                      CScript scriptChange;\n  \n                      // coin control: send change to custom address\n                      if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n                          scriptChange.SetDestination(coinControl->destChange);\n  \n                      // no coin control: send change to newly generated address\n                      else\n                      {\n                          // Note: We use a new key here to keep it from being obvious which side is the change.\n                          //  The drawback is that by not reusing a previous key, the change may be lost if a\n                          //  backup is restored, if the backup doesn't have the new private key for the change.\n                          //  If we reused the old key, it would be possible to add code to look for and\n                          //  rediscover unknown transactions that were written with keys of ours to recover\n                          //  post-backup change.\n  \n                          // Reserve a new key pair from key pool\n                          CPubKey vchPubKey = reservekey.GetReservedKey();\n  \n                          scriptChange.SetDestination(vchPubKey.GetID());\n                      }\n  \n                      // Insert change txn at random position:\n                      vector<CTxOut>::iterator position = wtxNew.vout.begin()+GetRandInt(wtxNew.vout.size());\n                      wtxNew.vout.insert(position, CTxOut(nChange, scriptChange));\n                  }\n                  else\n                      reservekey.ReturnKey();\n  \n                  // Fill vin\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      wtxNew.vin.push_back(CTxIn(coin.first->GetHash(),coin.second));\n  \n                  // Sign\n                  int nIn = 0;\n                  BOOST_FOREACH(const PAIRTYPE(const CWalletTx*,unsigned int)& coin, setCoins)\n                      if (!SignSignature(*this, *coin.first, wtxNew, nIn++))\n                          return false;\n  \n                  // Limit size\n                  unsigned int nBytes = ::GetSerializeSize(*(CTransaction*)&wtxNew, SER_NETWORK, PROTOCOL_VERSION);\n                  if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n                      return false;\n                  dPriority /= nBytes;\n  \n                  // Check that enough fee is included\n                  int64_t nPayFee = nTransactionFee * (1 + (int64_t)nBytes / 1000);\n                  int64_t nMinFee = wtxNew.GetMinFee(1, GMF_SEND, nBytes);\n  \n                  if (nFeeRet < max(nPayFee, nMinFee))\n                  {\n                      nFeeRet = max(nPayFee, nMinFee);\n                      continue;\n                  }\n  \n                  // Fill vtxPrev by copying from previous transactions vtxPrev\n                  wtxNew.AddSupportingTransactions(txdb);\n                  wtxNew.fTimeReceivedIsTxTime = true;\n  \n                  break;\n              }\n          }\n      }\n      return true;\n  }\n  \n  bool CWallet::CreateTransaction(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, CReserveKey& reservekey, int64_t& nFeeRet, const CCoinControl* coinControl)\n  {\n      vector< pair<CScript, int64_t> > vecSend;\n      vecSend.push_back(make_pair(scriptPubKey, nValue));\n      return CreateTransaction(vecSend, wtxNew, reservekey, nFeeRet, coinControl);\n  }\n  \n  // NovaCoin: get current stake weight\n  bool CWallet::GetStakeWeight(const CKeyStore& keystore,\n    uint64_t& nMinWeight, uint64_t& nMaxWeight, uint64_t& nWeight) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      if (!SelectCoinsSimple(nBalance - nReserveBalance, GetTime(), nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          int64_t nTimeWeight = GetWeight((int64_t)pcoin.first->nTime, (int64_t)GetTime());\n          CBigNum bnCoinDayWeight = CBigNum(pcoin.first->vout[pcoin.second].nValue) * nTimeWeight / COIN / (24 * 60 * 60);\n  \n          // Weight is greater than zero\n          if (nTimeWeight > 0)\n          {\n              nWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Weight is greater than zero, but the maximum value isn't reached yet\n          if (nTimeWeight > 0 && nTimeWeight < nStakeMaxAge)\n          {\n              nMinWeight += bnCoinDayWeight.getuint64();\n          }\n  \n          // Maximum weight was reached\n          if (nTimeWeight == nStakeMaxAge)\n          {\n              nMaxWeight += bnCoinDayWeight.getuint64();\n          }\n      }\n  \n      return true;\n  }\n  \n  bool CWallet::CreateCoinStake(const CKeyStore& keystore, uint nBits, int64_t nSearchInterval,\n    int64_t nFees, CTransaction& txNew, CKey& key) {\n      uint nStakeMaxAge = GetStakeMaxAge(GetTime());\n  \n      /* Don't split inputs above this age */\n      const uint nStakeSplitAge = (nStakeMinAge + nStakeMaxAge);\n      /* Time limit for searching a single input */\n      const uint nMaxStakeSearchInterval = 60;\n  \n      CBlockIndex* pindexPrev = pindexBest;\n  \n      CBigNum bnTargetPerCoinDay;\n      bnTargetPerCoinDay.SetCompact(nBits);\n  \n      txNew.vin.clear();\n      txNew.vout.clear();\n  \n      // Mark coin stake transaction\n      CScript scriptEmpty;\n      scriptEmpty.clear();\n      txNew.vout.push_back(CTxOut(0, scriptEmpty));\n  \n      // Choose coins to use\n      int64_t nBalance = GetBalance();\n  \n      if (nBalance <= nReserveBalance)\n          return false;\n  \n      vector<const CWalletTx*> vwtxPrev;\n  \n      set<pair<const CWalletTx*,unsigned int> > setCoins;\n      int64_t nValueIn = 0;\n  \n      // Select coins with suitable depth\n      if (!SelectCoinsSimple(nBalance - nReserveBalance, txNew.nTime, nCoinbaseMaturity + 10, setCoins, nValueIn))\n          return false;\n  \n      if (setCoins.empty())\n          return false;\n  \n      int64_t nCredit = 0;\n      CScript scriptPubKeyKernel;\n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, unsigned int) pcoin, setCoins)\n      {\n          CTxIndex txindex;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!txdb.ReadTxIndex(pcoin.first->GetHash(), txindex))\n                  continue;\n          }\n  \n          // Read block header\n          CBlock block;\n          {\n              LOCK2(cs_main, cs_wallet);\n              if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                  continue;\n          }\n  \n          if (block.GetBlockTime() + nStakeMinAge > txNew.nTime - nMaxStakeSearchInterval)\n              continue; // only count coins meeting min age requirement\n  \n          bool fKernelFound = false;\n          for (unsigned int n=0; n<min(nSearchInterval,(int64_t)nMaxStakeSearchInterval) && !fKernelFound && !fShutdown && pindexPrev == pindexBest; n++)\n          {\n              // Search backward in time from the given txNew timestamp \n              // Search nSearchInterval seconds back up to nMaxStakeSearchInterval\n              uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n              COutPoint prevoutStake = COutPoint(pcoin.first->GetHash(), pcoin.second);\n              if (CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, *pcoin.first, prevoutStake, txNew.nTime - n, hashProofOfStake, targetProofOfStake))\n              {\n                  // Found a kernel\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : kernel found\\n\");\n                  vector<valtype> vSolutions;\n                  txnouttype whichType;\n                  CScript scriptPubKeyOut;\n                  scriptPubKeyKernel = pcoin.first->vout[pcoin.second].scriptPubKey;\n                  if (!Solver(scriptPubKeyKernel, whichType, vSolutions))\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : failed to parse kernel\\n\");\n                      break;\n                  }\n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : parsed kernel type=%d\\n\", whichType);\n                  if (whichType != TX_PUBKEY && whichType != TX_PUBKEYHASH)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : no support for kernel type=%d\\n\", whichType);\n                      break;  // only support pay to public key and pay to address\n                  }\n                  if (whichType == TX_PUBKEYHASH) // pay to address type\n                  {\n                      // convert to pay to public key type\n                      if (!keystore.GetKey(uint160(vSolutions[0]), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n                      scriptPubKeyOut << key.GetPubKey() << OP_CHECKSIG;\n                  }\n                  if (whichType == TX_PUBKEY)\n                  {\n                      valtype& vchPubKey = vSolutions[0];\n                      if (!keystore.GetKey(Hash160(vchPubKey), key))\n                      {\n                          if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                              printf(\"CreateCoinStake : failed to get key for kernel type=%d\\n\", whichType);\n                          break;  // unable to find corresponding public key\n                      }\n  \n                  if (key.GetPubKey() != vchPubKey)\n                  {\n                      if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                          printf(\"CreateCoinStake : invalid key for kernel type=%d\\n\", whichType);\n                          break; // keys mismatch\n                      }\n  \n                      scriptPubKeyOut = scriptPubKeyKernel;\n                  }\n  \n                  txNew.nTime -= n;\n                  txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n                  nCredit += pcoin.first->vout[pcoin.second].nValue;\n                  vwtxPrev.push_back(pcoin.first);\n                  txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  /* Split large inputs into two near halves;\n                   * exact amounts to be defined after reward processing */\n                  if((nCredit >= nSplitThreshold) &&\n                    (block.GetBlockTime() + nStakeSplitAge > txNew.nTime))\n                    txNew.vout.push_back(CTxOut(0, scriptPubKeyOut));\n  \n                  if (fDebug && GetBoolArg(\"-printcoinstake\"))\n                      printf(\"CreateCoinStake : added kernel type=%d\\n\", whichType);\n                  fKernelFound = true;\n                  break;\n              }\n          }\n  \n          if (fKernelFound || fShutdown)\n              break; // if kernel is found stop searching\n      }\n  \n      /* At this point, stake amount must be positive and within the stake limit if defined */\n      if(!nCredit || (nCredit > (nBalance - nReserveBalance)))\n        return(false);\n  \n      BOOST_FOREACH(PAIRTYPE(const CWalletTx*, uint) pcoin, setCoins) {\n  \n          /* Make a larger stake by inserting additional inputs\n           * of the same public key (address) as the generating input */\n          if((txNew.vout.size() == 2) &&\n            (((pcoin.first->vout[pcoin.second].scriptPubKey == scriptPubKeyKernel) ||\n            (pcoin.first->vout[pcoin.second].scriptPubKey == txNew.vout[1].scriptPubKey))) &&\n            (pcoin.first->GetHash() != txNew.vin[0].prevout.hash)) {\n              int64 nTimeWeight = GetWeight((int64)pcoin.first->nTime, (int64)txNew.nTime);\n  \n              /* Do not add too many inputs */\n              if(txNew.vin.size() >= 10)\n                break;\n              /* Do not add any inputs if reached or exceeded the threshold already */\n              if(nCredit >= nCombineThreshold)\n                break;\n              /* Do not add a new input exceeding the stake limit if defined */\n              if((nCredit + pcoin.first->vout[pcoin.second].nValue) > (nBalance - nReserveBalance))\n                break;\n              /* Do not add any large inputs capable of stake generation on their own */\n              if(pcoin.first->vout[pcoin.second].nValue >= nCombineThreshold)\n                continue;\n              /* Do not add any inputs under the min. age */\n              if(nTimeWeight < nStakeMinAge)\n                continue;\n  \n              txNew.vin.push_back(CTxIn(pcoin.first->GetHash(), pcoin.second));\n              nCredit += pcoin.first->vout[pcoin.second].nValue;\n              vwtxPrev.push_back(pcoin.first);\n          }\n  \n      }\n  \n      // Calculate coin age reward\n      {\n          uint64_t nCoinAge;\n          CTxDB txdb(\"r\");\n          if (!txNew.GetCoinAge(txdb, nCoinAge))\n              return error(\"CreateCoinStake : failed to calculate coin age\");\n  \n          int64_t nReward = GetProofOfStakeReward(pindexBest->nHeight + 1, nCoinAge, nFees);\n          if (nReward <= 0)\n              return false;\n  \n          nCredit += nReward;\n      }\n  \n      // Set output amount\n      if (txNew.vout.size() == 3)\n      {\n          txNew.vout[1].nValue = (nCredit / 2 / CENT) * CENT;\n          txNew.vout[2].nValue = nCredit - txNew.vout[1].nValue;\n      }\n      else\n          txNew.vout[1].nValue = nCredit;\n  \n      // Sign\n      int nIn = 0;\n      BOOST_FOREACH(const CWalletTx* pcoin, vwtxPrev)\n      {\n          if (!SignSignature(*this, *pcoin, txNew, nIn++))\n              return error(\"CreateCoinStake : failed to sign coinstake\");\n      }\n  \n      // Limit size\n      unsigned int nBytes = ::GetSerializeSize(txNew, SER_NETWORK, PROTOCOL_VERSION);\n      if (nBytes >= MAX_BLOCK_SIZE_GEN/5)\n          return error(\"CreateCoinStake : exceeded coinstake size limit\");\n  \n      // Successfully generated coinstake\n      return true;\n  }\n  \n  \n  // Call after CreateTransaction unless you want to abort\n  bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n          {\n              // This is only to keep the database open to defeat the auto-flush for the\n              // duration of this scope.  This is the only place where this optimization\n              // maybe makes sense; please don't do it anywhere else.\n              CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n  \n              // Take key pair from key pool so it won't be used again\n              reservekey.KeepKey();\n  \n              // Add tx to wallet, because if it has change it's also ours,\n              // otherwise just for transaction history.\n              AddToWallet(wtxNew);\n  \n              // Mark old coins as spent\n              set<CWalletTx*> setCoins;\n              BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n              {\n                  CWalletTx &coin = mapWallet[txin.prevout.hash];\n                  coin.BindWallet(this);\n                  coin.MarkSpent(txin.prevout.n);\n                  coin.WriteToDisk();\n                  NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n              }\n  \n              if (fFileBacked)\n                  delete pwalletdb;\n          }\n  \n          // Track how many getdata requests our transaction gets\n          mapRequestCount[wtxNew.GetHash()] = 0;\n  \n          // Broadcast\n          if (!wtxNew.AcceptToMemoryPool())\n          {\n              // This must not fail. The transaction has already been signed and recorded.\n              printf(\"CommitTransaction() : Error: Transaction not valid\\n\");\n              return false;\n          }\n          wtxNew.RelayWalletTransaction();\n      }\n      return true;\n  }\n  \n  \n  \n  \n  string CWallet::SendMoney(CScript scriptPubKey, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      CReserveKey reservekey(this);\n      int64_t nFeeRequired;\n  \n      if (IsLocked())\n      {\n          string strError = _(\"Error: Wallet locked, unable to create transaction  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (fWalletUnlockStakingOnly)\n      {\n          string strError = _(\"Error: Wallet unlocked for staking only, unable to create transaction.\");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n      if (!CreateTransaction(scriptPubKey, nValue, wtxNew, reservekey, nFeeRequired))\n      {\n          string strError;\n          if (nValue + nFeeRequired > GetBalance())\n              strError = strprintf(_(\"Error: This transaction requires a transaction fee of at least %s because of its amount, complexity, or use of recently received funds  \"), FormatMoney(nFeeRequired).c_str());\n          else\n              strError = _(\"Error: Transaction creation failed  \");\n          printf(\"SendMoney() : %s\", strError.c_str());\n          return strError;\n      }\n  \n      if (fAskFee && !uiInterface.ThreadSafeAskFee(nFeeRequired, _(\"Sending...\")))\n          return \"ABORTED\";\n  \n      if (!CommitTransaction(wtxNew, reservekey))\n          return _(\"Error: The transaction was rejected.  This might happen if some of the coins in your wallet were already spent, such as if you used a copy of wallet.dat and coins were spent in the copy but not marked as spent here.\");\n  \n      return \"\";\n  }\n  \n  \n  \n  string CWallet::SendMoneyToDestination(const CTxDestination& address, int64_t nValue, CWalletTx& wtxNew, bool fAskFee)\n  {\n      // Check amount\n      if (nValue <= 0)\n          return _(\"Invalid amount\");\n      if (nValue + nTransactionFee > GetBalance())\n          return _(\"Insufficient funds\");\n  \n      // Parse Bitcoin address\n      CScript scriptPubKey;\n      scriptPubKey.SetDestination(address);\n  \n      return SendMoney(scriptPubKey, nValue, wtxNew, fAskFee);\n  }\n  \n  \n  \n  \n  DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n  {\n      if (!fFileBacked)\n          return DB_LOAD_OK;\n      fFirstRunRet = false;\n      DBErrors nLoadWalletRet = CWalletDB(strWalletFile,\"cr+\").LoadWallet(this);\n      if (nLoadWalletRet == DB_NEED_REWRITE)\n      {\n          if (CDB::Rewrite(strWalletFile, \"\\x04pool\"))\n          {\n              setKeyPool.clear();\n              // Note: can't top-up keypool here, because wallet is locked.\n              // User will be prompted to unlock wallet the next operation\n              // the requires a new key.\n          }\n      }\n  \n      if (nLoadWalletRet != DB_LOAD_OK)\n          return nLoadWalletRet;\n      fFirstRunRet = !vchDefaultKey.IsValid();\n  \n      NewThread(ThreadFlushWalletDB, &strWalletFile);\n      return DB_LOAD_OK;\n  }\n  \n  \n  bool CWallet::SetAddressBookName(const CTxDestination& address, const string& strName)\n  {\n      std::map<CTxDestination, std::string>::iterator mi = mapAddressBook.find(address);\n      mapAddressBook[address] = strName;\n      NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address), (mi == mapAddressBook.end()) ? CT_NEW : CT_UPDATED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).WriteName(CBitcoinAddress(address).ToString(), strName);\n  }\n  \n  bool CWallet::DelAddressBookName(const CTxDestination& address)\n  {\n      mapAddressBook.erase(address);\n      NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address), CT_DELETED);\n      if (!fFileBacked)\n          return false;\n      return CWalletDB(strWalletFile).EraseName(CBitcoinAddress(address).ToString());\n  }\n  \n  \n  void CWallet::PrintWallet(const CBlock& block)\n  {\n      {\n          LOCK(cs_wallet);\n          if (block.IsProofOfWork() && mapWallet.count(block.vtx[0].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[0].GetHash()];\n              printf(\"    mine:  %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n          }\n          if (block.IsProofOfStake() && mapWallet.count(block.vtx[1].GetHash()))\n          {\n              CWalletTx& wtx = mapWallet[block.vtx[1].GetHash()];\n              printf(\"    stake: %d  %d  %\"PRId64\"\", wtx.GetDepthInMainChain(), wtx.GetBlocksToMaturity(), wtx.GetCredit());\n           }\n  \n      }\n      printf(\"\\n\");\n  }\n  \n  bool CWallet::GetTransaction(const uint256 &hashTx, CWalletTx& wtx)\n  {\n      {\n          LOCK(cs_wallet);\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n          {\n              wtx = (*mi).second;\n              return true;\n          }\n      }\n      return false;\n  }\n  \n  bool CWallet::SetDefaultKey(const CPubKey &vchPubKey)\n  {\n      if (fFileBacked)\n      {\n          if (!CWalletDB(strWalletFile).WriteDefaultKey(vchPubKey))\n              return false;\n      }\n      vchDefaultKey = vchPubKey;\n      return true;\n  }\n  \n  bool GetWalletFile(CWallet* pwallet, string &strWalletFileOut)\n  {\n      if (!pwallet->fFileBacked)\n          return false;\n      strWalletFileOut = pwallet->strWalletFile;\n      return true;\n  }\n  \n  //\n  // Mark old keypool keys as used,\n  // and generate all new keys\n  //\n  bool CWallet::NewKeyPool()\n  {\n      {\n          LOCK(cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n          BOOST_FOREACH(int64_t nIndex, setKeyPool)\n              walletdb.ErasePool(nIndex);\n          setKeyPool.clear();\n  \n          if (IsLocked())\n              return false;\n  \n          int64_t nKeys = max(GetArg(\"-keypool\", 100), (int64_t)0);\n          for (int i = 0; i < nKeys; i++)\n          {\n              int64_t nIndex = i+1;\n              walletdb.WritePool(nIndex, CKeyPool(GenerateNewKey()));\n              setKeyPool.insert(nIndex);\n          }\n          printf(\"CWallet::NewKeyPool wrote %\"PRId64\" new keys\\n\", nKeys);\n      }\n      return true;\n  }\n  \n  bool CWallet::TopUpKeyPool(unsigned int nSize)\n  {\n      {\n          LOCK(cs_wallet);\n  \n          if (IsLocked())\n              return false;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          // Top up key pool\n          unsigned int nTargetSize;\n          if (nSize > 0)\n              nTargetSize = nSize;\n          else\n              nTargetSize = max(GetArg(\"-keypool\", 100), (int64_t)0);\n  \n          while (setKeyPool.size() < (nTargetSize + 1))\n          {\n              int64_t nEnd = 1;\n              if (!setKeyPool.empty())\n                  nEnd = *(--setKeyPool.end()) + 1;\n              if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n                  throw runtime_error(\"TopUpKeyPool() : writing generated key failed\");\n              setKeyPool.insert(nEnd);\n              printf(\"keypool added key %\"PRId64\", size=%\"PRIszu\"\\n\", nEnd, setKeyPool.size());\n          }\n      }\n      return true;\n  }\n  \n  void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n  {\n      nIndex = -1;\n      keypool.vchPubKey = CPubKey();\n      {\n          LOCK(cs_wallet);\n  \n          if (!IsLocked())\n              TopUpKeyPool();\n  \n          // Get the oldest key\n          if(setKeyPool.empty())\n              return;\n  \n          CWalletDB walletdb(strWalletFile);\n  \n          nIndex = *(setKeyPool.begin());\n          setKeyPool.erase(setKeyPool.begin());\n          if (!walletdb.ReadPool(nIndex, keypool))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : read failed\");\n          if (!HaveKey(keypool.vchPubKey.GetID()))\n              throw runtime_error(\"ReserveKeyFromKeyPool() : unknown key in key pool\");\n          assert(keypool.vchPubKey.IsValid());\n          if (fDebug && GetBoolArg(\"-printkeypool\"))\n              printf(\"keypool reserve %\"PRId64\"\\n\", nIndex);\n      }\n  }\n  \n  int64_t CWallet::AddReserveKey(const CKeyPool& keypool)\n  {\n      {\n          LOCK2(cs_main, cs_wallet);\n          CWalletDB walletdb(strWalletFile);\n  \n          int64_t nIndex = 1 + *(--setKeyPool.end());\n          if (!walletdb.WritePool(nIndex, keypool))\n              throw runtime_error(\"AddReserveKey() : writing added key failed\");\n          setKeyPool.insert(nIndex);\n          return nIndex;\n      }\n      return -1;\n  }\n  \n  void CWallet::KeepKey(int64_t nIndex)\n  {\n      // Remove from key pool\n      if (fFileBacked)\n      {\n          CWalletDB walletdb(strWalletFile);\n          walletdb.ErasePool(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool keep %\"PRId64\"\\n\", nIndex);\n  }\n  \n  void CWallet::ReturnKey(int64_t nIndex)\n  {\n      // Return to key pool\n      {\n          LOCK(cs_wallet);\n          setKeyPool.insert(nIndex);\n      }\n      if(fDebug)\n          printf(\"keypool return %\"PRId64\"\\n\", nIndex);\n  }\n  \n  bool CWallet::GetKeyFromPool(CPubKey& result, bool fAllowReuse)\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      {\n          LOCK(cs_wallet);\n          ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex == -1)\n          {\n              if (fAllowReuse && vchDefaultKey.IsValid())\n              {\n                  result = vchDefaultKey;\n                  return true;\n              }\n              if (IsLocked()) return false;\n              result = GenerateNewKey();\n              return true;\n          }\n          KeepKey(nIndex);\n          result = keypool.vchPubKey;\n      }\n      return true;\n  }\n  \n  int64_t CWallet::GetOldestKeyPoolTime()\n  {\n      int64_t nIndex = 0;\n      CKeyPool keypool;\n      ReserveKeyFromKeyPool(nIndex, keypool);\n      if (nIndex == -1)\n          return GetTime();\n      ReturnKey(nIndex);\n      return keypool.nTime;\n  }\n  \n  std::map<CTxDestination, int64_t> CWallet::GetAddressBalances()\n  {\n      map<CTxDestination, int64_t> balances;\n  \n      {\n          LOCK(cs_wallet);\n          BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n          {\n              CWalletTx *pcoin = &walletEntry.second;\n  \n              if (!pcoin->IsFinal() || !pcoin->IsTrusted())\n                  continue;\n  \n              if ((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && pcoin->GetBlocksToMaturity() > 0)\n                  continue;\n  \n              int nDepth = pcoin->GetDepthInMainChain();\n              if (nDepth < (pcoin->IsFromMe() ? 0 : 1))\n                  continue;\n  \n              for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              {\n                  CTxDestination addr;\n                  if (!IsMine(pcoin->vout[i]))\n                      continue;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, addr))\n                      continue;\n  \n                  int64_t n = pcoin->IsSpent(i) ? 0 : pcoin->vout[i].nValue;\n  \n                  if (!balances.count(addr))\n                      balances[addr] = 0;\n                  balances[addr] += n;\n              }\n          }\n      }\n  \n      return balances;\n  }\n  \n  set< set<CTxDestination> > CWallet::GetAddressGroupings()\n  {\n      set< set<CTxDestination> > groupings;\n      set<CTxDestination> grouping;\n  \n      BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n      {\n          CWalletTx *pcoin = &walletEntry.second;\n  \n          if (pcoin->vin.size() > 0 && IsMine(pcoin->vin[0]))\n          {\n              // group all input addresses with each other\n              BOOST_FOREACH(CTxIn txin, pcoin->vin)\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(mapWallet[txin.prevout.hash].vout[txin.prevout.n].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n              }\n  \n              // group change with input addresses\n              BOOST_FOREACH(CTxOut txout, pcoin->vout)\n                  if (IsChange(txout))\n                  {\n                      CWalletTx tx = mapWallet[pcoin->vin[0].prevout.hash];\n                      CTxDestination txoutAddr;\n                      if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n                          continue;\n                      grouping.insert(txoutAddr);\n                  }\n              groupings.insert(grouping);\n              grouping.clear();\n          }\n  \n          // group lone addrs by themselves\n          for (unsigned int i = 0; i < pcoin->vout.size(); i++)\n              if (IsMine(pcoin->vout[i]))\n              {\n                  CTxDestination address;\n                  if(!ExtractDestination(pcoin->vout[i].scriptPubKey, address))\n                      continue;\n                  grouping.insert(address);\n                  groupings.insert(grouping);\n                  grouping.clear();\n              }\n      }\n  \n      set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n      map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n      BOOST_FOREACH(set<CTxDestination> grouping, groupings)\n      {\n          // make a set of all the groups hit by this new group\n          set< set<CTxDestination>* > hits;\n          map< CTxDestination, set<CTxDestination>* >::iterator it;\n          BOOST_FOREACH(CTxDestination address, grouping)\n              if ((it = setmap.find(address)) != setmap.end())\n                  hits.insert((*it).second);\n  \n          // merge all hit groups into a new single group and delete old groups\n          set<CTxDestination>* merged = new set<CTxDestination>(grouping);\n          BOOST_FOREACH(set<CTxDestination>* hit, hits)\n          {\n              merged->insert(hit->begin(), hit->end());\n              uniqueGroupings.erase(hit);\n              delete hit;\n          }\n          uniqueGroupings.insert(merged);\n  \n          // update setmap\n          BOOST_FOREACH(CTxDestination element, *merged)\n              setmap[element] = merged;\n      }\n  \n      set< set<CTxDestination> > ret;\n      BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n      {\n          ret.insert(*uniqueGrouping);\n          delete uniqueGrouping;\n      }\n  \n      return ret;\n  }\n  \n  \n  /* Checks for wallet vs. transaction index consistency;\n   * reports any spent state inconsistency found and\n   * (optionally) fixes the wallet according to the transaction index */\n  void CWallet::FixSpentCoins(int& nMismatchFound, int& nOrphansFound, int64& nBalanceInQuestion,\n    bool fCheckOnly) {\n      nMismatchFound = 0;\n      nOrphansFound = 0;\n      nBalanceInQuestion = 0;\n  \n      LOCK(cs_wallet);\n      vector<CWalletTx*> vCoins;\n      vCoins.reserve(mapWallet.size());\n      for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n          vCoins.push_back(&(*it).second);\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(CWalletTx* pcoin, vCoins) {\n          uint256 hash = pcoin->GetHash();\n          CTxIndex txindex;\n          uint n;\n  \n          if(!txdb.ReadTxIndex(hash, txindex) && !(pcoin->IsCoinBase() || pcoin->IsCoinStake()))\n              continue;\n  \n          for(n = 0; n < pcoin->vout.size(); n++) {\n              bool fUpdated = false;\n  \n              if(IsMine(pcoin->vout[n])) {\n                  if(pcoin->IsSpent(n) &&\n                    ((txindex.vSpent.size() <= n) || txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found lost coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkUnspent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  } else if(!pcoin->IsSpent(n) &&\n                    (txindex.vSpent.size() > n && !txindex.vSpent[n].IsNull())) {\n                      printf(\"FixSpentCoins() found spent coins %s %s[%d], %s\\n\",\n                        FormatMoney(pcoin->vout[n].nValue).c_str(), hash.ToString().c_str(), n,\n                          fCheckOnly? \"repair not attempted\" : \"repairing\");\n                      nMismatchFound++;\n                      nBalanceInQuestion += pcoin->vout[n].nValue;\n                      if(!fCheckOnly) {\n                          fUpdated = true;\n                          pcoin->MarkSpent(n);\n                          pcoin->WriteToDisk();\n                      }\n                  }\n  \n              }\n  \n              if(fUpdated)\n                NotifyTransactionChanged(this, hash, CT_UPDATED);\n          }\n  \n          if((pcoin->IsCoinBase() || pcoin->IsCoinStake()) && (pcoin->GetDepthInMainChain() < 0)) {\n             nOrphansFound++;\n             if(!fCheckOnly) {\n                 EraseFromWallet(hash);\n                 NotifyTransactionChanged(this, hash, CT_DELETED);\n             }\n             printf(\"FixSpentCoins() %s orphaned generation tx %s\\n\",\n               fCheckOnly ? \"found\" : \"removed\", hash.ToString().c_str());\n          }\n      }\n  }\n  \n  \n  // ppcoin: disable transaction (only for coinstake)\n  void CWallet::DisableTransaction(const CTransaction &tx)\n  {\n      if (!tx.IsCoinStake() || !IsFromMe(tx))\n          return; // only disconnecting coinstake requires marking input unspent\n  \n      LOCK(cs_wallet);\n      BOOST_FOREACH(const CTxIn& txin, tx.vin)\n      {\n          map<uint256, CWalletTx>::iterator mi = mapWallet.find(txin.prevout.hash);\n          if (mi != mapWallet.end())\n          {\n              CWalletTx& prev = (*mi).second;\n              if (txin.prevout.n < prev.vout.size() && IsMine(prev.vout[txin.prevout.n]))\n              {\n                  prev.MarkUnspent(txin.prevout.n);\n                  prev.WriteToDisk();\n              }\n          }\n      }\n  }\n  \n  CPubKey CReserveKey::GetReservedKey()\n  {\n      if (nIndex == -1)\n      {\n          CKeyPool keypool;\n          pwallet->ReserveKeyFromKeyPool(nIndex, keypool);\n          if (nIndex != -1)\n              vchPubKey = keypool.vchPubKey;\n          else\n          {\n              printf(\"CReserveKey::GetReservedKey(): Warning: Using default key instead of a new key, top up your keypool!\");\n              vchPubKey = pwallet->vchDefaultKey;\n          }\n      }\n      assert(vchPubKey.IsValid());\n      return vchPubKey;\n  }\n  \n  void CReserveKey::KeepKey()\n  {\n      if (nIndex != -1)\n          pwallet->KeepKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CReserveKey::ReturnKey()\n  {\n      if (nIndex != -1)\n          pwallet->ReturnKey(nIndex);\n      nIndex = -1;\n      vchPubKey = CPubKey();\n  }\n  \n  void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n  {\n      setAddress.clear();\n  \n      CWalletDB walletdb(strWalletFile);\n  \n      LOCK2(cs_main, cs_wallet);\n      BOOST_FOREACH(const int64_t& id, setKeyPool)\n      {\n          CKeyPool keypool;\n          if (!walletdb.ReadPool(id, keypool))\n              throw runtime_error(\"GetAllReserveKeyHashes() : read failed\");\n          assert(keypool.vchPubKey.IsValid());\n          CKeyID keyID = keypool.vchPubKey.GetID();\n          if (!HaveKey(keyID))\n              throw runtime_error(\"GetAllReserveKeyHashes() : unknown key in key pool\");\n          setAddress.insert(keyID);\n      }\n  }\n  \n  void CWallet::UpdatedTransaction(const uint256 &hashTx)\n  {\n      {\n          LOCK(cs_wallet);\n          // Only notify UI if this transaction is in this wallet\n          map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n          if (mi != mapWallet.end())\n              NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n      }\n  }\n  \n  void CWallet::GetKeyBirthTimes(std::map<CKeyID, int64_t> &mapKeyBirth) const {\n      mapKeyBirth.clear();\n  \n      // get birth times for keys with metadata\n      for (std::map<CKeyID, CKeyMetadata>::const_iterator it = mapKeyMetadata.begin(); it != mapKeyMetadata.end(); it++)\n          if (it->second.nCreateTime)\n              mapKeyBirth[it->first] = it->second.nCreateTime;\n  \n      // map in which we'll infer heights of other keys\n      CBlockIndex *pindexMax = FindBlockByHeight(std::max(0, nBestHeight - 144)); // the tip can be reorganised; use a 144-block safety margin\n      std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n      std::set<CKeyID> setKeys;\n      GetKeys(setKeys);\n      BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n          if (mapKeyBirth.count(keyid) == 0)\n              mapKeyFirstBlock[keyid] = pindexMax;\n      }\n      setKeys.clear();\n  \n      // if there are no such keys, we're done\n      if (mapKeyFirstBlock.empty())\n          return;\n  \n      // find first block that affects those keys, if there are any left\n      std::vector<CKeyID> vAffected;\n      for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); it++) {\n          // iterate over all wallet transactions...\n          const CWalletTx &wtx = (*it).second;\n          std::map<uint256, CBlockIndex*>::const_iterator blit = mapBlockIndex.find(wtx.hashBlock);\n          if (blit != mapBlockIndex.end() && blit->second->IsInMainChain()) {\n              // ... which are already in a block\n              int nHeight = blit->second->nHeight;\n              BOOST_FOREACH(const CTxOut &txout, wtx.vout) {\n                  // iterate over all their outputs\n                  ::ExtractAffectedKeys(*this, txout.scriptPubKey, vAffected);\n                  BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n                      // ... and all their affected keys\n                      std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                      if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n                          rit->second = blit->second;\n                  }\n                  vAffected.clear();\n              }\n          }\n      }\n  \n      // Extract block timestamps for those keys\n      for (std::map<CKeyID, CBlockIndex*>::const_iterator it = mapKeyFirstBlock.begin(); it != mapKeyFirstBlock.end(); it++)\n          mapKeyBirth[it->first] = it->second->nTime - 7200; // block times can be 2h off\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "InitError",
          "args": [
            "strErrors.str()"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "InitError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "202-206",
          "snippet": "bool static InitError(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::MODAL);\n    return false;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CClientUIInterface uiInterface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nbool static InitError(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::MODAL);\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strErrors.str",
          "args": [],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "789-792",
          "snippet": "std::string str() const\n    {\n        return (std::string(begin(), end()));\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  std::string str() const\n      {\n          return (std::string(begin(), end()));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Done loading\\n\""
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiInterface.InitMessage",
          "args": [
            "_(\"Done loading\")"
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "InitMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "82-89",
          "snippet": "static void InitMessage(const std::string &message)\n{\n    if(splashref)\n    {\n        splashref->showMessage(QString::fromStdString(message), Qt::AlignBottom|Qt::AlignHCenter, QColor(255,255,255));\n        QApplication::instance()->processEvents();\n    }\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static QSplashScreen *splashref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic QSplashScreen *splashref;\n\nstatic void InitMessage(const std::string &message)\n{\n    if(splashref)\n    {\n        splashref->showMessage(QString::fromStdString(message), Qt::AlignBottom|Qt::AlignHCenter, QColor(255,255,255));\n        QApplication::instance()->processEvents();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Done loading\""
          ],
          "line": 925
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewThread",
          "args": [
            "ThreadRPCServer",
            "NULL"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "NewThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1350-1360",
          "snippet": "bool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"mapAddressBook.size() = %\"PRIszu\"\\n\"",
            "pwalletMain->mapAddressBook.size()"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->mapAddressBook.size",
          "args": [],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RandAddSeedPerfmon",
          "args": [],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "RandAddSeedPerfmon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "146-171",
          "snippet": "void RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckDiskSpace",
          "args": [],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Loaded %i addresses from peers.dat  %\"PRId64\"ms\\n\"",
            "addrman.size()",
            "GetTimeMillis() - nStart"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTimeMillis",
          "args": [],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Invalid or missing peers.dat; recreating\\n\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "adb.Read",
          "args": [
            "addrman"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "CAddrDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "540-591",
          "snippet": "bool CAddrDB::Read(CAddrMan& addr)\n{\n    // open input file, and associate with CAutoFile\n    FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n    CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n    if (!filein)\n        return error(\"CAddrman::Read() : open failed\");\n\n    // use file size to size memory buffer\n    int fileSize = boost::filesystem::file_size(pathAddr);\n    int dataSize = fileSize - sizeof(uint256);\n    // Don't try to resize to a negative number if file is small\n    if ( dataSize < 0 ) dataSize = 0;\n    vector<unsigned char> vchData;\n    vchData.resize(dataSize);\n    uint256 hashIn;\n\n    // read data and checksum from file\n    try {\n        filein.read((char *)&vchData[0], dataSize);\n        filein >> hashIn;\n    }\n    catch (std::exception &e) {\n        return error(\"CAddrman::Read() 2 : I/O error or stream data corrupted\");\n    }\n    filein.fclose();\n\n    CDataStream ssPeers(vchData, SER_DISK, CLIENT_VERSION);\n\n    // verify stored checksum matches input data\n    uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n    if (hashIn != hashTmp)\n        return error(\"CAddrman::Read() : checksum mismatch; data corrupted\");\n\n    unsigned char pchMsgTmp[4];\n    try {\n        // de-serialize file header (pchMessageStart magic number) and\n        ssPeers >> FLATDATA(pchMsgTmp);\n\n        // verify the network matches ours\n        if (memcmp(pchMsgTmp, pchMessageStart, sizeof(pchMsgTmp)))\n            return error(\"CAddrman::Read() : invalid network magic number\");\n\n        // de-serialize address data into one CAddrMan object\n        ssPeers >> addr;\n    }\n    catch (std::exception &e) {\n        return error(\"CAddrman::Read() : I/O error or stream data corrupted\");\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCAddrDB {\n  bool CAddrDB::Read(CAddrMan& addr)\n  {\n      // open input file, and associate with CAutoFile\n      FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n      CAutoFile filein = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n      if (!filein)\n          return error(\"CAddrman::Read() : open failed\");\n  \n      // use file size to size memory buffer\n      int fileSize = boost::filesystem::file_size(pathAddr);\n      int dataSize = fileSize - sizeof(uint256);\n      // Don't try to resize to a negative number if file is small\n      if ( dataSize < 0 ) dataSize = 0;\n      vector<unsigned char> vchData;\n      vchData.resize(dataSize);\n      uint256 hashIn;\n  \n      // read data and checksum from file\n      try {\n          filein.read((char *)&vchData[0], dataSize);\n          filein >> hashIn;\n      }\n      catch (std::exception &e) {\n          return error(\"CAddrman::Read() 2 : I/O error or stream data corrupted\");\n      }\n      filein.fclose();\n  \n      CDataStream ssPeers(vchData, SER_DISK, CLIENT_VERSION);\n  \n      // verify stored checksum matches input data\n      uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n      if (hashIn != hashTmp)\n          return error(\"CAddrman::Read() : checksum mismatch; data corrupted\");\n  \n      unsigned char pchMsgTmp[4];\n      try {\n          // de-serialize file header (pchMessageStart magic number) and\n          ssPeers >> FLATDATA(pchMsgTmp);\n  \n          // verify the network matches ours\n          if (memcmp(pchMsgTmp, pchMessageStart, sizeof(pchMsgTmp)))\n              return error(\"CAddrman::Read() : invalid network magic number\");\n  \n          // de-serialize address data into one CAddrMan object\n          ssPeers >> addr;\n      }\n      catch (std::exception &e) {\n          return error(\"CAddrman::Read() : I/O error or stream data corrupted\");\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Loading addresses...\\n\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RenameOver",
          "args": [
            "pathBootstrap",
            "pathBootstrapOld"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "RenameOver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1130-1139",
          "snippet": "bool RenameOver(boost::filesystem::path src, boost::filesystem::path dest)\n{\n#ifdef WIN32\n    return MoveFileExA(src.string().c_str(), dest.string().c_str(),\n                      MOVEFILE_REPLACE_EXISTING);\n#else\n    int rc = std::rename(src.string().c_str(), dest.string().c_str());\n    return (rc == 0);\n#endif /* WIN32 */\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool RenameOver(boost::filesystem::path src, boost::filesystem::path dest)\n{\n#ifdef WIN32\n    return MoveFileExA(src.string().c_str(), dest.string().c_str(),\n                      MOVEFILE_REPLACE_EXISTING);\n#else\n    int rc = std::rename(src.string().c_str(), dest.string().c_str());\n    return (rc == 0);\n#endif /* WIN32 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "LoadExternalBlockFile",
          "args": [
            "file"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "LoadExternalBlockFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2888-2946",
          "snippet": "bool LoadExternalBlockFile(FILE* fileIn)\n{\n    int64_t nStart = GetTimeMillis();\n\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n    return nLoaded > 0;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_main;",
            "unsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nunsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };\n\nbool LoadExternalBlockFile(FILE* fileIn)\n{\n    int64_t nStart = GetTimeMillis();\n\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n    return nLoaded > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pathBootstrap.string().c_str()",
            "\"rb\""
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathBootstrap.string",
          "args": [],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathBootstrap.string",
          "args": [],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::exists",
          "args": [
            "pathBootstrap"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "strFile.c_str()",
            "\"rb\""
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strFile.c_str",
          "args": [],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapArgs.count",
          "args": [
            "\"-loadblock\""
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->ScanForWalletTransactions",
          "args": [
            "pindexRescan",
            "true"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "ScanForWalletTransactions",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "838-865",
          "snippet": "int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n{\n    int ret = 0;\n\n    CBlockIndex* pindex = pindexStart;\n    {\n        LOCK(cs_wallet);\n        while (pindex)\n        {\n            // no need to read and scan block, if block was created before\n            // our wallet birthday (as adjusted for block time variability)\n            if (nTimeFirstKey && (pindex->nTime < (nTimeFirstKey - 7200))) {\n                pindex = pindex->pnext;\n                continue;\n            }\n\n            CBlock block;\n            block.ReadFromDisk(pindex, true);\n            BOOST_FOREACH(CTransaction& tx, block.vtx)\n            {\n                if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                    ret++;\n            }\n            pindex = pindex->pnext;\n        }\n    }\n    return ret;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n  {\n      int ret = 0;\n  \n      CBlockIndex* pindex = pindexStart;\n      {\n          LOCK(cs_wallet);\n          while (pindex)\n          {\n              // no need to read and scan block, if block was created before\n              // our wallet birthday (as adjusted for block time variability)\n              if (nTimeFirstKey && (pindex->nTime < (nTimeFirstKey - 7200))) {\n                  pindex = pindex->pnext;\n                  continue;\n              }\n  \n              CBlock block;\n              block.ReadFromDisk(pindex, true);\n              BOOST_FOREACH(CTransaction& tx, block.vtx)\n              {\n                  if (AddToWalletIfInvolvingMe(tx, &block, fUpdate))\n                      ret++;\n              }\n              pindex = pindex->pnext;\n          }\n      }\n      return ret;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Rescanning last %i blocks (from block %i)...\\n\"",
            "pindexBest->nHeight - pindexRescan->nHeight",
            "pindexRescan->nHeight"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locator.GetBlockIndex",
          "args": [],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walletdb.ReadBestBlock",
          "args": [
            "locator"
          ],
          "line": 849
        },
        "resolved": true,
        "details": {
          "function_name": "ReadBestBlock",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "131-134",
          "snippet": "bool ReadBestBlock(CBlockLocator& locator)\n    {\n        return Read(std::string(\"bestblock\"), locator);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool ReadBestBlock(CBlockLocator& locator)\n      {\n          return Read(std::string(\"bestblock\"), locator);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-rescan\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RegisterWallet",
          "args": [
            "pwalletMain"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "RegisterWallet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "104-110",
          "snippet": "void RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_setpwalletRegistered;",
            "set<CWallet*> setpwalletRegistered;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->SetAddressBookName",
          "args": [
            "pwalletMain->vchDefaultKey.GetID()",
            "\"\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->vchDefaultKey.GetID",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->SetDefaultKey",
          "args": [
            "newDefaultKey"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetKeyFromPool",
          "args": [
            "newDefaultKey",
            "false"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->SetMaxVersion",
          "args": [
            "nMaxVersion"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "SetMaxVersion",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "235-244",
          "snippet": "bool CWallet::SetMaxVersion(int nVersion)\n{\n    // cannot downgrade below current version\n    if (nWalletVersion > nVersion)\n        return false;\n\n    nWalletMaxVersion = nVersion;\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::SetMaxVersion(int nVersion)\n  {\n      // cannot downgrade below current version\n      if (nWalletVersion > nVersion)\n          return false;\n  \n      nWalletMaxVersion = nVersion;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetVersion",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "GetVersion",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "312-312",
          "snippet": "int GetVersion() { return nWalletVersion; }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  int GetVersion() { return nWalletVersion; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->SetMinVersion",
          "args": [
            "FEATURE_LATEST"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-upgradewallet\"",
            "0"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-upgradewallet\"",
            "fFirstRun"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "GetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "569-578",
          "snippet": "bool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nbool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiInterface.ThreadSafeMessageBox",
          "args": [
            "msg",
            "_(\"Halcyon\")",
            "CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadSafeMessageBox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "38-56",
          "snippet": "static void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BitcoinGUI *guiref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic BitcoinGUI *guiref;\n\nstatic void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->LoadWallet",
          "args": [
            "fFirstRun"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "LoadWallet",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "433-531",
          "snippet": "DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n{\n    pwallet->vchDefaultKey = CPubKey();\n    CWalletScanState wss;\n    bool fNoncriticalErrors = false;\n    DBErrors result = DB_LOAD_OK;\n\n    try {\n        LOCK(pwallet->cs_wallet);\n        int nMinVersion = 0;\n        if (Read((string)\"minversion\", nMinVersion))\n        {\n            if (nMinVersion > CLIENT_VERSION)\n                return DB_TOO_NEW;\n            pwallet->LoadMinVersion(nMinVersion);\n        }\n\n        // Get cursor\n        Dbc* pcursor = GetCursor();\n        if (!pcursor)\n        {\n            printf(\"Error getting wallet database cursor\\n\");\n            return DB_CORRUPT;\n        }\n\n        while (true)\n        {\n            // Read next record\n            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n            if (ret == DB_NOTFOUND)\n                break;\n            else if (ret != 0)\n            {\n                printf(\"Error reading next record from wallet database\\n\");\n                return DB_CORRUPT;\n            }\n\n            // Try to be tolerant of single corrupt records:\n            string strType, strErr;\n            if (!ReadKeyValue(pwallet, ssKey, ssValue, wss, strType, strErr))\n            {\n                // losing keys is considered a catastrophic error, anything else\n                // we assume the user can live with:\n                if (IsKeyType(strType))\n                    result = DB_CORRUPT;\n                else\n                {\n                    // Leave other errors alone, if we try to fix them we might make things worse.\n                    fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n                    if (strType == \"tx\")\n                        // Rescan if there is a bad transaction record:\n                        SoftSetBoolArg(\"-rescan\", true);\n                }\n            }\n            if (!strErr.empty())\n                printf(\"%s\\n\", strErr.c_str());\n        }\n        pcursor->close();\n    }\n    catch (...)\n    {\n        result = DB_CORRUPT;\n    }\n\n    if (fNoncriticalErrors && result == DB_LOAD_OK)\n        result = DB_NONCRITICAL_ERROR;\n\n    // Any wallet corruption at all: skip any rewriting or\n    // upgrading, we don't want to make it worse.\n    if (result != DB_LOAD_OK)\n        return result;\n\n    printf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n\n    printf(\"Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total\\n\",\n           wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys);\n\n    // nTimeFirstKey is only reliable if all keys have metadata\n    if ((wss.nKeys + wss.nCKeys) != wss.nKeyMeta)\n        pwallet->nTimeFirstKey = 1; // 0 would be considered 'no value'\n\n\n    BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n        WriteTx(hash, pwallet->mapWallet[hash]);\n\n    // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n    if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n        return DB_NEED_REWRITE;\n\n    if (wss.nFileVersion < CLIENT_VERSION) // Update\n        WriteVersion(CLIENT_VERSION);\n\n    if (wss.fAnyUnordered)\n        result = ReorderTransactions(pwallet);\n\n    return result;\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n  {\n      pwallet->vchDefaultKey = CPubKey();\n      CWalletScanState wss;\n      bool fNoncriticalErrors = false;\n      DBErrors result = DB_LOAD_OK;\n  \n      try {\n          LOCK(pwallet->cs_wallet);\n          int nMinVersion = 0;\n          if (Read((string)\"minversion\", nMinVersion))\n          {\n              if (nMinVersion > CLIENT_VERSION)\n                  return DB_TOO_NEW;\n              pwallet->LoadMinVersion(nMinVersion);\n          }\n  \n          // Get cursor\n          Dbc* pcursor = GetCursor();\n          if (!pcursor)\n          {\n              printf(\"Error getting wallet database cursor\\n\");\n              return DB_CORRUPT;\n          }\n  \n          while (true)\n          {\n              // Read next record\n              CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n              CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n              int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n              if (ret == DB_NOTFOUND)\n                  break;\n              else if (ret != 0)\n              {\n                  printf(\"Error reading next record from wallet database\\n\");\n                  return DB_CORRUPT;\n              }\n  \n              // Try to be tolerant of single corrupt records:\n              string strType, strErr;\n              if (!ReadKeyValue(pwallet, ssKey, ssValue, wss, strType, strErr))\n              {\n                  // losing keys is considered a catastrophic error, anything else\n                  // we assume the user can live with:\n                  if (IsKeyType(strType))\n                      result = DB_CORRUPT;\n                  else\n                  {\n                      // Leave other errors alone, if we try to fix them we might make things worse.\n                      fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n                      if (strType == \"tx\")\n                          // Rescan if there is a bad transaction record:\n                          SoftSetBoolArg(\"-rescan\", true);\n                  }\n              }\n              if (!strErr.empty())\n                  printf(\"%s\\n\", strErr.c_str());\n          }\n          pcursor->close();\n      }\n      catch (...)\n      {\n          result = DB_CORRUPT;\n      }\n  \n      if (fNoncriticalErrors && result == DB_LOAD_OK)\n          result = DB_NONCRITICAL_ERROR;\n  \n      // Any wallet corruption at all: skip any rewriting or\n      // upgrading, we don't want to make it worse.\n      if (result != DB_LOAD_OK)\n          return result;\n  \n      printf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n  \n      printf(\"Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total\\n\",\n             wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys);\n  \n      // nTimeFirstKey is only reliable if all keys have metadata\n      if ((wss.nKeys + wss.nCKeys) != wss.nKeyMeta)\n          pwallet->nTimeFirstKey = 1; // 0 would be considered 'no value'\n  \n  \n      BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n          WriteTx(hash, pwallet->mapWallet[hash]);\n  \n      // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n      if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n          return DB_NEED_REWRITE;\n  \n      if (wss.nFileVersion < CLIENT_VERSION) // Update\n          WriteVersion(CLIENT_VERSION);\n  \n      if (wss.fAnyUnordered)\n          result = ReorderTransactions(pwallet);\n  \n      return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Loading wallet...\\n\""
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strMatch.c_str",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.print",
          "args": [],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "print",
          "container": "COrphan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
          "lines": "35-41",
          "snippet": "void print() const\n    {\n        printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n               ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n        BOOST_FOREACH(uint256 hash, setDependsOn)\n            printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n    }",
          "includes": [
            "#include \"kernel.h\"",
            "#include \"miner.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nCOrphan {\n  void print() const\n      {\n          printf(\"COrphan(hash=%s, dPriority=%.1f, dFeePerKb=%.1f)\\n\",\n                 ptx->GetHash().ToString().substr(0,10).c_str(), dPriority, dFeePerKb);\n          BOOST_FOREACH(uint256 hash, setDependsOn)\n              printf(\"   setDependsOn %s\\n\", hash.ToString().substr(0,10).c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.BuildMerkleTree",
          "args": [],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "BuildMerkleTree",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1020-1037",
          "snippet": "uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 BuildMerkleTree() const\n      {\n          vMerkleTree.clear();\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              vMerkleTree.push_back(tx.GetHash());\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              for (int i = 0; i < nSize; i += 2)\n              {\n                  int i2 = std::min(i+1, nSize-1);\n                  vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                             BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n              }\n              j += nSize;\n          }\n          return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindex"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "601-626",
          "snippet": "bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n      {\n          CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n  \n          // Read transaction\n          if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n              return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n  \n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          // Return file pointer\n          if (pfileRet)\n          {\n              if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                  return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n              *pfileRet = filein.release();\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "hash.ToString().c_str()",
            "strMatch.c_str()",
            "strMatch.size()"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strMatch.c_str",
          "args": [],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.begin",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintBlockTree",
          "args": [],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "PrintBlockTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2814-2886",
          "snippet": "void PrintBlockTree()\n{\n    // pre-compute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %08x  %s  mint %7s  tx %\"PRIszu\"\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().c_str(),\n            block.nBits,\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            FormatMoney(pindex->nMint).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main time-chain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexGenesisBlock = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\n\nvoid PrintBlockTree()\n{\n    // pre-compute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %08x  %s  mint %7s  tx %\"PRIszu\"\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().c_str(),\n            block.nBits,\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            FormatMoney(pindex->nMint).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main time-chain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printblocktree\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printblockindex\""
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutdown requested. Exiting.\\n\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LoadBlockIndex",
          "args": [],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "LoadBlockIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "327-571",
          "snippet": "bool CTxDB::LoadBlockIndex()\n{\n    if (mapBlockIndex.size() > 0) {\n        // Already loaded once in this session. It can happen during migration\n        // from BDB.\n        return true;\n    }\n    // The block index is an in-memory structure that maps hashes to on-disk\n    // locations where the contents of the block can be found. Here, we scan it\n    // out of the DB and into mapBlockIndex.\n    leveldb::Iterator *iterator = pdb->NewIterator(leveldb::ReadOptions());\n    // Seek to start key.\n    CDataStream ssStartKey(SER_DISK, CLIENT_VERSION);\n    ssStartKey << make_pair(string(\"blockindex\"), uint256(0));\n    iterator->Seek(ssStartKey.str());\n    // Now read each entry.\n    while (iterator->Valid())\n    {\n        // Unpack keys and values.\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.write(iterator->key().data(), iterator->key().size());\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.write(iterator->value().data(), iterator->value().size());\n        string strType;\n        ssKey >> strType;\n        // Did we reach the end of the data to read?\n        if (fRequestShutdown || strType != \"blockindex\")\n            break;\n        CDiskBlockIndex diskindex;\n        ssValue >> diskindex;\n\n        uint256 blockHash = diskindex.GetBlockHash();\n\n        // Construct block index object\n        CBlockIndex* pindexNew    = InsertBlockIndex(blockHash);\n        pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n        pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n        pindexNew->nFile          = diskindex.nFile;\n        pindexNew->nBlockPos      = diskindex.nBlockPos;\n        pindexNew->nHeight        = diskindex.nHeight;\n        pindexNew->nMint          = diskindex.nMint;\n        pindexNew->nMoneySupply   = diskindex.nMoneySupply;\n        pindexNew->nFlags         = diskindex.nFlags;\n        pindexNew->nStakeModifier = diskindex.nStakeModifier;\n        pindexNew->prevoutStake   = diskindex.prevoutStake;\n        pindexNew->nStakeTime     = diskindex.nStakeTime;\n        pindexNew->hashProofOfStake = diskindex.hashProofOfStake;\n        pindexNew->nVersion       = diskindex.nVersion;\n        pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n        pindexNew->nTime          = diskindex.nTime;\n        pindexNew->nBits          = diskindex.nBits;\n        pindexNew->nNonce         = diskindex.nNonce;\n\n        // Watch for genesis block\n        if (pindexGenesisBlock == NULL && blockHash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n            pindexGenesisBlock = pindexNew;\n\n        if (!pindexNew->CheckIndex()) {\n            delete iterator;\n            return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n        }\n\n        // NovaCoin: build setStakeSeen\n        if (pindexNew->IsProofOfStake())\n            setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n\n        iterator->Next();\n    }\n    delete iterator;\n\n    if (fRequestShutdown)\n        return true;\n\n    // Calculate nChainTrust\n    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n    vSortedByHeight.reserve(mapBlockIndex.size());\n    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n    {\n        CBlockIndex* pindex = item.second;\n        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n    }\n    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n    {\n        CBlockIndex* pindex = item.second;\n        pindex->nChainTrust = (pindex->pprev ? pindex->pprev->nChainTrust : 0) + pindex->GetBlockTrust();\n        // NovaCoin: calculate stake modifier checksum\n        pindex->nStakeModifierChecksum = GetStakeModifierChecksum(pindex);\n        if (!CheckStakeModifierCheckpoints(pindex->nHeight, pindex->nStakeModifierChecksum))\n            return error(\"CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindex->nHeight, pindex->nStakeModifier);\n    }\n\n    // Load hashBestChain pointer to end of best chain\n    if (!ReadHashBestChain(hashBestChain))\n    {\n        if (pindexGenesisBlock == NULL)\n            return true;\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n    }\n    if (!mapBlockIndex.count(hashBestChain))\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n    pindexBest = mapBlockIndex[hashBestChain];\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexBest->nChainTrust;\n\n    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, CBigNum(nBestChainTrust).ToString().c_str(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    // NovaCoin: load hashSyncCheckpoint\n    if (!ReadSyncCheckpoint(Checkpoints::hashSyncCheckpoint))\n        return error(\"CTxDB::LoadBlockIndex() : hashSyncCheckpoint not loaded\");\n    printf(\"LoadBlockIndex(): synchronized checkpoint %s\\n\", Checkpoints::hashSyncCheckpoint.ToString().c_str());\n\n    // Load bnBestInvalidTrust, OK if it doesn't exist\n    CBigNum bnBestInvalidTrust;\n    ReadBestInvalidTrust(bnBestInvalidTrust);\n    nBestInvalidTrust = bnBestInvalidTrust.getuint256();\n\n    // Verify blocks in the best chain\n    int nCheckLevel = GetArg(\"-checklevel\", 1);\n    int nCheckDepth = GetArg( \"-checkblocks\", 500);\n    if (nCheckDepth == 0)\n        nCheckDepth = 1000000000; // suffices until the year 19000\n    if (nCheckDepth > nBestHeight)\n        nCheckDepth = nBestHeight;\n    printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n    CBlockIndex* pindexFork = NULL;\n    map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n    {\n        if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n            break;\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        // check level 1: verify block validity\n        if((nCheckLevel > 0) && !block.CheckBlock()) {\n            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n            pindexFork = pindex->pprev;\n        }\n        // check level 2: verify transaction index validity\n        if (nCheckLevel>1)\n        {\n            pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n            mapBlockPos[pos] = pindex;\n            BOOST_FOREACH(const CTransaction &tx, block.vtx)\n            {\n                uint256 hashTx = tx.GetHash();\n                CTxIndex txindex;\n                if (ReadTxIndex(hashTx, txindex))\n                {\n                    // check level 3: checker transaction hashes\n                    if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                    {\n                        // either an error or a duplicate transaction\n                        CTransaction txFound;\n                        if (!txFound.ReadFromDisk(txindex.pos))\n                        {\n                            printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n                            pindexFork = pindex->pprev;\n                        }\n                        else\n                            if (txFound.GetHash() != hashTx) // not a duplicate tx\n                            {\n                                printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n                                pindexFork = pindex->pprev;\n                            }\n                    }\n                    // check level 4: check whether spent txouts were spent within the main chain\n                    unsigned int nOutput = 0;\n                    if (nCheckLevel>3)\n                    {\n                        BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n                        {\n                            if (!txpos.IsNull())\n                            {\n                                pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n                                if (!mapBlockPos.count(posFind))\n                                {\n                                    printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                    pindexFork = pindex->pprev;\n                                }\n                                // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                if (nCheckLevel>5)\n                                {\n                                    CTransaction txSpend;\n                                    if (!txSpend.ReadFromDisk(txpos))\n                                    {\n                                        printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else if (!txSpend.CheckTransaction())\n                                    {\n                                        printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else\n                                    {\n                                        bool fFound = false;\n                                        BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n                                            if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n                                                fFound = true;\n                                        if (!fFound)\n                                        {\n                                            printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n                                            pindexFork = pindex->pprev;\n                                        }\n                                    }\n                                }\n                            }\n                            nOutput++;\n                        }\n                    }\n                }\n                // check level 5: check whether all prevouts are marked spent\n                if (nCheckLevel>4)\n                {\n                     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n                     {\n                          CTxIndex txindex;\n                          if (ReadTxIndex(txin.prevout.hash, txindex))\n                              if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n                              {\n                                  printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n                                  pindexFork = pindex->pprev;\n                              }\n                     }\n                }\n            }\n        }\n    }\n    if (pindexFork && !fRequestShutdown)\n    {\n        // Reorg back to the fork\n        printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n        CBlock block;\n        if (!block.ReadFromDisk(pindexFork))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        CTxDB txdb;\n        block.SetBestChain(txdb, pindexFork);\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [
            "leveldb::DB *txdb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nleveldb::DB *txdb;\n\nCTxDB {\n  bool CTxDB::LoadBlockIndex()\n  {\n      if (mapBlockIndex.size() > 0) {\n          // Already loaded once in this session. It can happen during migration\n          // from BDB.\n          return true;\n      }\n      // The block index is an in-memory structure that maps hashes to on-disk\n      // locations where the contents of the block can be found. Here, we scan it\n      // out of the DB and into mapBlockIndex.\n      leveldb::Iterator *iterator = pdb->NewIterator(leveldb::ReadOptions());\n      // Seek to start key.\n      CDataStream ssStartKey(SER_DISK, CLIENT_VERSION);\n      ssStartKey << make_pair(string(\"blockindex\"), uint256(0));\n      iterator->Seek(ssStartKey.str());\n      // Now read each entry.\n      while (iterator->Valid())\n      {\n          // Unpack keys and values.\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.write(iterator->key().data(), iterator->key().size());\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.write(iterator->value().data(), iterator->value().size());\n          string strType;\n          ssKey >> strType;\n          // Did we reach the end of the data to read?\n          if (fRequestShutdown || strType != \"blockindex\")\n              break;\n          CDiskBlockIndex diskindex;\n          ssValue >> diskindex;\n  \n          uint256 blockHash = diskindex.GetBlockHash();\n  \n          // Construct block index object\n          CBlockIndex* pindexNew    = InsertBlockIndex(blockHash);\n          pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n          pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n          pindexNew->nFile          = diskindex.nFile;\n          pindexNew->nBlockPos      = diskindex.nBlockPos;\n          pindexNew->nHeight        = diskindex.nHeight;\n          pindexNew->nMint          = diskindex.nMint;\n          pindexNew->nMoneySupply   = diskindex.nMoneySupply;\n          pindexNew->nFlags         = diskindex.nFlags;\n          pindexNew->nStakeModifier = diskindex.nStakeModifier;\n          pindexNew->prevoutStake   = diskindex.prevoutStake;\n          pindexNew->nStakeTime     = diskindex.nStakeTime;\n          pindexNew->hashProofOfStake = diskindex.hashProofOfStake;\n          pindexNew->nVersion       = diskindex.nVersion;\n          pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n          pindexNew->nTime          = diskindex.nTime;\n          pindexNew->nBits          = diskindex.nBits;\n          pindexNew->nNonce         = diskindex.nNonce;\n  \n          // Watch for genesis block\n          if (pindexGenesisBlock == NULL && blockHash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n              pindexGenesisBlock = pindexNew;\n  \n          if (!pindexNew->CheckIndex()) {\n              delete iterator;\n              return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n          }\n  \n          // NovaCoin: build setStakeSeen\n          if (pindexNew->IsProofOfStake())\n              setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n  \n          iterator->Next();\n      }\n      delete iterator;\n  \n      if (fRequestShutdown)\n          return true;\n  \n      // Calculate nChainTrust\n      vector<pair<int, CBlockIndex*> > vSortedByHeight;\n      vSortedByHeight.reserve(mapBlockIndex.size());\n      BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n      {\n          CBlockIndex* pindex = item.second;\n          vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n      }\n      sort(vSortedByHeight.begin(), vSortedByHeight.end());\n      BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n      {\n          CBlockIndex* pindex = item.second;\n          pindex->nChainTrust = (pindex->pprev ? pindex->pprev->nChainTrust : 0) + pindex->GetBlockTrust();\n          // NovaCoin: calculate stake modifier checksum\n          pindex->nStakeModifierChecksum = GetStakeModifierChecksum(pindex);\n          if (!CheckStakeModifierCheckpoints(pindex->nHeight, pindex->nStakeModifierChecksum))\n              return error(\"CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindex->nHeight, pindex->nStakeModifier);\n      }\n  \n      // Load hashBestChain pointer to end of best chain\n      if (!ReadHashBestChain(hashBestChain))\n      {\n          if (pindexGenesisBlock == NULL)\n              return true;\n          return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n      }\n      if (!mapBlockIndex.count(hashBestChain))\n          return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n      pindexBest = mapBlockIndex[hashBestChain];\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexBest->nChainTrust;\n  \n      printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, CBigNum(nBestChainTrust).ToString().c_str(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      // NovaCoin: load hashSyncCheckpoint\n      if (!ReadSyncCheckpoint(Checkpoints::hashSyncCheckpoint))\n          return error(\"CTxDB::LoadBlockIndex() : hashSyncCheckpoint not loaded\");\n      printf(\"LoadBlockIndex(): synchronized checkpoint %s\\n\", Checkpoints::hashSyncCheckpoint.ToString().c_str());\n  \n      // Load bnBestInvalidTrust, OK if it doesn't exist\n      CBigNum bnBestInvalidTrust;\n      ReadBestInvalidTrust(bnBestInvalidTrust);\n      nBestInvalidTrust = bnBestInvalidTrust.getuint256();\n  \n      // Verify blocks in the best chain\n      int nCheckLevel = GetArg(\"-checklevel\", 1);\n      int nCheckDepth = GetArg( \"-checkblocks\", 500);\n      if (nCheckDepth == 0)\n          nCheckDepth = 1000000000; // suffices until the year 19000\n      if (nCheckDepth > nBestHeight)\n          nCheckDepth = nBestHeight;\n      printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n      CBlockIndex* pindexFork = NULL;\n      map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n      for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n      {\n          if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n              break;\n          CBlock block;\n          if (!block.ReadFromDisk(pindex))\n              return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n          // check level 1: verify block validity\n          if((nCheckLevel > 0) && !block.CheckBlock()) {\n              printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n              pindexFork = pindex->pprev;\n          }\n          // check level 2: verify transaction index validity\n          if (nCheckLevel>1)\n          {\n              pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n              mapBlockPos[pos] = pindex;\n              BOOST_FOREACH(const CTransaction &tx, block.vtx)\n              {\n                  uint256 hashTx = tx.GetHash();\n                  CTxIndex txindex;\n                  if (ReadTxIndex(hashTx, txindex))\n                  {\n                      // check level 3: checker transaction hashes\n                      if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                      {\n                          // either an error or a duplicate transaction\n                          CTransaction txFound;\n                          if (!txFound.ReadFromDisk(txindex.pos))\n                          {\n                              printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n                              pindexFork = pindex->pprev;\n                          }\n                          else\n                              if (txFound.GetHash() != hashTx) // not a duplicate tx\n                              {\n                                  printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n                                  pindexFork = pindex->pprev;\n                              }\n                      }\n                      // check level 4: check whether spent txouts were spent within the main chain\n                      unsigned int nOutput = 0;\n                      if (nCheckLevel>3)\n                      {\n                          BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n                          {\n                              if (!txpos.IsNull())\n                              {\n                                  pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n                                  if (!mapBlockPos.count(posFind))\n                                  {\n                                      printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                      pindexFork = pindex->pprev;\n                                  }\n                                  // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                  if (nCheckLevel>5)\n                                  {\n                                      CTransaction txSpend;\n                                      if (!txSpend.ReadFromDisk(txpos))\n                                      {\n                                          printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n                                          pindexFork = pindex->pprev;\n                                      }\n                                      else if (!txSpend.CheckTransaction())\n                                      {\n                                          printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n                                          pindexFork = pindex->pprev;\n                                      }\n                                      else\n                                      {\n                                          bool fFound = false;\n                                          BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n                                              if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n                                                  fFound = true;\n                                          if (!fFound)\n                                          {\n                                              printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n                                              pindexFork = pindex->pprev;\n                                          }\n                                      }\n                                  }\n                              }\n                              nOutput++;\n                          }\n                      }\n                  }\n                  // check level 5: check whether all prevouts are marked spent\n                  if (nCheckLevel>4)\n                  {\n                       BOOST_FOREACH(const CTxIn &txin, tx.vin)\n                       {\n                            CTxIndex txindex;\n                            if (ReadTxIndex(txin.prevout.hash, txindex))\n                                if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n                                {\n                                    printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n                                    pindexFork = pindex->pprev;\n                                }\n                       }\n                  }\n              }\n          }\n      }\n      if (pindexFork && !fRequestShutdown)\n      {\n          // Reorg back to the fork\n          printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n          CBlock block;\n          if (!block.ReadFromDisk(pindexFork))\n              return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n          CTxDB txdb;\n          block.SetBestChain(txdb, pindexFork);\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Loading block index...\\n\""
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-loadblockindextest\""
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDataDir.c_str",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitdb.Open",
          "args": [
            "GetDataDir()"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "61-113",
          "snippet": "bool CDBEnv::Open(boost::filesystem::path pathEnv_)\n{\n    if (fDbEnvInit)\n        return true;\n\n    if (fShutdown)\n        return false;\n\n    pathEnv = pathEnv_;\n    filesystem::path pathDataDir = pathEnv;\n    strPath = pathDataDir.string();\n    filesystem::path pathLogDir = pathDataDir / \"database\";\n    filesystem::create_directory(pathLogDir);\n    filesystem::path pathErrorFile = pathDataDir / \"db.log\";\n    printf(\"dbenv.open LogDir=%s ErrorFile=%s\\n\", pathLogDir.string().c_str(), pathErrorFile.string().c_str());\n\n    unsigned int nEnvFlags = 0;\n    if (GetBoolArg(\"-privdb\", true))\n        nEnvFlags |= DB_PRIVATE;\n\n    int nDbCache = GetArg(\"-dbcache\", 25);\n    dbenv.set_lg_dir(pathLogDir.string().c_str());\n    dbenv.set_cachesize(nDbCache / 1024, (nDbCache % 1024)*1048576, 1);\n    dbenv.set_lg_bsize(1048576);\n    dbenv.set_lg_max(10485760);\n\n    // Bugfix: Bump lk_max_locks default to 537000, to safely handle reorgs with up to 5 blocks reversed\n    // dbenv.set_lk_max_locks(10000);\n    dbenv.set_lk_max_locks(537000);\n\n    dbenv.set_lk_max_objects(10000);\n    dbenv.set_errfile(fopen(pathErrorFile.string().c_str(), \"a\")); /// debug\n    dbenv.set_flags(DB_AUTO_COMMIT, 1);\n    dbenv.set_flags(DB_TXN_WRITE_NOSYNC, 1);\n    dbenv.log_set_config(DB_LOG_AUTO_REMOVE, 1);\n    int ret = dbenv.open(strPath.c_str(),\n                     DB_CREATE     |\n                     DB_INIT_LOCK  |\n                     DB_INIT_LOG   |\n                     DB_INIT_MPOOL |\n                     DB_INIT_TXN   |\n                     DB_THREAD     |\n                     DB_RECOVER    |\n                     nEnvFlags,\n                     S_IRUSR | S_IWUSR);\n    if (ret != 0)\n        return error(\"CDB() : error %s (%d) opening database environment\", DbEnv::strerror(ret), ret);\n\n    fDbEnvInit = true;\n    fMockDb = false;\n\n    return true;\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv {\n  bool CDBEnv::Open(boost::filesystem::path pathEnv_)\n  {\n      if (fDbEnvInit)\n          return true;\n  \n      if (fShutdown)\n          return false;\n  \n      pathEnv = pathEnv_;\n      filesystem::path pathDataDir = pathEnv;\n      strPath = pathDataDir.string();\n      filesystem::path pathLogDir = pathDataDir / \"database\";\n      filesystem::create_directory(pathLogDir);\n      filesystem::path pathErrorFile = pathDataDir / \"db.log\";\n      printf(\"dbenv.open LogDir=%s ErrorFile=%s\\n\", pathLogDir.string().c_str(), pathErrorFile.string().c_str());\n  \n      unsigned int nEnvFlags = 0;\n      if (GetBoolArg(\"-privdb\", true))\n          nEnvFlags |= DB_PRIVATE;\n  \n      int nDbCache = GetArg(\"-dbcache\", 25);\n      dbenv.set_lg_dir(pathLogDir.string().c_str());\n      dbenv.set_cachesize(nDbCache / 1024, (nDbCache % 1024)*1048576, 1);\n      dbenv.set_lg_bsize(1048576);\n      dbenv.set_lg_max(10485760);\n  \n      // Bugfix: Bump lk_max_locks default to 537000, to safely handle reorgs with up to 5 blocks reversed\n      // dbenv.set_lk_max_locks(10000);\n      dbenv.set_lk_max_locks(537000);\n  \n      dbenv.set_lk_max_objects(10000);\n      dbenv.set_errfile(fopen(pathErrorFile.string().c_str(), \"a\")); /// debug\n      dbenv.set_flags(DB_AUTO_COMMIT, 1);\n      dbenv.set_flags(DB_TXN_WRITE_NOSYNC, 1);\n      dbenv.log_set_config(DB_LOG_AUTO_REMOVE, 1);\n      int ret = dbenv.open(strPath.c_str(),\n                       DB_CREATE     |\n                       DB_INIT_LOCK  |\n                       DB_INIT_LOG   |\n                       DB_INIT_MPOOL |\n                       DB_INIT_TXN   |\n                       DB_THREAD     |\n                       DB_RECOVER    |\n                       nEnvFlags,\n                       S_IRUSR | S_IWUSR);\n      if (ret != 0)\n          return error(\"CDB() : error %s (%d) opening database environment\", DbEnv::strerror(ret), ret);\n  \n      fDbEnvInit = true;\n      fMockDb = false;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddOneShot",
          "args": [
            "strDest"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "AddOneShot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "83-87",
          "snippet": "void AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static deque<string> vOneShots;",
            "CCriticalSection cs_vOneShots;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic deque<string> vOneShots;\nCCriticalSection cs_vOneShots;\n\nvoid AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::SetCheckpointPrivKey",
          "args": [
            "GetArg(\"-checkpointkey\", \"\")"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "SetCheckpointPrivKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "303-321",
          "snippet": "bool SetCheckpointPrivKey(std::string strPrivKey)\n    {\n        // Test signing a sync-checkpoint with genesis block\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = !fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        std::vector<unsigned char> vchPrivKey = ParseHex(strPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return false;\n\n        // Test signing successful, proceed\n        CSyncCheckpoint::strMasterPrivKey = strPrivKey;\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [
            "std::string CSyncCheckpoint::strMasterPrivKey = \"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nstd::string CSyncCheckpoint::strMasterPrivKey = \"\";\n\nbool SetCheckpointPrivKey(std::string strPrivKey)\n    {\n        // Test signing a sync-checkpoint with genesis block\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = !fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        std::vector<unsigned char> vchPrivKey = ParseHex(strPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return false;\n\n        // Test signing successful, proceed\n        CSyncCheckpoint::strMasterPrivKey = strPrivKey;\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "ParseMoney",
          "args": [
            "mapArgs[\"-reservebalance\"]",
            "nReserveBalance"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "ParseMoney",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "400-438",
          "snippet": "bool ParseMoney(const char* pszIn, int64_t& nRet)\n{\n    string strWhole;\n    int64_t nUnits = 0;\n    const char* p = pszIn;\n    while (isspace(*p))\n        p++;\n    for (; *p; p++)\n    {\n        if (*p == '.')\n        {\n            p++;\n            int64_t nMult = CENT*10;\n            while (isdigit(*p) && (nMult > 0))\n            {\n                nUnits += nMult * (*p++ - '0');\n                nMult /= 10;\n            }\n            break;\n        }\n        if (isspace(*p))\n            break;\n        if (!isdigit(*p))\n            return false;\n        strWhole.insert(strWhole.end(), *p);\n    }\n    for (; *p; p++)\n        if (!isspace(*p))\n            return false;\n    if (strWhole.size() > 10) // guard against 63 bit overflow\n        return false;\n    if (nUnits < 0 || nUnits > COIN)\n        return false;\n    int64_t nWhole = atoi64(strWhole);\n    int64_t nValue = nWhole*COIN + nUnits;\n\n    nRet = nValue;\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool ParseMoney(const char* pszIn, int64_t& nRet)\n{\n    string strWhole;\n    int64_t nUnits = 0;\n    const char* p = pszIn;\n    while (isspace(*p))\n        p++;\n    for (; *p; p++)\n    {\n        if (*p == '.')\n        {\n            p++;\n            int64_t nMult = CENT*10;\n            while (isdigit(*p) && (nMult > 0))\n            {\n                nUnits += nMult * (*p++ - '0');\n                nMult /= 10;\n            }\n            break;\n        }\n        if (isspace(*p))\n            break;\n        if (!isdigit(*p))\n            return false;\n        strWhole.insert(strWhole.end(), *p);\n    }\n    for (; *p; p++)\n        if (!isspace(*p))\n            return false;\n    if (strWhole.size() > 10) // guard against 63 bit overflow\n        return false;\n    if (nUnits < 0 || nUnits > COIN)\n        return false;\n    int64_t nWhole = atoi64(strWhole);\n    int64_t nValue = nWhole*COIN + nUnits;\n\n    nRet = nValue;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddLocal",
          "args": [
            "CService(strAddr, GetListenPort(), fNameLookup)",
            "LOCAL_MANUAL"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "AddLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "252-255",
          "snippet": "bool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "strAddr",
            "GetListenPort()",
            "fNameLookup"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "CService",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1089-1095",
          "snippet": "CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n{\n    Init();\n    CService ip;\n    if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n        *this = ip;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n  {\n      Init();\n      CService ip;\n      if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n          *this = ip;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetListenPort",
          "args": [],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "GetListenPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "89-92",
          "snippet": "unsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nunsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strAddr.c_str",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrLocal.IsValid",
          "args": [],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bind",
          "args": [
            "CService(inaddr_any, GetListenPort())",
            "!fBound"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "inaddr_any",
            "GetListenPort()"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLimited",
          "args": [
            "NET_IPV4"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "IsLimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "272-275",
          "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}"
        }
      },
      {
        "call_info": {
          "callee": "Bind",
          "args": [
            "CService(in6addr_any, GetListenPort())",
            "false"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Bind",
          "args": [
            "addrBind"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "Bind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "215-225",
          "snippet": "bool static Bind(const CService &addr, bool fError = true) {\n    if (IsLimited(addr))\n        return false;\n    std::string strError;\n    if (!BindListenPort(addr, strError)) {\n        if (fError)\n            return InitError(strError);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nbool static Bind(const CService &addr, bool fError = true) {\n    if (IsLimited(addr))\n        return false;\n    std::string strError;\n    if (!BindListenPort(addr, strError)) {\n        if (fError)\n            return InitError(strError);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strBind.c_str",
          "args": [],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "strBind.c_str()",
            "addrBind",
            "GetListenPort()",
            "false"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "159-167",
          "snippet": "bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strBind.c_str",
          "args": [],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetReachable",
          "args": [
            "NET_TOR"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetProxy",
          "args": [
            "NET_TOR",
            "addrOnion",
            "5"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "SetProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "432-441",
          "snippet": "bool SetProxy(enum Network net, CService addrProxy, int nSocksVersion) {\n    assert(net >= 0 && net < NET_MAX);\n    if (nSocksVersion != 0 && nSocksVersion != 4 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    proxyInfo[net] = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static proxyType proxyInfo[NET_MAX];",
            "static CCriticalSection cs_proxyInfos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType proxyInfo[NET_MAX];\nstatic CCriticalSection cs_proxyInfos;\n\nbool SetProxy(enum Network net, CService addrProxy, int nSocksVersion) {\n    assert(net >= 0 && net < NET_MAX);\n    if (nSocksVersion != 0 && nSocksVersion != 4 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    proxyInfo[net] = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapArgs[\"-tor\"].c_str",
          "args": [],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetNameProxy",
          "args": [
            "addrProxy",
            "nSocksVersion"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "SetNameProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "452-460",
          "snippet": "bool SetNameProxy(CService addrProxy, int nSocksVersion) {\n    if (nSocksVersion != 0 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    nameproxyInfo = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static proxyType nameproxyInfo;",
            "static CCriticalSection cs_proxyInfos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType nameproxyInfo;\nstatic CCriticalSection cs_proxyInfos;\n\nbool SetNameProxy(CService addrProxy, int nSocksVersion) {\n    if (nSocksVersion != 0 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    nameproxyInfo = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapArgs[\"-proxy\"].c_str",
          "args": [],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetLimited",
          "args": [
            "net"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nets.insert",
          "args": [
            "net"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snet.c_str",
          "args": [],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseNetwork",
          "args": [
            "snet"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "ParseNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "28-35",
          "snippet": "enum Network ParseNetwork(std::string net) {\n    boost::to_lower(net);\n    if (net == \"ipv4\") return NET_IPV4;\n    if (net == \"ipv6\") return NET_IPV6;\n    if (net == \"tor\")  return NET_TOR;\n    if (net == \"i2p\")  return NET_I2P;\n    return NET_UNROUTABLE;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nenum Network ParseNetwork(std::string net) {\n    boost::to_lower(net);\n    if (net == \"ipv4\") return NET_IPV4;\n    if (net == \"ipv6\") return NET_IPV6;\n    if (net == \"tor\")  return NET_TOR;\n    if (net == \"i2p\")  return NET_I2P;\n    return NET_UNROUTABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strDataDir.c_str",
          "args": [],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitdb.Verify",
          "args": [
            "strWalletFileName",
            "CWalletDB::Recover"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "Verify",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "392-399",
          "snippet": "bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    // -1 = error, 0 = bad sig, 1 = good\n    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      // -1 = error, 0 = bad sig, 1 = good\n      if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n          return false;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CWalletDB::Recover",
          "args": [
            "bitdb",
            "strWalletFileName",
            "true"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "Recover",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "638-714",
          "snippet": "bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n{\n    // Recovery procedure:\n    // move wallet.dat to wallet.timestamp.bak\n    // Call Salvage with fAggressive=true to\n    // get as much data as possible.\n    // Rewrite salvaged data to wallet.dat\n    // Set -rescan so any missing transactions will be\n    // found.\n    int64_t now = GetTime();\n    std::string newFilename = strprintf(\"wallet.%\"PRId64\".bak\", now);\n\n    int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n                                      newFilename.c_str(), DB_AUTO_COMMIT);\n    if (result == 0)\n        printf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n    else\n    {\n        printf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n        return false;\n    }\n\n    std::vector<CDBEnv::KeyValPair> salvagedData;\n    bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n    if (salvagedData.empty())\n    {\n        printf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n        return false;\n    }\n    printf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n\n    bool fSuccess = allOK;\n    Db* pdbCopy = new Db(&dbenv.dbenv, 0);\n    int ret = pdbCopy->open(NULL,                 // Txn pointer\n                            filename.c_str(),   // Filename\n                            \"main\",    // Logical db name\n                            DB_BTREE,  // Database type\n                            DB_CREATE,    // Flags\n                            0);\n    if (ret > 0)\n    {\n        printf(\"Cannot create database file %s\\n\", filename.c_str());\n        return false;\n    }\n    CWallet dummyWallet;\n    CWalletScanState wss;\n\n    DbTxn* ptxn = dbenv.TxnBegin();\n    BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n    {\n        if (fOnlyKeys)\n        {\n            CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n            CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n            string strType, strErr;\n            bool fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n                                        wss, strType, strErr);\n            if (!IsKeyType(strType))\n                continue;\n            if (!fReadOK)\n            {\n                printf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n                continue;\n            }\n        }\n        Dbt datKey(&row.first[0], row.first.size());\n        Dbt datValue(&row.second[0], row.second.size());\n        int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n        if (ret2 > 0)\n            fSuccess = false;\n    }\n    ptxn->commit(0);\n    pdbCopy->close(0);\n    delete pdbCopy;\n\n    return fSuccess;\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n  {\n      // Recovery procedure:\n      // move wallet.dat to wallet.timestamp.bak\n      // Call Salvage with fAggressive=true to\n      // get as much data as possible.\n      // Rewrite salvaged data to wallet.dat\n      // Set -rescan so any missing transactions will be\n      // found.\n      int64_t now = GetTime();\n      std::string newFilename = strprintf(\"wallet.%\"PRId64\".bak\", now);\n  \n      int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n                                        newFilename.c_str(), DB_AUTO_COMMIT);\n      if (result == 0)\n          printf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n      else\n      {\n          printf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n          return false;\n      }\n  \n      std::vector<CDBEnv::KeyValPair> salvagedData;\n      bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n      if (salvagedData.empty())\n      {\n          printf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n          return false;\n      }\n      printf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n  \n      bool fSuccess = allOK;\n      Db* pdbCopy = new Db(&dbenv.dbenv, 0);\n      int ret = pdbCopy->open(NULL,                 // Txn pointer\n                              filename.c_str(),   // Filename\n                              \"main\",    // Logical db name\n                              DB_BTREE,  // Database type\n                              DB_CREATE,    // Flags\n                              0);\n      if (ret > 0)\n      {\n          printf(\"Cannot create database file %s\\n\", filename.c_str());\n          return false;\n      }\n      CWallet dummyWallet;\n      CWalletScanState wss;\n  \n      DbTxn* ptxn = dbenv.TxnBegin();\n      BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n      {\n          if (fOnlyKeys)\n          {\n              CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n              CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n              string strType, strErr;\n              bool fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n                                          wss, strType, strErr);\n              if (!IsKeyType(strType))\n                  continue;\n              if (!fReadOK)\n              {\n                  printf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n                  continue;\n              }\n          }\n          Dbt datKey(&row.first[0], row.first.size());\n          Dbt datValue(&row.second[0], row.second.size());\n          int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n          if (ret2 > 0)\n              fSuccess = false;\n      }\n      ptxn->commit(0);\n      pdbCopy->close(0);\n      delete pdbCopy;\n  \n      return fSuccess;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-salvagewallet\""
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDataDir.c_str",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDataDir.c_str",
          "args": [],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDefaultDataDir",
          "args": [],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "GetDefaultDataDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1013-1035",
          "snippet": "boost::filesystem::path GetDefaultDataDir() {\n    namespace fs = boost::filesystem;\n    fs::path path;\n\n#if (WIN32)\n    /* Windows: current directory \\ data for livenet */\n    path = boost::filesystem::current_path() / \"data\";\n#else\n    /* Linux, Mac OS X, *BSD and so on: ~/.orbitcoin */\n    char* pszHome = getenv(\"HOME\");\n    if(!pszHome || !strlen(pszHome))\n      /* Must be root if no $HOME set */\n#if (__APPLE__)\n      path = fs::path(\"/private/var/root/.halcyon\");\n#else\n      path = fs::path(\"/root/.halcyon\");\n#endif\n    else\n      path = fs::path(pszHome) / \".halcyon\";\n#endif\n\n    return(path);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nboost::filesystem::path GetDefaultDataDir() {\n    namespace fs = boost::filesystem;\n    fs::path path;\n\n#if (WIN32)\n    /* Windows: current directory \\ data for livenet */\n    path = boost::filesystem::current_path() / \"data\";\n#else\n    /* Linux, Mac OS X, *BSD and so on: ~/.orbitcoin */\n    char* pszHome = getenv(\"HOME\");\n    if(!pszHome || !strlen(pszHome))\n      /* Must be root if no $HOME set */\n#if (__APPLE__)\n      path = fs::path(\"/private/var/root/.halcyon\");\n#else\n      path = fs::path(\"/root/.halcyon\");\n#endif\n    else\n      path = fs::path(pszHome) / \".halcyon\";\n#endif\n\n    return(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "\"%x %H:%M:%S\"",
            "GetTime()"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "376-383",
          "snippet": "inline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SSLeay_version",
          "args": [
            "SSLEAY_VERSION"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Halcyon version %s (%s)\\n\"",
            "FormatFullVersion().c_str()",
            "CLIENT_DATE.c_str()"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_DATE.c_str",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatFullVersion",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "FormatFullVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1288-1291",
          "snippet": "string FormatFullVersion()\n{\n    return CLIENT_BUILD;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring FormatFullVersion()\n{\n    return CLIENT_BUILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ShrinkDebugFile",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "ShrinkDebugFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1151-1171",
          "snippet": "void ShrinkDebugFile()\n{\n    // Scroll debug.log if it's getting too big\n    boost::filesystem::path pathLog = GetDataDir() / \"debug.log\";\n    FILE* file = fopen(pathLog.string().c_str(), \"r\");\n    if (file && boost::filesystem::file_size(pathLog) > 10 * 1000000)\n    {\n        // Restart the file with some of the end\n        char pch[200000];\n        fseek(file, -sizeof(pch), SEEK_END);\n        int nBytes = fread(pch, 1, sizeof(pch), file);\n        fclose(file);\n\n        file = fopen(pathLog.string().c_str(), \"w\");\n        if (file)\n        {\n            fwrite(pch, 1, nBytes, file);\n            fclose(file);\n        }\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid ShrinkDebugFile()\n{\n    // Scroll debug.log if it's getting too big\n    boost::filesystem::path pathLog = GetDataDir() / \"debug.log\";\n    FILE* file = fopen(pathLog.string().c_str(), \"r\");\n    if (file && boost::filesystem::file_size(pathLog) > 10 * 1000000)\n    {\n        // Restart the file with some of the end\n        char pch[200000];\n        fseek(file, -sizeof(pch), SEEK_END);\n        int nBytes = fread(pch, 1, sizeof(pch), file);\n        fclose(file);\n\n        file = fopen(pathLog.string().c_str(), \"w\");\n        if (file)\n        {\n            fwrite(pch, 1, nBytes, file);\n            fclose(file);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: setsid() returned %d errno %d\\n\"",
            "sid",
            "errno"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreatePidFile",
          "args": [
            "GetPidFile()",
            "pid"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "CreatePidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1119-1127",
          "snippet": "void CreatePidFile(const boost::filesystem::path &path, pid_t pid)\n{\n    FILE* file = fopen(path.string().c_str(), \"w\");\n    if (file)\n    {\n        fprintf(file, \"%d\\n\", pid);\n        fclose(file);\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid CreatePidFile(const boost::filesystem::path &path, pid_t pid)\n{\n    FILE* file = fopen(path.string().c_str(), \"w\");\n    if (file)\n    {\n        fprintf(file, \"%d\\n\", pid);\n        fclose(file);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetPidFile",
          "args": [],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "GetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1111-1116",
          "snippet": "boost::filesystem::path GetPidFile()\n{\n    boost::filesystem::path pathPidFile(GetArg(\"-pid\", \"halcyond.pid\"));\n    if (!pathPidFile.is_complete()) pathPidFile = GetDataDir() / pathPidFile;\n    return pathPidFile;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nboost::filesystem::path GetPidFile()\n{\n    boost::filesystem::path pathPidFile(GetArg(\"-pid\", \"halcyond.pid\"));\n    if (!pathPidFile.is_complete()) pathPidFile = GetDataDir() / pathPidFile;\n    return pathPidFile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: fork() returned %d errno %d\\n\"",
            "pid",
            "errno"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDataDir.c_str",
          "args": [],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.try_lock",
          "args": [],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathLockFile.string",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathLockFile.string",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "file"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "pathLockFile.string().c_str()",
            "\"a\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathLockFile.string",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathLockFile.string",
          "args": [],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "_(\"Wallet %s resides outside data directory %s.\")",
            "strWalletFileName.c_str()",
            "strDataDir.c_str()"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDataDir.c_str",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strWalletFileName.c_str",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::filesystem::extension",
          "args": [
            "strWalletFileName"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::filesystem::basename",
          "args": [
            "strWalletFileName"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapArgs[\"-stakesplit\"].c_str",
          "args": [],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapArgs[\"-stakecombine\"].c_str",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapArgs[\"-mininput\"].c_str",
          "args": [],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InitWarning",
          "args": [
            "_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\")"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "InitWarning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "208-212",
          "snippet": "bool static InitWarning(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n    return true;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CClientUIInterface uiInterface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nbool static InitWarning(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapArgs[\"-paytxfee\"].c_str",
          "args": [],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-logtimestamps\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printtodebugger\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printtoconsole\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-server\""
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-daemon\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitdb.SetDetach",
          "args": [
            "GetBoolArg(\"-detachdb\", false)"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "SetDetach",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "77-77",
          "snippet": "void SetDetach(bool fDetachDB_) { fDetachDB = fDetachDB_; }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDBEnv {\n  void SetDetach(bool fDetachDB_) { fDetachDB = fDetachDB_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-debugnet\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-debug\""
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SoftSetBoolArg",
          "args": [
            "\"-rescan\"",
            "true"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "SoftSetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "588-594",
          "snippet": "bool SoftSetBoolArg(const std::string& strArg, bool fValue)\n{\n    if (fValue)\n        return SoftSetArg(strArg, std::string(\"1\"));\n    else\n        return SoftSetArg(strArg, std::string(\"0\"));\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool SoftSetBoolArg(const std::string& strArg, bool fValue)\n{\n    if (fValue)\n        return SoftSetArg(strArg, std::string(\"1\"));\n    else\n        return SoftSetArg(strArg, std::string(\"0\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-salvagewallet\""
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-testnet\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SSE2 assembly optimisations enabled\\n\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGHUP",
            "&sa_hup",
            "NULL"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sa_hup.sa_mask"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&sa",
            "NULL"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGTERM",
            "&sa",
            "NULL"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&sa.sa_mask"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setProcDEPPol",
          "args": [
            "PROCESS_DEP_ENABLE"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProcAddress",
          "args": [
            "GetModuleHandleA(\"Kernel32.dll\")",
            "\"SetProcessDEPPolicy\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetModuleHandleA",
          "args": [
            "\"Kernel32.dll\""
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_abort_behavior",
          "args": [
            "0",
            "_WRITE_ABORT_MSG | _CALL_REPORTFAULT"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportFile",
          "args": [
            "_CRT_WARN",
            "CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateFileA",
          "args": [
            "\"NUL\"",
            "GENERIC_WRITE",
            "0",
            "NULL",
            "OPEN_EXISTING",
            "0",
            "0"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CrtSetReportMode",
          "args": [
            "_CRT_WARN",
            "_CRTDBG_MODE_FILE"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\n#define PROCESS_DEP_ENABLE 0x00000001\n\nCWallet* pwalletMain;\nCClientUIInterface uiInterface;\nstd::string strWalletFileName;\nbool fConfChange;\nbool fEnforceCanonical;\nunsigned int nNodeLifespan;\nunsigned int nDerivationMethodIndex;\nunsigned int nMinerSleep;\nenum Checkpoints::CPMode CheckpointsMode;\n\nbool AppInit2()\n{\n    // ********************************************************* Step 1: setup\n#ifdef _MSC_VER\n    // Turn off Microsoft heap dump noise\n    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n    _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n#endif\n#if _MSC_VER >= 1400\n    // Disable confusing \"helpful\" text message on abort, Ctrl-C\n    _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n#endif\n#ifdef WIN32\n    // Enable Data Execution Prevention (DEP)\n    // Minimum supported OS versions: WinXP SP3, WinVista >= SP1, Win Server 2008\n    // A failure is non-critical and needs no further attention!\n#ifndef PROCESS_DEP_ENABLE\n// We define this here, because GCCs winbase.h limits this to _WIN32_WINNT >= 0x0601 (Windows 7),\n// which is not correct. Can be removed, when GCCs winbase.h is fixed!\n#define PROCESS_DEP_ENABLE 0x00000001\n#endif\n    typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n    PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n#endif\n#ifndef WIN32\n    umask(077);\n\n    // Clean shutdown on SIGTERM\n    struct sigaction sa;\n    sa.sa_handler = HandleSIGTERM;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGTERM, &sa, NULL);\n    sigaction(SIGINT, &sa, NULL);\n\n    // Reopen debug.log on SIGHUP\n    struct sigaction sa_hup;\n    sa_hup.sa_handler = HandleSIGHUP;\n    sigemptyset(&sa_hup.sa_mask);\n    sa_hup.sa_flags = 0;\n    sigaction(SIGHUP, &sa_hup, NULL);\n#endif\n\n    // ********************************************************* Step 2: parameter interactions\n\n    if(GetBoolArg(\"-sse2\", false)) {\n        printf(\"SSE2 assembly optimisations enabled\\n\");\n        nNeoScryptOptions |= 0x1000;\n    }\n\n    nNodeLifespan = GetArg(\"-addrlifespan\", 7);\n\n    nMinerSleep = GetArg(\"-minersleep\", 500);\n\n    CheckpointsMode = Checkpoints::STRICT;\n    std::string strCpMode = GetArg(\"-cppolicy\", \"strict\");\n\n    if(strCpMode == \"strict\")\n        CheckpointsMode = Checkpoints::STRICT;\n\n    if(strCpMode == \"advisory\")\n        CheckpointsMode = Checkpoints::ADVISORY;\n\n    if(strCpMode == \"permissive\")\n        CheckpointsMode = Checkpoints::PERMISSIVE;\n\n    nDerivationMethodIndex = 0;\n\n    fTestNet = GetBoolArg(\"-testnet\");\n    //fTestNet = true;\n    if (fTestNet) {\n        SoftSetBoolArg(\"-irc\", true);\n    }\n\n    if (mapArgs.count(\"-bind\")) {\n        // when specifying an explicit binding address, you want to listen on it\n        // even when -connect or -proxy is specified\n        SoftSetBoolArg(\"-listen\", true);\n    }\n\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0) {\n        // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n        SoftSetBoolArg(\"-dnsseed\", false);\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (mapArgs.count(\"-proxy\")) {\n        // to protect privacy, do not listen by default if a proxy server is specified\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (!GetBoolArg(\"-listen\", true)) {\n        // do not map ports or try to retrieve public IP when not listening (pointless)\n        SoftSetBoolArg(\"-upnp\", false);\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (mapArgs.count(\"-externalip\")) {\n        // if an explicit public IP is specified, do not try to find others\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\")) {\n        // Rewrite just private keys: rescan to find transactions\n        SoftSetBoolArg(\"-rescan\", true);\n    }\n\n    // ********************************************************* Step 3: parameter-to-internal-flags\n\n    fDebug = GetBoolArg(\"-debug\");\n\n    // -debug implies fDebug*\n    if (fDebug)\n        fDebugNet = true;\n    else\n        fDebugNet = GetBoolArg(\"-debugnet\");\n\n    bitdb.SetDetach(GetBoolArg(\"-detachdb\", false));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    fDaemon = GetBoolArg(\"-daemon\");\n#else\n    fDaemon = false;\n#endif\n\n    if (fDaemon)\n        fServer = true;\n    else\n        fServer = GetBoolArg(\"-server\");\n\n    /* force fServer when running without GUI */\n#if !defined(QT_GUI)\n    fServer = true;\n#endif\n    fPrintToConsole = GetBoolArg(\"-printtoconsole\");\n    fPrintToDebugger = GetBoolArg(\"-printtodebugger\");\n    fLogTimestamps = GetBoolArg(\"-logtimestamps\");\n\n    if (mapArgs.count(\"-timeout\"))\n    {\n        int nNewTimeout = GetArg(\"-timeout\", 5000);\n        if (nNewTimeout > 0 && nNewTimeout < 600000)\n            nConnectTimeout = nNewTimeout;\n    }\n\n    if (mapArgs.count(\"-paytxfee\"))\n    {\n        if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"].c_str()));\n        if (nTransactionFee > 0.25 * COIN)\n            InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n    }\n\n    fConfChange = GetBoolArg(\"-confchange\", false);\n    fEnforceCanonical = GetBoolArg(\"-enforcecanonical\", true);\n\n    if (mapArgs.count(\"-mininput\"))\n    {\n        if (!ParseMoney(mapArgs[\"-mininput\"], nMinimumInputValue))\n            return InitError(strprintf(_(\"Invalid amount for -mininput=<amount>: '%s'\"), mapArgs[\"-mininput\"].c_str()));\n    }\n\n    /* Try to combine inputs while staking up to this limit */\n    if(mapArgs.count(\"-stakecombine\")) {\n        if(!ParseMoney(mapArgs[\"-stakecombine\"], nCombineThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakecombine=<amount>: '%s'\"),\n            mapArgs[\"-stakecombine\"].c_str())));\n        if(nCombineThreshold < 10 * COIN)\n          nCombineThreshold = 10 * COIN;\n        if(nCombineThreshold > 1000 * COIN)\n          nCombineThreshold = 1000 * COIN;\n    }\n\n    /* Don't split outputs while staking below this limit */\n    if(mapArgs.count(\"-stakesplit\")) {\n        if(!ParseMoney(mapArgs[\"-stakesplit\"], nSplitThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakesplit=<amount>: '%s'\"),\n            mapArgs[\"-stakesplit\"].c_str())));\n        if(nSplitThreshold < 20 * COIN)\n          nSplitThreshold = 20 * COIN;\n        if(nSplitThreshold > 2000 * COIN)\n          nSplitThreshold = 2000 * COIN;\n    }\n\n    // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n\n    std::string strDataDir = GetDataDir().string();\n    std::string strWalletFileName = GetArg(\"-wallet\", \"wallet.dat\");\n\n    // strWalletFileName must be a plain filename without a directory\n    if (strWalletFileName != boost::filesystem::basename(strWalletFileName) + boost::filesystem::extension(strWalletFileName))\n        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s.\"), strWalletFileName.c_str(), strDataDir.c_str()));\n\n    // Make sure only a single Bitcoin process is using the data directory.\n    boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n    FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n    if (file) fclose(file);\n    static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n    if (!lock.try_lock())\n        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Halcyon is probably already running.\"), strDataDir.c_str()));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    if (fDaemon)\n    {\n        // Daemonize\n        pid_t pid = fork();\n        if (pid < 0)\n        {\n            fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n            return false;\n        }\n        if (pid > 0)\n        {\n            CreatePidFile(GetPidFile(), pid);\n            return true;\n        }\n\n        pid_t sid = setsid();\n        if (sid < 0)\n            fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n    }\n#endif\n\n    if (GetBoolArg(\"-shrinkdebugfile\", !fDebug))\n        ShrinkDebugFile();\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n    printf(\"Halcyon version %s (%s)\\n\", FormatFullVersion().c_str(), CLIENT_DATE.c_str());\n    printf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n    if (!fLogTimestamps)\n        printf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n    printf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n    printf(\"Used data directory %s\\n\", strDataDir.c_str());\n    std::ostringstream strErrors;\n\n    int64_t nStart;\n\n    // ********************************************************* Step 5: verify database integrity\n\n    uiInterface.InitMessage(_(\"Verifying database integrity...\"));\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\"))\n    {\n        // Recover readable keypairs:\n        if (!CWalletDB::Recover(bitdb, strWalletFileName, true))\n            return false;\n    }\n\n    if (filesystem::exists(GetDataDir() / strWalletFileName))\n    {\n        CDBEnv::VerifyResult r = bitdb.Verify(strWalletFileName, CWalletDB::Recover);\n        if (r == CDBEnv::RECOVER_OK)\n        {\n            string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n                                     \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n                                     \" your balance or transactions are incorrect you should\"\n                                     \" restore from a backup.\"), strDataDir.c_str());\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        if (r == CDBEnv::RECOVER_FAIL)\n            return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n    }\n\n    // ********************************************************* Step 6: network initialization\n\n    int nSocksVersion = GetArg(\"-socks\", 5);\n\n    if (nSocksVersion != 4 && nSocksVersion != 5)\n        return InitError(strprintf(_(\"Unknown -socks proxy version requested: %i\"), nSocksVersion));\n\n    if (mapArgs.count(\"-onlynet\")) {\n        std::set<enum Network> nets;\n        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n            enum Network net = ParseNetwork(snet);\n            if (net == NET_UNROUTABLE)\n                return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet.c_str()));\n            nets.insert(net);\n        }\n        for (int n = 0; n < NET_MAX; n++) {\n            enum Network net = (enum Network)n;\n            if (!nets.count(net))\n                SetLimited(net);\n        }\n    }\n#if defined(USE_IPV6)\n#if ! USE_IPV6\n    else\n        SetLimited(NET_IPV6);\n#endif\n#endif\n\n    CService addrProxy;\n    bool fProxy = false;\n    if (mapArgs.count(\"-proxy\")) {\n        addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n        if (!addrProxy.IsValid())\n            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n\n        if (!IsLimited(NET_IPV4))\n            SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n        if (nSocksVersion > 4) {\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                SetProxy(NET_IPV6, addrProxy, nSocksVersion);\n#endif\n            SetNameProxy(addrProxy, nSocksVersion);\n        }\n        fProxy = true;\n    }\n\n    // -tor can override normal proxy, -notor disables tor entirely\n    if (!(mapArgs.count(\"-tor\") && mapArgs[\"-tor\"] == \"0\") && (fProxy || mapArgs.count(\"-tor\"))) {\n        CService addrOnion;\n        if (!mapArgs.count(\"-tor\"))\n            addrOnion = addrProxy;\n        else\n            addrOnion = CService(mapArgs[\"-tor\"], 9050);\n        if (!addrOnion.IsValid())\n            return InitError(strprintf(_(\"Invalid -tor address: '%s'\"), mapArgs[\"-tor\"].c_str()));\n        SetProxy(NET_TOR, addrOnion, 5);\n        SetReachable(NET_TOR);\n    }\n\n    // see Step 2: parameter interactions for more information about these\n    fNoListen = !GetBoolArg(\"-listen\", true);\n    fDiscover = GetBoolArg(\"-discover\", true);\n    fNameLookup = GetBoolArg(\"-dns\", true);\n#ifdef USE_UPNP\n    fUseUPnP = GetBoolArg(\"-upnp\", USE_UPNP);\n#endif\n\n    bool fBound = false;\n    if (!fNoListen)\n    {\n        std::string strError;\n        if (mapArgs.count(\"-bind\")) {\n            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n                CService addrBind;\n                if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                    return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind.c_str()));\n                fBound |= Bind(addrBind);\n            }\n        } else {\n            struct in_addr inaddr_any;\n            inaddr_any.s_addr = INADDR_ANY;\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                fBound |= Bind(CService(in6addr_any, GetListenPort()), false);\n#endif\n            if (!IsLimited(NET_IPV4))\n                fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound);\n        }\n        if (!fBound)\n            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n    }\n\n    if (mapArgs.count(\"-externalip\"))\n    {\n        BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n            CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n            if (!addrLocal.IsValid())\n                return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr.c_str()));\n            AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n        }\n    }\n\n    if (mapArgs.count(\"-reservebalance\")) // ppcoin: reserve balance amount\n    {\n        if (!ParseMoney(mapArgs[\"-reservebalance\"], nReserveBalance))\n        {\n            InitError(_(\"Invalid amount for -reservebalance=<amount>\"));\n            return false;\n        }\n    }\n\n    if (mapArgs.count(\"-checkpointkey\")) // ppcoin: checkpoint master priv key\n    {\n        if (!Checkpoints::SetCheckpointPrivKey(GetArg(\"-checkpointkey\", \"\")))\n            InitError(_(\"Unable to sign checkpoint, wrong checkpointkey?\\n\"));\n    }\n\n    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n        AddOneShot(strDest);\n\n    // ********************************************************* Step 7: load blockchain\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-loadblockindextest\"))\n    {\n        CTxDB txdb(\"r\");\n        txdb.LoadBlockIndex();\n        PrintBlockTree();\n        return false;\n    }\n\n    uiInterface.InitMessage(_(\"Loading block index...\"));\n    printf(\"Loading block index...\\n\");\n    nStart = GetTimeMillis();\n    if (!LoadBlockIndex())\n        return InitError(_(\"Error loading blkindex.dat\"));\n\n\n    // as LoadBlockIndex can take several minutes, it's possible the user\n    // requested to kill bitcoin-qt during the last operation. If so, exit.\n    // As the program has not fully started yet, Shutdown() is possibly overkill.\n    if (fRequestShutdown)\n    {\n        printf(\"Shutdown requested. Exiting.\\n\");\n        return false;\n    }\n    printf(\" block index %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    if (GetBoolArg(\"-printblockindex\") || GetBoolArg(\"-printblocktree\"))\n    {\n        PrintBlockTree();\n        return false;\n    }\n\n    if (mapArgs.count(\"-printblock\"))\n    {\n        string strMatch = mapArgs[\"-printblock\"];\n        int nFound = 0;\n        for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n        {\n            uint256 hash = (*mi).first;\n            if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n            {\n                CBlockIndex* pindex = (*mi).second;\n                CBlock block;\n                block.ReadFromDisk(pindex);\n                block.BuildMerkleTree();\n                block.print();\n                printf(\"\\n\");\n                nFound++;\n            }\n        }\n        if (nFound == 0)\n            printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n        return false;\n    }\n\n    // ********************************************************* Step 8: load wallet\n\n    uiInterface.InitMessage(_(\"Loading wallet...\"));\n    printf(\"Loading wallet...\\n\");\n    nStart = GetTimeMillis();\n    bool fFirstRun = true;\n    pwalletMain = new CWallet(strWalletFileName);\n    DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n    if (nLoadWalletRet != DB_LOAD_OK)\n    {\n        if (nLoadWalletRet == DB_CORRUPT)\n            strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n        {\n            string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n                         \" or address book entries might be missing or incorrect.\"));\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        else if (nLoadWalletRet == DB_TOO_NEW)\n            strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Halcyon\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NEED_REWRITE)\n        {\n            strErrors << _(\"Wallet needed to be rewritten: restart Halcyon to complete\") << \"\\n\";\n            printf(\"%s\", strErrors.str().c_str());\n            return InitError(strErrors.str());\n        }\n        else\n            strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n    }\n\n    if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n    {\n        int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n        if (nMaxVersion == 0) // the -upgradewallet without argument case\n        {\n            printf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n            nMaxVersion = CLIENT_VERSION;\n            pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n        }\n        else\n            printf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n        if (nMaxVersion < pwalletMain->GetVersion())\n            strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n        pwalletMain->SetMaxVersion(nMaxVersion);\n    }\n\n    if (fFirstRun)\n    {\n        // Create new keyUser and set as default key\n        RandAddSeedPerfmon();\n\n        CPubKey newDefaultKey;\n        if (!pwalletMain->GetKeyFromPool(newDefaultKey, false))\n            strErrors << _(\"Cannot initialize keypool\") << \"\\n\";\n        pwalletMain->SetDefaultKey(newDefaultKey);\n        if (!pwalletMain->SetAddressBookName(pwalletMain->vchDefaultKey.GetID(), \"\"))\n            strErrors << _(\"Cannot write default address\") << \"\\n\";\n    }\n\n    printf(\"%s\", strErrors.str().c_str());\n    printf(\" wallet      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    RegisterWallet(pwalletMain);\n\n    CBlockIndex *pindexRescan = pindexBest;\n    if (GetBoolArg(\"-rescan\"))\n        pindexRescan = pindexGenesisBlock;\n    else\n    {\n        CWalletDB walletdb(strWalletFileName);\n        CBlockLocator locator;\n        if (walletdb.ReadBestBlock(locator))\n            pindexRescan = locator.GetBlockIndex();\n    }\n    if (pindexBest != pindexRescan && pindexBest && pindexRescan && pindexBest->nHeight > pindexRescan->nHeight)\n    {\n        uiInterface.InitMessage(_(\"Rescanning...\"));\n        printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n        nStart = GetTimeMillis();\n        pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n        printf(\" rescan      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n    }\n\n    // ********************************************************* Step 9: import blocks\n\n    if (mapArgs.count(\"-loadblock\"))\n    {\n        uiInterface.InitMessage(_(\"Importing blockchain data file.\"));\n\n        BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n        {\n            FILE *file = fopen(strFile.c_str(), \"rb\");\n            if (file)\n                LoadExternalBlockFile(file);\n        }\n        exit(0);\n    }\n\n    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n    if (filesystem::exists(pathBootstrap)) {\n        uiInterface.InitMessage(_(\"Importing bootstrap blockchain data file.\"));\n\n        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n        if (file) {\n            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n            LoadExternalBlockFile(file);\n            RenameOver(pathBootstrap, pathBootstrapOld);\n        }\n    }\n\n    // ********************************************************* Step 10: load peers\n\n    uiInterface.InitMessage(_(\"Loading addresses...\"));\n    printf(\"Loading addresses...\\n\");\n    nStart = GetTimeMillis();\n\n    {\n        CAddrDB adb;\n        if (!adb.Read(addrman))\n            printf(\"Invalid or missing peers.dat; recreating\\n\");\n    }\n\n    printf(\"Loaded %i addresses from peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n\n    // ********************************************************* Step 11: start node\n\n    if (!CheckDiskSpace())\n        return false;\n\n    RandAddSeedPerfmon();\n\n    //// debug print\n    printf(\"mapBlockIndex.size() = %\"PRIszu\"\\n\",   mapBlockIndex.size());\n    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n    printf(\"setKeyPool.size() = %\"PRIszu\"\\n\",      pwalletMain->setKeyPool.size());\n    printf(\"mapWallet.size() = %\"PRIszu\"\\n\",       pwalletMain->mapWallet.size());\n    printf(\"mapAddressBook.size() = %\"PRIszu\"\\n\",  pwalletMain->mapAddressBook.size());\n\n    if (!NewThread(StartNode, NULL))\n        InitError(_(\"Error: could not start node\"));\n\n    if (fServer)\n        NewThread(ThreadRPCServer, NULL);\n\n    // ********************************************************* Step 12: finished\n\n    uiInterface.InitMessage(_(\"Done loading\"));\n    printf(\"Done loading\\n\");\n\n    if (!strErrors.str().empty())\n        return InitError(strErrors.str());\n\n     // Add wallet transactions that aren't already in a block to mapTransactions\n    pwalletMain->ReacceptWalletTransactions();\n\n#if !defined(QT_GUI)\n    // Loop until process is exit()ed from shutdown() function,\n    // called from ThreadRPCServer thread when a \"stop\" command is received.\n    while (1)\n        MilliSleep(5000);\n#endif\n\n    return true;\n}"
  },
  {
    "function_name": "HelpMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "228-317",
    "snippet": "std::string HelpMessage()\n{\n    string strUsage = _(\"Options:\") + \"\\n\" +\n        \"  -?                     \" + _(\"This help message\") + \"\\n\" +\n        \"  -conf=<file>           \" + _(\"Specify configuration file (default: halcyon.conf)\") + \"\\n\" +\n        \"  -pid=<file>            \" + _(\"Specify pid file (default: halcyond.pid)\") + \"\\n\" +\n        \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\" +\n        \"  -wallet=<dir>          \" + _(\"Specify wallet file (within data directory)\") + \"\\n\" +\n        \"  -dbcache=<n>           \" + _(\"Set database cache size in megabytes (default: 25)\") + \"\\n\" +\n        \"  -dblogsize=<n>         \" + _(\"Set database disk log size in megabytes (default: 100)\") + \"\\n\" +\n        \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\" +\n        \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\" +\n        \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\" +\n        \"  -tor=<ip:port>         \" + _(\"Use proxy to reach tor hidden services (default: same as -proxy)\") + \"\\n\"\n        \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\" +\n        \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 21108 or testnet: 11108)\") + \"\\n\" +\n        \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\" +\n        \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\" +\n        \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\" +\n        \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\" +\n        \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\" +\n        \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\" +\n        \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\" +\n        \"  -irc                   \" + _(\"Find peers using internet relay chat (default: 1)\") + \"\\n\" +\n        \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\" +\n        \"  -bind=<addr>           \" + _(\"Bind to given address. Use [host]:port notation for IPv6\") + \"\\n\" +\n        \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1)\") + \"\\n\" +\n        \"  -staking               \" + _(\"Stake your coins to support network and gain reward (default: 1)\") + \"\\n\" +\n        \"  -synctime              \" + _(\"Sync time with other nodes. Disable if time on your system is precise e.g. syncing with NTP (default: 1)\") + \"\\n\" +\n        \"  -cppolicy              \" + _(\"Sync checkpoints policy (default: strict)\") + \"\\n\" +\n        \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\" +\n        \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\" +\n        \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\" +\n        \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\" +\n#ifdef USE_UPNP\n#if USE_UPNP\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\" +\n#else\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\" +\n#endif\n#endif\n        \"  -detachdb              \" + _(\"Detach block and address databases. Increases shutdown time (default: 0)\") + \"\\n\" +\n        \"  -paytxfee=<amt>        \" + _(\"Fee per KB to add to transactions you send\") + \"\\n\" +\n        \"  -mininput=<amt>        \" + _(\"When creating transactions, ignore inputs with value less than this (default: 0.01)\") + \"\\n\" +\n#ifdef QT_GUI\n        \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\" +\n#endif\n#if !defined(WIN32) && !defined(QT_GUI)\n        \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\" +\n#endif\n        \"  -testnet               \" + _(\"Use the test network\") + \"\\n\" +\n        \"  -debug                 \" + _(\"Output extra debugging information. Implies all other -debug* options\") + \"\\n\" +\n        \"  -debugnet              \" + _(\"Output extra network debugging information\") + \"\\n\" +\n        \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp\") + \"\\n\" +\n        \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\" +\n        \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\" +\n#ifdef WIN32\n        \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\" +\n#endif\n        \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 21109 or testnet: 35615)\") + \"\\n\" +\n        \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\" +\n        \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\" +\n        \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\" +\n        \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\" +\n        \"  -confchange            \" + _(\"Require a confirmations for change (default: 0)\") + \"\\n\" +\n        \"  -enforcecanonical      \" + _(\"Enforce transaction scripts to use canonical PUSH operators (default: 1)\") + \"\\n\" +\n        \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received (%s in cmd is replaced by message)\") + \"\\n\" +\n        \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\" +\n        \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\" +\n        \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\" +\n        \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\" +\n        \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 2500, 0 = all)\") + \"\\n\" +\n        \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-6, default: 1)\") + \"\\n\" +\n        \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000?.dat file\") + \"\\n\" +\n\n        \"\\n\" + _(\"Block creation options:\") + \"\\n\" +\n        \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\" +\n        \"  -blockmaxsize=<n>      \"   + _(\"Set maximum block size in bytes (default: 250000)\") + \"\\n\" +\n        \"  -blockprioritysize=<n> \"   + _(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") + \"\\n\" +\n\n        \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\" +\n        \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\" +\n        \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\" +\n        \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\") + \"\\n\";\n\n    return strUsage;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\""
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "QT_GUI"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "defined",
          "args": [
            "WIN32"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nstd::string HelpMessage()\n{\n    string strUsage = _(\"Options:\") + \"\\n\" +\n        \"  -?                     \" + _(\"This help message\") + \"\\n\" +\n        \"  -conf=<file>           \" + _(\"Specify configuration file (default: halcyon.conf)\") + \"\\n\" +\n        \"  -pid=<file>            \" + _(\"Specify pid file (default: halcyond.pid)\") + \"\\n\" +\n        \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\" +\n        \"  -wallet=<dir>          \" + _(\"Specify wallet file (within data directory)\") + \"\\n\" +\n        \"  -dbcache=<n>           \" + _(\"Set database cache size in megabytes (default: 25)\") + \"\\n\" +\n        \"  -dblogsize=<n>         \" + _(\"Set database disk log size in megabytes (default: 100)\") + \"\\n\" +\n        \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\" +\n        \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\" +\n        \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\" +\n        \"  -tor=<ip:port>         \" + _(\"Use proxy to reach tor hidden services (default: same as -proxy)\") + \"\\n\"\n        \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\" +\n        \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 21108 or testnet: 11108)\") + \"\\n\" +\n        \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\" +\n        \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\" +\n        \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\" +\n        \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\" +\n        \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\" +\n        \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\" +\n        \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\" +\n        \"  -irc                   \" + _(\"Find peers using internet relay chat (default: 1)\") + \"\\n\" +\n        \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\" +\n        \"  -bind=<addr>           \" + _(\"Bind to given address. Use [host]:port notation for IPv6\") + \"\\n\" +\n        \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1)\") + \"\\n\" +\n        \"  -staking               \" + _(\"Stake your coins to support network and gain reward (default: 1)\") + \"\\n\" +\n        \"  -synctime              \" + _(\"Sync time with other nodes. Disable if time on your system is precise e.g. syncing with NTP (default: 1)\") + \"\\n\" +\n        \"  -cppolicy              \" + _(\"Sync checkpoints policy (default: strict)\") + \"\\n\" +\n        \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\" +\n        \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\" +\n        \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\" +\n        \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\" +\n#ifdef USE_UPNP\n#if USE_UPNP\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\" +\n#else\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\" +\n#endif\n#endif\n        \"  -detachdb              \" + _(\"Detach block and address databases. Increases shutdown time (default: 0)\") + \"\\n\" +\n        \"  -paytxfee=<amt>        \" + _(\"Fee per KB to add to transactions you send\") + \"\\n\" +\n        \"  -mininput=<amt>        \" + _(\"When creating transactions, ignore inputs with value less than this (default: 0.01)\") + \"\\n\" +\n#ifdef QT_GUI\n        \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\" +\n#endif\n#if !defined(WIN32) && !defined(QT_GUI)\n        \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\" +\n#endif\n        \"  -testnet               \" + _(\"Use the test network\") + \"\\n\" +\n        \"  -debug                 \" + _(\"Output extra debugging information. Implies all other -debug* options\") + \"\\n\" +\n        \"  -debugnet              \" + _(\"Output extra network debugging information\") + \"\\n\" +\n        \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp\") + \"\\n\" +\n        \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\" +\n        \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\" +\n#ifdef WIN32\n        \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\" +\n#endif\n        \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 21109 or testnet: 35615)\") + \"\\n\" +\n        \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\" +\n        \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\" +\n        \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\" +\n        \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\" +\n        \"  -confchange            \" + _(\"Require a confirmations for change (default: 0)\") + \"\\n\" +\n        \"  -enforcecanonical      \" + _(\"Enforce transaction scripts to use canonical PUSH operators (default: 1)\") + \"\\n\" +\n        \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received (%s in cmd is replaced by message)\") + \"\\n\" +\n        \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\" +\n        \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\" +\n        \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\" +\n        \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\" +\n        \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 2500, 0 = all)\") + \"\\n\" +\n        \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-6, default: 1)\") + \"\\n\" +\n        \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000?.dat file\") + \"\\n\" +\n\n        \"\\n\" + _(\"Block creation options:\") + \"\\n\" +\n        \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\" +\n        \"  -blockmaxsize=<n>      \"   + _(\"Set maximum block size in bytes (default: 250000)\") + \"\\n\" +\n        \"  -blockprioritysize=<n> \"   + _(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") + \"\\n\" +\n\n        \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\" +\n        \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\" +\n        \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\" +\n        \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\") + \"\\n\";\n\n    return strUsage;\n}"
  },
  {
    "function_name": "Bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "215-225",
    "snippet": "bool static Bind(const CService &addr, bool fError = true) {\n    if (IsLimited(addr))\n        return false;\n    std::string strError;\n    if (!BindListenPort(addr, strError)) {\n        if (fError)\n            return InitError(strError);\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "InitError",
          "args": [
            "strError"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "InitError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "202-206",
          "snippet": "bool static InitError(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::MODAL);\n    return false;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CClientUIInterface uiInterface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nbool static InitError(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::MODAL);\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BindListenPort",
          "args": [
            "addr",
            "strError"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsLimited",
          "args": [
            "addr"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "IsLimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "272-275",
          "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nbool static Bind(const CService &addr, bool fError = true) {\n    if (IsLimited(addr))\n        return false;\n    std::string strError;\n    if (!BindListenPort(addr, strError)) {\n        if (fError)\n            return InitError(strError);\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "InitWarning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "208-212",
    "snippet": "bool static InitWarning(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n    return true;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CClientUIInterface uiInterface;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiInterface.ThreadSafeMessageBox",
          "args": [
            "str",
            "_(\"Halcyon\")",
            "CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadSafeMessageBox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "38-56",
          "snippet": "static void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BitcoinGUI *guiref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic BitcoinGUI *guiref;\n\nstatic void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Halcyon\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nbool static InitWarning(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n    return true;\n}"
  },
  {
    "function_name": "InitError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "202-206",
    "snippet": "bool static InitError(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::MODAL);\n    return false;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CClientUIInterface uiInterface;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiInterface.ThreadSafeMessageBox",
          "args": [
            "str",
            "_(\"Halcyon\")",
            "CClientUIInterface::OK | CClientUIInterface::MODAL"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadSafeMessageBox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "38-56",
          "snippet": "static void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BitcoinGUI *guiref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic BitcoinGUI *guiref;\n\nstatic void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Halcyon\""
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nbool static InitError(const std::string &str)\n{\n    uiInterface.ThreadSafeMessageBox(str, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::MODAL);\n    return false;\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "186-199",
    "snippet": "int main(int argc, char* argv[])\n{\n    bool fRet = false;\n\n    // Connect bitcoind signal handlers\n    noui_connect();\n\n    fRet = AppInit(argc, argv);\n\n    if (fRet && fDaemon)\n        return 0;\n\n    return 1;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AppInit",
          "args": [
            "argc",
            "argv"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "AppInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "129-183",
          "snippet": "bool AppInit(int argc, char* argv[])\n{\n    bool fRet = false;\n    try\n    {\n        //\n        // Parameters\n        //\n        // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n        ParseParameters(argc, argv);\n        if (!boost::filesystem::is_directory(GetDataDir(false)))\n        {\n            fprintf(stderr, \"Error: Specified directory does not exist\\n\");\n            Shutdown(NULL);\n        }\n        ReadConfigFile(mapArgs, mapMultiArgs);\n\n        if (mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n        {\n            // First part of help message is specific to bitcoind / RPC client\n            std::string strUsage = _(\"Halcyon version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n                _(\"Usage:\") + \"\\n\" +\n                  \"  halcyond [options]                     \" + \"\\n\" +\n                  \"  halcyond [options] <command> [params]  \" + _(\"Send command to -server or halcyond\") + \"\\n\" +\n                  \"  halcyond [options] help                \" + _(\"List commands\") + \"\\n\" +\n                  \"  halcyond [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n\n            strUsage += \"\\n\" + HelpMessage();\n\n            fprintf(stdout, \"%s\", strUsage.c_str());\n            return false;\n        }\n\n        // Command-line RPC\n        for (int i = 1; i < argc; i++)\n            if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"halcyon:\"))\n                fCommandLine = true;\n\n        if (fCommandLine)\n        {\n            int ret = CommandLineRPC(argc, argv);\n            exit(ret);\n        }\n\n        fRet = AppInit2();\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"AppInit()\");\n    } catch (...) {\n        PrintException(NULL, \"AppInit()\");\n    }\n    if (!fRet)\n        Shutdown(NULL);\n    return fRet;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nbool AppInit(int argc, char* argv[])\n{\n    bool fRet = false;\n    try\n    {\n        //\n        // Parameters\n        //\n        // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n        ParseParameters(argc, argv);\n        if (!boost::filesystem::is_directory(GetDataDir(false)))\n        {\n            fprintf(stderr, \"Error: Specified directory does not exist\\n\");\n            Shutdown(NULL);\n        }\n        ReadConfigFile(mapArgs, mapMultiArgs);\n\n        if (mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n        {\n            // First part of help message is specific to bitcoind / RPC client\n            std::string strUsage = _(\"Halcyon version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n                _(\"Usage:\") + \"\\n\" +\n                  \"  halcyond [options]                     \" + \"\\n\" +\n                  \"  halcyond [options] <command> [params]  \" + _(\"Send command to -server or halcyond\") + \"\\n\" +\n                  \"  halcyond [options] help                \" + _(\"List commands\") + \"\\n\" +\n                  \"  halcyond [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n\n            strUsage += \"\\n\" + HelpMessage();\n\n            fprintf(stdout, \"%s\", strUsage.c_str());\n            return false;\n        }\n\n        // Command-line RPC\n        for (int i = 1; i < argc; i++)\n            if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"halcyon:\"))\n                fCommandLine = true;\n\n        if (fCommandLine)\n        {\n            int ret = CommandLineRPC(argc, argv);\n            exit(ret);\n        }\n\n        fRet = AppInit2();\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"AppInit()\");\n    } catch (...) {\n        PrintException(NULL, \"AppInit()\");\n    }\n    if (!fRet)\n        Shutdown(NULL);\n    return fRet;\n}"
        }
      },
      {
        "call_info": {
          "callee": "noui_connect",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "noui_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/noui.cpp",
          "lines": "23-28",
          "snippet": "void noui_connect()\n{\n    // Connect bitcoind signal handlers\n    uiInterface.ThreadSafeMessageBox.connect(noui_ThreadSafeMessageBox);\n    uiInterface.ThreadSafeAskFee.connect(noui_ThreadSafeAskFee);\n}",
          "includes": [
            "#include <string>",
            "#include \"bitcoinrpc.h\"",
            "#include \"init.h\"",
            "#include \"ui_interface.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include \"bitcoinrpc.h\"\n#include \"init.h\"\n#include \"ui_interface.h\"\n\nvoid noui_connect()\n{\n    // Connect bitcoind signal handlers\n    uiInterface.ThreadSafeMessageBox.connect(noui_ThreadSafeMessageBox);\n    uiInterface.ThreadSafeAskFee.connect(noui_ThreadSafeAskFee);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nint main(int argc, char* argv[])\n{\n    bool fRet = false;\n\n    // Connect bitcoind signal handlers\n    noui_connect();\n\n    fRet = AppInit(argc, argv);\n\n    if (fRet && fDaemon)\n        return 0;\n\n    return 1;\n}"
  },
  {
    "function_name": "AppInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "129-183",
    "snippet": "bool AppInit(int argc, char* argv[])\n{\n    bool fRet = false;\n    try\n    {\n        //\n        // Parameters\n        //\n        // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n        ParseParameters(argc, argv);\n        if (!boost::filesystem::is_directory(GetDataDir(false)))\n        {\n            fprintf(stderr, \"Error: Specified directory does not exist\\n\");\n            Shutdown(NULL);\n        }\n        ReadConfigFile(mapArgs, mapMultiArgs);\n\n        if (mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n        {\n            // First part of help message is specific to bitcoind / RPC client\n            std::string strUsage = _(\"Halcyon version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n                _(\"Usage:\") + \"\\n\" +\n                  \"  halcyond [options]                     \" + \"\\n\" +\n                  \"  halcyond [options] <command> [params]  \" + _(\"Send command to -server or halcyond\") + \"\\n\" +\n                  \"  halcyond [options] help                \" + _(\"List commands\") + \"\\n\" +\n                  \"  halcyond [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n\n            strUsage += \"\\n\" + HelpMessage();\n\n            fprintf(stdout, \"%s\", strUsage.c_str());\n            return false;\n        }\n\n        // Command-line RPC\n        for (int i = 1; i < argc; i++)\n            if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"halcyon:\"))\n                fCommandLine = true;\n\n        if (fCommandLine)\n        {\n            int ret = CommandLineRPC(argc, argv);\n            exit(ret);\n        }\n\n        fRet = AppInit2();\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"AppInit()\");\n    } catch (...) {\n        PrintException(NULL, \"AppInit()\");\n    }\n    if (!fRet)\n        Shutdown(NULL);\n    return fRet;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Shutdown",
          "args": [
            "NULL"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "Shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "63-108",
          "snippet": "void Shutdown(void* parg)\n{\n    static CCriticalSection cs_Shutdown;\n    static bool fTaken;\n\n    // Make this thread recognisable as the shutdown thread\n    RenameThread(\"hal-shutdown\");\n\n    bool fFirstThread = false;\n    {\n        TRY_LOCK(cs_Shutdown, lockShutdown);\n        if (lockShutdown)\n        {\n            fFirstThread = !fTaken;\n            fTaken = true;\n        }\n    }\n    static bool fExit;\n    if (fFirstThread)\n    {\n        printf(\"Shutdown() : in progress...\\n\");\n        fShutdown = true;\n        nTransactionsUpdated++;\n        bitdb.Flush(false);\n        StopNode();\n        bitdb.Flush(true);\n        boost::filesystem::remove(GetPidFile());\n        UnregisterWallet(pwalletMain);\n        delete pwalletMain;\n        NewThread(ExitTimeout, NULL);\n        fExit = true;\n        MilliSleep(1000);\n        printf(\"Shutdown() : completed\\n\\n\");\n#ifndef QT_GUI\n        // ensure non-UI client gets exited here, but let Bitcoin-Qt reach 'return 0;' in bitcoin.cpp\n        exit(0);\n#endif\n    }\n    else\n    {\n        while (!fExit)\n            MilliSleep(500);\n        MilliSleep(100);\n        ExitThread(0);\n    }\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CWallet* pwalletMain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCWallet* pwalletMain;\n\nvoid Shutdown(void* parg)\n{\n    static CCriticalSection cs_Shutdown;\n    static bool fTaken;\n\n    // Make this thread recognisable as the shutdown thread\n    RenameThread(\"hal-shutdown\");\n\n    bool fFirstThread = false;\n    {\n        TRY_LOCK(cs_Shutdown, lockShutdown);\n        if (lockShutdown)\n        {\n            fFirstThread = !fTaken;\n            fTaken = true;\n        }\n    }\n    static bool fExit;\n    if (fFirstThread)\n    {\n        printf(\"Shutdown() : in progress...\\n\");\n        fShutdown = true;\n        nTransactionsUpdated++;\n        bitdb.Flush(false);\n        StopNode();\n        bitdb.Flush(true);\n        boost::filesystem::remove(GetPidFile());\n        UnregisterWallet(pwalletMain);\n        delete pwalletMain;\n        NewThread(ExitTimeout, NULL);\n        fExit = true;\n        MilliSleep(1000);\n        printf(\"Shutdown() : completed\\n\\n\");\n#ifndef QT_GUI\n        // ensure non-UI client gets exited here, but let Bitcoin-Qt reach 'return 0;' in bitcoin.cpp\n        exit(0);\n#endif\n    }\n    else\n    {\n        while (!fExit)\n            MilliSleep(500);\n        MilliSleep(100);\n        ExitThread(0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "NULL",
            "\"AppInit()\""
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppInit2",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "AppInit2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "322-942",
          "snippet": "bool AppInit2()\n{\n    // ********************************************************* Step 1: setup\n#ifdef _MSC_VER\n    // Turn off Microsoft heap dump noise\n    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n    _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n#endif\n#if _MSC_VER >= 1400\n    // Disable confusing \"helpful\" text message on abort, Ctrl-C\n    _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n#endif\n#ifdef WIN32\n    // Enable Data Execution Prevention (DEP)\n    // Minimum supported OS versions: WinXP SP3, WinVista >= SP1, Win Server 2008\n    // A failure is non-critical and needs no further attention!\n#ifndef PROCESS_DEP_ENABLE\n// We define this here, because GCCs winbase.h limits this to _WIN32_WINNT >= 0x0601 (Windows 7),\n// which is not correct. Can be removed, when GCCs winbase.h is fixed!\n#define PROCESS_DEP_ENABLE 0x00000001\n#endif\n    typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n    PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n#endif\n#ifndef WIN32\n    umask(077);\n\n    // Clean shutdown on SIGTERM\n    struct sigaction sa;\n    sa.sa_handler = HandleSIGTERM;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGTERM, &sa, NULL);\n    sigaction(SIGINT, &sa, NULL);\n\n    // Reopen debug.log on SIGHUP\n    struct sigaction sa_hup;\n    sa_hup.sa_handler = HandleSIGHUP;\n    sigemptyset(&sa_hup.sa_mask);\n    sa_hup.sa_flags = 0;\n    sigaction(SIGHUP, &sa_hup, NULL);\n#endif\n\n    // ********************************************************* Step 2: parameter interactions\n\n    if(GetBoolArg(\"-sse2\", false)) {\n        printf(\"SSE2 assembly optimisations enabled\\n\");\n        nNeoScryptOptions |= 0x1000;\n    }\n\n    nNodeLifespan = GetArg(\"-addrlifespan\", 7);\n\n    nMinerSleep = GetArg(\"-minersleep\", 500);\n\n    CheckpointsMode = Checkpoints::STRICT;\n    std::string strCpMode = GetArg(\"-cppolicy\", \"strict\");\n\n    if(strCpMode == \"strict\")\n        CheckpointsMode = Checkpoints::STRICT;\n\n    if(strCpMode == \"advisory\")\n        CheckpointsMode = Checkpoints::ADVISORY;\n\n    if(strCpMode == \"permissive\")\n        CheckpointsMode = Checkpoints::PERMISSIVE;\n\n    nDerivationMethodIndex = 0;\n\n    fTestNet = GetBoolArg(\"-testnet\");\n    //fTestNet = true;\n    if (fTestNet) {\n        SoftSetBoolArg(\"-irc\", true);\n    }\n\n    if (mapArgs.count(\"-bind\")) {\n        // when specifying an explicit binding address, you want to listen on it\n        // even when -connect or -proxy is specified\n        SoftSetBoolArg(\"-listen\", true);\n    }\n\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0) {\n        // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n        SoftSetBoolArg(\"-dnsseed\", false);\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (mapArgs.count(\"-proxy\")) {\n        // to protect privacy, do not listen by default if a proxy server is specified\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (!GetBoolArg(\"-listen\", true)) {\n        // do not map ports or try to retrieve public IP when not listening (pointless)\n        SoftSetBoolArg(\"-upnp\", false);\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (mapArgs.count(\"-externalip\")) {\n        // if an explicit public IP is specified, do not try to find others\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\")) {\n        // Rewrite just private keys: rescan to find transactions\n        SoftSetBoolArg(\"-rescan\", true);\n    }\n\n    // ********************************************************* Step 3: parameter-to-internal-flags\n\n    fDebug = GetBoolArg(\"-debug\");\n\n    // -debug implies fDebug*\n    if (fDebug)\n        fDebugNet = true;\n    else\n        fDebugNet = GetBoolArg(\"-debugnet\");\n\n    bitdb.SetDetach(GetBoolArg(\"-detachdb\", false));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    fDaemon = GetBoolArg(\"-daemon\");\n#else\n    fDaemon = false;\n#endif\n\n    if (fDaemon)\n        fServer = true;\n    else\n        fServer = GetBoolArg(\"-server\");\n\n    /* force fServer when running without GUI */\n#if !defined(QT_GUI)\n    fServer = true;\n#endif\n    fPrintToConsole = GetBoolArg(\"-printtoconsole\");\n    fPrintToDebugger = GetBoolArg(\"-printtodebugger\");\n    fLogTimestamps = GetBoolArg(\"-logtimestamps\");\n\n    if (mapArgs.count(\"-timeout\"))\n    {\n        int nNewTimeout = GetArg(\"-timeout\", 5000);\n        if (nNewTimeout > 0 && nNewTimeout < 600000)\n            nConnectTimeout = nNewTimeout;\n    }\n\n    if (mapArgs.count(\"-paytxfee\"))\n    {\n        if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"].c_str()));\n        if (nTransactionFee > 0.25 * COIN)\n            InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n    }\n\n    fConfChange = GetBoolArg(\"-confchange\", false);\n    fEnforceCanonical = GetBoolArg(\"-enforcecanonical\", true);\n\n    if (mapArgs.count(\"-mininput\"))\n    {\n        if (!ParseMoney(mapArgs[\"-mininput\"], nMinimumInputValue))\n            return InitError(strprintf(_(\"Invalid amount for -mininput=<amount>: '%s'\"), mapArgs[\"-mininput\"].c_str()));\n    }\n\n    /* Try to combine inputs while staking up to this limit */\n    if(mapArgs.count(\"-stakecombine\")) {\n        if(!ParseMoney(mapArgs[\"-stakecombine\"], nCombineThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakecombine=<amount>: '%s'\"),\n            mapArgs[\"-stakecombine\"].c_str())));\n        if(nCombineThreshold < 10 * COIN)\n          nCombineThreshold = 10 * COIN;\n        if(nCombineThreshold > 1000 * COIN)\n          nCombineThreshold = 1000 * COIN;\n    }\n\n    /* Don't split outputs while staking below this limit */\n    if(mapArgs.count(\"-stakesplit\")) {\n        if(!ParseMoney(mapArgs[\"-stakesplit\"], nSplitThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakesplit=<amount>: '%s'\"),\n            mapArgs[\"-stakesplit\"].c_str())));\n        if(nSplitThreshold < 20 * COIN)\n          nSplitThreshold = 20 * COIN;\n        if(nSplitThreshold > 2000 * COIN)\n          nSplitThreshold = 2000 * COIN;\n    }\n\n    // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n\n    std::string strDataDir = GetDataDir().string();\n    std::string strWalletFileName = GetArg(\"-wallet\", \"wallet.dat\");\n\n    // strWalletFileName must be a plain filename without a directory\n    if (strWalletFileName != boost::filesystem::basename(strWalletFileName) + boost::filesystem::extension(strWalletFileName))\n        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s.\"), strWalletFileName.c_str(), strDataDir.c_str()));\n\n    // Make sure only a single Bitcoin process is using the data directory.\n    boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n    FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n    if (file) fclose(file);\n    static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n    if (!lock.try_lock())\n        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Halcyon is probably already running.\"), strDataDir.c_str()));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    if (fDaemon)\n    {\n        // Daemonize\n        pid_t pid = fork();\n        if (pid < 0)\n        {\n            fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n            return false;\n        }\n        if (pid > 0)\n        {\n            CreatePidFile(GetPidFile(), pid);\n            return true;\n        }\n\n        pid_t sid = setsid();\n        if (sid < 0)\n            fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n    }\n#endif\n\n    if (GetBoolArg(\"-shrinkdebugfile\", !fDebug))\n        ShrinkDebugFile();\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n    printf(\"Halcyon version %s (%s)\\n\", FormatFullVersion().c_str(), CLIENT_DATE.c_str());\n    printf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n    if (!fLogTimestamps)\n        printf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n    printf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n    printf(\"Used data directory %s\\n\", strDataDir.c_str());\n    std::ostringstream strErrors;\n\n    int64_t nStart;\n\n    // ********************************************************* Step 5: verify database integrity\n\n    uiInterface.InitMessage(_(\"Verifying database integrity...\"));\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\"))\n    {\n        // Recover readable keypairs:\n        if (!CWalletDB::Recover(bitdb, strWalletFileName, true))\n            return false;\n    }\n\n    if (filesystem::exists(GetDataDir() / strWalletFileName))\n    {\n        CDBEnv::VerifyResult r = bitdb.Verify(strWalletFileName, CWalletDB::Recover);\n        if (r == CDBEnv::RECOVER_OK)\n        {\n            string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n                                     \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n                                     \" your balance or transactions are incorrect you should\"\n                                     \" restore from a backup.\"), strDataDir.c_str());\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        if (r == CDBEnv::RECOVER_FAIL)\n            return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n    }\n\n    // ********************************************************* Step 6: network initialization\n\n    int nSocksVersion = GetArg(\"-socks\", 5);\n\n    if (nSocksVersion != 4 && nSocksVersion != 5)\n        return InitError(strprintf(_(\"Unknown -socks proxy version requested: %i\"), nSocksVersion));\n\n    if (mapArgs.count(\"-onlynet\")) {\n        std::set<enum Network> nets;\n        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n            enum Network net = ParseNetwork(snet);\n            if (net == NET_UNROUTABLE)\n                return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet.c_str()));\n            nets.insert(net);\n        }\n        for (int n = 0; n < NET_MAX; n++) {\n            enum Network net = (enum Network)n;\n            if (!nets.count(net))\n                SetLimited(net);\n        }\n    }\n#if defined(USE_IPV6)\n#if ! USE_IPV6\n    else\n        SetLimited(NET_IPV6);\n#endif\n#endif\n\n    CService addrProxy;\n    bool fProxy = false;\n    if (mapArgs.count(\"-proxy\")) {\n        addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n        if (!addrProxy.IsValid())\n            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n\n        if (!IsLimited(NET_IPV4))\n            SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n        if (nSocksVersion > 4) {\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                SetProxy(NET_IPV6, addrProxy, nSocksVersion);\n#endif\n            SetNameProxy(addrProxy, nSocksVersion);\n        }\n        fProxy = true;\n    }\n\n    // -tor can override normal proxy, -notor disables tor entirely\n    if (!(mapArgs.count(\"-tor\") && mapArgs[\"-tor\"] == \"0\") && (fProxy || mapArgs.count(\"-tor\"))) {\n        CService addrOnion;\n        if (!mapArgs.count(\"-tor\"))\n            addrOnion = addrProxy;\n        else\n            addrOnion = CService(mapArgs[\"-tor\"], 9050);\n        if (!addrOnion.IsValid())\n            return InitError(strprintf(_(\"Invalid -tor address: '%s'\"), mapArgs[\"-tor\"].c_str()));\n        SetProxy(NET_TOR, addrOnion, 5);\n        SetReachable(NET_TOR);\n    }\n\n    // see Step 2: parameter interactions for more information about these\n    fNoListen = !GetBoolArg(\"-listen\", true);\n    fDiscover = GetBoolArg(\"-discover\", true);\n    fNameLookup = GetBoolArg(\"-dns\", true);\n#ifdef USE_UPNP\n    fUseUPnP = GetBoolArg(\"-upnp\", USE_UPNP);\n#endif\n\n    bool fBound = false;\n    if (!fNoListen)\n    {\n        std::string strError;\n        if (mapArgs.count(\"-bind\")) {\n            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n                CService addrBind;\n                if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                    return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind.c_str()));\n                fBound |= Bind(addrBind);\n            }\n        } else {\n            struct in_addr inaddr_any;\n            inaddr_any.s_addr = INADDR_ANY;\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                fBound |= Bind(CService(in6addr_any, GetListenPort()), false);\n#endif\n            if (!IsLimited(NET_IPV4))\n                fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound);\n        }\n        if (!fBound)\n            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n    }\n\n    if (mapArgs.count(\"-externalip\"))\n    {\n        BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n            CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n            if (!addrLocal.IsValid())\n                return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr.c_str()));\n            AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n        }\n    }\n\n    if (mapArgs.count(\"-reservebalance\")) // ppcoin: reserve balance amount\n    {\n        if (!ParseMoney(mapArgs[\"-reservebalance\"], nReserveBalance))\n        {\n            InitError(_(\"Invalid amount for -reservebalance=<amount>\"));\n            return false;\n        }\n    }\n\n    if (mapArgs.count(\"-checkpointkey\")) // ppcoin: checkpoint master priv key\n    {\n        if (!Checkpoints::SetCheckpointPrivKey(GetArg(\"-checkpointkey\", \"\")))\n            InitError(_(\"Unable to sign checkpoint, wrong checkpointkey?\\n\"));\n    }\n\n    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n        AddOneShot(strDest);\n\n    // ********************************************************* Step 7: load blockchain\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-loadblockindextest\"))\n    {\n        CTxDB txdb(\"r\");\n        txdb.LoadBlockIndex();\n        PrintBlockTree();\n        return false;\n    }\n\n    uiInterface.InitMessage(_(\"Loading block index...\"));\n    printf(\"Loading block index...\\n\");\n    nStart = GetTimeMillis();\n    if (!LoadBlockIndex())\n        return InitError(_(\"Error loading blkindex.dat\"));\n\n\n    // as LoadBlockIndex can take several minutes, it's possible the user\n    // requested to kill bitcoin-qt during the last operation. If so, exit.\n    // As the program has not fully started yet, Shutdown() is possibly overkill.\n    if (fRequestShutdown)\n    {\n        printf(\"Shutdown requested. Exiting.\\n\");\n        return false;\n    }\n    printf(\" block index %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    if (GetBoolArg(\"-printblockindex\") || GetBoolArg(\"-printblocktree\"))\n    {\n        PrintBlockTree();\n        return false;\n    }\n\n    if (mapArgs.count(\"-printblock\"))\n    {\n        string strMatch = mapArgs[\"-printblock\"];\n        int nFound = 0;\n        for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n        {\n            uint256 hash = (*mi).first;\n            if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n            {\n                CBlockIndex* pindex = (*mi).second;\n                CBlock block;\n                block.ReadFromDisk(pindex);\n                block.BuildMerkleTree();\n                block.print();\n                printf(\"\\n\");\n                nFound++;\n            }\n        }\n        if (nFound == 0)\n            printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n        return false;\n    }\n\n    // ********************************************************* Step 8: load wallet\n\n    uiInterface.InitMessage(_(\"Loading wallet...\"));\n    printf(\"Loading wallet...\\n\");\n    nStart = GetTimeMillis();\n    bool fFirstRun = true;\n    pwalletMain = new CWallet(strWalletFileName);\n    DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n    if (nLoadWalletRet != DB_LOAD_OK)\n    {\n        if (nLoadWalletRet == DB_CORRUPT)\n            strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n        {\n            string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n                         \" or address book entries might be missing or incorrect.\"));\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        else if (nLoadWalletRet == DB_TOO_NEW)\n            strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Halcyon\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NEED_REWRITE)\n        {\n            strErrors << _(\"Wallet needed to be rewritten: restart Halcyon to complete\") << \"\\n\";\n            printf(\"%s\", strErrors.str().c_str());\n            return InitError(strErrors.str());\n        }\n        else\n            strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n    }\n\n    if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n    {\n        int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n        if (nMaxVersion == 0) // the -upgradewallet without argument case\n        {\n            printf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n            nMaxVersion = CLIENT_VERSION;\n            pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n        }\n        else\n            printf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n        if (nMaxVersion < pwalletMain->GetVersion())\n            strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n        pwalletMain->SetMaxVersion(nMaxVersion);\n    }\n\n    if (fFirstRun)\n    {\n        // Create new keyUser and set as default key\n        RandAddSeedPerfmon();\n\n        CPubKey newDefaultKey;\n        if (!pwalletMain->GetKeyFromPool(newDefaultKey, false))\n            strErrors << _(\"Cannot initialize keypool\") << \"\\n\";\n        pwalletMain->SetDefaultKey(newDefaultKey);\n        if (!pwalletMain->SetAddressBookName(pwalletMain->vchDefaultKey.GetID(), \"\"))\n            strErrors << _(\"Cannot write default address\") << \"\\n\";\n    }\n\n    printf(\"%s\", strErrors.str().c_str());\n    printf(\" wallet      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    RegisterWallet(pwalletMain);\n\n    CBlockIndex *pindexRescan = pindexBest;\n    if (GetBoolArg(\"-rescan\"))\n        pindexRescan = pindexGenesisBlock;\n    else\n    {\n        CWalletDB walletdb(strWalletFileName);\n        CBlockLocator locator;\n        if (walletdb.ReadBestBlock(locator))\n            pindexRescan = locator.GetBlockIndex();\n    }\n    if (pindexBest != pindexRescan && pindexBest && pindexRescan && pindexBest->nHeight > pindexRescan->nHeight)\n    {\n        uiInterface.InitMessage(_(\"Rescanning...\"));\n        printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n        nStart = GetTimeMillis();\n        pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n        printf(\" rescan      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n    }\n\n    // ********************************************************* Step 9: import blocks\n\n    if (mapArgs.count(\"-loadblock\"))\n    {\n        uiInterface.InitMessage(_(\"Importing blockchain data file.\"));\n\n        BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n        {\n            FILE *file = fopen(strFile.c_str(), \"rb\");\n            if (file)\n                LoadExternalBlockFile(file);\n        }\n        exit(0);\n    }\n\n    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n    if (filesystem::exists(pathBootstrap)) {\n        uiInterface.InitMessage(_(\"Importing bootstrap blockchain data file.\"));\n\n        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n        if (file) {\n            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n            LoadExternalBlockFile(file);\n            RenameOver(pathBootstrap, pathBootstrapOld);\n        }\n    }\n\n    // ********************************************************* Step 10: load peers\n\n    uiInterface.InitMessage(_(\"Loading addresses...\"));\n    printf(\"Loading addresses...\\n\");\n    nStart = GetTimeMillis();\n\n    {\n        CAddrDB adb;\n        if (!adb.Read(addrman))\n            printf(\"Invalid or missing peers.dat; recreating\\n\");\n    }\n\n    printf(\"Loaded %i addresses from peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n\n    // ********************************************************* Step 11: start node\n\n    if (!CheckDiskSpace())\n        return false;\n\n    RandAddSeedPerfmon();\n\n    //// debug print\n    printf(\"mapBlockIndex.size() = %\"PRIszu\"\\n\",   mapBlockIndex.size());\n    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n    printf(\"setKeyPool.size() = %\"PRIszu\"\\n\",      pwalletMain->setKeyPool.size());\n    printf(\"mapWallet.size() = %\"PRIszu\"\\n\",       pwalletMain->mapWallet.size());\n    printf(\"mapAddressBook.size() = %\"PRIszu\"\\n\",  pwalletMain->mapAddressBook.size());\n\n    if (!NewThread(StartNode, NULL))\n        InitError(_(\"Error: could not start node\"));\n\n    if (fServer)\n        NewThread(ThreadRPCServer, NULL);\n\n    // ********************************************************* Step 12: finished\n\n    uiInterface.InitMessage(_(\"Done loading\"));\n    printf(\"Done loading\\n\");\n\n    if (!strErrors.str().empty())\n        return InitError(strErrors.str());\n\n     // Add wallet transactions that aren't already in a block to mapTransactions\n    pwalletMain->ReacceptWalletTransactions();\n\n#if !defined(QT_GUI)\n    // Loop until process is exit()ed from shutdown() function,\n    // called from ThreadRPCServer thread when a \"stop\" command is received.\n    while (1)\n        MilliSleep(5000);\n#endif\n\n    return true;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [
            "#define PROCESS_DEP_ENABLE 0x00000001"
          ],
          "globals_used": [
            "CWallet* pwalletMain;",
            "CClientUIInterface uiInterface;",
            "std::string strWalletFileName;",
            "bool fConfChange;",
            "bool fEnforceCanonical;",
            "unsigned int nNodeLifespan;",
            "unsigned int nDerivationMethodIndex;",
            "unsigned int nMinerSleep;",
            "enum Checkpoints::CPMode CheckpointsMode;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\n#define PROCESS_DEP_ENABLE 0x00000001\n\nCWallet* pwalletMain;\nCClientUIInterface uiInterface;\nstd::string strWalletFileName;\nbool fConfChange;\nbool fEnforceCanonical;\nunsigned int nNodeLifespan;\nunsigned int nDerivationMethodIndex;\nunsigned int nMinerSleep;\nenum Checkpoints::CPMode CheckpointsMode;\n\nbool AppInit2()\n{\n    // ********************************************************* Step 1: setup\n#ifdef _MSC_VER\n    // Turn off Microsoft heap dump noise\n    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n    _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n#endif\n#if _MSC_VER >= 1400\n    // Disable confusing \"helpful\" text message on abort, Ctrl-C\n    _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n#endif\n#ifdef WIN32\n    // Enable Data Execution Prevention (DEP)\n    // Minimum supported OS versions: WinXP SP3, WinVista >= SP1, Win Server 2008\n    // A failure is non-critical and needs no further attention!\n#ifndef PROCESS_DEP_ENABLE\n// We define this here, because GCCs winbase.h limits this to _WIN32_WINNT >= 0x0601 (Windows 7),\n// which is not correct. Can be removed, when GCCs winbase.h is fixed!\n#define PROCESS_DEP_ENABLE 0x00000001\n#endif\n    typedef BOOL (WINAPI *PSETPROCDEPPOL)(DWORD);\n    PSETPROCDEPPOL setProcDEPPol = (PSETPROCDEPPOL)GetProcAddress(GetModuleHandleA(\"Kernel32.dll\"), \"SetProcessDEPPolicy\");\n    if (setProcDEPPol != NULL) setProcDEPPol(PROCESS_DEP_ENABLE);\n#endif\n#ifndef WIN32\n    umask(077);\n\n    // Clean shutdown on SIGTERM\n    struct sigaction sa;\n    sa.sa_handler = HandleSIGTERM;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sigaction(SIGTERM, &sa, NULL);\n    sigaction(SIGINT, &sa, NULL);\n\n    // Reopen debug.log on SIGHUP\n    struct sigaction sa_hup;\n    sa_hup.sa_handler = HandleSIGHUP;\n    sigemptyset(&sa_hup.sa_mask);\n    sa_hup.sa_flags = 0;\n    sigaction(SIGHUP, &sa_hup, NULL);\n#endif\n\n    // ********************************************************* Step 2: parameter interactions\n\n    if(GetBoolArg(\"-sse2\", false)) {\n        printf(\"SSE2 assembly optimisations enabled\\n\");\n        nNeoScryptOptions |= 0x1000;\n    }\n\n    nNodeLifespan = GetArg(\"-addrlifespan\", 7);\n\n    nMinerSleep = GetArg(\"-minersleep\", 500);\n\n    CheckpointsMode = Checkpoints::STRICT;\n    std::string strCpMode = GetArg(\"-cppolicy\", \"strict\");\n\n    if(strCpMode == \"strict\")\n        CheckpointsMode = Checkpoints::STRICT;\n\n    if(strCpMode == \"advisory\")\n        CheckpointsMode = Checkpoints::ADVISORY;\n\n    if(strCpMode == \"permissive\")\n        CheckpointsMode = Checkpoints::PERMISSIVE;\n\n    nDerivationMethodIndex = 0;\n\n    fTestNet = GetBoolArg(\"-testnet\");\n    //fTestNet = true;\n    if (fTestNet) {\n        SoftSetBoolArg(\"-irc\", true);\n    }\n\n    if (mapArgs.count(\"-bind\")) {\n        // when specifying an explicit binding address, you want to listen on it\n        // even when -connect or -proxy is specified\n        SoftSetBoolArg(\"-listen\", true);\n    }\n\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0) {\n        // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n        SoftSetBoolArg(\"-dnsseed\", false);\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (mapArgs.count(\"-proxy\")) {\n        // to protect privacy, do not listen by default if a proxy server is specified\n        SoftSetBoolArg(\"-listen\", false);\n    }\n\n    if (!GetBoolArg(\"-listen\", true)) {\n        // do not map ports or try to retrieve public IP when not listening (pointless)\n        SoftSetBoolArg(\"-upnp\", false);\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (mapArgs.count(\"-externalip\")) {\n        // if an explicit public IP is specified, do not try to find others\n        SoftSetBoolArg(\"-discover\", false);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\")) {\n        // Rewrite just private keys: rescan to find transactions\n        SoftSetBoolArg(\"-rescan\", true);\n    }\n\n    // ********************************************************* Step 3: parameter-to-internal-flags\n\n    fDebug = GetBoolArg(\"-debug\");\n\n    // -debug implies fDebug*\n    if (fDebug)\n        fDebugNet = true;\n    else\n        fDebugNet = GetBoolArg(\"-debugnet\");\n\n    bitdb.SetDetach(GetBoolArg(\"-detachdb\", false));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    fDaemon = GetBoolArg(\"-daemon\");\n#else\n    fDaemon = false;\n#endif\n\n    if (fDaemon)\n        fServer = true;\n    else\n        fServer = GetBoolArg(\"-server\");\n\n    /* force fServer when running without GUI */\n#if !defined(QT_GUI)\n    fServer = true;\n#endif\n    fPrintToConsole = GetBoolArg(\"-printtoconsole\");\n    fPrintToDebugger = GetBoolArg(\"-printtodebugger\");\n    fLogTimestamps = GetBoolArg(\"-logtimestamps\");\n\n    if (mapArgs.count(\"-timeout\"))\n    {\n        int nNewTimeout = GetArg(\"-timeout\", 5000);\n        if (nNewTimeout > 0 && nNewTimeout < 600000)\n            nConnectTimeout = nNewTimeout;\n    }\n\n    if (mapArgs.count(\"-paytxfee\"))\n    {\n        if (!ParseMoney(mapArgs[\"-paytxfee\"], nTransactionFee))\n            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s'\"), mapArgs[\"-paytxfee\"].c_str()));\n        if (nTransactionFee > 0.25 * COIN)\n            InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n    }\n\n    fConfChange = GetBoolArg(\"-confchange\", false);\n    fEnforceCanonical = GetBoolArg(\"-enforcecanonical\", true);\n\n    if (mapArgs.count(\"-mininput\"))\n    {\n        if (!ParseMoney(mapArgs[\"-mininput\"], nMinimumInputValue))\n            return InitError(strprintf(_(\"Invalid amount for -mininput=<amount>: '%s'\"), mapArgs[\"-mininput\"].c_str()));\n    }\n\n    /* Try to combine inputs while staking up to this limit */\n    if(mapArgs.count(\"-stakecombine\")) {\n        if(!ParseMoney(mapArgs[\"-stakecombine\"], nCombineThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakecombine=<amount>: '%s'\"),\n            mapArgs[\"-stakecombine\"].c_str())));\n        if(nCombineThreshold < 10 * COIN)\n          nCombineThreshold = 10 * COIN;\n        if(nCombineThreshold > 1000 * COIN)\n          nCombineThreshold = 1000 * COIN;\n    }\n\n    /* Don't split outputs while staking below this limit */\n    if(mapArgs.count(\"-stakesplit\")) {\n        if(!ParseMoney(mapArgs[\"-stakesplit\"], nSplitThreshold))\n          return(InitError(strprintf(_(\"Invalid amount for -stakesplit=<amount>: '%s'\"),\n            mapArgs[\"-stakesplit\"].c_str())));\n        if(nSplitThreshold < 20 * COIN)\n          nSplitThreshold = 20 * COIN;\n        if(nSplitThreshold > 2000 * COIN)\n          nSplitThreshold = 2000 * COIN;\n    }\n\n    // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n\n    std::string strDataDir = GetDataDir().string();\n    std::string strWalletFileName = GetArg(\"-wallet\", \"wallet.dat\");\n\n    // strWalletFileName must be a plain filename without a directory\n    if (strWalletFileName != boost::filesystem::basename(strWalletFileName) + boost::filesystem::extension(strWalletFileName))\n        return InitError(strprintf(_(\"Wallet %s resides outside data directory %s.\"), strWalletFileName.c_str(), strDataDir.c_str()));\n\n    // Make sure only a single Bitcoin process is using the data directory.\n    boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n    FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n    if (file) fclose(file);\n    static boost::interprocess::file_lock lock(pathLockFile.string().c_str());\n    if (!lock.try_lock())\n        return InitError(strprintf(_(\"Cannot obtain a lock on data directory %s.  Halcyon is probably already running.\"), strDataDir.c_str()));\n\n#if !defined(WIN32) && !defined(QT_GUI)\n    if (fDaemon)\n    {\n        // Daemonize\n        pid_t pid = fork();\n        if (pid < 0)\n        {\n            fprintf(stderr, \"Error: fork() returned %d errno %d\\n\", pid, errno);\n            return false;\n        }\n        if (pid > 0)\n        {\n            CreatePidFile(GetPidFile(), pid);\n            return true;\n        }\n\n        pid_t sid = setsid();\n        if (sid < 0)\n            fprintf(stderr, \"Error: setsid() returned %d errno %d\\n\", sid, errno);\n    }\n#endif\n\n    if (GetBoolArg(\"-shrinkdebugfile\", !fDebug))\n        ShrinkDebugFile();\n    printf(\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\");\n    printf(\"Halcyon version %s (%s)\\n\", FormatFullVersion().c_str(), CLIENT_DATE.c_str());\n    printf(\"Using OpenSSL version %s\\n\", SSLeay_version(SSLEAY_VERSION));\n    if (!fLogTimestamps)\n        printf(\"Startup time: %s\\n\", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n    printf(\"Default data directory %s\\n\", GetDefaultDataDir().string().c_str());\n    printf(\"Used data directory %s\\n\", strDataDir.c_str());\n    std::ostringstream strErrors;\n\n    int64_t nStart;\n\n    // ********************************************************* Step 5: verify database integrity\n\n    uiInterface.InitMessage(_(\"Verifying database integrity...\"));\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-salvagewallet\"))\n    {\n        // Recover readable keypairs:\n        if (!CWalletDB::Recover(bitdb, strWalletFileName, true))\n            return false;\n    }\n\n    if (filesystem::exists(GetDataDir() / strWalletFileName))\n    {\n        CDBEnv::VerifyResult r = bitdb.Verify(strWalletFileName, CWalletDB::Recover);\n        if (r == CDBEnv::RECOVER_OK)\n        {\n            string msg = strprintf(_(\"Warning: wallet.dat corrupt, data salvaged!\"\n                                     \" Original wallet.dat saved as wallet.{timestamp}.bak in %s; if\"\n                                     \" your balance or transactions are incorrect you should\"\n                                     \" restore from a backup.\"), strDataDir.c_str());\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        if (r == CDBEnv::RECOVER_FAIL)\n            return InitError(_(\"wallet.dat corrupt, salvage failed\"));\n    }\n\n    // ********************************************************* Step 6: network initialization\n\n    int nSocksVersion = GetArg(\"-socks\", 5);\n\n    if (nSocksVersion != 4 && nSocksVersion != 5)\n        return InitError(strprintf(_(\"Unknown -socks proxy version requested: %i\"), nSocksVersion));\n\n    if (mapArgs.count(\"-onlynet\")) {\n        std::set<enum Network> nets;\n        BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n            enum Network net = ParseNetwork(snet);\n            if (net == NET_UNROUTABLE)\n                return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet.c_str()));\n            nets.insert(net);\n        }\n        for (int n = 0; n < NET_MAX; n++) {\n            enum Network net = (enum Network)n;\n            if (!nets.count(net))\n                SetLimited(net);\n        }\n    }\n#if defined(USE_IPV6)\n#if ! USE_IPV6\n    else\n        SetLimited(NET_IPV6);\n#endif\n#endif\n\n    CService addrProxy;\n    bool fProxy = false;\n    if (mapArgs.count(\"-proxy\")) {\n        addrProxy = CService(mapArgs[\"-proxy\"], 9050);\n        if (!addrProxy.IsValid())\n            return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"].c_str()));\n\n        if (!IsLimited(NET_IPV4))\n            SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n        if (nSocksVersion > 4) {\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                SetProxy(NET_IPV6, addrProxy, nSocksVersion);\n#endif\n            SetNameProxy(addrProxy, nSocksVersion);\n        }\n        fProxy = true;\n    }\n\n    // -tor can override normal proxy, -notor disables tor entirely\n    if (!(mapArgs.count(\"-tor\") && mapArgs[\"-tor\"] == \"0\") && (fProxy || mapArgs.count(\"-tor\"))) {\n        CService addrOnion;\n        if (!mapArgs.count(\"-tor\"))\n            addrOnion = addrProxy;\n        else\n            addrOnion = CService(mapArgs[\"-tor\"], 9050);\n        if (!addrOnion.IsValid())\n            return InitError(strprintf(_(\"Invalid -tor address: '%s'\"), mapArgs[\"-tor\"].c_str()));\n        SetProxy(NET_TOR, addrOnion, 5);\n        SetReachable(NET_TOR);\n    }\n\n    // see Step 2: parameter interactions for more information about these\n    fNoListen = !GetBoolArg(\"-listen\", true);\n    fDiscover = GetBoolArg(\"-discover\", true);\n    fNameLookup = GetBoolArg(\"-dns\", true);\n#ifdef USE_UPNP\n    fUseUPnP = GetBoolArg(\"-upnp\", USE_UPNP);\n#endif\n\n    bool fBound = false;\n    if (!fNoListen)\n    {\n        std::string strError;\n        if (mapArgs.count(\"-bind\")) {\n            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n                CService addrBind;\n                if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                    return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind.c_str()));\n                fBound |= Bind(addrBind);\n            }\n        } else {\n            struct in_addr inaddr_any;\n            inaddr_any.s_addr = INADDR_ANY;\n#ifdef USE_IPV6\n            if (!IsLimited(NET_IPV6))\n                fBound |= Bind(CService(in6addr_any, GetListenPort()), false);\n#endif\n            if (!IsLimited(NET_IPV4))\n                fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound);\n        }\n        if (!fBound)\n            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n    }\n\n    if (mapArgs.count(\"-externalip\"))\n    {\n        BOOST_FOREACH(string strAddr, mapMultiArgs[\"-externalip\"]) {\n            CService addrLocal(strAddr, GetListenPort(), fNameLookup);\n            if (!addrLocal.IsValid())\n                return InitError(strprintf(_(\"Cannot resolve -externalip address: '%s'\"), strAddr.c_str()));\n            AddLocal(CService(strAddr, GetListenPort(), fNameLookup), LOCAL_MANUAL);\n        }\n    }\n\n    if (mapArgs.count(\"-reservebalance\")) // ppcoin: reserve balance amount\n    {\n        if (!ParseMoney(mapArgs[\"-reservebalance\"], nReserveBalance))\n        {\n            InitError(_(\"Invalid amount for -reservebalance=<amount>\"));\n            return false;\n        }\n    }\n\n    if (mapArgs.count(\"-checkpointkey\")) // ppcoin: checkpoint master priv key\n    {\n        if (!Checkpoints::SetCheckpointPrivKey(GetArg(\"-checkpointkey\", \"\")))\n            InitError(_(\"Unable to sign checkpoint, wrong checkpointkey?\\n\"));\n    }\n\n    BOOST_FOREACH(string strDest, mapMultiArgs[\"-seednode\"])\n        AddOneShot(strDest);\n\n    // ********************************************************* Step 7: load blockchain\n\n    if (!bitdb.Open(GetDataDir()))\n    {\n        string msg = strprintf(_(\"Error initializing database environment %s!\"\n                                 \" To recover, BACKUP THAT DIRECTORY, then remove\"\n                                 \" everything from it except for wallet.dat.\"), strDataDir.c_str());\n        return InitError(msg);\n    }\n\n    if (GetBoolArg(\"-loadblockindextest\"))\n    {\n        CTxDB txdb(\"r\");\n        txdb.LoadBlockIndex();\n        PrintBlockTree();\n        return false;\n    }\n\n    uiInterface.InitMessage(_(\"Loading block index...\"));\n    printf(\"Loading block index...\\n\");\n    nStart = GetTimeMillis();\n    if (!LoadBlockIndex())\n        return InitError(_(\"Error loading blkindex.dat\"));\n\n\n    // as LoadBlockIndex can take several minutes, it's possible the user\n    // requested to kill bitcoin-qt during the last operation. If so, exit.\n    // As the program has not fully started yet, Shutdown() is possibly overkill.\n    if (fRequestShutdown)\n    {\n        printf(\"Shutdown requested. Exiting.\\n\");\n        return false;\n    }\n    printf(\" block index %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    if (GetBoolArg(\"-printblockindex\") || GetBoolArg(\"-printblocktree\"))\n    {\n        PrintBlockTree();\n        return false;\n    }\n\n    if (mapArgs.count(\"-printblock\"))\n    {\n        string strMatch = mapArgs[\"-printblock\"];\n        int nFound = 0;\n        for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n        {\n            uint256 hash = (*mi).first;\n            if (strncmp(hash.ToString().c_str(), strMatch.c_str(), strMatch.size()) == 0)\n            {\n                CBlockIndex* pindex = (*mi).second;\n                CBlock block;\n                block.ReadFromDisk(pindex);\n                block.BuildMerkleTree();\n                block.print();\n                printf(\"\\n\");\n                nFound++;\n            }\n        }\n        if (nFound == 0)\n            printf(\"No blocks matching %s were found\\n\", strMatch.c_str());\n        return false;\n    }\n\n    // ********************************************************* Step 8: load wallet\n\n    uiInterface.InitMessage(_(\"Loading wallet...\"));\n    printf(\"Loading wallet...\\n\");\n    nStart = GetTimeMillis();\n    bool fFirstRun = true;\n    pwalletMain = new CWallet(strWalletFileName);\n    DBErrors nLoadWalletRet = pwalletMain->LoadWallet(fFirstRun);\n    if (nLoadWalletRet != DB_LOAD_OK)\n    {\n        if (nLoadWalletRet == DB_CORRUPT)\n            strErrors << _(\"Error loading wallet.dat: Wallet corrupted\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NONCRITICAL_ERROR)\n        {\n            string msg(_(\"Warning: error reading wallet.dat! All keys read correctly, but transaction data\"\n                         \" or address book entries might be missing or incorrect.\"));\n            uiInterface.ThreadSafeMessageBox(msg, _(\"Halcyon\"), CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        }\n        else if (nLoadWalletRet == DB_TOO_NEW)\n            strErrors << _(\"Error loading wallet.dat: Wallet requires newer version of Halcyon\") << \"\\n\";\n        else if (nLoadWalletRet == DB_NEED_REWRITE)\n        {\n            strErrors << _(\"Wallet needed to be rewritten: restart Halcyon to complete\") << \"\\n\";\n            printf(\"%s\", strErrors.str().c_str());\n            return InitError(strErrors.str());\n        }\n        else\n            strErrors << _(\"Error loading wallet.dat\") << \"\\n\";\n    }\n\n    if (GetBoolArg(\"-upgradewallet\", fFirstRun))\n    {\n        int nMaxVersion = GetArg(\"-upgradewallet\", 0);\n        if (nMaxVersion == 0) // the -upgradewallet without argument case\n        {\n            printf(\"Performing wallet upgrade to %i\\n\", FEATURE_LATEST);\n            nMaxVersion = CLIENT_VERSION;\n            pwalletMain->SetMinVersion(FEATURE_LATEST); // permanently upgrade the wallet immediately\n        }\n        else\n            printf(\"Allowing wallet upgrade up to %i\\n\", nMaxVersion);\n        if (nMaxVersion < pwalletMain->GetVersion())\n            strErrors << _(\"Cannot downgrade wallet\") << \"\\n\";\n        pwalletMain->SetMaxVersion(nMaxVersion);\n    }\n\n    if (fFirstRun)\n    {\n        // Create new keyUser and set as default key\n        RandAddSeedPerfmon();\n\n        CPubKey newDefaultKey;\n        if (!pwalletMain->GetKeyFromPool(newDefaultKey, false))\n            strErrors << _(\"Cannot initialize keypool\") << \"\\n\";\n        pwalletMain->SetDefaultKey(newDefaultKey);\n        if (!pwalletMain->SetAddressBookName(pwalletMain->vchDefaultKey.GetID(), \"\"))\n            strErrors << _(\"Cannot write default address\") << \"\\n\";\n    }\n\n    printf(\"%s\", strErrors.str().c_str());\n    printf(\" wallet      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n\n    RegisterWallet(pwalletMain);\n\n    CBlockIndex *pindexRescan = pindexBest;\n    if (GetBoolArg(\"-rescan\"))\n        pindexRescan = pindexGenesisBlock;\n    else\n    {\n        CWalletDB walletdb(strWalletFileName);\n        CBlockLocator locator;\n        if (walletdb.ReadBestBlock(locator))\n            pindexRescan = locator.GetBlockIndex();\n    }\n    if (pindexBest != pindexRescan && pindexBest && pindexRescan && pindexBest->nHeight > pindexRescan->nHeight)\n    {\n        uiInterface.InitMessage(_(\"Rescanning...\"));\n        printf(\"Rescanning last %i blocks (from block %i)...\\n\", pindexBest->nHeight - pindexRescan->nHeight, pindexRescan->nHeight);\n        nStart = GetTimeMillis();\n        pwalletMain->ScanForWalletTransactions(pindexRescan, true);\n        printf(\" rescan      %15\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n    }\n\n    // ********************************************************* Step 9: import blocks\n\n    if (mapArgs.count(\"-loadblock\"))\n    {\n        uiInterface.InitMessage(_(\"Importing blockchain data file.\"));\n\n        BOOST_FOREACH(string strFile, mapMultiArgs[\"-loadblock\"])\n        {\n            FILE *file = fopen(strFile.c_str(), \"rb\");\n            if (file)\n                LoadExternalBlockFile(file);\n        }\n        exit(0);\n    }\n\n    filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n    if (filesystem::exists(pathBootstrap)) {\n        uiInterface.InitMessage(_(\"Importing bootstrap blockchain data file.\"));\n\n        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n        if (file) {\n            filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n            LoadExternalBlockFile(file);\n            RenameOver(pathBootstrap, pathBootstrapOld);\n        }\n    }\n\n    // ********************************************************* Step 10: load peers\n\n    uiInterface.InitMessage(_(\"Loading addresses...\"));\n    printf(\"Loading addresses...\\n\");\n    nStart = GetTimeMillis();\n\n    {\n        CAddrDB adb;\n        if (!adb.Read(addrman))\n            printf(\"Invalid or missing peers.dat; recreating\\n\");\n    }\n\n    printf(\"Loaded %i addresses from peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n\n    // ********************************************************* Step 11: start node\n\n    if (!CheckDiskSpace())\n        return false;\n\n    RandAddSeedPerfmon();\n\n    //// debug print\n    printf(\"mapBlockIndex.size() = %\"PRIszu\"\\n\",   mapBlockIndex.size());\n    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n    printf(\"setKeyPool.size() = %\"PRIszu\"\\n\",      pwalletMain->setKeyPool.size());\n    printf(\"mapWallet.size() = %\"PRIszu\"\\n\",       pwalletMain->mapWallet.size());\n    printf(\"mapAddressBook.size() = %\"PRIszu\"\\n\",  pwalletMain->mapAddressBook.size());\n\n    if (!NewThread(StartNode, NULL))\n        InitError(_(\"Error: could not start node\"));\n\n    if (fServer)\n        NewThread(ThreadRPCServer, NULL);\n\n    // ********************************************************* Step 12: finished\n\n    uiInterface.InitMessage(_(\"Done loading\"));\n    printf(\"Done loading\\n\");\n\n    if (!strErrors.str().empty())\n        return InitError(strErrors.str());\n\n     // Add wallet transactions that aren't already in a block to mapTransactions\n    pwalletMain->ReacceptWalletTransactions();\n\n#if !defined(QT_GUI)\n    // Loop until process is exit()ed from shutdown() function,\n    // called from ThreadRPCServer thread when a \"stop\" command is received.\n    while (1)\n        MilliSleep(5000);\n#endif\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "ret"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CommandLineRPC",
          "args": [
            "argc",
            "argv"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "CommandLineRPC",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "1291-1353",
          "snippet": "int CommandLineRPC(int argc, char *argv[])\n{\n    string strPrint;\n    int nRet = 0;\n    try\n    {\n        // Skip switches\n        while (argc > 1 && IsSwitchChar(argv[1][0]))\n        {\n            argc--;\n            argv++;\n        }\n\n        // Method\n        if (argc < 2)\n            throw runtime_error(\"too few parameters\");\n        string strMethod = argv[1];\n\n        // Parameters default to strings\n        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n        Array params = RPCConvertValues(strMethod, strParams);\n\n        // Execute\n        Object reply = CallRPC(strMethod, params);\n\n        // Parse reply\n        const Value& result = find_value(reply, \"result\");\n        const Value& error  = find_value(reply, \"error\");\n\n        if (error.type() != null_type)\n        {\n            // Error\n            strPrint = \"error: \" + write_string(error, false);\n            int code = find_value(error.get_obj(), \"code\").get_int();\n            nRet = abs(code);\n        }\n        else\n        {\n            // Result\n            if (result.type() == null_type)\n                strPrint = \"\";\n            else if (result.type() == str_type)\n                strPrint = result.get_str();\n            else\n                strPrint = write_string(result, true);\n        }\n    }\n    catch (std::exception& e)\n    {\n        strPrint = string(\"error: \") + e.what();\n        nRet = 87;\n    }\n    catch (...)\n    {\n        PrintException(NULL, \"CommandLineRPC()\");\n    }\n\n    if (strPrint != \"\")\n    {\n        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n    }\n    return nRet;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nint CommandLineRPC(int argc, char *argv[])\n{\n    string strPrint;\n    int nRet = 0;\n    try\n    {\n        // Skip switches\n        while (argc > 1 && IsSwitchChar(argv[1][0]))\n        {\n            argc--;\n            argv++;\n        }\n\n        // Method\n        if (argc < 2)\n            throw runtime_error(\"too few parameters\");\n        string strMethod = argv[1];\n\n        // Parameters default to strings\n        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n        Array params = RPCConvertValues(strMethod, strParams);\n\n        // Execute\n        Object reply = CallRPC(strMethod, params);\n\n        // Parse reply\n        const Value& result = find_value(reply, \"result\");\n        const Value& error  = find_value(reply, \"error\");\n\n        if (error.type() != null_type)\n        {\n            // Error\n            strPrint = \"error: \" + write_string(error, false);\n            int code = find_value(error.get_obj(), \"code\").get_int();\n            nRet = abs(code);\n        }\n        else\n        {\n            // Result\n            if (result.type() == null_type)\n                strPrint = \"\";\n            else if (result.type() == str_type)\n                strPrint = result.get_str();\n            else\n                strPrint = write_string(result, true);\n        }\n    }\n    catch (std::exception& e)\n    {\n        strPrint = string(\"error: \") + e.what();\n        nRet = 87;\n    }\n    catch (...)\n    {\n        PrintException(NULL, \"CommandLineRPC()\");\n    }\n\n    if (strPrint != \"\")\n    {\n        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n    }\n    return nRet;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boost::algorithm::istarts_with",
          "args": [
            "argv[i]",
            "\"halcyon:\""
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsSwitchChar",
          "args": [
            "argv[i][0]"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "IsSwitchChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "399-406",
          "snippet": "inline bool IsSwitchChar(char c)\n{\n#ifdef WIN32\n    return c == '-' || c == '/';\n#else\n    return c == '-';\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline bool IsSwitchChar(char c)\n{\n#ifdef WIN32\n    return c == '-' || c == '/';\n#else\n    return c == '-';\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stdout",
            "\"%s\"",
            "strUsage.c_str()"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strUsage.c_str",
          "args": [],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HelpMessage",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "HelpMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "228-317",
          "snippet": "std::string HelpMessage()\n{\n    string strUsage = _(\"Options:\") + \"\\n\" +\n        \"  -?                     \" + _(\"This help message\") + \"\\n\" +\n        \"  -conf=<file>           \" + _(\"Specify configuration file (default: halcyon.conf)\") + \"\\n\" +\n        \"  -pid=<file>            \" + _(\"Specify pid file (default: halcyond.pid)\") + \"\\n\" +\n        \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\" +\n        \"  -wallet=<dir>          \" + _(\"Specify wallet file (within data directory)\") + \"\\n\" +\n        \"  -dbcache=<n>           \" + _(\"Set database cache size in megabytes (default: 25)\") + \"\\n\" +\n        \"  -dblogsize=<n>         \" + _(\"Set database disk log size in megabytes (default: 100)\") + \"\\n\" +\n        \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\" +\n        \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\" +\n        \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\" +\n        \"  -tor=<ip:port>         \" + _(\"Use proxy to reach tor hidden services (default: same as -proxy)\") + \"\\n\"\n        \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\" +\n        \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 21108 or testnet: 11108)\") + \"\\n\" +\n        \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\" +\n        \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\" +\n        \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\" +\n        \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\" +\n        \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\" +\n        \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\" +\n        \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\" +\n        \"  -irc                   \" + _(\"Find peers using internet relay chat (default: 1)\") + \"\\n\" +\n        \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\" +\n        \"  -bind=<addr>           \" + _(\"Bind to given address. Use [host]:port notation for IPv6\") + \"\\n\" +\n        \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1)\") + \"\\n\" +\n        \"  -staking               \" + _(\"Stake your coins to support network and gain reward (default: 1)\") + \"\\n\" +\n        \"  -synctime              \" + _(\"Sync time with other nodes. Disable if time on your system is precise e.g. syncing with NTP (default: 1)\") + \"\\n\" +\n        \"  -cppolicy              \" + _(\"Sync checkpoints policy (default: strict)\") + \"\\n\" +\n        \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\" +\n        \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\" +\n        \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\" +\n        \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\" +\n#ifdef USE_UPNP\n#if USE_UPNP\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\" +\n#else\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\" +\n#endif\n#endif\n        \"  -detachdb              \" + _(\"Detach block and address databases. Increases shutdown time (default: 0)\") + \"\\n\" +\n        \"  -paytxfee=<amt>        \" + _(\"Fee per KB to add to transactions you send\") + \"\\n\" +\n        \"  -mininput=<amt>        \" + _(\"When creating transactions, ignore inputs with value less than this (default: 0.01)\") + \"\\n\" +\n#ifdef QT_GUI\n        \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\" +\n#endif\n#if !defined(WIN32) && !defined(QT_GUI)\n        \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\" +\n#endif\n        \"  -testnet               \" + _(\"Use the test network\") + \"\\n\" +\n        \"  -debug                 \" + _(\"Output extra debugging information. Implies all other -debug* options\") + \"\\n\" +\n        \"  -debugnet              \" + _(\"Output extra network debugging information\") + \"\\n\" +\n        \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp\") + \"\\n\" +\n        \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\" +\n        \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\" +\n#ifdef WIN32\n        \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\" +\n#endif\n        \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 21109 or testnet: 35615)\") + \"\\n\" +\n        \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\" +\n        \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\" +\n        \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\" +\n        \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\" +\n        \"  -confchange            \" + _(\"Require a confirmations for change (default: 0)\") + \"\\n\" +\n        \"  -enforcecanonical      \" + _(\"Enforce transaction scripts to use canonical PUSH operators (default: 1)\") + \"\\n\" +\n        \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received (%s in cmd is replaced by message)\") + \"\\n\" +\n        \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\" +\n        \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\" +\n        \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\" +\n        \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\" +\n        \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 2500, 0 = all)\") + \"\\n\" +\n        \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-6, default: 1)\") + \"\\n\" +\n        \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000?.dat file\") + \"\\n\" +\n\n        \"\\n\" + _(\"Block creation options:\") + \"\\n\" +\n        \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\" +\n        \"  -blockmaxsize=<n>      \"   + _(\"Set maximum block size in bytes (default: 250000)\") + \"\\n\" +\n        \"  -blockprioritysize=<n> \"   + _(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") + \"\\n\" +\n\n        \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\" +\n        \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\" +\n        \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\" +\n        \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\") + \"\\n\";\n\n    return strUsage;\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nstd::string HelpMessage()\n{\n    string strUsage = _(\"Options:\") + \"\\n\" +\n        \"  -?                     \" + _(\"This help message\") + \"\\n\" +\n        \"  -conf=<file>           \" + _(\"Specify configuration file (default: halcyon.conf)\") + \"\\n\" +\n        \"  -pid=<file>            \" + _(\"Specify pid file (default: halcyond.pid)\") + \"\\n\" +\n        \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\" +\n        \"  -wallet=<dir>          \" + _(\"Specify wallet file (within data directory)\") + \"\\n\" +\n        \"  -dbcache=<n>           \" + _(\"Set database cache size in megabytes (default: 25)\") + \"\\n\" +\n        \"  -dblogsize=<n>         \" + _(\"Set database disk log size in megabytes (default: 100)\") + \"\\n\" +\n        \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\" +\n        \"  -proxy=<ip:port>       \" + _(\"Connect through socks proxy\") + \"\\n\" +\n        \"  -socks=<n>             \" + _(\"Select the version of socks proxy to use (4-5, default: 5)\") + \"\\n\" +\n        \"  -tor=<ip:port>         \" + _(\"Use proxy to reach tor hidden services (default: same as -proxy)\") + \"\\n\"\n        \"  -dns                   \" + _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \"\\n\" +\n        \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 21108 or testnet: 11108)\") + \"\\n\" +\n        \"  -maxconnections=<n>    \" + _(\"Maintain at most <n> connections to peers (default: 125)\") + \"\\n\" +\n        \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\" +\n        \"  -connect=<ip>          \" + _(\"Connect only to the specified node(s)\") + \"\\n\" +\n        \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\" +\n        \"  -externalip=<ip>       \" + _(\"Specify your own public address\") + \"\\n\" +\n        \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\" +\n        \"  -discover              \" + _(\"Discover own IP address (default: 1 when listening and no -externalip)\") + \"\\n\" +\n        \"  -irc                   \" + _(\"Find peers using internet relay chat (default: 1)\") + \"\\n\" +\n        \"  -listen                \" + _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\") + \"\\n\" +\n        \"  -bind=<addr>           \" + _(\"Bind to given address. Use [host]:port notation for IPv6\") + \"\\n\" +\n        \"  -dnsseed               \" + _(\"Find peers using DNS lookup (default: 1)\") + \"\\n\" +\n        \"  -staking               \" + _(\"Stake your coins to support network and gain reward (default: 1)\") + \"\\n\" +\n        \"  -synctime              \" + _(\"Sync time with other nodes. Disable if time on your system is precise e.g. syncing with NTP (default: 1)\") + \"\\n\" +\n        \"  -cppolicy              \" + _(\"Sync checkpoints policy (default: strict)\") + \"\\n\" +\n        \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\" +\n        \"  -bantime=<n>           \" + _(\"Number of seconds to keep misbehaving peers from reconnecting (default: 86400)\") + \"\\n\" +\n        \"  -maxreceivebuffer=<n>  \" + _(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\") + \"\\n\" +\n        \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\" +\n#ifdef USE_UPNP\n#if USE_UPNP\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 1 when listening)\") + \"\\n\" +\n#else\n        \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\" +\n#endif\n#endif\n        \"  -detachdb              \" + _(\"Detach block and address databases. Increases shutdown time (default: 0)\") + \"\\n\" +\n        \"  -paytxfee=<amt>        \" + _(\"Fee per KB to add to transactions you send\") + \"\\n\" +\n        \"  -mininput=<amt>        \" + _(\"When creating transactions, ignore inputs with value less than this (default: 0.01)\") + \"\\n\" +\n#ifdef QT_GUI\n        \"  -server                \" + _(\"Accept command line and JSON-RPC commands\") + \"\\n\" +\n#endif\n#if !defined(WIN32) && !defined(QT_GUI)\n        \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\" +\n#endif\n        \"  -testnet               \" + _(\"Use the test network\") + \"\\n\" +\n        \"  -debug                 \" + _(\"Output extra debugging information. Implies all other -debug* options\") + \"\\n\" +\n        \"  -debugnet              \" + _(\"Output extra network debugging information\") + \"\\n\" +\n        \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp\") + \"\\n\" +\n        \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\" +\n        \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\" +\n#ifdef WIN32\n        \"  -printtodebugger       \" + _(\"Send trace/debug info to debugger\") + \"\\n\" +\n#endif\n        \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 21109 or testnet: 35615)\") + \"\\n\" +\n        \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address\") + \"\\n\" +\n        \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\" +\n        \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\" +\n        \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\" +\n        \"  -confchange            \" + _(\"Require a confirmations for change (default: 0)\") + \"\\n\" +\n        \"  -enforcecanonical      \" + _(\"Enforce transaction scripts to use canonical PUSH operators (default: 1)\") + \"\\n\" +\n        \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received (%s in cmd is replaced by message)\") + \"\\n\" +\n        \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \"\\n\" +\n        \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\" +\n        \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \"\\n\" +\n        \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \"\\n\" +\n        \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 2500, 0 = all)\") + \"\\n\" +\n        \"  -checklevel=<n>        \" + _(\"How thorough the block verification is (0-6, default: 1)\") + \"\\n\" +\n        \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000?.dat file\") + \"\\n\" +\n\n        \"\\n\" + _(\"Block creation options:\") + \"\\n\" +\n        \"  -blockminsize=<n>      \"   + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\" +\n        \"  -blockmaxsize=<n>      \"   + _(\"Set maximum block size in bytes (default: 250000)\") + \"\\n\" +\n        \"  -blockprioritysize=<n> \"   + _(\"Set maximum size of high-priority/low-fee transactions in bytes (default: 27000)\") + \"\\n\" +\n\n        \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\" +\n        \"  -rpcssl                                  \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\" +\n        \"  -rpcsslcertificatechainfile=<file.cert>  \" + _(\"Server certificate file (default: server.cert)\") + \"\\n\" +\n        \"  -rpcsslprivatekeyfile=<file.pem>         \" + _(\"Server private key (default: server.pem)\") + \"\\n\" +\n        \"  -rpcsslciphers=<ciphers>                 \" + _(\"Acceptable ciphers (default: TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH)\") + \"\\n\";\n\n    return strUsage;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Get help for a command\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "FormatFullVersion",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "FormatFullVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1288-1291",
          "snippet": "string FormatFullVersion()\n{\n    return CLIENT_BUILD;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring FormatFullVersion()\n{\n    return CLIENT_BUILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapArgs.count",
          "args": [
            "\"--help\""
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadConfigFile",
          "args": [
            "mapArgs",
            "mapMultiArgs"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ReadConfigFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1087-1109",
          "snippet": "void ReadConfigFile(map<string, string>& mapSettingsRet,\n                    map<string, vector<string> >& mapMultiSettingsRet)\n{\n    boost::filesystem::ifstream streamConfig(GetConfigFile());\n    if (!streamConfig.good())\n        return; // No bitcoin.conf file is OK\n\n    set<string> setOptions;\n    setOptions.insert(\"*\");\n\n    for (boost::program_options::detail::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it)\n    {\n        // Don't overwrite existing settings so command line settings override bitcoin.conf\n        string strKey = string(\"-\") + it->string_key;\n        if (mapSettingsRet.count(strKey) == 0)\n        {\n            mapSettingsRet[strKey] = it->value[0];\n            // interpret nofoo=1 as foo=0 (and nofoo=0 as foo=1) as long as foo not set)\n            InterpretNegativeSetting(strKey, mapSettingsRet);\n        }\n        mapMultiSettingsRet[strKey].push_back(it->value[0]);\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid ReadConfigFile(map<string, string>& mapSettingsRet,\n                    map<string, vector<string> >& mapMultiSettingsRet)\n{\n    boost::filesystem::ifstream streamConfig(GetConfigFile());\n    if (!streamConfig.good())\n        return; // No bitcoin.conf file is OK\n\n    set<string> setOptions;\n    setOptions.insert(\"*\");\n\n    for (boost::program_options::detail::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it)\n    {\n        // Don't overwrite existing settings so command line settings override bitcoin.conf\n        string strKey = string(\"-\") + it->string_key;\n        if (mapSettingsRet.count(strKey) == 0)\n        {\n            mapSettingsRet[strKey] = it->value[0];\n            // interpret nofoo=1 as foo=0 (and nofoo=0 as foo=1) as long as foo not set)\n            InterpretNegativeSetting(strKey, mapSettingsRet);\n        }\n        mapMultiSettingsRet[strKey].push_back(it->value[0]);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Error: Specified directory does not exist\\n\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::filesystem::is_directory",
          "args": [
            "GetDataDir(false)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [
            "false"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseParameters",
          "args": [
            "argc",
            "argv"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "ParseParameters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "510-553",
          "snippet": "void ParseParameters(int argc, const char* const argv[])\n{\n    mapArgs.clear();\n    mapMultiArgs.clear();\n    for (int i = 1; i < argc; i++)\n    {\n        char psz[10000];\n        strlcpy(psz, argv[i], sizeof(psz));\n        char* pszValue = (char*)\"\";\n        if (strchr(psz, '='))\n        {\n            pszValue = strchr(psz, '=');\n            *pszValue++ = '\\0';\n        }\n        #ifdef WIN32\n        _strlwr(psz);\n        if (psz[0] == '/')\n            psz[0] = '-';\n        #endif\n        if (psz[0] != '-')\n            break;\n\n        mapArgs[psz] = pszValue;\n        mapMultiArgs[psz].push_back(pszValue);\n    }\n\n    // New 0.6 features:\n    BOOST_FOREACH(const PAIRTYPE(string,string)& entry, mapArgs)\n    {\n        string name = entry.first;\n\n        //  interpret --foo as -foo (as long as both are not set)\n        if (name.find(\"--\") == 0)\n        {\n            std::string singleDash(name.begin()+1, name.end());\n            if (mapArgs.count(singleDash) == 0)\n                mapArgs[singleDash] = entry.second;\n            name = singleDash;\n        }\n\n        // interpret -nofoo as -foo=0 (and -nofoo=0 as -foo=1) as long as -foo not set\n        InterpretNegativeSetting(name, mapArgs);\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;",
            "map<string, vector<string> > mapMultiArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\nmap<string, vector<string> > mapMultiArgs;\n\nvoid ParseParameters(int argc, const char* const argv[])\n{\n    mapArgs.clear();\n    mapMultiArgs.clear();\n    for (int i = 1; i < argc; i++)\n    {\n        char psz[10000];\n        strlcpy(psz, argv[i], sizeof(psz));\n        char* pszValue = (char*)\"\";\n        if (strchr(psz, '='))\n        {\n            pszValue = strchr(psz, '=');\n            *pszValue++ = '\\0';\n        }\n        #ifdef WIN32\n        _strlwr(psz);\n        if (psz[0] == '/')\n            psz[0] = '-';\n        #endif\n        if (psz[0] != '-')\n            break;\n\n        mapArgs[psz] = pszValue;\n        mapMultiArgs[psz].push_back(pszValue);\n    }\n\n    // New 0.6 features:\n    BOOST_FOREACH(const PAIRTYPE(string,string)& entry, mapArgs)\n    {\n        string name = entry.first;\n\n        //  interpret --foo as -foo (as long as both are not set)\n        if (name.find(\"--\") == 0)\n        {\n            std::string singleDash(name.begin()+1, name.end());\n            if (mapArgs.count(singleDash) == 0)\n                mapArgs[singleDash] = entry.second;\n            name = singleDash;\n        }\n\n        // interpret -nofoo as -foo=0 (and -nofoo=0 as -foo=1) as long as -foo not set\n        InterpretNegativeSetting(name, mapArgs);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nbool AppInit(int argc, char* argv[])\n{\n    bool fRet = false;\n    try\n    {\n        //\n        // Parameters\n        //\n        // If Qt is used, parameters/bitcoin.conf are parsed in qt/bitcoin.cpp's main()\n        ParseParameters(argc, argv);\n        if (!boost::filesystem::is_directory(GetDataDir(false)))\n        {\n            fprintf(stderr, \"Error: Specified directory does not exist\\n\");\n            Shutdown(NULL);\n        }\n        ReadConfigFile(mapArgs, mapMultiArgs);\n\n        if (mapArgs.count(\"-?\") || mapArgs.count(\"--help\"))\n        {\n            // First part of help message is specific to bitcoind / RPC client\n            std::string strUsage = _(\"Halcyon version\") + \" \" + FormatFullVersion() + \"\\n\\n\" +\n                _(\"Usage:\") + \"\\n\" +\n                  \"  halcyond [options]                     \" + \"\\n\" +\n                  \"  halcyond [options] <command> [params]  \" + _(\"Send command to -server or halcyond\") + \"\\n\" +\n                  \"  halcyond [options] help                \" + _(\"List commands\") + \"\\n\" +\n                  \"  halcyond [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n\n            strUsage += \"\\n\" + HelpMessage();\n\n            fprintf(stdout, \"%s\", strUsage.c_str());\n            return false;\n        }\n\n        // Command-line RPC\n        for (int i = 1; i < argc; i++)\n            if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"halcyon:\"))\n                fCommandLine = true;\n\n        if (fCommandLine)\n        {\n            int ret = CommandLineRPC(argc, argv);\n            exit(ret);\n        }\n\n        fRet = AppInit2();\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"AppInit()\");\n    } catch (...) {\n        PrintException(NULL, \"AppInit()\");\n    }\n    if (!fRet)\n        Shutdown(NULL);\n    return fRet;\n}"
  },
  {
    "function_name": "HandleSIGHUP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "115-118",
    "snippet": "void HandleSIGHUP(int)\n{\n    fReopenDebugLog = true;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nvoid HandleSIGHUP(int)\n{\n    fReopenDebugLog = true;\n}"
  },
  {
    "function_name": "HandleSIGTERM",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "110-113",
    "snippet": "void HandleSIGTERM(int)\n{\n    fRequestShutdown = true;\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nvoid HandleSIGTERM(int)\n{\n    fRequestShutdown = true;\n}"
  },
  {
    "function_name": "Shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "63-108",
    "snippet": "void Shutdown(void* parg)\n{\n    static CCriticalSection cs_Shutdown;\n    static bool fTaken;\n\n    // Make this thread recognisable as the shutdown thread\n    RenameThread(\"hal-shutdown\");\n\n    bool fFirstThread = false;\n    {\n        TRY_LOCK(cs_Shutdown, lockShutdown);\n        if (lockShutdown)\n        {\n            fFirstThread = !fTaken;\n            fTaken = true;\n        }\n    }\n    static bool fExit;\n    if (fFirstThread)\n    {\n        printf(\"Shutdown() : in progress...\\n\");\n        fShutdown = true;\n        nTransactionsUpdated++;\n        bitdb.Flush(false);\n        StopNode();\n        bitdb.Flush(true);\n        boost::filesystem::remove(GetPidFile());\n        UnregisterWallet(pwalletMain);\n        delete pwalletMain;\n        NewThread(ExitTimeout, NULL);\n        fExit = true;\n        MilliSleep(1000);\n        printf(\"Shutdown() : completed\\n\\n\");\n#ifndef QT_GUI\n        // ensure non-UI client gets exited here, but let Bitcoin-Qt reach 'return 0;' in bitcoin.cpp\n        exit(0);\n#endif\n    }\n    else\n    {\n        while (!fExit)\n            MilliSleep(500);\n        MilliSleep(100);\n        ExitThread(0);\n    }\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CWallet* pwalletMain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExitThread",
          "args": [
            "0"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ExitThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "659-662",
          "snippet": "inline void ExitThread(size_t nExitCode)\n{\n    pthread_exit((void*)nExitCode);\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void ExitThread(size_t nExitCode)\n{\n    pthread_exit((void*)nExitCode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "100"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutdown() : completed\\n\\n\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewThread",
          "args": [
            "ExitTimeout",
            "NULL"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "NewThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1350-1360",
          "snippet": "bool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UnregisterWallet",
          "args": [
            "pwalletMain"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "UnregisterWallet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "112-118",
          "snippet": "void UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_setpwalletRegistered;",
            "set<CWallet*> setpwalletRegistered;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "boost::filesystem::remove",
          "args": [
            "GetPidFile()"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPidFile",
          "args": [],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "GetPidFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1111-1116",
          "snippet": "boost::filesystem::path GetPidFile()\n{\n    boost::filesystem::path pathPidFile(GetArg(\"-pid\", \"halcyond.pid\"));\n    if (!pathPidFile.is_complete()) pathPidFile = GetDataDir() / pathPidFile;\n    return pathPidFile;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nboost::filesystem::path GetPidFile()\n{\n    boost::filesystem::path pathPidFile(GetArg(\"-pid\", \"halcyond.pid\"));\n    if (!pathPidFile.is_complete()) pathPidFile = GetDataDir() / pathPidFile;\n    return pathPidFile;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.Flush",
          "args": [
            "true"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "Flush",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "445-489",
          "snippet": "void CDBEnv::Flush(bool fShutdown)\n{\n    int64_t nStart = GetTimeMillis();\n    // Flush log data to the actual data file\n    //  on all files that are not in use\n    printf(\"Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n    if (!fDbEnvInit)\n        return;\n    {\n        LOCK(cs_db);\n        map<string, int>::iterator mi = mapFileUseCount.begin();\n        while (mi != mapFileUseCount.end())\n        {\n            string strFile = (*mi).first;\n            int nRefCount = (*mi).second;\n            printf(\"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n            if (nRefCount == 0)\n            {\n                // Move log data to the dat file\n                CloseDb(strFile);\n                printf(\"%s checkpoint\\n\", strFile.c_str());\n                dbenv.txn_checkpoint(0, 0, 0);\n                if (!IsChainFile(strFile) || fDetachDB) {\n                    printf(\"%s detach\\n\", strFile.c_str());\n                    if (!fMockDb)\n                        dbenv.lsn_reset(strFile.c_str(), 0);\n                }\n                printf(\"%s closed\\n\", strFile.c_str());\n                mapFileUseCount.erase(mi++);\n            }\n            else\n                mi++;\n        }\n        printf(\"DBFlush(%s)%s ended %15\"PRId64\"ms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\", GetTimeMillis() - nStart);\n        if (fShutdown)\n        {\n            char** listp;\n            if (mapFileUseCount.empty())\n            {\n                dbenv.log_archive(&listp, DB_ARCH_REMOVE);\n                Close();\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv {\n  void CDBEnv::Flush(bool fShutdown)\n  {\n      int64_t nStart = GetTimeMillis();\n      // Flush log data to the actual data file\n      //  on all files that are not in use\n      printf(\"Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\");\n      if (!fDbEnvInit)\n          return;\n      {\n          LOCK(cs_db);\n          map<string, int>::iterator mi = mapFileUseCount.begin();\n          while (mi != mapFileUseCount.end())\n          {\n              string strFile = (*mi).first;\n              int nRefCount = (*mi).second;\n              printf(\"%s refcount=%d\\n\", strFile.c_str(), nRefCount);\n              if (nRefCount == 0)\n              {\n                  // Move log data to the dat file\n                  CloseDb(strFile);\n                  printf(\"%s checkpoint\\n\", strFile.c_str());\n                  dbenv.txn_checkpoint(0, 0, 0);\n                  if (!IsChainFile(strFile) || fDetachDB) {\n                      printf(\"%s detach\\n\", strFile.c_str());\n                      if (!fMockDb)\n                          dbenv.lsn_reset(strFile.c_str(), 0);\n                  }\n                  printf(\"%s closed\\n\", strFile.c_str());\n                  mapFileUseCount.erase(mi++);\n              }\n              else\n                  mi++;\n          }\n          printf(\"DBFlush(%s)%s ended %15\"PRId64\"ms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" db not started\", GetTimeMillis() - nStart);\n          if (fShutdown)\n          {\n              char** listp;\n              if (mapFileUseCount.empty())\n              {\n                  dbenv.log_archive(&listp, DB_ARCH_REMOVE);\n                  Close();\n              }\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "StopNode",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "StopNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1939-1977",
          "snippet": "bool StopNode()\n{\n    printf(\"StopNode()\\n\");\n    fShutdown = true;\n    nTransactionsUpdated++;\n    int64_t nStart = GetTime();\n    if (semOutbound)\n        for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n            semOutbound->post();\n    do\n    {\n        int nThreadsRunning = 0;\n        for (int n = 0; n < THREAD_MAX; n++)\n            nThreadsRunning += vnThreadsRunning[n];\n        if (nThreadsRunning == 0)\n            break;\n        if (GetTime() - nStart > 20)\n            break;\n        MilliSleep(20);\n    } while(true);\n    if (vnThreadsRunning[THREAD_SOCKETHANDLER] > 0) printf(\"ThreadSocketHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_OPENCONNECTIONS] > 0) printf(\"ThreadOpenConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0) printf(\"ThreadMessageHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCLISTENER] > 0) printf(\"ThreadRPCListener still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCHANDLER] > 0) printf(\"ThreadsRPCServer still running\\n\");\n#ifdef USE_UPNP\n    if (vnThreadsRunning[THREAD_UPNP] > 0) printf(\"ThreadMapPort still running\\n\");\n#endif\n    if (vnThreadsRunning[THREAD_DNSSEED] > 0) printf(\"ThreadDNSAddressSeed still running\\n\");\n    if (vnThreadsRunning[THREAD_ADDEDCONNECTIONS] > 0) printf(\"ThreadOpenAddedConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_DUMPADDRESS] > 0) printf(\"ThreadDumpAddresses still running\\n\");\n    if (vnThreadsRunning[THREAD_STAKE_MINER] > 0) printf(\"ThreadStakeMiner still running\\n\");\n    if(vnThreadsRunning[THREAD_NTP] > 0) printf(\"ThreadNtpPoller still running\\n\");\n    while (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0 || vnThreadsRunning[THREAD_RPCHANDLER] > 0)\n        MilliSleep(20);\n    MilliSleep(50);\n    DumpAddresses();\n    return true;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int MAX_OUTBOUND_CONNECTIONS = 16;",
            "array<int, THREAD_MAX> vnThreadsRunning;",
            "static CSemaphore *semOutbound = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic const int MAX_OUTBOUND_CONNECTIONS = 16;\narray<int, THREAD_MAX> vnThreadsRunning;\nstatic CSemaphore *semOutbound = NULL;\n\nbool StopNode()\n{\n    printf(\"StopNode()\\n\");\n    fShutdown = true;\n    nTransactionsUpdated++;\n    int64_t nStart = GetTime();\n    if (semOutbound)\n        for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n            semOutbound->post();\n    do\n    {\n        int nThreadsRunning = 0;\n        for (int n = 0; n < THREAD_MAX; n++)\n            nThreadsRunning += vnThreadsRunning[n];\n        if (nThreadsRunning == 0)\n            break;\n        if (GetTime() - nStart > 20)\n            break;\n        MilliSleep(20);\n    } while(true);\n    if (vnThreadsRunning[THREAD_SOCKETHANDLER] > 0) printf(\"ThreadSocketHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_OPENCONNECTIONS] > 0) printf(\"ThreadOpenConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0) printf(\"ThreadMessageHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCLISTENER] > 0) printf(\"ThreadRPCListener still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCHANDLER] > 0) printf(\"ThreadsRPCServer still running\\n\");\n#ifdef USE_UPNP\n    if (vnThreadsRunning[THREAD_UPNP] > 0) printf(\"ThreadMapPort still running\\n\");\n#endif\n    if (vnThreadsRunning[THREAD_DNSSEED] > 0) printf(\"ThreadDNSAddressSeed still running\\n\");\n    if (vnThreadsRunning[THREAD_ADDEDCONNECTIONS] > 0) printf(\"ThreadOpenAddedConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_DUMPADDRESS] > 0) printf(\"ThreadDumpAddresses still running\\n\");\n    if (vnThreadsRunning[THREAD_STAKE_MINER] > 0) printf(\"ThreadStakeMiner still running\\n\");\n    if(vnThreadsRunning[THREAD_NTP] > 0) printf(\"ThreadNtpPoller still running\\n\");\n    while (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0 || vnThreadsRunning[THREAD_RPCHANDLER] > 0)\n        MilliSleep(20);\n    MilliSleep(50);\n    DumpAddresses();\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Shutdown() : in progress...\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "cs_Shutdown",
            "lockShutdown"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-shutdown\""
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCWallet* pwalletMain;\n\nvoid Shutdown(void* parg)\n{\n    static CCriticalSection cs_Shutdown;\n    static bool fTaken;\n\n    // Make this thread recognisable as the shutdown thread\n    RenameThread(\"hal-shutdown\");\n\n    bool fFirstThread = false;\n    {\n        TRY_LOCK(cs_Shutdown, lockShutdown);\n        if (lockShutdown)\n        {\n            fFirstThread = !fTaken;\n            fTaken = true;\n        }\n    }\n    static bool fExit;\n    if (fFirstThread)\n    {\n        printf(\"Shutdown() : in progress...\\n\");\n        fShutdown = true;\n        nTransactionsUpdated++;\n        bitdb.Flush(false);\n        StopNode();\n        bitdb.Flush(true);\n        boost::filesystem::remove(GetPidFile());\n        UnregisterWallet(pwalletMain);\n        delete pwalletMain;\n        NewThread(ExitTimeout, NULL);\n        fExit = true;\n        MilliSleep(1000);\n        printf(\"Shutdown() : completed\\n\\n\");\n#ifndef QT_GUI\n        // ensure non-UI client gets exited here, but let Bitcoin-Qt reach 'return 0;' in bitcoin.cpp\n        exit(0);\n#endif\n    }\n    else\n    {\n        while (!fExit)\n            MilliSleep(500);\n        MilliSleep(100);\n        ExitThread(0);\n    }\n}"
  },
  {
    "function_name": "StartShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "52-61",
    "snippet": "void StartShutdown()\n{\n#ifdef QT_GUI\n    // ensure we leave the Qt main loop for a clean GUI exit (Shutdown() is called in bitcoin.cpp afterwards)\n    uiInterface.QueueShutdown();\n#else\n    // Without UI, Shutdown() can simply be started in a new thread\n    NewThread(Shutdown, NULL);\n#endif\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CClientUIInterface uiInterface;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NewThread",
          "args": [
            "Shutdown",
            "NULL"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "NewThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1350-1360",
          "snippet": "bool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiInterface.QueueShutdown",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "QueueShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "91-94",
          "snippet": "static void QueueShutdown()\n{\n    QMetaObject::invokeMethod(QCoreApplication::instance(), \"quit\", Qt::QueuedConnection);\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic void QueueShutdown()\n{\n    QMetaObject::invokeMethod(QCoreApplication::instance(), \"quit\", Qt::QueuedConnection);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nvoid StartShutdown()\n{\n#ifdef QT_GUI\n    // ensure we leave the Qt main loop for a clean GUI exit (Shutdown() is called in bitcoin.cpp afterwards)\n    uiInterface.QueueShutdown();\n#else\n    // Without UI, Shutdown() can simply be started in a new thread\n    NewThread(Shutdown, NULL);\n#endif\n}"
  },
  {
    "function_name": "ExitTimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
    "lines": "44-50",
    "snippet": "void ExitTimeout(void* parg)\n{\n#ifdef WIN32\n    MilliSleep(5000);\n    ExitProcess(0);\n#endif\n}",
    "includes": [
      "#include <signal.h>",
      "#include <openssl/crypto.h>",
      "#include <boost/algorithm/string/predicate.hpp>",
      "#include <boost/interprocess/sync/file_lock.hpp>",
      "#include <boost/filesystem/convenience.hpp>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include \"checkpoints.h\"",
      "#include \"ui_interface.h\"",
      "#include \"util.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"bitcoinrpc.h\"",
      "#include \"walletdb.h\"",
      "#include \"txdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExitProcess",
          "args": [
            "0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "5000"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nvoid ExitTimeout(void* parg)\n{\n#ifdef WIN32\n    MilliSleep(5000);\n    ExitProcess(0);\n#endif\n}"
  }
]