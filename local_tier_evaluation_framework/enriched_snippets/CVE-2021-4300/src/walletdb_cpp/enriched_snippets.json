[
  {
    "function_name": "Recover",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "716-719",
    "snippet": "bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename)\n{\n    return CWalletDB::Recover(dbenv, filename, false);\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CWalletDB::Recover",
          "args": [
            "dbenv",
            "filename",
            "false"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "Recover",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "638-714",
          "snippet": "bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n{\n    // Recovery procedure:\n    // move wallet.dat to wallet.timestamp.bak\n    // Call Salvage with fAggressive=true to\n    // get as much data as possible.\n    // Rewrite salvaged data to wallet.dat\n    // Set -rescan so any missing transactions will be\n    // found.\n    int64_t now = GetTime();\n    std::string newFilename = strprintf(\"wallet.%\"PRId64\".bak\", now);\n\n    int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n                                      newFilename.c_str(), DB_AUTO_COMMIT);\n    if (result == 0)\n        printf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n    else\n    {\n        printf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n        return false;\n    }\n\n    std::vector<CDBEnv::KeyValPair> salvagedData;\n    bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n    if (salvagedData.empty())\n    {\n        printf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n        return false;\n    }\n    printf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n\n    bool fSuccess = allOK;\n    Db* pdbCopy = new Db(&dbenv.dbenv, 0);\n    int ret = pdbCopy->open(NULL,                 // Txn pointer\n                            filename.c_str(),   // Filename\n                            \"main\",    // Logical db name\n                            DB_BTREE,  // Database type\n                            DB_CREATE,    // Flags\n                            0);\n    if (ret > 0)\n    {\n        printf(\"Cannot create database file %s\\n\", filename.c_str());\n        return false;\n    }\n    CWallet dummyWallet;\n    CWalletScanState wss;\n\n    DbTxn* ptxn = dbenv.TxnBegin();\n    BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n    {\n        if (fOnlyKeys)\n        {\n            CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n            CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n            string strType, strErr;\n            bool fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n                                        wss, strType, strErr);\n            if (!IsKeyType(strType))\n                continue;\n            if (!fReadOK)\n            {\n                printf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n                continue;\n            }\n        }\n        Dbt datKey(&row.first[0], row.first.size());\n        Dbt datValue(&row.second[0], row.second.size());\n        int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n        if (ret2 > 0)\n            fSuccess = false;\n    }\n    ptxn->commit(0);\n    pdbCopy->close(0);\n    delete pdbCopy;\n\n    return fSuccess;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename)\n  {\n      return CWalletDB::Recover(dbenv, filename, false);\n  }\n}"
  },
  {
    "function_name": "Recover",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "638-714",
    "snippet": "bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n{\n    // Recovery procedure:\n    // move wallet.dat to wallet.timestamp.bak\n    // Call Salvage with fAggressive=true to\n    // get as much data as possible.\n    // Rewrite salvaged data to wallet.dat\n    // Set -rescan so any missing transactions will be\n    // found.\n    int64_t now = GetTime();\n    std::string newFilename = strprintf(\"wallet.%\"PRId64\".bak\", now);\n\n    int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n                                      newFilename.c_str(), DB_AUTO_COMMIT);\n    if (result == 0)\n        printf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n    else\n    {\n        printf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n        return false;\n    }\n\n    std::vector<CDBEnv::KeyValPair> salvagedData;\n    bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n    if (salvagedData.empty())\n    {\n        printf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n        return false;\n    }\n    printf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n\n    bool fSuccess = allOK;\n    Db* pdbCopy = new Db(&dbenv.dbenv, 0);\n    int ret = pdbCopy->open(NULL,                 // Txn pointer\n                            filename.c_str(),   // Filename\n                            \"main\",    // Logical db name\n                            DB_BTREE,  // Database type\n                            DB_CREATE,    // Flags\n                            0);\n    if (ret > 0)\n    {\n        printf(\"Cannot create database file %s\\n\", filename.c_str());\n        return false;\n    }\n    CWallet dummyWallet;\n    CWalletScanState wss;\n\n    DbTxn* ptxn = dbenv.TxnBegin();\n    BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n    {\n        if (fOnlyKeys)\n        {\n            CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n            CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n            string strType, strErr;\n            bool fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n                                        wss, strType, strErr);\n            if (!IsKeyType(strType))\n                continue;\n            if (!fReadOK)\n            {\n                printf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n                continue;\n            }\n        }\n        Dbt datKey(&row.first[0], row.first.size());\n        Dbt datValue(&row.second[0], row.second.size());\n        int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n        if (ret2 > 0)\n            fSuccess = false;\n    }\n    ptxn->commit(0);\n    pdbCopy->close(0);\n    delete pdbCopy;\n\n    return fSuccess;\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pdbCopy->close",
          "args": [
            "0"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptxn->commit",
          "args": [
            "0"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdbCopy->put",
          "args": [
            "ptxn",
            "&datKey",
            "&datValue",
            "DB_NOOVERWRITE"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "row.second.size",
          "args": [],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARNING: CWalletDB::Recover skipping %s: %s\\n\"",
            "strType.c_str()",
            "strErr.c_str()"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strErr.c_str",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strType.c_str",
          "args": [],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsKeyType",
          "args": [
            "strType"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "IsKeyType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "427-431",
          "snippet": "static bool IsKeyType(string strType)\n{\n    return (strType== \"key\" || strType == \"wkey\" ||\n            strType == \"mkey\" || strType == \"ckey\");\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nstatic bool IsKeyType(string strType)\n{\n    return (strType== \"key\" || strType == \"wkey\" ||\n            strType == \"mkey\" || strType == \"ckey\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadKeyValue",
          "args": [
            "&dummyWallet",
            "ssKey",
            "ssValue",
            "wss",
            "strType",
            "strErr"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "ReadKeyValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "203-425",
          "snippet": "bool\nReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CWalletScanState &wss, string& strType, string& strErr)\n{\n    try {\n        // Unserialize\n        // Taking advantage of the fact that pair serialization\n        // is just the two items serialized one after the other\n        ssKey >> strType;\n        if (strType == \"name\")\n        {\n            string strAddress;\n            ssKey >> strAddress;\n            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n        }\n        else if (strType == \"tx\")\n        {\n            uint256 hash;\n            ssKey >> hash;\n            CWalletTx& wtx = pwallet->mapWallet[hash];\n            ssValue >> wtx;\n            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n                wtx.BindWallet(pwallet);\n            else\n            {\n                pwallet->mapWallet.erase(hash);\n                return false;\n            }\n\n            // Undo serialize changes in 31600\n            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n            {\n                if (!ssValue.empty())\n                {\n                    char fTmp;\n                    char fUnused;\n                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = fTmp;\n                }\n                else\n                {\n                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = 0;\n                }\n                wss.vWalletUpgrade.push_back(hash);\n            }\n\n            if (wtx.nOrderPos == -1)\n                wss.fAnyUnordered = true;\n\n            //// debug print\n            //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n            //printf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n            //    wtx.vout[0].nValue,\n            //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n            //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n            //    wtx.mapValue[\"message\"].c_str());\n        }\n        else if (strType == \"acentry\")\n        {\n            string strAccount;\n            ssKey >> strAccount;\n            uint64_t nNumber;\n            ssKey >> nNumber;\n            if (nNumber > nAccountingEntryNumber)\n                nAccountingEntryNumber = nNumber;\n\n            if (!wss.fAnyUnordered)\n            {\n                CAccountingEntry acentry;\n                ssValue >> acentry;\n                if (acentry.nOrderPos == -1)\n                    wss.fAnyUnordered = true;\n            }\n        }\n        else if (strType == \"key\" || strType == \"wkey\")\n        {\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            CKey key;\n            if (strType == \"key\")\n            {\n                wss.nKeys++;\n                CPrivKey pkey;\n                ssValue >> pkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(pkey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n                    return false;\n                }\n            }\n            else\n            {\n                CWalletKey wkey;\n                ssValue >> wkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(wkey.vchPrivKey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n                    return false;\n                }\n            }\n            if (!pwallet->LoadKey(key))\n            {\n                strErr = \"Error reading wallet database: LoadKey failed\";\n                return false;\n            }\n        }\n        else if (strType == \"mkey\")\n        {\n            unsigned int nID;\n            ssKey >> nID;\n            CMasterKey kMasterKey;\n            ssValue >> kMasterKey;\n            if(pwallet->mapMasterKeys.count(nID) != 0)\n            {\n                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n                return false;\n            }\n            pwallet->mapMasterKeys[nID] = kMasterKey;\n            if (pwallet->nMasterKeyMaxID < nID)\n                pwallet->nMasterKeyMaxID = nID;\n        }\n        else if (strType == \"ckey\")\n        {\n            wss.nCKeys++;\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            vector<unsigned char> vchPrivKey;\n            ssValue >> vchPrivKey;\n            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n            {\n                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n                return false;\n            }\n            wss.fIsEncrypted = true;\n        }\n        else if (strType == \"keymeta\")\n        {\n            CPubKey vchPubKey;\n            ssKey >> vchPubKey;\n            CKeyMetadata keyMeta;\n            ssValue >> keyMeta;\n            wss.nKeyMeta++;\n\n            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n\n            // find earliest key creation time, as wallet birthday\n            if (!pwallet->nTimeFirstKey ||\n                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n        }\n        else if (strType == \"defaultkey\")\n        {\n            ssValue >> pwallet->vchDefaultKey;\n        }\n        else if (strType == \"pool\")\n        {\n            int64_t nIndex;\n            ssKey >> nIndex;\n            CKeyPool keypool;\n            ssValue >> keypool;\n            pwallet->setKeyPool.insert(nIndex);\n\n            // If no metadata exists yet, create a default with the pool key's\n            // creation time. Note that this may be overwritten by actually\n            // stored metadata for that key later, which is fine.\n            CKeyID keyid = keypool.vchPubKey.GetID();\n            if (pwallet->mapKeyMetadata.count(keyid) == 0)\n                pwallet->mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n\n        }\n        else if (strType == \"version\")\n        {\n            ssValue >> wss.nFileVersion;\n            if (wss.nFileVersion == 10300)\n                wss.nFileVersion = 300;\n        }\n        else if (strType == \"cscript\")\n        {\n            uint160 hash;\n            ssKey >> hash;\n            CScript script;\n            ssValue >> script;\n            if (!pwallet->LoadCScript(script))\n            {\n                strErr = \"Error reading wallet database: LoadCScript failed\";\n                return false;\n            }\n        }\n        else if (strType == \"orderposnext\")\n        {\n            ssValue >> pwallet->nOrderPosNext;\n        }\n    } catch (...)\n    {\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t nAccountingEntryNumber = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nstatic uint64_t nAccountingEntryNumber = 0;\n\nbool\nReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CWalletScanState &wss, string& strType, string& strErr)\n{\n    try {\n        // Unserialize\n        // Taking advantage of the fact that pair serialization\n        // is just the two items serialized one after the other\n        ssKey >> strType;\n        if (strType == \"name\")\n        {\n            string strAddress;\n            ssKey >> strAddress;\n            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n        }\n        else if (strType == \"tx\")\n        {\n            uint256 hash;\n            ssKey >> hash;\n            CWalletTx& wtx = pwallet->mapWallet[hash];\n            ssValue >> wtx;\n            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n                wtx.BindWallet(pwallet);\n            else\n            {\n                pwallet->mapWallet.erase(hash);\n                return false;\n            }\n\n            // Undo serialize changes in 31600\n            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n            {\n                if (!ssValue.empty())\n                {\n                    char fTmp;\n                    char fUnused;\n                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = fTmp;\n                }\n                else\n                {\n                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = 0;\n                }\n                wss.vWalletUpgrade.push_back(hash);\n            }\n\n            if (wtx.nOrderPos == -1)\n                wss.fAnyUnordered = true;\n\n            //// debug print\n            //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n            //printf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n            //    wtx.vout[0].nValue,\n            //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n            //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n            //    wtx.mapValue[\"message\"].c_str());\n        }\n        else if (strType == \"acentry\")\n        {\n            string strAccount;\n            ssKey >> strAccount;\n            uint64_t nNumber;\n            ssKey >> nNumber;\n            if (nNumber > nAccountingEntryNumber)\n                nAccountingEntryNumber = nNumber;\n\n            if (!wss.fAnyUnordered)\n            {\n                CAccountingEntry acentry;\n                ssValue >> acentry;\n                if (acentry.nOrderPos == -1)\n                    wss.fAnyUnordered = true;\n            }\n        }\n        else if (strType == \"key\" || strType == \"wkey\")\n        {\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            CKey key;\n            if (strType == \"key\")\n            {\n                wss.nKeys++;\n                CPrivKey pkey;\n                ssValue >> pkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(pkey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n                    return false;\n                }\n            }\n            else\n            {\n                CWalletKey wkey;\n                ssValue >> wkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(wkey.vchPrivKey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n                    return false;\n                }\n            }\n            if (!pwallet->LoadKey(key))\n            {\n                strErr = \"Error reading wallet database: LoadKey failed\";\n                return false;\n            }\n        }\n        else if (strType == \"mkey\")\n        {\n            unsigned int nID;\n            ssKey >> nID;\n            CMasterKey kMasterKey;\n            ssValue >> kMasterKey;\n            if(pwallet->mapMasterKeys.count(nID) != 0)\n            {\n                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n                return false;\n            }\n            pwallet->mapMasterKeys[nID] = kMasterKey;\n            if (pwallet->nMasterKeyMaxID < nID)\n                pwallet->nMasterKeyMaxID = nID;\n        }\n        else if (strType == \"ckey\")\n        {\n            wss.nCKeys++;\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            vector<unsigned char> vchPrivKey;\n            ssValue >> vchPrivKey;\n            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n            {\n                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n                return false;\n            }\n            wss.fIsEncrypted = true;\n        }\n        else if (strType == \"keymeta\")\n        {\n            CPubKey vchPubKey;\n            ssKey >> vchPubKey;\n            CKeyMetadata keyMeta;\n            ssValue >> keyMeta;\n            wss.nKeyMeta++;\n\n            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n\n            // find earliest key creation time, as wallet birthday\n            if (!pwallet->nTimeFirstKey ||\n                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n        }\n        else if (strType == \"defaultkey\")\n        {\n            ssValue >> pwallet->vchDefaultKey;\n        }\n        else if (strType == \"pool\")\n        {\n            int64_t nIndex;\n            ssKey >> nIndex;\n            CKeyPool keypool;\n            ssValue >> keypool;\n            pwallet->setKeyPool.insert(nIndex);\n\n            // If no metadata exists yet, create a default with the pool key's\n            // creation time. Note that this may be overwritten by actually\n            // stored metadata for that key later, which is fine.\n            CKeyID keyid = keypool.vchPubKey.GetID();\n            if (pwallet->mapKeyMetadata.count(keyid) == 0)\n                pwallet->mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n\n        }\n        else if (strType == \"version\")\n        {\n            ssValue >> wss.nFileVersion;\n            if (wss.nFileVersion == 10300)\n                wss.nFileVersion = 300;\n        }\n        else if (strType == \"cscript\")\n        {\n            uint160 hash;\n            ssKey >> hash;\n            CScript script;\n            ssValue >> script;\n            if (!pwallet->LoadCScript(script))\n            {\n                strErr = \"Error reading wallet database: LoadCScript failed\";\n                return false;\n            }\n        }\n        else if (strType == \"orderposnext\")\n        {\n            ssValue >> pwallet->nOrderPosNext;\n        }\n    } catch (...)\n    {\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbenv.TxnBegin",
          "args": [],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "TxnBegin",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "271-280",
          "snippet": "bool TxnBegin()\n    {\n        if (!pdb || activeTxn)\n            return false;\n        DbTxn* ptxn = bitdb.TxnBegin();\n        if (!ptxn)\n            return false;\n        activeTxn = ptxn;\n        return true;\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnBegin()\n      {\n          if (!pdb || activeTxn)\n              return false;\n          DbTxn* ptxn = bitdb.TxnBegin();\n          if (!ptxn)\n              return false;\n          activeTxn = ptxn;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cannot create database file %s\\n\"",
            "filename.c_str()"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdbCopy->open",
          "args": [
            "NULL",
            "// Txn pointerfilename.c_str()",
            "// Filename\"main\"",
            "// Logical db nameDB_BTREE",
            "// Database typeDB_CREATE",
            "// Flags0"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newFilename.c_str",
          "args": [],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "salvagedData.empty",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbenv.Salvage",
          "args": [
            "newFilename",
            "true",
            "salvagedData"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "Salvage",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "165-217",
          "snippet": "bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n                     std::vector<CDBEnv::KeyValPair >& vResult)\n{\n    LOCK(cs_db);\n    assert(mapFileUseCount.count(strFile) == 0);\n\n    u_int32_t flags = DB_SALVAGE;\n    if (fAggressive) flags |= DB_AGGRESSIVE;\n\n    stringstream strDump;\n\n    Db db(&dbenv, 0);\n    int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n    if (result == DB_VERIFY_BAD)\n    {\n        printf(\"Error: Salvage found errors, all data may not be recoverable.\\n\");\n        if (!fAggressive)\n        {\n            printf(\"Error: Rerun with aggressive mode to ignore errors and continue.\\n\");\n            return false;\n        }\n    }\n    if (result != 0 && result != DB_VERIFY_BAD)\n    {\n        printf(\"ERROR: db salvage failed: %d\\n\",result);\n        return false;\n    }\n\n    // Format of bdb dump is ascii lines:\n    // header lines...\n    // HEADER=END\n    // hexadecimal key\n    // hexadecimal value\n    // ... repeated\n    // DATA=END\n\n    string strLine;\n    while (!strDump.eof() && strLine != \"HEADER=END\")\n        getline(strDump, strLine); // Skip past header\n\n    std::string keyHex, valueHex;\n    while (!strDump.eof() && keyHex != \"DATA=END\")\n    {\n        getline(strDump, keyHex);\n        if (keyHex != \"DATA_END\")\n        {\n            getline(strDump, valueHex);\n            vResult.push_back(make_pair(ParseHex(keyHex),ParseHex(valueHex)));\n        }\n    }\n\n    return (result == 0);\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv {\n  bool CDBEnv::Salvage(std::string strFile, bool fAggressive,\n                       std::vector<CDBEnv::KeyValPair >& vResult)\n  {\n      LOCK(cs_db);\n      assert(mapFileUseCount.count(strFile) == 0);\n  \n      u_int32_t flags = DB_SALVAGE;\n      if (fAggressive) flags |= DB_AGGRESSIVE;\n  \n      stringstream strDump;\n  \n      Db db(&dbenv, 0);\n      int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n      if (result == DB_VERIFY_BAD)\n      {\n          printf(\"Error: Salvage found errors, all data may not be recoverable.\\n\");\n          if (!fAggressive)\n          {\n              printf(\"Error: Rerun with aggressive mode to ignore errors and continue.\\n\");\n              return false;\n          }\n      }\n      if (result != 0 && result != DB_VERIFY_BAD)\n      {\n          printf(\"ERROR: db salvage failed: %d\\n\",result);\n          return false;\n      }\n  \n      // Format of bdb dump is ascii lines:\n      // header lines...\n      // HEADER=END\n      // hexadecimal key\n      // hexadecimal value\n      // ... repeated\n      // DATA=END\n  \n      string strLine;\n      while (!strDump.eof() && strLine != \"HEADER=END\")\n          getline(strDump, strLine); // Skip past header\n  \n      std::string keyHex, valueHex;\n      while (!strDump.eof() && keyHex != \"DATA=END\")\n      {\n          getline(strDump, keyHex);\n          if (keyHex != \"DATA_END\")\n          {\n              getline(strDump, valueHex);\n              vResult.push_back(make_pair(ParseHex(keyHex),ParseHex(valueHex)));\n          }\n      }\n  \n      return (result == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Failed to rename %s to %s\\n\"",
            "filename.c_str()",
            "newFilename.c_str()"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newFilename.c_str",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Renamed %s to %s\\n\"",
            "filename.c_str()",
            "newFilename.c_str()"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newFilename.c_str",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbenv.dbenv.dbrename",
          "args": [
            "NULL",
            "filename.c_str()",
            "NULL",
            "newFilename.c_str()",
            "DB_AUTO_COMMIT"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "newFilename.c_str",
          "args": [],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filename.c_str",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::Recover(CDBEnv& dbenv, std::string filename, bool fOnlyKeys)\n  {\n      // Recovery procedure:\n      // move wallet.dat to wallet.timestamp.bak\n      // Call Salvage with fAggressive=true to\n      // get as much data as possible.\n      // Rewrite salvaged data to wallet.dat\n      // Set -rescan so any missing transactions will be\n      // found.\n      int64_t now = GetTime();\n      std::string newFilename = strprintf(\"wallet.%\"PRId64\".bak\", now);\n  \n      int result = dbenv.dbenv.dbrename(NULL, filename.c_str(), NULL,\n                                        newFilename.c_str(), DB_AUTO_COMMIT);\n      if (result == 0)\n          printf(\"Renamed %s to %s\\n\", filename.c_str(), newFilename.c_str());\n      else\n      {\n          printf(\"Failed to rename %s to %s\\n\", filename.c_str(), newFilename.c_str());\n          return false;\n      }\n  \n      std::vector<CDBEnv::KeyValPair> salvagedData;\n      bool allOK = dbenv.Salvage(newFilename, true, salvagedData);\n      if (salvagedData.empty())\n      {\n          printf(\"Salvage(aggressive) found no records in %s.\\n\", newFilename.c_str());\n          return false;\n      }\n      printf(\"Salvage(aggressive) found %\"PRIszu\" records\\n\", salvagedData.size());\n  \n      bool fSuccess = allOK;\n      Db* pdbCopy = new Db(&dbenv.dbenv, 0);\n      int ret = pdbCopy->open(NULL,                 // Txn pointer\n                              filename.c_str(),   // Filename\n                              \"main\",    // Logical db name\n                              DB_BTREE,  // Database type\n                              DB_CREATE,    // Flags\n                              0);\n      if (ret > 0)\n      {\n          printf(\"Cannot create database file %s\\n\", filename.c_str());\n          return false;\n      }\n      CWallet dummyWallet;\n      CWalletScanState wss;\n  \n      DbTxn* ptxn = dbenv.TxnBegin();\n      BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n      {\n          if (fOnlyKeys)\n          {\n              CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n              CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n              string strType, strErr;\n              bool fReadOK = ReadKeyValue(&dummyWallet, ssKey, ssValue,\n                                          wss, strType, strErr);\n              if (!IsKeyType(strType))\n                  continue;\n              if (!fReadOK)\n              {\n                  printf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType.c_str(), strErr.c_str());\n                  continue;\n              }\n          }\n          Dbt datKey(&row.first[0], row.first.size());\n          Dbt datValue(&row.second[0], row.second.size());\n          int ret2 = pdbCopy->put(ptxn, &datKey, &datValue, DB_NOOVERWRITE);\n          if (ret2 > 0)\n              fSuccess = false;\n      }\n      ptxn->commit(0);\n      pdbCopy->close(0);\n      delete pdbCopy;\n  \n      return fSuccess;\n  }\n}"
  },
  {
    "function_name": "BackupWallet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "595-633",
    "snippet": "bool BackupWallet(const CWallet& wallet, const string& strDest)\n{\n    if (!wallet.fFileBacked)\n        return false;\n    while (!fShutdown)\n    {\n        {\n            LOCK(bitdb.cs_db);\n            if (!bitdb.mapFileUseCount.count(wallet.strWalletFile) || bitdb.mapFileUseCount[wallet.strWalletFile] == 0)\n            {\n                // Flush log data to the dat file\n                bitdb.CloseDb(wallet.strWalletFile);\n                bitdb.CheckpointLSN(wallet.strWalletFile);\n                bitdb.mapFileUseCount.erase(wallet.strWalletFile);\n\n                // Copy wallet.dat\n                filesystem::path pathSrc = GetDataDir() / wallet.strWalletFile;\n                filesystem::path pathDest(strDest);\n                if (filesystem::is_directory(pathDest))\n                    pathDest /= wallet.strWalletFile;\n\n                try {\n#if BOOST_VERSION >= 104000\n                    filesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n#else\n                    filesystem::copy_file(pathSrc, pathDest);\n#endif\n                    printf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n                    return true;\n                } catch(const filesystem::filesystem_error &e) {\n                    printf(\"error copying wallet.dat to %s - %s\\n\", pathDest.string().c_str(), e.what());\n                    return false;\n                }\n            }\n        }\n        MilliSleep(100);\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "100"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"error copying wallet.dat to %s - %s\\n\"",
            "pathDest.string().c_str()",
            "e.what()"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathDest.string",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathDest.string",
          "args": [],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"copied wallet.dat to %s\\n\"",
            "pathDest.string().c_str()"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pathDest.string",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pathDest.string",
          "args": [],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::copy_file",
          "args": [
            "pathSrc",
            "pathDest"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::copy_file",
          "args": [
            "pathSrc",
            "pathDest",
            "filesystem::copy_option::overwrite_if_exists"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::is_directory",
          "args": [
            "pathDest"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitdb.mapFileUseCount.erase",
          "args": [
            "wallet.strWalletFile"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.CheckpointLSN",
          "args": [
            "wallet.strWalletFile"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "CheckpointLSN",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "220-226",
          "snippet": "void CDBEnv::CheckpointLSN(std::string strFile)\n{\n    dbenv.txn_checkpoint(0, 0, 0);\n    if (fMockDb)\n        return;\n    dbenv.lsn_reset(strFile.c_str(), 0);\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv {\n  void CDBEnv::CheckpointLSN(std::string strFile)\n  {\n      dbenv.txn_checkpoint(0, 0, 0);\n      if (fMockDb)\n          return;\n      dbenv.lsn_reset(strFile.c_str(), 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.CloseDb",
          "args": [
            "wallet.strWalletFile"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "CloseDb",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "327-340",
          "snippet": "void CDBEnv::CloseDb(const string& strFile)\n{\n    {\n        LOCK(cs_db);\n        if (mapDb[strFile] != NULL)\n        {\n            // Close the database handle\n            Db* pdb = mapDb[strFile];\n            pdb->close(0);\n            delete pdb;\n            mapDb[strFile] = NULL;\n        }\n    }\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv {\n  void CDBEnv::CloseDb(const string& strFile)\n  {\n      {\n          LOCK(cs_db);\n          if (mapDb[strFile] != NULL)\n          {\n              // Close the database handle\n              Db* pdb = mapDb[strFile];\n              pdb->close(0);\n              delete pdb;\n              mapDb[strFile] = NULL;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.mapFileUseCount.count",
          "args": [
            "wallet.strWalletFile"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "bitdb.cs_db"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nbool BackupWallet(const CWallet& wallet, const string& strDest)\n{\n    if (!wallet.fFileBacked)\n        return false;\n    while (!fShutdown)\n    {\n        {\n            LOCK(bitdb.cs_db);\n            if (!bitdb.mapFileUseCount.count(wallet.strWalletFile) || bitdb.mapFileUseCount[wallet.strWalletFile] == 0)\n            {\n                // Flush log data to the dat file\n                bitdb.CloseDb(wallet.strWalletFile);\n                bitdb.CheckpointLSN(wallet.strWalletFile);\n                bitdb.mapFileUseCount.erase(wallet.strWalletFile);\n\n                // Copy wallet.dat\n                filesystem::path pathSrc = GetDataDir() / wallet.strWalletFile;\n                filesystem::path pathDest(strDest);\n                if (filesystem::is_directory(pathDest))\n                    pathDest /= wallet.strWalletFile;\n\n                try {\n#if BOOST_VERSION >= 104000\n                    filesystem::copy_file(pathSrc, pathDest, filesystem::copy_option::overwrite_if_exists);\n#else\n                    filesystem::copy_file(pathSrc, pathDest);\n#endif\n                    printf(\"copied wallet.dat to %s\\n\", pathDest.string().c_str());\n                    return true;\n                } catch(const filesystem::filesystem_error &e) {\n                    printf(\"error copying wallet.dat to %s - %s\\n\", pathDest.string().c_str(), e.what());\n                    return false;\n                }\n            }\n        }\n        MilliSleep(100);\n    }\n    return false;\n}"
  },
  {
    "function_name": "ThreadFlushWalletDB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "533-593",
    "snippet": "void ThreadFlushWalletDB(void* parg)\n{\n    // Make this thread recognisable as the wallet flushing thread\n    RenameThread(\"hal-wallet\");\n\n    const string& strFile = ((const string*)parg)[0];\n    static bool fOneThread;\n    if (fOneThread)\n        return;\n    fOneThread = true;\n    if (!GetBoolArg(\"-flushwallet\", true))\n        return;\n\n    unsigned int nLastSeen = nWalletDBUpdated;\n    unsigned int nLastFlushed = nWalletDBUpdated;\n    int64_t nLastWalletUpdate = GetTime();\n    while (!fShutdown)\n    {\n        MilliSleep(500);\n\n        if (nLastSeen != nWalletDBUpdated)\n        {\n            nLastSeen = nWalletDBUpdated;\n            nLastWalletUpdate = GetTime();\n        }\n\n        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n        {\n            TRY_LOCK(bitdb.cs_db,lockDb);\n            if (lockDb)\n            {\n                // Don't do this if any databases are in use\n                int nRefCount = 0;\n                map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n                while (mi != bitdb.mapFileUseCount.end())\n                {\n                    nRefCount += (*mi).second;\n                    mi++;\n                }\n\n                if (nRefCount == 0 && !fShutdown)\n                {\n                    map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n                    if (mi != bitdb.mapFileUseCount.end())\n                    {\n                        printf(\"Flushing wallet.dat\\n\");\n                        nLastFlushed = nWalletDBUpdated;\n                        int64_t nStart = GetTimeMillis();\n\n                        // Flush wallet.dat so it's self contained\n                        bitdb.CloseDb(strFile);\n                        bitdb.CheckpointLSN(strFile);\n\n                        bitdb.mapFileUseCount.erase(mi++);\n                        printf(\"Flushed wallet.dat %\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n                    }\n                }\n            }\n        }\n    }\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Flushed wallet.dat %\"PRId64\"ms\\n\"",
            "GetTimeMillis() - nStart"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTimeMillis",
          "args": [],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.mapFileUseCount.erase",
          "args": [
            "mi++"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.CheckpointLSN",
          "args": [
            "strFile"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "CheckpointLSN",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "220-226",
          "snippet": "void CDBEnv::CheckpointLSN(std::string strFile)\n{\n    dbenv.txn_checkpoint(0, 0, 0);\n    if (fMockDb)\n        return;\n    dbenv.lsn_reset(strFile.c_str(), 0);\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv {\n  void CDBEnv::CheckpointLSN(std::string strFile)\n  {\n      dbenv.txn_checkpoint(0, 0, 0);\n      if (fMockDb)\n          return;\n      dbenv.lsn_reset(strFile.c_str(), 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.CloseDb",
          "args": [
            "strFile"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "CloseDb",
          "container": "CDBEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "327-340",
          "snippet": "void CDBEnv::CloseDb(const string& strFile)\n{\n    {\n        LOCK(cs_db);\n        if (mapDb[strFile] != NULL)\n        {\n            // Close the database handle\n            Db* pdb = mapDb[strFile];\n            pdb->close(0);\n            delete pdb;\n            mapDb[strFile] = NULL;\n        }\n    }\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCDBEnv {\n  void CDBEnv::CloseDb(const string& strFile)\n  {\n      {\n          LOCK(cs_db);\n          if (mapDb[strFile] != NULL)\n          {\n              // Close the database handle\n              Db* pdb = mapDb[strFile];\n              pdb->close(0);\n              delete pdb;\n              mapDb[strFile] = NULL;\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Flushing wallet.dat\\n\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitdb.mapFileUseCount.end",
          "args": [],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.mapFileUseCount.find",
          "args": [
            "strFile"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitdb.mapFileUseCount.begin",
          "args": [],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "bitdb.cs_db",
            "lockDb"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "500"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-flushwallet\"",
            "true"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "GetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "569-578",
          "snippet": "bool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nbool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-wallet\""
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nvoid ThreadFlushWalletDB(void* parg)\n{\n    // Make this thread recognisable as the wallet flushing thread\n    RenameThread(\"hal-wallet\");\n\n    const string& strFile = ((const string*)parg)[0];\n    static bool fOneThread;\n    if (fOneThread)\n        return;\n    fOneThread = true;\n    if (!GetBoolArg(\"-flushwallet\", true))\n        return;\n\n    unsigned int nLastSeen = nWalletDBUpdated;\n    unsigned int nLastFlushed = nWalletDBUpdated;\n    int64_t nLastWalletUpdate = GetTime();\n    while (!fShutdown)\n    {\n        MilliSleep(500);\n\n        if (nLastSeen != nWalletDBUpdated)\n        {\n            nLastSeen = nWalletDBUpdated;\n            nLastWalletUpdate = GetTime();\n        }\n\n        if (nLastFlushed != nWalletDBUpdated && GetTime() - nLastWalletUpdate >= 2)\n        {\n            TRY_LOCK(bitdb.cs_db,lockDb);\n            if (lockDb)\n            {\n                // Don't do this if any databases are in use\n                int nRefCount = 0;\n                map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n                while (mi != bitdb.mapFileUseCount.end())\n                {\n                    nRefCount += (*mi).second;\n                    mi++;\n                }\n\n                if (nRefCount == 0 && !fShutdown)\n                {\n                    map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n                    if (mi != bitdb.mapFileUseCount.end())\n                    {\n                        printf(\"Flushing wallet.dat\\n\");\n                        nLastFlushed = nWalletDBUpdated;\n                        int64_t nStart = GetTimeMillis();\n\n                        // Flush wallet.dat so it's self contained\n                        bitdb.CloseDb(strFile);\n                        bitdb.CheckpointLSN(strFile);\n\n                        bitdb.mapFileUseCount.erase(mi++);\n                        printf(\"Flushed wallet.dat %\"PRId64\"ms\\n\", GetTimeMillis() - nStart);\n                    }\n                }\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "LoadWallet",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "433-531",
    "snippet": "DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n{\n    pwallet->vchDefaultKey = CPubKey();\n    CWalletScanState wss;\n    bool fNoncriticalErrors = false;\n    DBErrors result = DB_LOAD_OK;\n\n    try {\n        LOCK(pwallet->cs_wallet);\n        int nMinVersion = 0;\n        if (Read((string)\"minversion\", nMinVersion))\n        {\n            if (nMinVersion > CLIENT_VERSION)\n                return DB_TOO_NEW;\n            pwallet->LoadMinVersion(nMinVersion);\n        }\n\n        // Get cursor\n        Dbc* pcursor = GetCursor();\n        if (!pcursor)\n        {\n            printf(\"Error getting wallet database cursor\\n\");\n            return DB_CORRUPT;\n        }\n\n        while (true)\n        {\n            // Read next record\n            CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n            CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n            int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n            if (ret == DB_NOTFOUND)\n                break;\n            else if (ret != 0)\n            {\n                printf(\"Error reading next record from wallet database\\n\");\n                return DB_CORRUPT;\n            }\n\n            // Try to be tolerant of single corrupt records:\n            string strType, strErr;\n            if (!ReadKeyValue(pwallet, ssKey, ssValue, wss, strType, strErr))\n            {\n                // losing keys is considered a catastrophic error, anything else\n                // we assume the user can live with:\n                if (IsKeyType(strType))\n                    result = DB_CORRUPT;\n                else\n                {\n                    // Leave other errors alone, if we try to fix them we might make things worse.\n                    fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n                    if (strType == \"tx\")\n                        // Rescan if there is a bad transaction record:\n                        SoftSetBoolArg(\"-rescan\", true);\n                }\n            }\n            if (!strErr.empty())\n                printf(\"%s\\n\", strErr.c_str());\n        }\n        pcursor->close();\n    }\n    catch (...)\n    {\n        result = DB_CORRUPT;\n    }\n\n    if (fNoncriticalErrors && result == DB_LOAD_OK)\n        result = DB_NONCRITICAL_ERROR;\n\n    // Any wallet corruption at all: skip any rewriting or\n    // upgrading, we don't want to make it worse.\n    if (result != DB_LOAD_OK)\n        return result;\n\n    printf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n\n    printf(\"Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total\\n\",\n           wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys);\n\n    // nTimeFirstKey is only reliable if all keys have metadata\n    if ((wss.nKeys + wss.nCKeys) != wss.nKeyMeta)\n        pwallet->nTimeFirstKey = 1; // 0 would be considered 'no value'\n\n\n    BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n        WriteTx(hash, pwallet->mapWallet[hash]);\n\n    // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n    if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n        return DB_NEED_REWRITE;\n\n    if (wss.nFileVersion < CLIENT_VERSION) // Update\n        WriteVersion(CLIENT_VERSION);\n\n    if (wss.fAnyUnordered)\n        result = ReorderTransactions(pwallet);\n\n    return result;\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReorderTransactions",
          "args": [
            "pwallet"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ReorderTransactions",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "113-183",
          "snippet": "DBErrors\nCWalletDB::ReorderTransactions(CWallet* pwallet)\n{\n    LOCK(pwallet->cs_wallet);\n    // Old wallets didn't have any defined order for transactions\n    // Probably a bad idea to change the output of this\n\n    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n    typedef multimap<int64_t, TxPair > TxItems;\n    TxItems txByTime;\n\n    for (map<uint256, CWalletTx>::iterator it = pwallet->mapWallet.begin(); it != pwallet->mapWallet.end(); ++it)\n    {\n        CWalletTx* wtx = &((*it).second);\n        txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n    }\n    list<CAccountingEntry> acentries;\n    ListAccountCreditDebit(\"\", acentries);\n    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n    {\n        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n    }\n\n    int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n    nOrderPosNext = 0;\n    std::vector<int64_t> nOrderPosOffsets;\n    for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n    {\n        CWalletTx *const pwtx = (*it).second.first;\n        CAccountingEntry *const pacentry = (*it).second.second;\n        int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n\n        if (nOrderPos == -1)\n        {\n            nOrderPos = nOrderPosNext++;\n            nOrderPosOffsets.push_back(nOrderPos);\n\n            if (pacentry)\n                // Have to write accounting regardless, since we don't keep it in memory\n                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n        else\n        {\n            int64_t nOrderPosOff = 0;\n            BOOST_FOREACH(const int64_t& nOffsetStart, nOrderPosOffsets)\n            {\n                if (nOrderPos >= nOffsetStart)\n                    ++nOrderPosOff;\n            }\n            nOrderPos += nOrderPosOff;\n            nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);\n\n            if (!nOrderPosOff)\n                continue;\n\n            // Since we're changing the order, write it back\n            if (pwtx)\n            {\n                if (!WriteTx(pwtx->GetHash(), *pwtx))\n                    return DB_LOAD_FAIL;\n            }\n            else\n                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n    }\n\n    return DB_LOAD_OK;\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  DBErrors\n  CWalletDB::ReorderTransactions(CWallet* pwallet)\n  {\n      LOCK(pwallet->cs_wallet);\n      // Old wallets didn't have any defined order for transactions\n      // Probably a bad idea to change the output of this\n  \n      // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n      typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n      typedef multimap<int64_t, TxPair > TxItems;\n      TxItems txByTime;\n  \n      for (map<uint256, CWalletTx>::iterator it = pwallet->mapWallet.begin(); it != pwallet->mapWallet.end(); ++it)\n      {\n          CWalletTx* wtx = &((*it).second);\n          txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n      }\n      list<CAccountingEntry> acentries;\n      ListAccountCreditDebit(\"\", acentries);\n      BOOST_FOREACH(CAccountingEntry& entry, acentries)\n      {\n          txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n      }\n  \n      int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n      nOrderPosNext = 0;\n      std::vector<int64_t> nOrderPosOffsets;\n      for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n      {\n          CWalletTx *const pwtx = (*it).second.first;\n          CAccountingEntry *const pacentry = (*it).second.second;\n          int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n  \n          if (nOrderPos == -1)\n          {\n              nOrderPos = nOrderPosNext++;\n              nOrderPosOffsets.push_back(nOrderPos);\n  \n              if (pacentry)\n                  // Have to write accounting regardless, since we don't keep it in memory\n                  if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                      return DB_LOAD_FAIL;\n          }\n          else\n          {\n              int64_t nOrderPosOff = 0;\n              BOOST_FOREACH(const int64_t& nOffsetStart, nOrderPosOffsets)\n              {\n                  if (nOrderPos >= nOffsetStart)\n                      ++nOrderPosOff;\n              }\n              nOrderPos += nOrderPosOff;\n              nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);\n  \n              if (!nOrderPosOff)\n                  continue;\n  \n              // Since we're changing the order, write it back\n              if (pwtx)\n              {\n                  if (!WriteTx(pwtx->GetHash(), *pwtx))\n                      return DB_LOAD_FAIL;\n              }\n              else\n                  if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                      return DB_LOAD_FAIL;\n          }\n      }\n  \n      return DB_LOAD_OK;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteVersion",
          "args": [
            "CLIENT_VERSION"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "WriteVersion",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "181-184",
          "snippet": "bool WriteVersion(int nVersion)\n    {\n        return Write(std::string(\"version\"), nVersion);\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool WriteVersion(int nVersion)\n      {\n          return Write(std::string(\"version\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteTx",
          "args": [
            "hash",
            "pwallet->mapWallet[hash]"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "WriteTx",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "73-77",
          "snippet": "bool WriteTx(uint256 hash, const CWalletTx& wtx)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteTx(uint256 hash, const CWalletTx& wtx)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total\\n\"",
            "wss.nKeys",
            "wss.nCKeys",
            "wss.nKeyMeta",
            "wss.nKeys + wss.nCKeys"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"nFileVersion = %d\\n\"",
            "wss.nFileVersion"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pcursor->close",
          "args": [],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "AcceptedConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "664-667",
          "snippet": "virtual void close()\n    {\n        _stream.close();\n    }",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nAcceptedConnectionImpl {\n  virtual void close()\n      {\n          _stream.close();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strErr.c_str",
          "args": [],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strErr.empty",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SoftSetBoolArg",
          "args": [
            "\"-rescan\"",
            "true"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "SoftSetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "588-594",
          "snippet": "bool SoftSetBoolArg(const std::string& strArg, bool fValue)\n{\n    if (fValue)\n        return SoftSetArg(strArg, std::string(\"1\"));\n    else\n        return SoftSetArg(strArg, std::string(\"0\"));\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool SoftSetBoolArg(const std::string& strArg, bool fValue)\n{\n    if (fValue)\n        return SoftSetArg(strArg, std::string(\"1\"));\n    else\n        return SoftSetArg(strArg, std::string(\"0\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsKeyType",
          "args": [
            "strType"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "IsKeyType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "427-431",
          "snippet": "static bool IsKeyType(string strType)\n{\n    return (strType== \"key\" || strType == \"wkey\" ||\n            strType == \"mkey\" || strType == \"ckey\");\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nstatic bool IsKeyType(string strType)\n{\n    return (strType== \"key\" || strType == \"wkey\" ||\n            strType == \"mkey\" || strType == \"ckey\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadKeyValue",
          "args": [
            "pwallet",
            "ssKey",
            "ssValue",
            "wss",
            "strType",
            "strErr"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ReadKeyValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "203-425",
          "snippet": "bool\nReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CWalletScanState &wss, string& strType, string& strErr)\n{\n    try {\n        // Unserialize\n        // Taking advantage of the fact that pair serialization\n        // is just the two items serialized one after the other\n        ssKey >> strType;\n        if (strType == \"name\")\n        {\n            string strAddress;\n            ssKey >> strAddress;\n            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n        }\n        else if (strType == \"tx\")\n        {\n            uint256 hash;\n            ssKey >> hash;\n            CWalletTx& wtx = pwallet->mapWallet[hash];\n            ssValue >> wtx;\n            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n                wtx.BindWallet(pwallet);\n            else\n            {\n                pwallet->mapWallet.erase(hash);\n                return false;\n            }\n\n            // Undo serialize changes in 31600\n            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n            {\n                if (!ssValue.empty())\n                {\n                    char fTmp;\n                    char fUnused;\n                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = fTmp;\n                }\n                else\n                {\n                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = 0;\n                }\n                wss.vWalletUpgrade.push_back(hash);\n            }\n\n            if (wtx.nOrderPos == -1)\n                wss.fAnyUnordered = true;\n\n            //// debug print\n            //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n            //printf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n            //    wtx.vout[0].nValue,\n            //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n            //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n            //    wtx.mapValue[\"message\"].c_str());\n        }\n        else if (strType == \"acentry\")\n        {\n            string strAccount;\n            ssKey >> strAccount;\n            uint64_t nNumber;\n            ssKey >> nNumber;\n            if (nNumber > nAccountingEntryNumber)\n                nAccountingEntryNumber = nNumber;\n\n            if (!wss.fAnyUnordered)\n            {\n                CAccountingEntry acentry;\n                ssValue >> acentry;\n                if (acentry.nOrderPos == -1)\n                    wss.fAnyUnordered = true;\n            }\n        }\n        else if (strType == \"key\" || strType == \"wkey\")\n        {\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            CKey key;\n            if (strType == \"key\")\n            {\n                wss.nKeys++;\n                CPrivKey pkey;\n                ssValue >> pkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(pkey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n                    return false;\n                }\n            }\n            else\n            {\n                CWalletKey wkey;\n                ssValue >> wkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(wkey.vchPrivKey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n                    return false;\n                }\n            }\n            if (!pwallet->LoadKey(key))\n            {\n                strErr = \"Error reading wallet database: LoadKey failed\";\n                return false;\n            }\n        }\n        else if (strType == \"mkey\")\n        {\n            unsigned int nID;\n            ssKey >> nID;\n            CMasterKey kMasterKey;\n            ssValue >> kMasterKey;\n            if(pwallet->mapMasterKeys.count(nID) != 0)\n            {\n                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n                return false;\n            }\n            pwallet->mapMasterKeys[nID] = kMasterKey;\n            if (pwallet->nMasterKeyMaxID < nID)\n                pwallet->nMasterKeyMaxID = nID;\n        }\n        else if (strType == \"ckey\")\n        {\n            wss.nCKeys++;\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            vector<unsigned char> vchPrivKey;\n            ssValue >> vchPrivKey;\n            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n            {\n                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n                return false;\n            }\n            wss.fIsEncrypted = true;\n        }\n        else if (strType == \"keymeta\")\n        {\n            CPubKey vchPubKey;\n            ssKey >> vchPubKey;\n            CKeyMetadata keyMeta;\n            ssValue >> keyMeta;\n            wss.nKeyMeta++;\n\n            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n\n            // find earliest key creation time, as wallet birthday\n            if (!pwallet->nTimeFirstKey ||\n                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n        }\n        else if (strType == \"defaultkey\")\n        {\n            ssValue >> pwallet->vchDefaultKey;\n        }\n        else if (strType == \"pool\")\n        {\n            int64_t nIndex;\n            ssKey >> nIndex;\n            CKeyPool keypool;\n            ssValue >> keypool;\n            pwallet->setKeyPool.insert(nIndex);\n\n            // If no metadata exists yet, create a default with the pool key's\n            // creation time. Note that this may be overwritten by actually\n            // stored metadata for that key later, which is fine.\n            CKeyID keyid = keypool.vchPubKey.GetID();\n            if (pwallet->mapKeyMetadata.count(keyid) == 0)\n                pwallet->mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n\n        }\n        else if (strType == \"version\")\n        {\n            ssValue >> wss.nFileVersion;\n            if (wss.nFileVersion == 10300)\n                wss.nFileVersion = 300;\n        }\n        else if (strType == \"cscript\")\n        {\n            uint160 hash;\n            ssKey >> hash;\n            CScript script;\n            ssValue >> script;\n            if (!pwallet->LoadCScript(script))\n            {\n                strErr = \"Error reading wallet database: LoadCScript failed\";\n                return false;\n            }\n        }\n        else if (strType == \"orderposnext\")\n        {\n            ssValue >> pwallet->nOrderPosNext;\n        }\n    } catch (...)\n    {\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t nAccountingEntryNumber = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nstatic uint64_t nAccountingEntryNumber = 0;\n\nbool\nReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CWalletScanState &wss, string& strType, string& strErr)\n{\n    try {\n        // Unserialize\n        // Taking advantage of the fact that pair serialization\n        // is just the two items serialized one after the other\n        ssKey >> strType;\n        if (strType == \"name\")\n        {\n            string strAddress;\n            ssKey >> strAddress;\n            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n        }\n        else if (strType == \"tx\")\n        {\n            uint256 hash;\n            ssKey >> hash;\n            CWalletTx& wtx = pwallet->mapWallet[hash];\n            ssValue >> wtx;\n            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n                wtx.BindWallet(pwallet);\n            else\n            {\n                pwallet->mapWallet.erase(hash);\n                return false;\n            }\n\n            // Undo serialize changes in 31600\n            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n            {\n                if (!ssValue.empty())\n                {\n                    char fTmp;\n                    char fUnused;\n                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = fTmp;\n                }\n                else\n                {\n                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = 0;\n                }\n                wss.vWalletUpgrade.push_back(hash);\n            }\n\n            if (wtx.nOrderPos == -1)\n                wss.fAnyUnordered = true;\n\n            //// debug print\n            //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n            //printf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n            //    wtx.vout[0].nValue,\n            //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n            //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n            //    wtx.mapValue[\"message\"].c_str());\n        }\n        else if (strType == \"acentry\")\n        {\n            string strAccount;\n            ssKey >> strAccount;\n            uint64_t nNumber;\n            ssKey >> nNumber;\n            if (nNumber > nAccountingEntryNumber)\n                nAccountingEntryNumber = nNumber;\n\n            if (!wss.fAnyUnordered)\n            {\n                CAccountingEntry acentry;\n                ssValue >> acentry;\n                if (acentry.nOrderPos == -1)\n                    wss.fAnyUnordered = true;\n            }\n        }\n        else if (strType == \"key\" || strType == \"wkey\")\n        {\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            CKey key;\n            if (strType == \"key\")\n            {\n                wss.nKeys++;\n                CPrivKey pkey;\n                ssValue >> pkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(pkey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n                    return false;\n                }\n            }\n            else\n            {\n                CWalletKey wkey;\n                ssValue >> wkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(wkey.vchPrivKey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n                    return false;\n                }\n            }\n            if (!pwallet->LoadKey(key))\n            {\n                strErr = \"Error reading wallet database: LoadKey failed\";\n                return false;\n            }\n        }\n        else if (strType == \"mkey\")\n        {\n            unsigned int nID;\n            ssKey >> nID;\n            CMasterKey kMasterKey;\n            ssValue >> kMasterKey;\n            if(pwallet->mapMasterKeys.count(nID) != 0)\n            {\n                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n                return false;\n            }\n            pwallet->mapMasterKeys[nID] = kMasterKey;\n            if (pwallet->nMasterKeyMaxID < nID)\n                pwallet->nMasterKeyMaxID = nID;\n        }\n        else if (strType == \"ckey\")\n        {\n            wss.nCKeys++;\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            vector<unsigned char> vchPrivKey;\n            ssValue >> vchPrivKey;\n            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n            {\n                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n                return false;\n            }\n            wss.fIsEncrypted = true;\n        }\n        else if (strType == \"keymeta\")\n        {\n            CPubKey vchPubKey;\n            ssKey >> vchPubKey;\n            CKeyMetadata keyMeta;\n            ssValue >> keyMeta;\n            wss.nKeyMeta++;\n\n            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n\n            // find earliest key creation time, as wallet birthday\n            if (!pwallet->nTimeFirstKey ||\n                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n        }\n        else if (strType == \"defaultkey\")\n        {\n            ssValue >> pwallet->vchDefaultKey;\n        }\n        else if (strType == \"pool\")\n        {\n            int64_t nIndex;\n            ssKey >> nIndex;\n            CKeyPool keypool;\n            ssValue >> keypool;\n            pwallet->setKeyPool.insert(nIndex);\n\n            // If no metadata exists yet, create a default with the pool key's\n            // creation time. Note that this may be overwritten by actually\n            // stored metadata for that key later, which is fine.\n            CKeyID keyid = keypool.vchPubKey.GetID();\n            if (pwallet->mapKeyMetadata.count(keyid) == 0)\n                pwallet->mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n\n        }\n        else if (strType == \"version\")\n        {\n            ssValue >> wss.nFileVersion;\n            if (wss.nFileVersion == 10300)\n                wss.nFileVersion = 300;\n        }\n        else if (strType == \"cscript\")\n        {\n            uint160 hash;\n            ssKey >> hash;\n            CScript script;\n            ssValue >> script;\n            if (!pwallet->LoadCScript(script))\n            {\n                strErr = \"Error reading wallet database: LoadCScript failed\";\n                return false;\n            }\n        }\n        else if (strType == \"orderposnext\")\n        {\n            ssValue >> pwallet->nOrderPosNext;\n        }\n    } catch (...)\n    {\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error reading next record from wallet database\\n\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadAtCursor",
          "args": [
            "pcursor",
            "ssKey",
            "ssValue"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ReadAtCursor",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "231-268",
          "snippet": "int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags=DB_NEXT)\n    {\n        // Read at cursor\n        Dbt datKey;\n        if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n        {\n            datKey.set_data(&ssKey[0]);\n            datKey.set_size(ssKey.size());\n        }\n        Dbt datValue;\n        if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n        {\n            datValue.set_data(&ssValue[0]);\n            datValue.set_size(ssValue.size());\n        }\n        datKey.set_flags(DB_DBT_MALLOC);\n        datValue.set_flags(DB_DBT_MALLOC);\n        int ret = pcursor->get(&datKey, &datValue, fFlags);\n        if (ret != 0)\n            return ret;\n        else if (datKey.get_data() == NULL || datValue.get_data() == NULL)\n            return 99999;\n\n        // Convert to streams\n        ssKey.SetType(SER_DISK);\n        ssKey.clear();\n        ssKey.write((char*)datKey.get_data(), datKey.get_size());\n        ssValue.SetType(SER_DISK);\n        ssValue.clear();\n        ssValue.write((char*)datValue.get_data(), datValue.get_size());\n\n        // Clear and free memory\n        memset(datKey.get_data(), 0, datKey.get_size());\n        memset(datValue.get_data(), 0, datValue.get_size());\n        free(datKey.get_data());\n        free(datValue.get_data());\n        return 0;\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  int ReadAtCursor(Dbc* pcursor, CDataStream& ssKey, CDataStream& ssValue, unsigned int fFlags=DB_NEXT)\n      {\n          // Read at cursor\n          Dbt datKey;\n          if (fFlags == DB_SET || fFlags == DB_SET_RANGE || fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n          {\n              datKey.set_data(&ssKey[0]);\n              datKey.set_size(ssKey.size());\n          }\n          Dbt datValue;\n          if (fFlags == DB_GET_BOTH || fFlags == DB_GET_BOTH_RANGE)\n          {\n              datValue.set_data(&ssValue[0]);\n              datValue.set_size(ssValue.size());\n          }\n          datKey.set_flags(DB_DBT_MALLOC);\n          datValue.set_flags(DB_DBT_MALLOC);\n          int ret = pcursor->get(&datKey, &datValue, fFlags);\n          if (ret != 0)\n              return ret;\n          else if (datKey.get_data() == NULL || datValue.get_data() == NULL)\n              return 99999;\n  \n          // Convert to streams\n          ssKey.SetType(SER_DISK);\n          ssKey.clear();\n          ssKey.write((char*)datKey.get_data(), datKey.get_size());\n          ssValue.SetType(SER_DISK);\n          ssValue.clear();\n          ssValue.write((char*)datValue.get_data(), datValue.get_size());\n  \n          // Clear and free memory\n          memset(datKey.get_data(), 0, datKey.get_size());\n          memset(datValue.get_data(), 0, datValue.get_size());\n          free(datKey.get_data());\n          free(datValue.get_data());\n          return 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error getting wallet database cursor\\n\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCursor",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwallet->LoadMinVersion",
          "args": [
            "nMinVersion"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "LoadMinVersion",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "143-143",
          "snippet": "bool LoadMinVersion(int nVersion) { nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  bool LoadMinVersion(int nVersion) { nWalletVersion = nVersion; nWalletMaxVersion = std::max(nWalletMaxVersion, nVersion); return true; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "(string)\"minversion\"",
            "nMinVersion"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "ReadAccount",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "36-40",
          "snippet": "bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n{\n    account.SetNull();\n    return Read(make_pair(string(\"acc\"), strAccount), account);\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n  {\n      account.SetNull();\n      return Read(make_pair(string(\"acc\"), strAccount), account);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "pwallet->cs_wallet"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n  {\n      pwallet->vchDefaultKey = CPubKey();\n      CWalletScanState wss;\n      bool fNoncriticalErrors = false;\n      DBErrors result = DB_LOAD_OK;\n  \n      try {\n          LOCK(pwallet->cs_wallet);\n          int nMinVersion = 0;\n          if (Read((string)\"minversion\", nMinVersion))\n          {\n              if (nMinVersion > CLIENT_VERSION)\n                  return DB_TOO_NEW;\n              pwallet->LoadMinVersion(nMinVersion);\n          }\n  \n          // Get cursor\n          Dbc* pcursor = GetCursor();\n          if (!pcursor)\n          {\n              printf(\"Error getting wallet database cursor\\n\");\n              return DB_CORRUPT;\n          }\n  \n          while (true)\n          {\n              // Read next record\n              CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n              CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n              int ret = ReadAtCursor(pcursor, ssKey, ssValue);\n              if (ret == DB_NOTFOUND)\n                  break;\n              else if (ret != 0)\n              {\n                  printf(\"Error reading next record from wallet database\\n\");\n                  return DB_CORRUPT;\n              }\n  \n              // Try to be tolerant of single corrupt records:\n              string strType, strErr;\n              if (!ReadKeyValue(pwallet, ssKey, ssValue, wss, strType, strErr))\n              {\n                  // losing keys is considered a catastrophic error, anything else\n                  // we assume the user can live with:\n                  if (IsKeyType(strType))\n                      result = DB_CORRUPT;\n                  else\n                  {\n                      // Leave other errors alone, if we try to fix them we might make things worse.\n                      fNoncriticalErrors = true; // ... but do warn the user there is something wrong.\n                      if (strType == \"tx\")\n                          // Rescan if there is a bad transaction record:\n                          SoftSetBoolArg(\"-rescan\", true);\n                  }\n              }\n              if (!strErr.empty())\n                  printf(\"%s\\n\", strErr.c_str());\n          }\n          pcursor->close();\n      }\n      catch (...)\n      {\n          result = DB_CORRUPT;\n      }\n  \n      if (fNoncriticalErrors && result == DB_LOAD_OK)\n          result = DB_NONCRITICAL_ERROR;\n  \n      // Any wallet corruption at all: skip any rewriting or\n      // upgrading, we don't want to make it worse.\n      if (result != DB_LOAD_OK)\n          return result;\n  \n      printf(\"nFileVersion = %d\\n\", wss.nFileVersion);\n  \n      printf(\"Keys: %u plaintext, %u encrypted, %u w/ metadata, %u total\\n\",\n             wss.nKeys, wss.nCKeys, wss.nKeyMeta, wss.nKeys + wss.nCKeys);\n  \n      // nTimeFirstKey is only reliable if all keys have metadata\n      if ((wss.nKeys + wss.nCKeys) != wss.nKeyMeta)\n          pwallet->nTimeFirstKey = 1; // 0 would be considered 'no value'\n  \n  \n      BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n          WriteTx(hash, pwallet->mapWallet[hash]);\n  \n      // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n      if (wss.fIsEncrypted && (wss.nFileVersion == 40000 || wss.nFileVersion == 50000))\n          return DB_NEED_REWRITE;\n  \n      if (wss.nFileVersion < CLIENT_VERSION) // Update\n          WriteVersion(CLIENT_VERSION);\n  \n      if (wss.fAnyUnordered)\n          result = ReorderTransactions(pwallet);\n  \n      return result;\n  }\n}"
  },
  {
    "function_name": "IsKeyType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "427-431",
    "snippet": "static bool IsKeyType(string strType)\n{\n    return (strType== \"key\" || strType == \"wkey\" ||\n            strType == \"mkey\" || strType == \"ckey\");\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nstatic bool IsKeyType(string strType)\n{\n    return (strType== \"key\" || strType == \"wkey\" ||\n            strType == \"mkey\" || strType == \"ckey\");\n}"
  },
  {
    "function_name": "ReadKeyValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "203-425",
    "snippet": "bool\nReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CWalletScanState &wss, string& strType, string& strErr)\n{\n    try {\n        // Unserialize\n        // Taking advantage of the fact that pair serialization\n        // is just the two items serialized one after the other\n        ssKey >> strType;\n        if (strType == \"name\")\n        {\n            string strAddress;\n            ssKey >> strAddress;\n            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n        }\n        else if (strType == \"tx\")\n        {\n            uint256 hash;\n            ssKey >> hash;\n            CWalletTx& wtx = pwallet->mapWallet[hash];\n            ssValue >> wtx;\n            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n                wtx.BindWallet(pwallet);\n            else\n            {\n                pwallet->mapWallet.erase(hash);\n                return false;\n            }\n\n            // Undo serialize changes in 31600\n            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n            {\n                if (!ssValue.empty())\n                {\n                    char fTmp;\n                    char fUnused;\n                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = fTmp;\n                }\n                else\n                {\n                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = 0;\n                }\n                wss.vWalletUpgrade.push_back(hash);\n            }\n\n            if (wtx.nOrderPos == -1)\n                wss.fAnyUnordered = true;\n\n            //// debug print\n            //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n            //printf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n            //    wtx.vout[0].nValue,\n            //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n            //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n            //    wtx.mapValue[\"message\"].c_str());\n        }\n        else if (strType == \"acentry\")\n        {\n            string strAccount;\n            ssKey >> strAccount;\n            uint64_t nNumber;\n            ssKey >> nNumber;\n            if (nNumber > nAccountingEntryNumber)\n                nAccountingEntryNumber = nNumber;\n\n            if (!wss.fAnyUnordered)\n            {\n                CAccountingEntry acentry;\n                ssValue >> acentry;\n                if (acentry.nOrderPos == -1)\n                    wss.fAnyUnordered = true;\n            }\n        }\n        else if (strType == \"key\" || strType == \"wkey\")\n        {\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            CKey key;\n            if (strType == \"key\")\n            {\n                wss.nKeys++;\n                CPrivKey pkey;\n                ssValue >> pkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(pkey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n                    return false;\n                }\n            }\n            else\n            {\n                CWalletKey wkey;\n                ssValue >> wkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(wkey.vchPrivKey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n                    return false;\n                }\n            }\n            if (!pwallet->LoadKey(key))\n            {\n                strErr = \"Error reading wallet database: LoadKey failed\";\n                return false;\n            }\n        }\n        else if (strType == \"mkey\")\n        {\n            unsigned int nID;\n            ssKey >> nID;\n            CMasterKey kMasterKey;\n            ssValue >> kMasterKey;\n            if(pwallet->mapMasterKeys.count(nID) != 0)\n            {\n                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n                return false;\n            }\n            pwallet->mapMasterKeys[nID] = kMasterKey;\n            if (pwallet->nMasterKeyMaxID < nID)\n                pwallet->nMasterKeyMaxID = nID;\n        }\n        else if (strType == \"ckey\")\n        {\n            wss.nCKeys++;\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            vector<unsigned char> vchPrivKey;\n            ssValue >> vchPrivKey;\n            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n            {\n                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n                return false;\n            }\n            wss.fIsEncrypted = true;\n        }\n        else if (strType == \"keymeta\")\n        {\n            CPubKey vchPubKey;\n            ssKey >> vchPubKey;\n            CKeyMetadata keyMeta;\n            ssValue >> keyMeta;\n            wss.nKeyMeta++;\n\n            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n\n            // find earliest key creation time, as wallet birthday\n            if (!pwallet->nTimeFirstKey ||\n                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n        }\n        else if (strType == \"defaultkey\")\n        {\n            ssValue >> pwallet->vchDefaultKey;\n        }\n        else if (strType == \"pool\")\n        {\n            int64_t nIndex;\n            ssKey >> nIndex;\n            CKeyPool keypool;\n            ssValue >> keypool;\n            pwallet->setKeyPool.insert(nIndex);\n\n            // If no metadata exists yet, create a default with the pool key's\n            // creation time. Note that this may be overwritten by actually\n            // stored metadata for that key later, which is fine.\n            CKeyID keyid = keypool.vchPubKey.GetID();\n            if (pwallet->mapKeyMetadata.count(keyid) == 0)\n                pwallet->mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n\n        }\n        else if (strType == \"version\")\n        {\n            ssValue >> wss.nFileVersion;\n            if (wss.nFileVersion == 10300)\n                wss.nFileVersion = 300;\n        }\n        else if (strType == \"cscript\")\n        {\n            uint160 hash;\n            ssKey >> hash;\n            CScript script;\n            ssValue >> script;\n            if (!pwallet->LoadCScript(script))\n            {\n                strErr = \"Error reading wallet database: LoadCScript failed\";\n                return false;\n            }\n        }\n        else if (strType == \"orderposnext\")\n        {\n            ssValue >> pwallet->nOrderPosNext;\n        }\n    } catch (...)\n    {\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint64_t nAccountingEntryNumber = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->LoadCScript",
          "args": [
            "script"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "LoadCScript",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "150-150",
          "snippet": "bool LoadCScript(const CScript& redeemScript) { return CCryptoKeyStore::AddCScript(redeemScript); }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  bool LoadCScript(const CScript& redeemScript) { return CCryptoKeyStore::AddCScript(redeemScript); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CKeyMetadata",
          "args": [
            "keypool.nTime"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "CKeyMetadata",
          "container": "CKeyMetadata",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "37-41",
          "snippet": "CKeyMetadata(int64_t nCreateTime_)\n    {\n        nVersion = CKeyMetadata::CURRENT_VERSION;\n        nCreateTime = nCreateTime_;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCKeyMetadata {\n  CKeyMetadata(int64_t nCreateTime_)\n      {\n          nVersion = CKeyMetadata::CURRENT_VERSION;\n          nCreateTime = nCreateTime_;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->mapKeyMetadata.count",
          "args": [
            "keyid"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "keypool.vchPubKey.GetID",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "GetID",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "80-82",
          "snippet": "CKeyID GetID() const {\n        return CKeyID(Hash160(vchPubKey));\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CKeyID GetID() const {\n          return CKeyID(Hash160(vchPubKey));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->setKeyPool.insert",
          "args": [
            "nIndex"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->LoadKeyMetadata",
          "args": [
            "vchPubKey",
            "keyMeta"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "LoadKeyMetadata",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "87-94",
          "snippet": "bool CWallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n{\n    if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n        nTimeFirstKey = meta.nCreateTime;\n\n    mapKeyMetadata[pubkey.GetID()] = meta;\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::LoadKeyMetadata(const CPubKey &pubkey, const CKeyMetadata &meta)\n  {\n      if (meta.nCreateTime && (!nTimeFirstKey || meta.nCreateTime < nTimeFirstKey))\n          nTimeFirstKey = meta.nCreateTime;\n  \n      mapKeyMetadata[pubkey.GetID()] = meta;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->LoadCryptedKey",
          "args": [
            "vchPubKey",
            "vchPrivKey"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "LoadCryptedKey",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "96-99",
          "snippet": "bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n{\n    return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret)\n  {\n      return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"Error reading wallet database: duplicate CMasterKey id %u\"",
            "nID"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->LoadKey",
          "args": [
            "key"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "LoadKey",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "139-139",
          "snippet": "bool LoadKey(const CKey& key) { return CCryptoKeyStore::AddKey(key); }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWallet {\n  bool LoadKey(const CKey& key) { return CCryptoKeyStore::AddKey(key); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.IsValid",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetPrivKey",
          "args": [
            "wkey.vchPrivKey"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "SetPrivKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "186-207",
          "snippet": "bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n{\n    const unsigned char* pbegin = &vchPrivKey[0];\n    if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n    {\n        // In testing, d2i_ECPrivateKey can return true\n        // but fill in pkey with a key that fails\n        // EC_KEY_check_key, so:\n        if (EC_KEY_check_key(pkey))\n        {\n            fSet = true;\n            return true;\n        }\n    }\n    // If vchPrivKey data is bad d2i_ECPrivateKey() can\n    // leave pkey in a state where calling EC_KEY_free()\n    // crashes. To avoid that, set pkey to NULL and\n    // leak the memory (a leak is better than a crash)\n    pkey = NULL;\n    Reset();\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPrivKey(const CPrivKey& vchPrivKey)\n  {\n      const unsigned char* pbegin = &vchPrivKey[0];\n      if (d2i_ECPrivateKey(&pkey, &pbegin, vchPrivKey.size()))\n      {\n          // In testing, d2i_ECPrivateKey can return true\n          // but fill in pkey with a key that fails\n          // EC_KEY_check_key, so:\n          if (EC_KEY_check_key(pkey))\n          {\n              fSet = true;\n              return true;\n          }\n      }\n      // If vchPrivKey data is bad d2i_ECPrivateKey() can\n      // leave pkey in a state where calling EC_KEY_free()\n      // crashes. To avoid that, set pkey to NULL and\n      // leak the memory (a leak is better than a crash)\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetPubKey",
          "args": [
            "vchPubKey"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "SetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "259-272",
          "snippet": "bool CKey::SetPubKey(const CPubKey& vchPubKey)\n{\n    const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n    {\n        fSet = true;\n        if (vchPubKey.vchPubKey.size() == 33)\n            SetCompressedPubKey();\n        return true;\n    }\n    pkey = NULL;\n    Reset();\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPubKey(const CPubKey& vchPubKey)\n  {\n      const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n      if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n      {\n          fSet = true;\n          if (vchPubKey.vchPubKey.size() == 33)\n              SetCompressedPubKey();\n          return true;\n      }\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wss.vWalletUpgrade.push_back",
          "args": [
            "hash"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"LoadWallet() repairing tx ver=%d %s\"",
            "wtx.fTimeReceivedIsTxTime",
            "hash.ToString().c_str()"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"LoadWallet() upgrading tx ver=%d %d '%s' %s\"",
            "wtx.fTimeReceivedIsTxTime",
            "fTmp",
            "wtx.strFromAccount.c_str()",
            "hash.ToString().c_str()"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wtx.strFromAccount.c_str",
          "args": [],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssValue.empty",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwallet->mapWallet.erase",
          "args": [
            "hash"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.BindWallet",
          "args": [
            "pwallet"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "BindWallet",
          "container": "CWalletTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.h",
          "lines": "535-539",
          "snippet": "void BindWallet(CWallet *pwalletIn)\n    {\n        pwallet = pwalletIn;\n        MarkDirty();\n    }",
          "includes": [
            "#include \"walletdb.h\"",
            "#include \"util.h\"",
            "#include \"ui_interface.h\"",
            "#include \"script.h\"",
            "#include \"keystore.h\"",
            "#include \"key.h\"",
            "#include \"main.h\"",
            "#include <stdlib.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"walletdb.h\"\n#include \"util.h\"\n#include \"ui_interface.h\"\n#include \"script.h\"\n#include \"keystore.h\"\n#include \"key.h\"\n#include \"main.h\"\n#include <stdlib.h>\n#include <vector>\n#include <string>\n\nCWalletTx {\n  void BindWallet(CWallet *pwalletIn)\n      {\n          pwallet = pwalletIn;\n          MarkDirty();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.GetHash",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wtx.CheckTransaction",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "CheckTransaction",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "478-527",
          "snippet": "bool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::CheckTransaction() const\n  {\n      // Basic checks that don't depend on any context\n      if (vin.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n      if (vout.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n      // Size limits\n      if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n  \n      // Check for negative or overflow output values\n      int64_t nValueOut = 0;\n      for (unsigned int i = 0; i < vout.size(); i++)\n      {\n          const CTxOut& txout = vout[i];\n          if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n          if (txout.nValue < 0)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n          if (txout.nValue > MAX_MONEY)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n          nValueOut += txout.nValue;\n          if (!MoneyRange(nValueOut))\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n      }\n  \n      // Check for duplicate inputs\n      set<COutPoint> vInOutPoints;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          if (vInOutPoints.count(txin.prevout))\n              return false;\n          vInOutPoints.insert(txin.prevout);\n      }\n  \n      if (IsCoinBase())\n      {\n          if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n      }\n      else\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (txin.prevout.IsNull())\n                  return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "strAddress"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nstatic uint64_t nAccountingEntryNumber = 0;\n\nbool\nReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             CWalletScanState &wss, string& strType, string& strErr)\n{\n    try {\n        // Unserialize\n        // Taking advantage of the fact that pair serialization\n        // is just the two items serialized one after the other\n        ssKey >> strType;\n        if (strType == \"name\")\n        {\n            string strAddress;\n            ssKey >> strAddress;\n            ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()];\n        }\n        else if (strType == \"tx\")\n        {\n            uint256 hash;\n            ssKey >> hash;\n            CWalletTx& wtx = pwallet->mapWallet[hash];\n            ssValue >> wtx;\n            if (wtx.CheckTransaction() && (wtx.GetHash() == hash))\n                wtx.BindWallet(pwallet);\n            else\n            {\n                pwallet->mapWallet.erase(hash);\n                return false;\n            }\n\n            // Undo serialize changes in 31600\n            if (31404 <= wtx.fTimeReceivedIsTxTime && wtx.fTimeReceivedIsTxTime <= 31703)\n            {\n                if (!ssValue.empty())\n                {\n                    char fTmp;\n                    char fUnused;\n                    ssValue >> fTmp >> fUnused >> wtx.strFromAccount;\n                    strErr = strprintf(\"LoadWallet() upgrading tx ver=%d %d '%s' %s\",\n                                       wtx.fTimeReceivedIsTxTime, fTmp, wtx.strFromAccount.c_str(), hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = fTmp;\n                }\n                else\n                {\n                    strErr = strprintf(\"LoadWallet() repairing tx ver=%d %s\", wtx.fTimeReceivedIsTxTime, hash.ToString().c_str());\n                    wtx.fTimeReceivedIsTxTime = 0;\n                }\n                wss.vWalletUpgrade.push_back(hash);\n            }\n\n            if (wtx.nOrderPos == -1)\n                wss.fAnyUnordered = true;\n\n            //// debug print\n            //printf(\"LoadWallet  %s\\n\", wtx.GetHash().ToString().c_str());\n            //printf(\" %12\"PRId64\"  %s  %s  %s\\n\",\n            //    wtx.vout[0].nValue,\n            //    DateTimeStrFormat(\"%x %H:%M:%S\", wtx.GetBlockTime()).c_str(),\n            //    wtx.hashBlock.ToString().substr(0,20).c_str(),\n            //    wtx.mapValue[\"message\"].c_str());\n        }\n        else if (strType == \"acentry\")\n        {\n            string strAccount;\n            ssKey >> strAccount;\n            uint64_t nNumber;\n            ssKey >> nNumber;\n            if (nNumber > nAccountingEntryNumber)\n                nAccountingEntryNumber = nNumber;\n\n            if (!wss.fAnyUnordered)\n            {\n                CAccountingEntry acentry;\n                ssValue >> acentry;\n                if (acentry.nOrderPos == -1)\n                    wss.fAnyUnordered = true;\n            }\n        }\n        else if (strType == \"key\" || strType == \"wkey\")\n        {\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            CKey key;\n            if (strType == \"key\")\n            {\n                wss.nKeys++;\n                CPrivKey pkey;\n                ssValue >> pkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(pkey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CPrivKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CPrivKey\";\n                    return false;\n                }\n            }\n            else\n            {\n                CWalletKey wkey;\n                ssValue >> wkey;\n                key.SetPubKey(vchPubKey);\n                if (!key.SetPrivKey(wkey.vchPrivKey))\n                {\n                    strErr = \"Error reading wallet database: CPrivKey corrupt\";\n                    return false;\n                }\n                if (key.GetPubKey() != vchPubKey)\n                {\n                    strErr = \"Error reading wallet database: CWalletKey pubkey inconsistency\";\n                    return false;\n                }\n                if (!key.IsValid())\n                {\n                    strErr = \"Error reading wallet database: invalid CWalletKey\";\n                    return false;\n                }\n            }\n            if (!pwallet->LoadKey(key))\n            {\n                strErr = \"Error reading wallet database: LoadKey failed\";\n                return false;\n            }\n        }\n        else if (strType == \"mkey\")\n        {\n            unsigned int nID;\n            ssKey >> nID;\n            CMasterKey kMasterKey;\n            ssValue >> kMasterKey;\n            if(pwallet->mapMasterKeys.count(nID) != 0)\n            {\n                strErr = strprintf(\"Error reading wallet database: duplicate CMasterKey id %u\", nID);\n                return false;\n            }\n            pwallet->mapMasterKeys[nID] = kMasterKey;\n            if (pwallet->nMasterKeyMaxID < nID)\n                pwallet->nMasterKeyMaxID = nID;\n        }\n        else if (strType == \"ckey\")\n        {\n            wss.nCKeys++;\n            vector<unsigned char> vchPubKey;\n            ssKey >> vchPubKey;\n            vector<unsigned char> vchPrivKey;\n            ssValue >> vchPrivKey;\n            if (!pwallet->LoadCryptedKey(vchPubKey, vchPrivKey))\n            {\n                strErr = \"Error reading wallet database: LoadCryptedKey failed\";\n                return false;\n            }\n            wss.fIsEncrypted = true;\n        }\n        else if (strType == \"keymeta\")\n        {\n            CPubKey vchPubKey;\n            ssKey >> vchPubKey;\n            CKeyMetadata keyMeta;\n            ssValue >> keyMeta;\n            wss.nKeyMeta++;\n\n            pwallet->LoadKeyMetadata(vchPubKey, keyMeta);\n\n            // find earliest key creation time, as wallet birthday\n            if (!pwallet->nTimeFirstKey ||\n                (keyMeta.nCreateTime < pwallet->nTimeFirstKey))\n                pwallet->nTimeFirstKey = keyMeta.nCreateTime;\n        }\n        else if (strType == \"defaultkey\")\n        {\n            ssValue >> pwallet->vchDefaultKey;\n        }\n        else if (strType == \"pool\")\n        {\n            int64_t nIndex;\n            ssKey >> nIndex;\n            CKeyPool keypool;\n            ssValue >> keypool;\n            pwallet->setKeyPool.insert(nIndex);\n\n            // If no metadata exists yet, create a default with the pool key's\n            // creation time. Note that this may be overwritten by actually\n            // stored metadata for that key later, which is fine.\n            CKeyID keyid = keypool.vchPubKey.GetID();\n            if (pwallet->mapKeyMetadata.count(keyid) == 0)\n                pwallet->mapKeyMetadata[keyid] = CKeyMetadata(keypool.nTime);\n\n        }\n        else if (strType == \"version\")\n        {\n            ssValue >> wss.nFileVersion;\n            if (wss.nFileVersion == 10300)\n                wss.nFileVersion = 300;\n        }\n        else if (strType == \"cscript\")\n        {\n            uint160 hash;\n            ssKey >> hash;\n            CScript script;\n            ssValue >> script;\n            if (!pwallet->LoadCScript(script))\n            {\n                strErr = \"Error reading wallet database: LoadCScript failed\";\n                return false;\n            }\n        }\n        else if (strType == \"orderposnext\")\n        {\n            ssValue >> pwallet->nOrderPosNext;\n        }\n    } catch (...)\n    {\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "CWalletScanState",
    "container": "CWalletScanState",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "195-200",
    "snippet": "CWalletScanState() {\n        nKeys = nCKeys = nKeyMeta = 0;\n        fIsEncrypted = false;\n        fAnyUnordered = false;\n        nFileVersion = 0;\n    }",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletScanState {\n  CWalletScanState() {\n          nKeys = nCKeys = nKeyMeta = 0;\n          fIsEncrypted = false;\n          fAnyUnordered = false;\n          nFileVersion = 0;\n      }\n}"
  },
  {
    "function_name": "ReorderTransactions",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "113-183",
    "snippet": "DBErrors\nCWalletDB::ReorderTransactions(CWallet* pwallet)\n{\n    LOCK(pwallet->cs_wallet);\n    // Old wallets didn't have any defined order for transactions\n    // Probably a bad idea to change the output of this\n\n    // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n    typedef multimap<int64_t, TxPair > TxItems;\n    TxItems txByTime;\n\n    for (map<uint256, CWalletTx>::iterator it = pwallet->mapWallet.begin(); it != pwallet->mapWallet.end(); ++it)\n    {\n        CWalletTx* wtx = &((*it).second);\n        txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n    }\n    list<CAccountingEntry> acentries;\n    ListAccountCreditDebit(\"\", acentries);\n    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n    {\n        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n    }\n\n    int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n    nOrderPosNext = 0;\n    std::vector<int64_t> nOrderPosOffsets;\n    for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n    {\n        CWalletTx *const pwtx = (*it).second.first;\n        CAccountingEntry *const pacentry = (*it).second.second;\n        int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n\n        if (nOrderPos == -1)\n        {\n            nOrderPos = nOrderPosNext++;\n            nOrderPosOffsets.push_back(nOrderPos);\n\n            if (pacentry)\n                // Have to write accounting regardless, since we don't keep it in memory\n                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n        else\n        {\n            int64_t nOrderPosOff = 0;\n            BOOST_FOREACH(const int64_t& nOffsetStart, nOrderPosOffsets)\n            {\n                if (nOrderPos >= nOffsetStart)\n                    ++nOrderPosOff;\n            }\n            nOrderPos += nOrderPosOff;\n            nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);\n\n            if (!nOrderPosOff)\n                continue;\n\n            // Since we're changing the order, write it back\n            if (pwtx)\n            {\n                if (!WriteTx(pwtx->GetHash(), *pwtx))\n                    return DB_LOAD_FAIL;\n            }\n            else\n                if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                    return DB_LOAD_FAIL;\n        }\n    }\n\n    return DB_LOAD_OK;\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WriteAccountingEntry",
          "args": [
            "pacentry->nEntryNo",
            "*pacentry"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "WriteAccountingEntry",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "47-50",
          "snippet": "bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n{\n    return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n  {\n      return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteTx",
          "args": [
            "pwtx->GetHash()",
            "*pwtx"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "WriteTx",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "73-77",
          "snippet": "bool WriteTx(uint256 hash, const CWalletTx& wtx)\n    {\n        nWalletDBUpdated++;\n        return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCWalletDB {\n  bool WriteTx(uint256 hash, const CWalletTx& wtx)\n      {\n          nWalletDBUpdated++;\n          return Write(std::make_pair(std::string(\"tx\"), hash), wtx);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwtx->GetHash",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::max",
          "args": [
            "nOrderPosNext",
            "nOrderPos + 1"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nOrderPosOffsets.push_back",
          "args": [
            "nOrderPos"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txByTime.end",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txByTime.begin",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txByTime.insert",
          "args": [
            "make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry))"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "entry.nTime",
            "TxPair((CWalletTx*)0, &entry)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TxPair",
          "args": [
            "(CWalletTx*)0",
            "&entry"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ListAccountCreditDebit",
          "args": [
            "\"\"",
            "acentries"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ListAccountCreditDebit",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "69-110",
          "snippet": "void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n{\n    bool fAllAccounts = (strAccount == \"*\");\n\n    Dbc* pcursor = GetCursor();\n    if (!pcursor)\n        throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n    unsigned int fFlags = DB_SET_RANGE;\n    while (true)\n    {\n        // Read next record\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        if (fFlags == DB_SET_RANGE)\n            ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n        fFlags = DB_NEXT;\n        if (ret == DB_NOTFOUND)\n            break;\n        else if (ret != 0)\n        {\n            pcursor->close();\n            throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n        }\n\n        // Unserialize\n        string strType;\n        ssKey >> strType;\n        if (strType != \"acentry\")\n            break;\n        CAccountingEntry acentry;\n        ssKey >> acentry.strAccount;\n        if (!fAllAccounts && acentry.strAccount != strAccount)\n            break;\n\n        ssValue >> acentry;\n        ssKey >> acentry.nEntryNo;\n        entries.push_back(acentry);\n    }\n\n    pcursor->close();\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n  {\n      bool fAllAccounts = (strAccount == \"*\");\n  \n      Dbc* pcursor = GetCursor();\n      if (!pcursor)\n          throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n      unsigned int fFlags = DB_SET_RANGE;\n      while (true)\n      {\n          // Read next record\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          if (fFlags == DB_SET_RANGE)\n              ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n          fFlags = DB_NEXT;\n          if (ret == DB_NOTFOUND)\n              break;\n          else if (ret != 0)\n          {\n              pcursor->close();\n              throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n          }\n  \n          // Unserialize\n          string strType;\n          ssKey >> strType;\n          if (strType != \"acentry\")\n              break;\n          CAccountingEntry acentry;\n          ssKey >> acentry.strAccount;\n          if (!fAllAccounts && acentry.strAccount != strAccount)\n              break;\n  \n          ssValue >> acentry;\n          ssKey >> acentry.nEntryNo;\n          entries.push_back(acentry);\n      }\n  \n      pcursor->close();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "wtx->nTimeReceived",
            "TxPair(wtx, (CAccountingEntry*)0)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TxPair",
          "args": [
            "wtx",
            "(CAccountingEntry*)0"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "pwallet->cs_wallet"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  DBErrors\n  CWalletDB::ReorderTransactions(CWallet* pwallet)\n  {\n      LOCK(pwallet->cs_wallet);\n      // Old wallets didn't have any defined order for transactions\n      // Probably a bad idea to change the output of this\n  \n      // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n      typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n      typedef multimap<int64_t, TxPair > TxItems;\n      TxItems txByTime;\n  \n      for (map<uint256, CWalletTx>::iterator it = pwallet->mapWallet.begin(); it != pwallet->mapWallet.end(); ++it)\n      {\n          CWalletTx* wtx = &((*it).second);\n          txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n      }\n      list<CAccountingEntry> acentries;\n      ListAccountCreditDebit(\"\", acentries);\n      BOOST_FOREACH(CAccountingEntry& entry, acentries)\n      {\n          txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n      }\n  \n      int64_t& nOrderPosNext = pwallet->nOrderPosNext;\n      nOrderPosNext = 0;\n      std::vector<int64_t> nOrderPosOffsets;\n      for (TxItems::iterator it = txByTime.begin(); it != txByTime.end(); ++it)\n      {\n          CWalletTx *const pwtx = (*it).second.first;\n          CAccountingEntry *const pacentry = (*it).second.second;\n          int64_t& nOrderPos = (pwtx != 0) ? pwtx->nOrderPos : pacentry->nOrderPos;\n  \n          if (nOrderPos == -1)\n          {\n              nOrderPos = nOrderPosNext++;\n              nOrderPosOffsets.push_back(nOrderPos);\n  \n              if (pacentry)\n                  // Have to write accounting regardless, since we don't keep it in memory\n                  if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                      return DB_LOAD_FAIL;\n          }\n          else\n          {\n              int64_t nOrderPosOff = 0;\n              BOOST_FOREACH(const int64_t& nOffsetStart, nOrderPosOffsets)\n              {\n                  if (nOrderPos >= nOffsetStart)\n                      ++nOrderPosOff;\n              }\n              nOrderPos += nOrderPosOff;\n              nOrderPosNext = std::max(nOrderPosNext, nOrderPos + 1);\n  \n              if (!nOrderPosOff)\n                  continue;\n  \n              // Since we're changing the order, write it back\n              if (pwtx)\n              {\n                  if (!WriteTx(pwtx->GetHash(), *pwtx))\n                      return DB_LOAD_FAIL;\n              }\n              else\n                  if (!WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                      return DB_LOAD_FAIL;\n          }\n      }\n  \n      return DB_LOAD_OK;\n  }\n}"
  },
  {
    "function_name": "ListAccountCreditDebit",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "69-110",
    "snippet": "void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n{\n    bool fAllAccounts = (strAccount == \"*\");\n\n    Dbc* pcursor = GetCursor();\n    if (!pcursor)\n        throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n    unsigned int fFlags = DB_SET_RANGE;\n    while (true)\n    {\n        // Read next record\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        if (fFlags == DB_SET_RANGE)\n            ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n        fFlags = DB_NEXT;\n        if (ret == DB_NOTFOUND)\n            break;\n        else if (ret != 0)\n        {\n            pcursor->close();\n            throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n        }\n\n        // Unserialize\n        string strType;\n        ssKey >> strType;\n        if (strType != \"acentry\")\n            break;\n        CAccountingEntry acentry;\n        ssKey >> acentry.strAccount;\n        if (!fAllAccounts && acentry.strAccount != strAccount)\n            break;\n\n        ssValue >> acentry;\n        ssKey >> acentry.nEntryNo;\n        entries.push_back(acentry);\n    }\n\n    pcursor->close();\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcursor->close",
          "args": [],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "close",
          "container": "AcceptedConnectionImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "664-667",
          "snippet": "virtual void close()\n    {\n        _stream.close();\n    }",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nAcceptedConnectionImpl {\n  virtual void close()\n      {\n          _stream.close();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entries.push_back",
          "args": [
            "acentry"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"CWalletDB::ListAccountCreditDebit() : error scanning DB\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadAtCursor",
          "args": [
            "pcursor",
            "ssKey",
            "ssValue",
            "fFlags"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::make_tuple",
          "args": [
            "string(\"acentry\")",
            "(fAllAccounts? string(\"\") : strAccount)",
            "uint64_t(0)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint64_t",
          "args": [
            "0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"\""
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetCursor",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n  {\n      bool fAllAccounts = (strAccount == \"*\");\n  \n      Dbc* pcursor = GetCursor();\n      if (!pcursor)\n          throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n      unsigned int fFlags = DB_SET_RANGE;\n      while (true)\n      {\n          // Read next record\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          if (fFlags == DB_SET_RANGE)\n              ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n          fFlags = DB_NEXT;\n          if (ret == DB_NOTFOUND)\n              break;\n          else if (ret != 0)\n          {\n              pcursor->close();\n              throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n          }\n  \n          // Unserialize\n          string strType;\n          ssKey >> strType;\n          if (strType != \"acentry\")\n              break;\n          CAccountingEntry acentry;\n          ssKey >> acentry.strAccount;\n          if (!fAllAccounts && acentry.strAccount != strAccount)\n              break;\n  \n          ssValue >> acentry;\n          ssKey >> acentry.nEntryNo;\n          entries.push_back(acentry);\n      }\n  \n      pcursor->close();\n  }\n}"
  },
  {
    "function_name": "GetAccountCreditDebit",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "57-67",
    "snippet": "int64_t CWalletDB::GetAccountCreditDebit(const string& strAccount)\n{\n    list<CAccountingEntry> entries;\n    ListAccountCreditDebit(strAccount, entries);\n\n    int64_t nCreditDebit = 0;\n    BOOST_FOREACH (const CAccountingEntry& entry, entries)\n        nCreditDebit += entry.nCreditDebit;\n\n    return nCreditDebit;\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ListAccountCreditDebit",
          "args": [
            "strAccount",
            "entries"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "ListAccountCreditDebit",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "69-110",
          "snippet": "void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n{\n    bool fAllAccounts = (strAccount == \"*\");\n\n    Dbc* pcursor = GetCursor();\n    if (!pcursor)\n        throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n    unsigned int fFlags = DB_SET_RANGE;\n    while (true)\n    {\n        // Read next record\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        if (fFlags == DB_SET_RANGE)\n            ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n        fFlags = DB_NEXT;\n        if (ret == DB_NOTFOUND)\n            break;\n        else if (ret != 0)\n        {\n            pcursor->close();\n            throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n        }\n\n        // Unserialize\n        string strType;\n        ssKey >> strType;\n        if (strType != \"acentry\")\n            break;\n        CAccountingEntry acentry;\n        ssKey >> acentry.strAccount;\n        if (!fAllAccounts && acentry.strAccount != strAccount)\n            break;\n\n        ssValue >> acentry;\n        ssKey >> acentry.nEntryNo;\n        entries.push_back(acentry);\n    }\n\n    pcursor->close();\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n  {\n      bool fAllAccounts = (strAccount == \"*\");\n  \n      Dbc* pcursor = GetCursor();\n      if (!pcursor)\n          throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : cannot create DB cursor\");\n      unsigned int fFlags = DB_SET_RANGE;\n      while (true)\n      {\n          // Read next record\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          if (fFlags == DB_SET_RANGE)\n              ssKey << boost::make_tuple(string(\"acentry\"), (fAllAccounts? string(\"\") : strAccount), uint64_t(0));\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          int ret = ReadAtCursor(pcursor, ssKey, ssValue, fFlags);\n          fFlags = DB_NEXT;\n          if (ret == DB_NOTFOUND)\n              break;\n          else if (ret != 0)\n          {\n              pcursor->close();\n              throw runtime_error(\"CWalletDB::ListAccountCreditDebit() : error scanning DB\");\n          }\n  \n          // Unserialize\n          string strType;\n          ssKey >> strType;\n          if (strType != \"acentry\")\n              break;\n          CAccountingEntry acentry;\n          ssKey >> acentry.strAccount;\n          if (!fAllAccounts && acentry.strAccount != strAccount)\n              break;\n  \n          ssValue >> acentry;\n          ssKey >> acentry.nEntryNo;\n          entries.push_back(acentry);\n      }\n  \n      pcursor->close();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  int64_t CWalletDB::GetAccountCreditDebit(const string& strAccount)\n  {\n      list<CAccountingEntry> entries;\n      ListAccountCreditDebit(strAccount, entries);\n  \n      int64_t nCreditDebit = 0;\n      BOOST_FOREACH (const CAccountingEntry& entry, entries)\n          nCreditDebit += entry.nCreditDebit;\n  \n      return nCreditDebit;\n  }\n}"
  },
  {
    "function_name": "WriteAccountingEntry",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "52-55",
    "snippet": "bool CWalletDB::WriteAccountingEntry(const CAccountingEntry& acentry)\n{\n    return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint64_t nAccountingEntryNumber = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WriteAccountingEntry",
          "args": [
            "++nAccountingEntryNumber",
            "acentry"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "WriteAccountingEntry",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "47-50",
          "snippet": "bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n{\n    return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nstatic uint64_t nAccountingEntryNumber = 0;\n\nCWalletDB {\n  bool CWalletDB::WriteAccountingEntry(const CAccountingEntry& acentry)\n  {\n      return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n  }\n}"
  },
  {
    "function_name": "WriteAccountingEntry",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "47-50",
    "snippet": "bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n{\n    return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum)",
            "acentry"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "WriteAccountingEntry",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "47-50",
          "snippet": "bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n{\n    return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "boost::make_tuple",
          "args": [
            "string(\"acentry\")",
            "acentry.strAccount",
            "nAccEntryNum"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"acentry\""
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n  {\n      return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n  }\n}"
  },
  {
    "function_name": "WriteAccount",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "42-45",
    "snippet": "bool CWalletDB::WriteAccount(const string& strAccount, const CAccount& account)\n{\n    return Write(make_pair(string(\"acc\"), strAccount), account);\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "make_pair(string(\"acc\"), strAccount)",
            "account"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "WriteAccountingEntry",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "47-50",
          "snippet": "bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n{\n    return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n  {\n      return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"acc\")",
            "strAccount"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"acc\""
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::WriteAccount(const string& strAccount, const CAccount& account)\n  {\n      return Write(make_pair(string(\"acc\"), strAccount), account);\n  }\n}"
  },
  {
    "function_name": "ReadAccount",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "36-40",
    "snippet": "bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n{\n    account.SetNull();\n    return Read(make_pair(string(\"acc\"), strAccount), account);\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "make_pair(string(\"acc\"), strAccount)",
            "account"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ReadAccount",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "36-40",
          "snippet": "bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n{\n    account.SetNull();\n    return Read(make_pair(string(\"acc\"), strAccount), account);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"acc\")",
            "strAccount"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"acc\""
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "account.SetNull",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CKeyMetadata",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "50-54",
          "snippet": "void SetNull()\n    {\n        nVersion = CKeyMetadata::CURRENT_VERSION;\n        nCreateTime = 0;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCKeyMetadata {\n  void SetNull()\n      {\n          nVersion = CKeyMetadata::CURRENT_VERSION;\n          nCreateTime = 0;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n  {\n      account.SetNull();\n      return Read(make_pair(string(\"acc\"), strAccount), account);\n  }\n}"
  },
  {
    "function_name": "EraseName",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "28-34",
    "snippet": "bool CWalletDB::EraseName(const string& strAddress)\n{\n    // This should only be used for sending addresses, never for receiving addresses,\n    // receiving addresses must always have an address book entry if they're not change return.\n    nWalletDBUpdated++;\n    return Erase(make_pair(string(\"name\"), strAddress));\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Erase",
          "args": [
            "make_pair(string(\"name\"), strAddress)"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "EraseName",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "28-34",
          "snippet": "bool CWalletDB::EraseName(const string& strAddress)\n{\n    // This should only be used for sending addresses, never for receiving addresses,\n    // receiving addresses must always have an address book entry if they're not change return.\n    nWalletDBUpdated++;\n    return Erase(make_pair(string(\"name\"), strAddress));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"name\")",
            "strAddress"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"name\""
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::EraseName(const string& strAddress)\n  {\n      // This should only be used for sending addresses, never for receiving addresses,\n      // receiving addresses must always have an address book entry if they're not change return.\n      nWalletDBUpdated++;\n      return Erase(make_pair(string(\"name\"), strAddress));\n  }\n}"
  },
  {
    "function_name": "WriteName",
    "container": "CWalletDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
    "lines": "22-26",
    "snippet": "bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n{\n    nWalletDBUpdated++;\n    return Write(make_pair(string(\"name\"), strAddress), strName);\n}",
    "includes": [
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include \"wallet.h\"",
      "#include \"walletdb.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "make_pair(string(\"name\"), strAddress)",
            "strName"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "WriteAccountingEntry",
          "container": "CWalletDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.cpp",
          "lines": "47-50",
          "snippet": "bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n{\n    return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n}",
          "includes": [
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include \"wallet.h\"",
            "#include \"walletdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n  {\n      return Write(boost::make_tuple(string(\"acentry\"), acentry.strAccount, nAccEntryNum), acentry);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"name\")",
            "strAddress"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"name\""
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include \"wallet.h\"\n#include \"walletdb.h\"\n\nCWalletDB {\n  bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n  {\n      nWalletDBUpdated++;\n      return Write(make_pair(string(\"name\"), strAddress), strName);\n  }\n}"
  }
]