[
  {
    "function_name": "submitblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcmining.cpp",
    "lines": "359-383",
    "snippet": "Value submitblock(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 2)\n        throw runtime_error(\n            \"submitblock <hex data> [optional-params-obj]\\n\"\n            \"[optional-params-obj] parameter is currently ignored.\\n\"\n            \"Attempts to submit new block to network.\\n\"\n            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\");\n\n    vector<unsigned char> blockData(ParseHex(params[0].get_str()));\n    CDataStream ssBlock(blockData, SER_NETWORK, PROTOCOL_VERSION);\n    CBlock block;\n    try {\n        ssBlock >> block;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n    }\n\n    bool fAccepted = ProcessBlock(NULL, &block);\n    if (!fAccepted)\n        return \"rejected\";\n\n    return Value::null;\n}",
    "includes": [
      "#include \"bitcoinrpc.h\"",
      "#include \"miner.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ProcessBlock",
          "args": [
            "NULL",
            "&block"
          ],
          "line": 378
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2428-2512",
          "snippet": "bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "set<pair<COutPoint, unsigned int> > setStakeSeen;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexBest = NULL;",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "multimap<uint256, CBlock*> mapOrphanBlocksByPrev;",
            "set<pair<COutPoint, unsigned int> > setStakeSeenOrphan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_DESERIALIZATION_ERROR",
            "\"Block decode failed\""
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "params[0].get_str()"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"submitblock <hex data> [optional-params-obj]\\n\"\n            \"[optional-params-obj] parameter is currently ignored.\\n\"\n            \"Attempts to submit new block to network.\\n\"\n            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\""
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"miner.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"main.h\"\n\nValue submitblock(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 2)\n        throw runtime_error(\n            \"submitblock <hex data> [optional-params-obj]\\n\"\n            \"[optional-params-obj] parameter is currently ignored.\\n\"\n            \"Attempts to submit new block to network.\\n\"\n            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\");\n\n    vector<unsigned char> blockData(ParseHex(params[0].get_str()));\n    CDataStream ssBlock(blockData, SER_NETWORK, PROTOCOL_VERSION);\n    CBlock block;\n    try {\n        ssBlock >> block;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n    }\n\n    bool fAccepted = ProcessBlock(NULL, &block);\n    if (!fAccepted)\n        return \"rejected\";\n\n    return Value::null;\n}"
  },
  {
    "function_name": "getblocktemplate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcmining.cpp",
    "lines": "202-357",
    "snippet": "Value getblocktemplate(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 1)\n        throw runtime_error(\n            \"getblocktemplate [params]\\n\"\n            \"Returns data needed to construct a block to work on:\\n\"\n            \"  \\\"version\\\" : block version\\n\"\n            \"  \\\"previousblockhash\\\" : hash of current highest block\\n\"\n            \"  \\\"transactions\\\" : contents of non-coinbase transactions that should be included in the next block\\n\"\n            \"  \\\"coinbaseaux\\\" : data that should be included in coinbase\\n\"\n            \"  \\\"coinbasevalue\\\" : maximum allowable input to coinbase transaction, including the generation award and transaction fees\\n\"\n            \"  \\\"target\\\" : hash target\\n\"\n            \"  \\\"mintime\\\" : minimum timestamp appropriate for next block\\n\"\n            \"  \\\"curtime\\\" : current timestamp\\n\"\n            \"  \\\"mutable\\\" : list of ways the block template may be changed\\n\"\n            \"  \\\"noncerange\\\" : range of valid nonces\\n\"\n            \"  \\\"sigoplimit\\\" : limit of sigops in blocks\\n\"\n            \"  \\\"sizelimit\\\" : limit of block size\\n\"\n            \"  \\\"bits\\\" : compressed target of next block\\n\"\n            \"  \\\"height\\\" : height of the next block\\n\"\n            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\");\n\n    std::string strMode = \"template\";\n    if (params.size() > 0)\n    {\n        const Object& oparam = params[0].get_obj();\n        const Value& modeval = find_value(oparam, \"mode\");\n        if (modeval.type() == str_type)\n            strMode = modeval.get_str();\n        else if (modeval.type() == null_type)\n        {\n            /* Do nothing */\n        }\n        else\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n    }\n\n    if (strMode != \"template\")\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n\n    if (vNodes.empty())\n        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Halcyon is not connected!\");\n\n    if (IsInitialBlockDownload())\n        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Halcyon is downloading blocks...\");\n\n    static CReserveKey reservekey(pwalletMain);\n\n    // Update block\n    static unsigned int nTransactionsUpdatedLast;\n    static CBlockIndex* pindexPrev;\n    static int64_t nStart;\n    static CBlock* pblock;\n    if (pindexPrev != pindexBest ||\n        (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n    {\n        // Clear pindexPrev so future calls make a new block, despite any failures from here on\n        pindexPrev = NULL;\n\n        // Store the pindexBest used before CreateNewBlock, to avoid races\n        nTransactionsUpdatedLast = nTransactionsUpdated;\n        CBlockIndex* pindexPrevNew = pindexBest;\n        nStart = GetTime();\n\n        // Create new block\n        if(pblock)\n        {\n            delete pblock;\n            pblock = NULL;\n        }\n        pblock = CreateNewBlock(pwalletMain);\n        if (!pblock)\n            throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n\n        // Need to update only after we know CreateNewBlock succeeded\n        pindexPrev = pindexPrevNew;\n    }\n\n    // Update nTime\n    pblock->UpdateTime(pindexPrev);\n    pblock->nNonce = 0;\n\n    Array transactions;\n    map<uint256, int64_t> setTxIndex;\n    int i = 0;\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH (CTransaction& tx, pblock->vtx)\n    {\n        uint256 txHash = tx.GetHash();\n        setTxIndex[txHash] = i++;\n\n        if (tx.IsCoinBase() || tx.IsCoinStake())\n            continue;\n\n        Object entry;\n\n        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n        ssTx << tx;\n        entry.push_back(Pair(\"data\", HexStr(ssTx.begin(), ssTx.end())));\n\n        entry.push_back(Pair(\"hash\", txHash.GetHex()));\n\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            entry.push_back(Pair(\"fee\", (int64_t)(tx.GetValueIn(mapInputs) - tx.GetValueOut())));\n\n            Array deps;\n            BOOST_FOREACH (MapPrevTx::value_type& inp, mapInputs)\n            {\n                if (setTxIndex.count(inp.first))\n                    deps.push_back(setTxIndex[inp.first]);\n            }\n            entry.push_back(Pair(\"depends\", deps));\n\n            int64_t nSigOps = tx.GetLegacySigOpCount();\n            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            entry.push_back(Pair(\"sigops\", nSigOps));\n        }\n\n        transactions.push_back(entry);\n    }\n\n    Object aux;\n    aux.push_back(Pair(\"flags\", HexStr(COINBASE_FLAGS.begin(), COINBASE_FLAGS.end())));\n\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n    static Array aMutable;\n    if (aMutable.empty())\n    {\n        aMutable.push_back(\"time\");\n        aMutable.push_back(\"transactions\");\n        aMutable.push_back(\"prevblock\");\n    }\n\n    Object result;\n    result.push_back(Pair(\"version\", pblock->nVersion));\n    result.push_back(Pair(\"previousblockhash\", pblock->hashPrevBlock.GetHex()));\n    result.push_back(Pair(\"transactions\", transactions));\n    result.push_back(Pair(\"coinbaseaux\", aux));\n    result.push_back(Pair(\"coinbasevalue\", (int64_t)pblock->vtx[0].vout[0].nValue));\n    result.push_back(Pair(\"target\", hashTarget.GetHex()));\n    result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1));\n    result.push_back(Pair(\"mutable\", aMutable));\n    result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n    result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS));\n    result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SIZE));\n    result.push_back(Pair(\"curtime\", (int64_t)pblock->nTime));\n    result.push_back(Pair(\"bits\", HexBits(pblock->nBits)));\n    result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\n\n    return result;\n}",
    "includes": [
      "#include \"bitcoinrpc.h\"",
      "#include \"miner.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"height\", (int64_t)(pindexPrev->nHeight+1))"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"height\"",
            "(int64_t)(pindexPrev->nHeight+1)"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"bits\", HexBits(pblock->nBits))"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexBits",
          "args": [
            "pblock->nBits"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "HexBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "118-126",
          "snippet": "std::string HexBits(unsigned int nBits)\n{\n    union {\n        int32_t nBits;\n        char cBits[4];\n    } uBits;\n    uBits.nBits = htonl((int32_t)nBits);\n    return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nstd::string HexBits(unsigned int nBits)\n{\n    union {\n        int32_t nBits;\n        char cBits[4];\n    } uBits;\n    uBits.nBits = htonl((int32_t)nBits);\n    return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"curtime\", (int64_t)pblock->nTime)"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SIZE)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"noncerange\", \"00000000ffffffff\")"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"mutable\", aMutable)"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"mintime\", (int64_t)pindexPrev->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindexPrev->GetPastTimeLimit",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "GetPastTimeLimit",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1301-1304",
          "snippet": "int64_t GetPastTimeLimit() const\n    {\n        return GetMedianTimePast();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetPastTimeLimit() const\n      {\n          return GetMedianTimePast();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"target\", hashTarget.GetHex())"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashTarget.GetHex",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "GetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "402-405",
          "snippet": "std::string GetHex() const\n    {\n        return ToString(16);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  std::string GetHex() const\n      {\n          return ToString(16);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"coinbasevalue\", (int64_t)pblock->vtx[0].vout[0].nValue)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"coinbaseaux\", aux)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"transactions\", transactions)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"previousblockhash\", pblock->hashPrevBlock.GetHex())"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"version\", pblock->nVersion)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aMutable.push_back",
          "args": [
            "\"prevblock\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aMutable.push_back",
          "args": [
            "\"transactions\""
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aMutable.push_back",
          "args": [
            "\"time\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aMutable.empty",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "pblock->nBits"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "aux.push_back",
          "args": [
            "Pair(\"flags\", HexStr(COINBASE_FLAGS.begin(), COINBASE_FLAGS.end()))"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "COINBASE_FLAGS.begin()",
            "COINBASE_FLAGS.end()"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "COINBASE_FLAGS.end",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "COINBASE_FLAGS.begin",
          "args": [],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "transactions.push_back",
          "args": [
            "entry"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"sigops\", nSigOps)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetP2SHSigOpCount",
          "args": [
            "mapInputs"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetLegacySigOpCount",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "GetLegacySigOpCount",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "405-418",
          "snippet": "unsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  unsigned int\n  CTransaction::GetLegacySigOpCount() const\n  {\n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          nSigOps += txin.scriptSig.GetSigOpCount(false);\n      }\n      BOOST_FOREACH(const CTxOut& txout, vout)\n      {\n          nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n      }\n      return nSigOps;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"depends\", deps)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deps.push_back",
          "args": [
            "setTxIndex[inp.first]"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setTxIndex.count",
          "args": [
            "inp.first"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"fee\", (int64_t)(tx.GetValueIn(mapInputs) - tx.GetValueOut()))"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetValueOut",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueOut",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "577-587",
          "snippet": "int64_t GetValueOut() const\n    {\n        int64_t nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  int64_t GetValueOut() const\n      {\n          int64_t nValueOut = 0;\n          BOOST_FOREACH(const CTxOut& txout, vout)\n          {\n              nValueOut += txout.nValue;\n              if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                  throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n          }\n          return nValueOut;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetValueIn",
          "args": [
            "mapInputs"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.FetchInputs",
          "args": [
            "txdb",
            "mapUnused",
            "false",
            "false",
            "mapInputs",
            "fInvalid"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "FetchInputs",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1310-1523",
          "snippet": "bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n indexes are valid:\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nCoinbaseMaturity = 50;",
            "int nBestHeight = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nCoinbaseMaturity = 50;\nint nBestHeight = -1;\n\nCTransaction {\n  bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                                 bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n  {\n      // FetchInputs can return false either because we just haven't seen some inputs\n      // (in which case the transaction should be stored as an orphan)\n      // or because the transaction is malformed (in which case the transaction should\n      // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n      fInvalid = false;\n  \n      if (IsCoinBase())\n          return true; // Coinbase transactions have no inputs to fetch.\n  \n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          COutPoint prevout = vin[i].prevout;\n          if (inputsRet.count(prevout.hash))\n              continue; // Got it already\n  \n          // Read txindex\n          CTxIndex& txindex = inputsRet[prevout.hash].first;\n          bool fFound = true;\n          if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n          {\n              // Get txindex from current proposed changes\n              txindex = mapTestPool.find(prevout.hash)->second;\n          }\n          else\n          {\n              // Read txindex from txdb\n              fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n          }\n          if (!fFound && (fBlock || fMiner))\n              return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n  \n          // Read txPrev\n          CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n          {\n              // Get prev tx from single transactions in memory\n              {\n                  LOCK(mempool.cs);\n                  if (!mempool.exists(prevout.hash))\n                      return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                  txPrev = mempool.lookup(prevout.hash);\n              }\n              if (!fFound)\n                  txindex.vSpent.resize(txPrev.vout.size());\n          }\n          else\n          {\n              // Get prev tx from disk\n              if (!txPrev.ReadFromDisk(txindex.pos))\n                  return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n          }\n      }\n  \n      // Make sure all prevout.n indexes are valid:\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const COutPoint prevout = vin[i].prevout;\n          assert(inputsRet.count(prevout.hash) != 0);\n          const CTxIndex& txindex = inputsRet[prevout.hash].first;\n          const CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n          {\n              // Revisit this if/when transaction replacement is implemented and allows\n              // adding inputs:\n              fInvalid = true;\n              return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n          }\n      }\n  \n      return true;\n  }\n  \n  const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n  {\n      MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n      if (mi == inputs.end())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n  \n      const CTransaction& txPrev = (mi->second).second;\n      if (input.prevout.n >= txPrev.vout.size())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n  \n      return txPrev.vout[input.prevout.n];\n  }\n  \n  int64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      int64_t nResult = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          nResult += GetOutputFor(vin[i], inputs).nValue;\n      }\n      return nResult;\n  \n  }\n  \n  unsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      unsigned int nSigOps = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n          if (prevout.scriptPubKey.IsPayToScriptHash())\n              nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n      }\n      return nSigOps;\n  }\n  \n  bool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n      const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n  {\n      // Take over previous transactions' spent pointers\n      // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n      // fMiner is true when called from the internal bitcoin miner\n      // ... both are false when called from CTransaction::AcceptToMemoryPool\n      if (!IsCoinBase())\n      {\n          int64_t nValueIn = 0;\n          int64_t nFees = 0;\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                  return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n  \n              // If prev is coinbase or coinstake, check that it's matured\n              if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                  for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                      if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                          return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n  \n              // ppcoin: check transaction timestamp\n              if (txPrev.nTime > nTime)\n                  return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n  \n              // Check for negative or overflow input values\n              nValueIn += txPrev.vout[prevout.n].nValue;\n              if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                  return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n  \n          }\n          // The first loop above does all the inexpensive checks.\n          // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n          // Helps prevent CPU exhaustion attacks.\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              // Check for conflicts (double-spend)\n              // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n              // for an attacker to attempt to split the network.\n              if (!txindex.vSpent[prevout.n].IsNull())\n                  return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n  \n              // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n              // before the last blockchain checkpoint. This is safe because block merkle hashes are\n              // still computed and checked, and any change will be caught at the next checkpoint.\n              if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n              {\n                  // Verify signature\n                  if (!VerifySignature(txPrev, *this, i, 0))\n                  {\n                      return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                  }\n              }\n  \n              // Mark outpoints as spent\n              txindex.vSpent[prevout.n] = posThisTx;\n  \n              // Write back\n              if (fBlock || fMiner)\n              {\n                  mapTestPool[prevout.hash] = txindex;\n              }\n          }\n  \n          if (!IsCoinStake())\n          {\n              if (nValueIn < GetValueOut())\n                  return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // Tally transaction fees\n              int64_t nTxFee = nValueIn - GetValueOut();\n              if (nTxFee < 0)\n                  return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // enforce transaction fees for every block\n              if (nTxFee < GetMinFee())\n                  return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n  \n              nFees += nTxFee;\n              if (!MoneyRange(nFees))\n                  return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n          }\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"hash\", txHash.GetHex())"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entry.push_back",
          "args": [
            "Pair(\"data\", HexStr(ssTx.begin(), ssTx.end()))"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinBase",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BOOST_FOREACH",
          "args": [
            "CTransaction& tx",
            "pblock->vtx"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pblock->UpdateTime",
          "args": [
            "pindexPrev"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateTime",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1259-1262",
          "snippet": "void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max(GetBlockTime(), GetAdjustedTime());\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n  {\n      nTime = max(GetBlockTime(), GetAdjustedTime());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_OUT_OF_MEMORY",
            "\"Out of memory\""
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CreateNewBlock",
          "args": [
            "pwalletMain"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInitialBlockDownload",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "IsInitialBlockDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1220-1233",
          "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nBestHeight = -1;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "modeval.type",
          "args": [],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "type",
          "container": "Value_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "321-324",
          "snippet": "Value_type Value_impl< Config >::type() const\n    {\n        return type_;\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nValue_impl< Config > {\n  Value_type Value_impl< Config >::type() const\n      {\n          return type_;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "modeval.get_str",
          "args": [],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_value",
          "args": [
            "oparam",
            "\"mode\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params[0].get_obj",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "params.size",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"getblocktemplate [params]\\n\"\n            \"Returns data needed to construct a block to work on:\\n\"\n            \"  \\\"version\\\" : block version\\n\"\n            \"  \\\"previousblockhash\\\" : hash of current highest block\\n\"\n            \"  \\\"transactions\\\" : contents of non-coinbase transactions that should be included in the next block\\n\"\n            \"  \\\"coinbaseaux\\\" : data that should be included in coinbase\\n\"\n            \"  \\\"coinbasevalue\\\" : maximum allowable input to coinbase transaction, including the generation award and transaction fees\\n\"\n            \"  \\\"target\\\" : hash target\\n\"\n            \"  \\\"mintime\\\" : minimum timestamp appropriate for next block\\n\"\n            \"  \\\"curtime\\\" : current timestamp\\n\"\n            \"  \\\"mutable\\\" : list of ways the block template may be changed\\n\"\n            \"  \\\"noncerange\\\" : range of valid nonces\\n\"\n            \"  \\\"sigoplimit\\\" : limit of sigops in blocks\\n\"\n            \"  \\\"sizelimit\\\" : limit of block size\\n\"\n            \"  \\\"bits\\\" : compressed target of next block\\n\"\n            \"  \\\"height\\\" : height of the next block\\n\"\n            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"miner.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"main.h\"\n\nValue getblocktemplate(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() > 1)\n        throw runtime_error(\n            \"getblocktemplate [params]\\n\"\n            \"Returns data needed to construct a block to work on:\\n\"\n            \"  \\\"version\\\" : block version\\n\"\n            \"  \\\"previousblockhash\\\" : hash of current highest block\\n\"\n            \"  \\\"transactions\\\" : contents of non-coinbase transactions that should be included in the next block\\n\"\n            \"  \\\"coinbaseaux\\\" : data that should be included in coinbase\\n\"\n            \"  \\\"coinbasevalue\\\" : maximum allowable input to coinbase transaction, including the generation award and transaction fees\\n\"\n            \"  \\\"target\\\" : hash target\\n\"\n            \"  \\\"mintime\\\" : minimum timestamp appropriate for next block\\n\"\n            \"  \\\"curtime\\\" : current timestamp\\n\"\n            \"  \\\"mutable\\\" : list of ways the block template may be changed\\n\"\n            \"  \\\"noncerange\\\" : range of valid nonces\\n\"\n            \"  \\\"sigoplimit\\\" : limit of sigops in blocks\\n\"\n            \"  \\\"sizelimit\\\" : limit of block size\\n\"\n            \"  \\\"bits\\\" : compressed target of next block\\n\"\n            \"  \\\"height\\\" : height of the next block\\n\"\n            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\");\n\n    std::string strMode = \"template\";\n    if (params.size() > 0)\n    {\n        const Object& oparam = params[0].get_obj();\n        const Value& modeval = find_value(oparam, \"mode\");\n        if (modeval.type() == str_type)\n            strMode = modeval.get_str();\n        else if (modeval.type() == null_type)\n        {\n            /* Do nothing */\n        }\n        else\n            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n    }\n\n    if (strMode != \"template\")\n        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n\n    if (vNodes.empty())\n        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Halcyon is not connected!\");\n\n    if (IsInitialBlockDownload())\n        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Halcyon is downloading blocks...\");\n\n    static CReserveKey reservekey(pwalletMain);\n\n    // Update block\n    static unsigned int nTransactionsUpdatedLast;\n    static CBlockIndex* pindexPrev;\n    static int64_t nStart;\n    static CBlock* pblock;\n    if (pindexPrev != pindexBest ||\n        (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 5))\n    {\n        // Clear pindexPrev so future calls make a new block, despite any failures from here on\n        pindexPrev = NULL;\n\n        // Store the pindexBest used before CreateNewBlock, to avoid races\n        nTransactionsUpdatedLast = nTransactionsUpdated;\n        CBlockIndex* pindexPrevNew = pindexBest;\n        nStart = GetTime();\n\n        // Create new block\n        if(pblock)\n        {\n            delete pblock;\n            pblock = NULL;\n        }\n        pblock = CreateNewBlock(pwalletMain);\n        if (!pblock)\n            throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n\n        // Need to update only after we know CreateNewBlock succeeded\n        pindexPrev = pindexPrevNew;\n    }\n\n    // Update nTime\n    pblock->UpdateTime(pindexPrev);\n    pblock->nNonce = 0;\n\n    Array transactions;\n    map<uint256, int64_t> setTxIndex;\n    int i = 0;\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH (CTransaction& tx, pblock->vtx)\n    {\n        uint256 txHash = tx.GetHash();\n        setTxIndex[txHash] = i++;\n\n        if (tx.IsCoinBase() || tx.IsCoinStake())\n            continue;\n\n        Object entry;\n\n        CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n        ssTx << tx;\n        entry.push_back(Pair(\"data\", HexStr(ssTx.begin(), ssTx.end())));\n\n        entry.push_back(Pair(\"hash\", txHash.GetHex()));\n\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            entry.push_back(Pair(\"fee\", (int64_t)(tx.GetValueIn(mapInputs) - tx.GetValueOut())));\n\n            Array deps;\n            BOOST_FOREACH (MapPrevTx::value_type& inp, mapInputs)\n            {\n                if (setTxIndex.count(inp.first))\n                    deps.push_back(setTxIndex[inp.first]);\n            }\n            entry.push_back(Pair(\"depends\", deps));\n\n            int64_t nSigOps = tx.GetLegacySigOpCount();\n            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            entry.push_back(Pair(\"sigops\", nSigOps));\n        }\n\n        transactions.push_back(entry);\n    }\n\n    Object aux;\n    aux.push_back(Pair(\"flags\", HexStr(COINBASE_FLAGS.begin(), COINBASE_FLAGS.end())));\n\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n    static Array aMutable;\n    if (aMutable.empty())\n    {\n        aMutable.push_back(\"time\");\n        aMutable.push_back(\"transactions\");\n        aMutable.push_back(\"prevblock\");\n    }\n\n    Object result;\n    result.push_back(Pair(\"version\", pblock->nVersion));\n    result.push_back(Pair(\"previousblockhash\", pblock->hashPrevBlock.GetHex()));\n    result.push_back(Pair(\"transactions\", transactions));\n    result.push_back(Pair(\"coinbaseaux\", aux));\n    result.push_back(Pair(\"coinbasevalue\", (int64_t)pblock->vtx[0].vout[0].nValue));\n    result.push_back(Pair(\"target\", hashTarget.GetHex()));\n    result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1));\n    result.push_back(Pair(\"mutable\", aMutable));\n    result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n    result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS));\n    result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SIZE));\n    result.push_back(Pair(\"curtime\", (int64_t)pblock->nTime));\n    result.push_back(Pair(\"bits\", HexBits(pblock->nBits)));\n    result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\n\n    return result;\n}"
  },
  {
    "function_name": "getwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcmining.cpp",
    "lines": "88-199",
    "snippet": "Value getwork(const Array& params, bool fHelp) {\n\n    if(fHelp || (params.size() > 1))\n      throw(runtime_error(\n        \"getwork [data]\\n\"\n        \"If [data] is not specified, returns formatted data to work on:\\n\"\n        \"  \\\"data\\\" : block header\\n\"\n        \"  \\\"target\\\" : hash target\\n\"\n        \"  \\\"algorithm\\\" : hashing algorithm expected (optional)\\n\"\n        \"If [data] is specified, verifies the PoW hash against target and returns true if successful.\"));\n\n    if (vNodes.empty())\n        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Halcyon is not connected!\");\n\n    if (IsInitialBlockDownload())\n        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Halcyon is downloading blocks...\");\n\n    typedef map<uint256, pair<CBlock*, CScript> > mapNewBlock_t;\n    static mapNewBlock_t mapNewBlock;    // FIXME: thread safety\n    static vector<CBlock*> vNewBlock;\n    static CReserveKey reservekey(pwalletMain);\n\n    if (params.size() == 0)\n    {\n        // Update block\n        static unsigned int nTransactionsUpdatedLast;\n        static CBlockIndex* pindexPrev;\n        static int64_t nStart;\n        static CBlock* pblock;\n        if (pindexPrev != pindexBest ||\n            (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n        {\n            if (pindexPrev != pindexBest)\n            {\n                // Deallocate old blocks since they're obsolete now\n                mapNewBlock.clear();\n                BOOST_FOREACH(CBlock* pblock, vNewBlock)\n                    delete pblock;\n                vNewBlock.clear();\n            }\n\n            // Clear pindexPrev so future getworks make a new block, despite any failures from here on\n            pindexPrev = NULL;\n\n            // Store the pindexBest used before CreateNewBlock, to avoid races\n            nTransactionsUpdatedLast = nTransactionsUpdated;\n            CBlockIndex* pindexPrevNew = pindexBest;\n            nStart = GetTime();\n\n            // Create new block\n            pblock = CreateNewBlock(pwalletMain);\n            if (!pblock)\n                throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n            vNewBlock.push_back(pblock);\n\n            // Need to update only after we know CreateNewBlock succeeded\n            pindexPrev = pindexPrevNew;\n        }\n\n        // Update nTime\n        pblock->UpdateTime(pindexPrev);\n        pblock->nNonce = 0;\n\n        // Update nExtraNonce\n        static unsigned int nExtraNonce = 0;\n        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n\n       /* Save this block for the future use */\n        mapNewBlock[pblock->hashMerkleRoot] = make_pair(pblock, pblock->vtx[0].vin[0].scriptSig);\n\n        /* Prepare the block header for transmission */\n        uint pdata[20];\n        FormatDataBuffer(pblock, pdata);\n\n        /* Get the current decompressed block target */\n        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n        Object result;\n        result.push_back(Pair(\"data\",   HexStr(BEGIN(pdata), END(pdata))));\n        result.push_back(Pair(\"target\", HexStr(BEGIN(hashTarget), END(hashTarget))));\n        /* Optional */\n        result.push_back(Pair(\"algorithm\", \"neoscrypt\"));\n\n        return(result);\n\n    } else {\n\n        /* Data received */\n        vector<unsigned char> vchData = ParseHex(params[0].get_str());\n\n        /* Must be no less actual data than sent previously */\n        if(vchData.size() < 80)\n          throw(JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\"));\n        CBlock* pdata = (CBlock*) &vchData[0];\n\n        /* Pick up the block contents saved previously */\n        if(!mapNewBlock.count(pdata->hashMerkleRoot))\n          return(false);\n        CBlock* pblock = mapNewBlock[pdata->hashMerkleRoot].first;\n\n        /* Replace with the data received */\n        pblock->nTime = pdata->nTime;\n        pblock->nNonce = pdata->nNonce;\n        pblock->vtx[0].vin[0].scriptSig = mapNewBlock[pdata->hashMerkleRoot].second;\n\n        /* Rebuild the merkle root */\n        pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n\n        /* Verify the resulting hash against target */\n        return(CheckWork(pblock, *pwalletMain, reservekey));\n    }\n}",
    "includes": [
      "#include \"bitcoinrpc.h\"",
      "#include \"miner.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CheckWork",
          "args": [
            "pblock",
            "*pwalletMain",
            "reservekey"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "CheckWork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
          "lines": "388-431",
          "snippet": "bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfWork())\n      return(error(\"CheckWork() : %s height %d is not a proof-of-work block\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    uint256 hashProof = pblock->GetHashPoW();\n\n    if(hashProof > hashTarget)\n      return(error(\"CheckWork() : block %s height %d proof-of-work not meeting target\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    printf(\"CheckWork() : new proof-of-work block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckWork() : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckWork() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"kernel.h\"",
            "#include \"miner.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nbool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey) {\n    uint256 hashBlock = pblock->GetHash();\n    uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n    int nBlockHeight = pblock->GetBlockHeight();\n\n    if(!pblock->IsProofOfWork())\n      return(error(\"CheckWork() : %s height %d is not a proof-of-work block\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    uint256 hashProof = pblock->GetHashPoW();\n\n    if(hashProof > hashTarget)\n      return(error(\"CheckWork() : block %s height %d proof-of-work not meeting target\",\n        hashBlock.GetHex().c_str(), nBlockHeight));\n\n    printf(\"CheckWork() : new proof-of-work block of height %d found!\\n\"\n      \"  hash:      %s\\n  proofhash: %s\\n  target:    %s\\n\",\n      nBlockHeight, hashBlock.GetHex().c_str(), hashProof.GetHex().c_str(),\n      hashTarget.GetHex().c_str());\n    pblock->print();\n    printf(\"generated %s\\n\", FormatMoney(pblock->vtx[0].vout[0].nValue).c_str());\n\n    // Found a solution\n    {\n        LOCK(cs_main);\n        if (pblock->hashPrevBlock != hashBestChain)\n            return error(\"CheckWork() : generated block is stale\");\n\n        // Remove key from key pool\n        reservekey.KeepKey();\n\n        // Track how many getdata requests this block gets\n        {\n            LOCK(wallet.cs_wallet);\n            wallet.mapRequestCount[hashBlock] = 0;\n        }\n\n        // Process this block the same as if we had received it from another node\n        if (!ProcessBlock(NULL, pblock))\n            return error(\"CheckWork() : ProcessBlock, block not accepted\");\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->BuildMerkleTree",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "BuildMerkleTree",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1020-1037",
          "snippet": "uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 BuildMerkleTree() const\n      {\n          vMerkleTree.clear();\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              vMerkleTree.push_back(tx.GetHash());\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              for (int i = 0; i < nSize; i += 2)\n              {\n                  int i2 = std::min(i+1, nSize-1);\n                  vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                             BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n              }\n              j += nSize;\n          }\n          return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapNewBlock.count",
          "args": [
            "pdata->hashMerkleRoot"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "JSONRPCError",
          "args": [
            "RPC_INVALID_PARAMETER",
            "\"Invalid parameter\""
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "JSONRPCError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "54-60",
          "snippet": "Object JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nObject JSONRPCError(int code, const string& message)\n{\n    Object error;\n    error.push_back(Pair(\"code\", code));\n    error.push_back(Pair(\"message\", message));\n    return error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchData.size",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseHex",
          "args": [
            "params[0].get_str()"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ParseHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "490-493",
          "snippet": "vector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvector<unsigned char> ParseHex(const string& str)\n{\n    return ParseHex(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "params[0].get_str",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"algorithm\", \"neoscrypt\")"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"algorithm\"",
            "\"neoscrypt\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"target\", HexStr(BEGIN(hashTarget), END(hashTarget)))"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HexStr",
          "args": [
            "BEGIN(hashTarget)",
            "END(hashTarget)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "HexStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "323-339",
          "snippet": "std::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nstd::string HexStr(const T itbegin, const T itend, bool fSpaces=false)\n{\n    std::string rv;\n    static const char hexmap[16] = { '0', '1', '2', '3', '4', '5', '6', '7',\n                                     '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n    rv.reserve((itend-itbegin)*3);\n    for(T it = itbegin; it < itend; ++it)\n    {\n        unsigned char val = (unsigned char)(*it);\n        if(fSpaces && it != itbegin)\n            rv.push_back(' ');\n        rv.push_back(hexmap[val>>4]);\n        rv.push_back(hexmap[val&15]);\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "END",
          "args": [
            "hashTarget"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEGIN",
          "args": [
            "hashTarget"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.push_back",
          "args": [
            "Pair(\"data\",   HexStr(BEGIN(pdata), END(pdata)))"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END",
          "args": [
            "pdata"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEGIN",
          "args": [
            "pdata"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "pblock->nBits"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FormatDataBuffer",
          "args": [
            "pblock",
            "pdata"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "FormatDataBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
          "lines": "363-385",
          "snippet": "void FormatDataBuffer(CBlock *pblock, uint *pdata) {\n    uint i;\n\n    struct {\n        int nVersion;\n        uint256 hashPrevBlock;\n        uint256 hashMerkleRoot;\n        uint nTime;\n        uint nBits;\n        uint nNonce;\n    } data;\n\n    data.nVersion       = pblock->nVersion;\n    data.hashPrevBlock  = pblock->hashPrevBlock;\n    data.hashMerkleRoot = pblock->hashMerkleRoot;\n    data.nTime          = pblock->nTime;\n    data.nBits          = pblock->nBits;\n    data.nNonce         = pblock->nNonce;\n\n    /* Copy the LE data */\n    for(i = 0; i < 20; i++)\n      pdata[i] = ((uint *) &data)[i];\n}",
          "includes": [
            "#include \"kernel.h\"",
            "#include \"miner.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nvoid FormatDataBuffer(CBlock *pblock, uint *pdata) {\n    uint i;\n\n    struct {\n        int nVersion;\n        uint256 hashPrevBlock;\n        uint256 hashMerkleRoot;\n        uint nTime;\n        uint nBits;\n        uint nNonce;\n    } data;\n\n    data.nVersion       = pblock->nVersion;\n    data.hashPrevBlock  = pblock->hashPrevBlock;\n    data.hashMerkleRoot = pblock->hashMerkleRoot;\n    data.nTime          = pblock->nTime;\n    data.nBits          = pblock->nBits;\n    data.nNonce         = pblock->nNonce;\n\n    /* Copy the LE data */\n    for(i = 0; i < 20; i++)\n      pdata[i] = ((uint *) &data)[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pblock",
            "pblock->vtx[0].vin[0].scriptSig"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IncrementExtraNonce",
          "args": [
            "pblock",
            "pindexPrev",
            "nExtraNonce"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "IncrementExtraNonce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/miner.cpp",
          "lines": "343-359",
          "snippet": "void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n\n    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}",
          "includes": [
            "#include \"kernel.h\"",
            "#include \"miner.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kernel.h\"\n#include \"miner.h\"\n#include \"txdb.h\"\n\nvoid IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n{\n    // Update nExtraNonce\n    static uint256 hashPrevBlock;\n    if (hashPrevBlock != pblock->hashPrevBlock)\n    {\n        nExtraNonce = 0;\n        hashPrevBlock = pblock->hashPrevBlock;\n    }\n    ++nExtraNonce;\n\n    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CBigNum(nExtraNonce)) + COINBASE_FLAGS;\n    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n\n    pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->UpdateTime",
          "args": [
            "pindexPrev"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateTime",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1259-1262",
          "snippet": "void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max(GetBlockTime(), GetAdjustedTime());\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n  {\n      nTime = max(GetBlockTime(), GetAdjustedTime());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNewBlock.push_back",
          "args": [
            "pblock"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CreateNewBlock",
          "args": [
            "pwalletMain"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNewBlock.clear",
          "args": [],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInitialBlockDownload",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "IsInitialBlockDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1220-1233",
          "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nBestHeight = -1;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNodes.empty",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"getwork [data]\\n\"\n        \"If [data] is not specified, returns formatted data to work on:\\n\"\n        \"  \\\"data\\\" : block header\\n\"\n        \"  \\\"target\\\" : hash target\\n\"\n        \"  \\\"algorithm\\\" : hashing algorithm expected (optional)\\n\"\n        \"If [data] is specified, verifies the PoW hash against target and returns true if successful.\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"miner.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"main.h\"\n\nValue getwork(const Array& params, bool fHelp) {\n\n    if(fHelp || (params.size() > 1))\n      throw(runtime_error(\n        \"getwork [data]\\n\"\n        \"If [data] is not specified, returns formatted data to work on:\\n\"\n        \"  \\\"data\\\" : block header\\n\"\n        \"  \\\"target\\\" : hash target\\n\"\n        \"  \\\"algorithm\\\" : hashing algorithm expected (optional)\\n\"\n        \"If [data] is specified, verifies the PoW hash against target and returns true if successful.\"));\n\n    if (vNodes.empty())\n        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Halcyon is not connected!\");\n\n    if (IsInitialBlockDownload())\n        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Halcyon is downloading blocks...\");\n\n    typedef map<uint256, pair<CBlock*, CScript> > mapNewBlock_t;\n    static mapNewBlock_t mapNewBlock;    // FIXME: thread safety\n    static vector<CBlock*> vNewBlock;\n    static CReserveKey reservekey(pwalletMain);\n\n    if (params.size() == 0)\n    {\n        // Update block\n        static unsigned int nTransactionsUpdatedLast;\n        static CBlockIndex* pindexPrev;\n        static int64_t nStart;\n        static CBlock* pblock;\n        if (pindexPrev != pindexBest ||\n            (nTransactionsUpdated != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n        {\n            if (pindexPrev != pindexBest)\n            {\n                // Deallocate old blocks since they're obsolete now\n                mapNewBlock.clear();\n                BOOST_FOREACH(CBlock* pblock, vNewBlock)\n                    delete pblock;\n                vNewBlock.clear();\n            }\n\n            // Clear pindexPrev so future getworks make a new block, despite any failures from here on\n            pindexPrev = NULL;\n\n            // Store the pindexBest used before CreateNewBlock, to avoid races\n            nTransactionsUpdatedLast = nTransactionsUpdated;\n            CBlockIndex* pindexPrevNew = pindexBest;\n            nStart = GetTime();\n\n            // Create new block\n            pblock = CreateNewBlock(pwalletMain);\n            if (!pblock)\n                throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n            vNewBlock.push_back(pblock);\n\n            // Need to update only after we know CreateNewBlock succeeded\n            pindexPrev = pindexPrevNew;\n        }\n\n        // Update nTime\n        pblock->UpdateTime(pindexPrev);\n        pblock->nNonce = 0;\n\n        // Update nExtraNonce\n        static unsigned int nExtraNonce = 0;\n        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n\n       /* Save this block for the future use */\n        mapNewBlock[pblock->hashMerkleRoot] = make_pair(pblock, pblock->vtx[0].vin[0].scriptSig);\n\n        /* Prepare the block header for transmission */\n        uint pdata[20];\n        FormatDataBuffer(pblock, pdata);\n\n        /* Get the current decompressed block target */\n        uint256 hashTarget = CBigNum().SetCompact(pblock->nBits).getuint256();\n\n        Object result;\n        result.push_back(Pair(\"data\",   HexStr(BEGIN(pdata), END(pdata))));\n        result.push_back(Pair(\"target\", HexStr(BEGIN(hashTarget), END(hashTarget))));\n        /* Optional */\n        result.push_back(Pair(\"algorithm\", \"neoscrypt\"));\n\n        return(result);\n\n    } else {\n\n        /* Data received */\n        vector<unsigned char> vchData = ParseHex(params[0].get_str());\n\n        /* Must be no less actual data than sent previously */\n        if(vchData.size() < 80)\n          throw(JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\"));\n        CBlock* pdata = (CBlock*) &vchData[0];\n\n        /* Pick up the block contents saved previously */\n        if(!mapNewBlock.count(pdata->hashMerkleRoot))\n          return(false);\n        CBlock* pblock = mapNewBlock[pdata->hashMerkleRoot].first;\n\n        /* Replace with the data received */\n        pblock->nTime = pdata->nTime;\n        pblock->nNonce = pdata->nNonce;\n        pblock->vtx[0].vin[0].scriptSig = mapNewBlock[pdata->hashMerkleRoot].second;\n\n        /* Rebuild the merkle root */\n        pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n\n        /* Verify the resulting hash against target */\n        return(CheckWork(pblock, *pwalletMain, reservekey));\n    }\n}"
  },
  {
    "function_name": "getstakinginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcmining.cpp",
    "lines": "51-84",
    "snippet": "Value getstakinginfo(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 0)\n        throw runtime_error(\n            \"getstakinginfo\\n\"\n            \"Returns an object containing staking-related information.\");\n\n    uint64_t nMinWeight = 0, nMaxWeight = 0, nWeight = 0;\n    pwalletMain->GetStakeWeight(*pwalletMain, nMinWeight, nMaxWeight, nWeight);\n\n    uint64_t nNetworkWeight = GetPoSKernelPS();\n    bool staking = nLastCoinStakeSearchInterval && nWeight;\n    int nExpectedTime = staking ? (5 * nBaseTargetSpacing * nNetworkWeight / nWeight) : -1;\n\n    Object obj;\n\n    obj.push_back(Pair(\"enabled\", GetBoolArg(\"-staking\", true)));\n    obj.push_back(Pair(\"staking\", staking));\n    obj.push_back(Pair(\"errors\", GetWarnings(\"statusbar\")));\n\n    obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n    obj.push_back(Pair(\"currentblocktx\", (uint64_t)nLastBlockTx));\n    obj.push_back(Pair(\"pooledtx\", (uint64_t)mempool.size()));\n\n    obj.push_back(Pair(\"difficulty\", GetDifficulty(GetLastBlockIndex(pindexBest, true))));\n    obj.push_back(Pair(\"search-interval\", (int)nLastCoinStakeSearchInterval));\n\n    obj.push_back(Pair(\"weight\", (uint64_t)nWeight));\n    obj.push_back(Pair(\"netstakeweight\", (uint64_t)nNetworkWeight));\n\n    obj.push_back(Pair(\"expectedtime\", nExpectedTime));\n\n    return obj;\n}",
    "includes": [
      "#include \"bitcoinrpc.h\"",
      "#include \"miner.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"expectedtime\", nExpectedTime)"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"expectedtime\"",
            "nExpectedTime"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"netstakeweight\", (uint64_t)nNetworkWeight)"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"weight\", (uint64_t)nWeight)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"search-interval\", (int)nLastCoinStakeSearchInterval)"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"difficulty\", GetDifficulty(GetLastBlockIndex(pindexBest, true)))"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDifficulty",
          "args": [
            "GetLastBlockIndex(pindexBest, true)"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "GetDifficulty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcblockchain.cpp",
          "lines": "15-44",
          "snippet": "double GetDifficulty(const CBlockIndex* blockindex)\n{\n    // Floating point number that is a multiple of the minimum difficulty,\n    // minimum difficulty = 1.0.\n    if (blockindex == NULL)\n    {\n        if (pindexBest == NULL)\n            return 1.0;\n        else\n            blockindex = GetLastBlockIndex(pindexBest, false);\n    }\n\n    int nShift = (blockindex->nBits >> 24) & 0xff;\n\n    double dDiff =\n        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n\n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}",
          "includes": [
            "#include \"bitcoinrpc.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"main.h\"\n\ndouble GetDifficulty(const CBlockIndex* blockindex)\n{\n    // Floating point number that is a multiple of the minimum difficulty,\n    // minimum difficulty = 1.0.\n    if (blockindex == NULL)\n    {\n        if (pindexBest == NULL)\n            return 1.0;\n        else\n            blockindex = GetLastBlockIndex(pindexBest, false);\n    }\n\n    int nShift = (blockindex->nBits >> 24) & 0xff;\n\n    double dDiff =\n        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n\n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [
            "pindexBest",
            "true"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"pooledtx\", (uint64_t)mempool.size())"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.size",
          "args": [],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"currentblocktx\", (uint64_t)nLastBlockTx)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"currentblocksize\", (uint64_t)nLastBlockSize)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"errors\", GetWarnings(\"statusbar\"))"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetWarnings",
          "args": [
            "\"statusbar\""
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "GetWarnings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2956-3001",
          "snippet": "string GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "extern map<uint256, CAlert> mapAlerts;",
            "extern CCriticalSection cs_mapAlerts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nextern map<uint256, CAlert> mapAlerts;\nextern CCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"staking\", staking)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"enabled\", GetBoolArg(\"-staking\", true))"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-staking\"",
            "true"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "GetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "569-578",
          "snippet": "bool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nbool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetPoSKernelPS",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "GetPoSKernelPS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcblockchain.cpp",
          "lines": "70-93",
          "snippet": "double GetPoSKernelPS()\n{\n    int nPoSInterval = 72;\n    double dStakeKernelsTriedAvg = 0;\n    int nStakesHandled = 0, nStakesTime = 0;\n\n    CBlockIndex* pindex = pindexBest;;\n    CBlockIndex* pindexPrevStake = NULL;\n\n    while (pindex && nStakesHandled < nPoSInterval)\n    {\n        if (pindex->IsProofOfStake())\n        {\n            dStakeKernelsTriedAvg += GetDifficulty(pindex) * 4294967296.0;\n            nStakesTime += pindexPrevStake ? (pindexPrevStake->nTime - pindex->nTime) : 0;\n            pindexPrevStake = pindex;\n            nStakesHandled++;\n        }\n\n        pindex = pindex->pprev;\n    }\n\n    return nStakesTime ? dStakeKernelsTriedAvg / nStakesTime : 0;\n}",
          "includes": [
            "#include \"bitcoinrpc.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"main.h\"\n\ndouble GetPoSKernelPS()\n{\n    int nPoSInterval = 72;\n    double dStakeKernelsTriedAvg = 0;\n    int nStakesHandled = 0, nStakesTime = 0;\n\n    CBlockIndex* pindex = pindexBest;;\n    CBlockIndex* pindexPrevStake = NULL;\n\n    while (pindex && nStakesHandled < nPoSInterval)\n    {\n        if (pindex->IsProofOfStake())\n        {\n            dStakeKernelsTriedAvg += GetDifficulty(pindex) * 4294967296.0;\n            nStakesTime += pindexPrevStake ? (pindexPrevStake->nTime - pindex->nTime) : 0;\n            pindexPrevStake = pindex;\n            nStakesHandled++;\n        }\n\n        pindex = pindex->pprev;\n    }\n\n    return nStakesTime ? dStakeKernelsTriedAvg / nStakesTime : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetStakeWeight",
          "args": [
            "*pwalletMain",
            "nMinWeight",
            "nMaxWeight",
            "nWeight"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"getstakinginfo\\n\"\n            \"Returns an object containing staking-related information.\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"miner.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"main.h\"\n\nValue getstakinginfo(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 0)\n        throw runtime_error(\n            \"getstakinginfo\\n\"\n            \"Returns an object containing staking-related information.\");\n\n    uint64_t nMinWeight = 0, nMaxWeight = 0, nWeight = 0;\n    pwalletMain->GetStakeWeight(*pwalletMain, nMinWeight, nMaxWeight, nWeight);\n\n    uint64_t nNetworkWeight = GetPoSKernelPS();\n    bool staking = nLastCoinStakeSearchInterval && nWeight;\n    int nExpectedTime = staking ? (5 * nBaseTargetSpacing * nNetworkWeight / nWeight) : -1;\n\n    Object obj;\n\n    obj.push_back(Pair(\"enabled\", GetBoolArg(\"-staking\", true)));\n    obj.push_back(Pair(\"staking\", staking));\n    obj.push_back(Pair(\"errors\", GetWarnings(\"statusbar\")));\n\n    obj.push_back(Pair(\"currentblocksize\", (uint64_t)nLastBlockSize));\n    obj.push_back(Pair(\"currentblocktx\", (uint64_t)nLastBlockTx));\n    obj.push_back(Pair(\"pooledtx\", (uint64_t)mempool.size()));\n\n    obj.push_back(Pair(\"difficulty\", GetDifficulty(GetLastBlockIndex(pindexBest, true))));\n    obj.push_back(Pair(\"search-interval\", (int)nLastCoinStakeSearchInterval));\n\n    obj.push_back(Pair(\"weight\", (uint64_t)nWeight));\n    obj.push_back(Pair(\"netstakeweight\", (uint64_t)nNetworkWeight));\n\n    obj.push_back(Pair(\"expectedtime\", nExpectedTime));\n\n    return obj;\n}"
  },
  {
    "function_name": "getmininginfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcmining.cpp",
    "lines": "16-49",
    "snippet": "Value getmininginfo(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 0)\n        throw runtime_error(\n            \"getmininginfo\\n\"\n            \"Returns an object containing mining-related information.\");\n\n    uint64_t nMinWeight = 0, nMaxWeight = 0, nWeight = 0;\n    pwalletMain->GetStakeWeight(*pwalletMain, nMinWeight, nMaxWeight, nWeight);\n\n    Object obj, diff, weight;\n    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n    obj.push_back(Pair(\"currentblocksize\",(uint64_t)nLastBlockSize));\n    obj.push_back(Pair(\"currentblocktx\",(uint64_t)nLastBlockTx));\n\n    diff.push_back(Pair(\"proof-of-work\",        GetDifficulty()));\n    diff.push_back(Pair(\"proof-of-stake\",       GetDifficulty(GetLastBlockIndex(pindexBest, true))));\n    diff.push_back(Pair(\"search-interval\",      (int)nLastCoinStakeSearchInterval));\n    obj.push_back(Pair(\"difficulty\",    diff));\n\n    obj.push_back(Pair(\"blockvalue\",    (uint64_t)GetProofOfWorkReward(pindexBest->nHeight, 0)));\n    obj.push_back(Pair(\"netmhashps\",     GetPoWMHashPS()));\n    obj.push_back(Pair(\"netstakeweight\", GetPoSKernelPS()));\n    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n    obj.push_back(Pair(\"pooledtx\",      (uint64_t)mempool.size()));\n\n    weight.push_back(Pair(\"minimum\",    (uint64_t)nMinWeight));\n    weight.push_back(Pair(\"maximum\",    (uint64_t)nMaxWeight));\n    weight.push_back(Pair(\"combined\",  (uint64_t)nWeight));\n    obj.push_back(Pair(\"stakeweight\", weight));\n\n    obj.push_back(Pair(\"testnet\",       fTestNet));\n    return obj;\n}",
    "includes": [
      "#include \"bitcoinrpc.h\"",
      "#include \"miner.h\"",
      "#include \"init.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"main.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"testnet\",       fTestNet)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Pair",
          "args": [
            "\"testnet\"",
            "fTestNet"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "Pair_impl",
          "container": "Pair_impl< Config >",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_value.h",
          "lines": "439-443",
          "snippet": "Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n    :   name_( name )\n    ,   value_( value )\n    {\n    }",
          "includes": [
            "#include <boost/variant.hpp>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/cstdint.hpp>",
            "#include <boost/config.hpp>",
            "#include <stdexcept>",
            "#include <sstream>",
            "#include <cassert>",
            "#include <string>",
            "#include <map>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/variant.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/config.hpp>\n#include <stdexcept>\n#include <sstream>\n#include <cassert>\n#include <string>\n#include <map>\n#include <vector>\n\nPair_impl< Config > {\n  Pair_impl< Config >::Pair_impl( const String_type& name, const Value_type& value )\n      :   name_( name )\n      ,   value_( value )\n      {\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"stakeweight\", weight)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "weight.push_back",
          "args": [
            "Pair(\"combined\",  (uint64_t)nWeight)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "weight.push_back",
          "args": [
            "Pair(\"maximum\",    (uint64_t)nMaxWeight)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "weight.push_back",
          "args": [
            "Pair(\"minimum\",    (uint64_t)nMinWeight)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"pooledtx\",      (uint64_t)mempool.size())"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.size",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"errors\",        GetWarnings(\"statusbar\"))"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetWarnings",
          "args": [
            "\"statusbar\""
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "GetWarnings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2956-3001",
          "snippet": "string GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "extern map<uint256, CAlert> mapAlerts;",
            "extern CCriticalSection cs_mapAlerts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nextern map<uint256, CAlert> mapAlerts;\nextern CCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"netstakeweight\", GetPoSKernelPS())"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPoSKernelPS",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "GetPoSKernelPS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcblockchain.cpp",
          "lines": "70-93",
          "snippet": "double GetPoSKernelPS()\n{\n    int nPoSInterval = 72;\n    double dStakeKernelsTriedAvg = 0;\n    int nStakesHandled = 0, nStakesTime = 0;\n\n    CBlockIndex* pindex = pindexBest;;\n    CBlockIndex* pindexPrevStake = NULL;\n\n    while (pindex && nStakesHandled < nPoSInterval)\n    {\n        if (pindex->IsProofOfStake())\n        {\n            dStakeKernelsTriedAvg += GetDifficulty(pindex) * 4294967296.0;\n            nStakesTime += pindexPrevStake ? (pindexPrevStake->nTime - pindex->nTime) : 0;\n            pindexPrevStake = pindex;\n            nStakesHandled++;\n        }\n\n        pindex = pindex->pprev;\n    }\n\n    return nStakesTime ? dStakeKernelsTriedAvg / nStakesTime : 0;\n}",
          "includes": [
            "#include \"bitcoinrpc.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"main.h\"\n\ndouble GetPoSKernelPS()\n{\n    int nPoSInterval = 72;\n    double dStakeKernelsTriedAvg = 0;\n    int nStakesHandled = 0, nStakesTime = 0;\n\n    CBlockIndex* pindex = pindexBest;;\n    CBlockIndex* pindexPrevStake = NULL;\n\n    while (pindex && nStakesHandled < nPoSInterval)\n    {\n        if (pindex->IsProofOfStake())\n        {\n            dStakeKernelsTriedAvg += GetDifficulty(pindex) * 4294967296.0;\n            nStakesTime += pindexPrevStake ? (pindexPrevStake->nTime - pindex->nTime) : 0;\n            pindexPrevStake = pindex;\n            nStakesHandled++;\n        }\n\n        pindex = pindex->pprev;\n    }\n\n    return nStakesTime ? dStakeKernelsTriedAvg / nStakesTime : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"netmhashps\",     GetPoWMHashPS())"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetPoWMHashPS",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "GetPoWMHashPS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcblockchain.cpp",
          "lines": "46-68",
          "snippet": "double GetPoWMHashPS() {\n\n    int nPoWInterval = 72;\n    int64_t nTargetSpacingWorkMin = 30, nTargetSpacingWork = 30;\n\n    CBlockIndex* pindex = pindexGenesisBlock;\n    CBlockIndex* pindexPrevWork = pindexGenesisBlock;\n\n    while (pindex)\n    {\n        if (pindex->IsProofOfWork())\n        {\n            int64_t nActualSpacingWork = pindex->GetBlockTime() - pindexPrevWork->GetBlockTime();\n            nTargetSpacingWork = ((nPoWInterval - 1) * nTargetSpacingWork + nActualSpacingWork + nActualSpacingWork) / (nPoWInterval + 1);\n            nTargetSpacingWork = max(nTargetSpacingWork, nTargetSpacingWorkMin);\n            pindexPrevWork = pindex;\n        }\n\n        pindex = pindex->pnext;\n    }\n\n    return GetDifficulty() * 4294.967296 / nTargetSpacingWork;\n}",
          "includes": [
            "#include \"bitcoinrpc.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"main.h\"\n\ndouble GetPoWMHashPS() {\n\n    int nPoWInterval = 72;\n    int64_t nTargetSpacingWorkMin = 30, nTargetSpacingWork = 30;\n\n    CBlockIndex* pindex = pindexGenesisBlock;\n    CBlockIndex* pindexPrevWork = pindexGenesisBlock;\n\n    while (pindex)\n    {\n        if (pindex->IsProofOfWork())\n        {\n            int64_t nActualSpacingWork = pindex->GetBlockTime() - pindexPrevWork->GetBlockTime();\n            nTargetSpacingWork = ((nPoWInterval - 1) * nTargetSpacingWork + nActualSpacingWork + nActualSpacingWork) / (nPoWInterval + 1);\n            nTargetSpacingWork = max(nTargetSpacingWork, nTargetSpacingWorkMin);\n            pindexPrevWork = pindex;\n        }\n\n        pindex = pindex->pnext;\n    }\n\n    return GetDifficulty() * 4294.967296 / nTargetSpacingWork;\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"blockvalue\",    (uint64_t)GetProofOfWorkReward(pindexBest->nHeight, 0))"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProofOfWorkReward",
          "args": [
            "pindexBest->nHeight",
            "0"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "GetProofOfWorkReward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "976-1003",
          "snippet": "int64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}"
        }
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"difficulty\",    diff)"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff.push_back",
          "args": [
            "Pair(\"search-interval\",      (int)nLastCoinStakeSearchInterval)"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff.push_back",
          "args": [
            "Pair(\"proof-of-stake\",       GetDifficulty(GetLastBlockIndex(pindexBest, true)))"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDifficulty",
          "args": [
            "GetLastBlockIndex(pindexBest, true)"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "GetDifficulty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcblockchain.cpp",
          "lines": "15-44",
          "snippet": "double GetDifficulty(const CBlockIndex* blockindex)\n{\n    // Floating point number that is a multiple of the minimum difficulty,\n    // minimum difficulty = 1.0.\n    if (blockindex == NULL)\n    {\n        if (pindexBest == NULL)\n            return 1.0;\n        else\n            blockindex = GetLastBlockIndex(pindexBest, false);\n    }\n\n    int nShift = (blockindex->nBits >> 24) & 0xff;\n\n    double dDiff =\n        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n\n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}",
          "includes": [
            "#include \"bitcoinrpc.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"main.h\"\n\ndouble GetDifficulty(const CBlockIndex* blockindex)\n{\n    // Floating point number that is a multiple of the minimum difficulty,\n    // minimum difficulty = 1.0.\n    if (blockindex == NULL)\n    {\n        if (pindexBest == NULL)\n            return 1.0;\n        else\n            blockindex = GetLastBlockIndex(pindexBest, false);\n    }\n\n    int nShift = (blockindex->nBits >> 24) & 0xff;\n\n    double dDiff =\n        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n\n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [
            "pindexBest",
            "true"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "diff.push_back",
          "args": [
            "Pair(\"proof-of-work\",        GetDifficulty())"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDifficulty",
          "args": [],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"currentblocktx\",(uint64_t)nLastBlockTx)"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"currentblocksize\",(uint64_t)nLastBlockSize)"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "obj.push_back",
          "args": [
            "Pair(\"blocks\",        (int)nBestHeight)"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetStakeWeight",
          "args": [
            "*pwalletMain",
            "nMinWeight",
            "nMaxWeight",
            "nWeight"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"getmininginfo\\n\"\n            \"Returns an object containing mining-related information.\""
          ],
          "line": 19
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"miner.h\"\n#include \"init.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"main.h\"\n\nValue getmininginfo(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() != 0)\n        throw runtime_error(\n            \"getmininginfo\\n\"\n            \"Returns an object containing mining-related information.\");\n\n    uint64_t nMinWeight = 0, nMaxWeight = 0, nWeight = 0;\n    pwalletMain->GetStakeWeight(*pwalletMain, nMinWeight, nMaxWeight, nWeight);\n\n    Object obj, diff, weight;\n    obj.push_back(Pair(\"blocks\",        (int)nBestHeight));\n    obj.push_back(Pair(\"currentblocksize\",(uint64_t)nLastBlockSize));\n    obj.push_back(Pair(\"currentblocktx\",(uint64_t)nLastBlockTx));\n\n    diff.push_back(Pair(\"proof-of-work\",        GetDifficulty()));\n    diff.push_back(Pair(\"proof-of-stake\",       GetDifficulty(GetLastBlockIndex(pindexBest, true))));\n    diff.push_back(Pair(\"search-interval\",      (int)nLastCoinStakeSearchInterval));\n    obj.push_back(Pair(\"difficulty\",    diff));\n\n    obj.push_back(Pair(\"blockvalue\",    (uint64_t)GetProofOfWorkReward(pindexBest->nHeight, 0)));\n    obj.push_back(Pair(\"netmhashps\",     GetPoWMHashPS()));\n    obj.push_back(Pair(\"netstakeweight\", GetPoSKernelPS()));\n    obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n    obj.push_back(Pair(\"pooledtx\",      (uint64_t)mempool.size()));\n\n    weight.push_back(Pair(\"minimum\",    (uint64_t)nMinWeight));\n    weight.push_back(Pair(\"maximum\",    (uint64_t)nMaxWeight));\n    weight.push_back(Pair(\"combined\",  (uint64_t)nWeight));\n    obj.push_back(Pair(\"stakeweight\", weight));\n\n    obj.push_back(Pair(\"testnet\",       fTestNet));\n    return obj;\n}"
  }
]