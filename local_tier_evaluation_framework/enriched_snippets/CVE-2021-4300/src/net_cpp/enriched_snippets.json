[
  {
    "function_name": "RelayTransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "2012-2030",
    "snippet": "void RelayTransaction(const CTransaction& tx, const uint256& hash, const CDataStream& ss)\n{\n    CInv inv(MSG_TX, hash);\n    {\n        LOCK(cs_mapRelay);\n        // Expire old relay messages\n        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n        {\n            mapRelay.erase(vRelayExpiration.front().second);\n            vRelayExpiration.pop_front();\n        }\n\n        // Save original serialized message so newer versions are preserved\n        mapRelay.insert(std::make_pair(inv, ss));\n        vRelayExpiration.push_back(std::make_pair(GetTime() + 15 * 60, inv));\n    }\n\n    RelayInventory(inv);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<CInv, CDataStream> mapRelay;",
      "deque<pair<int64_t, CInv> > vRelayExpiration;",
      "CCriticalSection cs_mapRelay;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelayInventory",
          "args": [
            "inv"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "RelayInventory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "643-651",
          "snippet": "inline void RelayInventory(const CInv& inv)\n{\n    // Put on lists to offer to the other nodes\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            pnode->PushInventory(inv);\n    }\n}",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\ninline void RelayInventory(const CInv& inv)\n{\n    // Put on lists to offer to the other nodes\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            pnode->PushInventory(inv);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRelayExpiration.push_back",
          "args": [
            "std::make_pair(GetTime() + 15 * 60, inv)"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "GetTime() + 15 * 60",
            "inv"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapRelay.insert",
          "args": [
            "std::make_pair(inv, ss)"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "inv",
            "ss"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRelayExpiration.pop_front",
          "args": [],
          "line": 2021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapRelay.erase",
          "args": [
            "vRelayExpiration.front().second"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRelayExpiration.front",
          "args": [],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRelayExpiration.front",
          "args": [],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRelayExpiration.empty",
          "args": [],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapRelay"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nmap<CInv, CDataStream> mapRelay;\ndeque<pair<int64_t, CInv> > vRelayExpiration;\nCCriticalSection cs_mapRelay;\n\nvoid RelayTransaction(const CTransaction& tx, const uint256& hash, const CDataStream& ss)\n{\n    CInv inv(MSG_TX, hash);\n    {\n        LOCK(cs_mapRelay);\n        // Expire old relay messages\n        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n        {\n            mapRelay.erase(vRelayExpiration.front().second);\n            vRelayExpiration.pop_front();\n        }\n\n        // Save original serialized message so newer versions are preserved\n        mapRelay.insert(std::make_pair(inv, ss));\n        vRelayExpiration.push_back(std::make_pair(GetTime() + 15 * 60, inv));\n    }\n\n    RelayInventory(inv);\n}"
  },
  {
    "function_name": "RelayTransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "2004-2010",
    "snippet": "void RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RelayTransaction",
          "args": [
            "tx",
            "hash",
            "ss"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "2012-2030",
          "snippet": "void RelayTransaction(const CTransaction& tx, const uint256& hash, const CDataStream& ss)\n{\n    CInv inv(MSG_TX, hash);\n    {\n        LOCK(cs_mapRelay);\n        // Expire old relay messages\n        while (!vRelayExpiration.empty() && vRelayExpiration.front().first < GetTime())\n        {\n            mapRelay.erase(vRelayExpiration.front().second);\n            vRelayExpiration.pop_front();\n        }\n\n        // Save original serialized message so newer versions are preserved\n        mapRelay.insert(std::make_pair(inv, ss));\n        vRelayExpiration.push_back(std::make_pair(GetTime() + 15 * 60, inv));\n    }\n\n    RelayInventory(inv);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ss.reserve",
          "args": [
            "10000"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}"
  },
  {
    "function_name": "CNetCleanup",
    "container": "CNetCleanup",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1982-1984",
    "snippet": "CNetCleanup()\n    {\n    }",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNetCleanup {\n  CNetCleanup()\n      {\n      }\n}"
  },
  {
    "function_name": "StopNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1939-1977",
    "snippet": "bool StopNode()\n{\n    printf(\"StopNode()\\n\");\n    fShutdown = true;\n    nTransactionsUpdated++;\n    int64_t nStart = GetTime();\n    if (semOutbound)\n        for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n            semOutbound->post();\n    do\n    {\n        int nThreadsRunning = 0;\n        for (int n = 0; n < THREAD_MAX; n++)\n            nThreadsRunning += vnThreadsRunning[n];\n        if (nThreadsRunning == 0)\n            break;\n        if (GetTime() - nStart > 20)\n            break;\n        MilliSleep(20);\n    } while(true);\n    if (vnThreadsRunning[THREAD_SOCKETHANDLER] > 0) printf(\"ThreadSocketHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_OPENCONNECTIONS] > 0) printf(\"ThreadOpenConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0) printf(\"ThreadMessageHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCLISTENER] > 0) printf(\"ThreadRPCListener still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCHANDLER] > 0) printf(\"ThreadsRPCServer still running\\n\");\n#ifdef USE_UPNP\n    if (vnThreadsRunning[THREAD_UPNP] > 0) printf(\"ThreadMapPort still running\\n\");\n#endif\n    if (vnThreadsRunning[THREAD_DNSSEED] > 0) printf(\"ThreadDNSAddressSeed still running\\n\");\n    if (vnThreadsRunning[THREAD_ADDEDCONNECTIONS] > 0) printf(\"ThreadOpenAddedConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_DUMPADDRESS] > 0) printf(\"ThreadDumpAddresses still running\\n\");\n    if (vnThreadsRunning[THREAD_STAKE_MINER] > 0) printf(\"ThreadStakeMiner still running\\n\");\n    if(vnThreadsRunning[THREAD_NTP] > 0) printf(\"ThreadNtpPoller still running\\n\");\n    while (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0 || vnThreadsRunning[THREAD_RPCHANDLER] > 0)\n        MilliSleep(20);\n    MilliSleep(50);\n    DumpAddresses();\n    return true;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int MAX_OUTBOUND_CONNECTIONS = 16;",
      "array<int, THREAD_MAX> vnThreadsRunning;",
      "static CSemaphore *semOutbound = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DumpAddresses",
          "args": [],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "DumpAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1252-1261",
          "snippet": "void DumpAddresses()\n{\n    int64_t nStart = GetTimeMillis();\n\n    CAddrDB adb;\n    adb.Write(addrman);\n\n    printf(\"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CAddrMan addrman;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCAddrMan addrman;\n\nvoid DumpAddresses()\n{\n    int64_t nStart = GetTimeMillis();\n\n    CAddrDB adb;\n    adb.Write(addrman);\n\n    printf(\"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "50"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadNtpPoller still running\\n\""
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadStakeMiner still running\\n\""
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadDumpAddresses still running\\n\""
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadOpenAddedConnections still running\\n\""
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadDNSAddressSeed still running\\n\""
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadMapPort still running\\n\""
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadsRPCServer still running\\n\""
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadRPCListener still running\\n\""
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadMessageHandler still running\\n\""
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadOpenConnections still running\\n\""
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadSocketHandler still running\\n\""
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "semOutbound->post",
          "args": [],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "post",
          "container": "CSemaphore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "149-155",
          "snippet": "void post() {\n        {\n            boost::unique_lock<boost::mutex> lock(mutex);\n            value++;\n        }\n        condition.notify_one();\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  void post() {\n          {\n              boost::unique_lock<boost::mutex> lock(mutex);\n              value++;\n          }\n          condition.notify_one();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"StopNode()\\n\""
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic const int MAX_OUTBOUND_CONNECTIONS = 16;\narray<int, THREAD_MAX> vnThreadsRunning;\nstatic CSemaphore *semOutbound = NULL;\n\nbool StopNode()\n{\n    printf(\"StopNode()\\n\");\n    fShutdown = true;\n    nTransactionsUpdated++;\n    int64_t nStart = GetTime();\n    if (semOutbound)\n        for (int i=0; i<MAX_OUTBOUND_CONNECTIONS; i++)\n            semOutbound->post();\n    do\n    {\n        int nThreadsRunning = 0;\n        for (int n = 0; n < THREAD_MAX; n++)\n            nThreadsRunning += vnThreadsRunning[n];\n        if (nThreadsRunning == 0)\n            break;\n        if (GetTime() - nStart > 20)\n            break;\n        MilliSleep(20);\n    } while(true);\n    if (vnThreadsRunning[THREAD_SOCKETHANDLER] > 0) printf(\"ThreadSocketHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_OPENCONNECTIONS] > 0) printf(\"ThreadOpenConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0) printf(\"ThreadMessageHandler still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCLISTENER] > 0) printf(\"ThreadRPCListener still running\\n\");\n    if (vnThreadsRunning[THREAD_RPCHANDLER] > 0) printf(\"ThreadsRPCServer still running\\n\");\n#ifdef USE_UPNP\n    if (vnThreadsRunning[THREAD_UPNP] > 0) printf(\"ThreadMapPort still running\\n\");\n#endif\n    if (vnThreadsRunning[THREAD_DNSSEED] > 0) printf(\"ThreadDNSAddressSeed still running\\n\");\n    if (vnThreadsRunning[THREAD_ADDEDCONNECTIONS] > 0) printf(\"ThreadOpenAddedConnections still running\\n\");\n    if (vnThreadsRunning[THREAD_DUMPADDRESS] > 0) printf(\"ThreadDumpAddresses still running\\n\");\n    if (vnThreadsRunning[THREAD_STAKE_MINER] > 0) printf(\"ThreadStakeMiner still running\\n\");\n    if(vnThreadsRunning[THREAD_NTP] > 0) printf(\"ThreadNtpPoller still running\\n\");\n    while (vnThreadsRunning[THREAD_MESSAGEHANDLER] > 0 || vnThreadsRunning[THREAD_RPCHANDLER] > 0)\n        MilliSleep(20);\n    MilliSleep(50);\n    DumpAddresses();\n    return true;\n}"
  },
  {
    "function_name": "StartNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1870-1937",
    "snippet": "void StartNode(void* parg)\n{\n    // Make this thread recognisable as the startup thread\n    RenameThread(\"hal-start\");\n\n    if (semOutbound == NULL) {\n        // initialize semaphore\n        int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n        semOutbound = new CSemaphore(nMaxOutbound);\n    }\n\n    if (pnodeLocalHost == NULL)\n        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), nLocalServices));\n\n    Discover();\n\n    //\n    // Start threads\n    //\n\n    if (!GetBoolArg(\"-dnsseed\", true))\n        printf(\"DNS seeding disabled\\n\");\n    else\n        if (!NewThread(ThreadDNSAddressSeed, NULL))\n            printf(\"Error: NewThread(ThreadDNSAddressSeed) failed\\n\");\n\n    // Map ports with UPnP\n    if (fUseUPnP)\n        MapPort();\n\n    // Get addresses from IRC and advertise ours\n    if (!NewThread(ThreadIRCSeed, NULL))\n        printf(\"Error: NewThread(ThreadIRCSeed) failed\\n\");\n\n    // Send and receive from sockets, accept connections\n    if (!NewThread(ThreadSocketHandler, NULL))\n        printf(\"Error: NewThread(ThreadSocketHandler) failed\\n\");\n\n    // Initiate outbound connections from -addnode\n    if (!NewThread(ThreadOpenAddedConnections, NULL))\n        printf(\"Error: NewThread(ThreadOpenAddedConnections) failed\\n\");\n\n    // Initiate outbound connections\n    if (!NewThread(ThreadOpenConnections, NULL))\n        printf(\"Error: NewThread(ThreadOpenConnections) failed\\n\");\n\n    // Process messages\n    if (!NewThread(ThreadMessageHandler, NULL))\n        printf(\"Error: NewThread(ThreadMessageHandler) failed\\n\");\n\n    // Dump network addresses\n    if (!NewThread(ThreadDumpAddress, NULL))\n        printf(\"Error; NewThread(ThreadDumpAddress) failed\\n\");\n\n    // Mine proof-of-stake blocks in the background\n    if (!GetBoolArg(\"-staking\", true))\n        printf(\"Staking disabled\\n\");\n    else\n        if (!NewThread(ThreadStakeMiner, pwalletMain))\n            printf(\"Error: NewThread(ThreadStakeMiner) failed\\n\");\n\n    /* Trusted NTP server */\n    strTrustedNTP = GetArg(\"-ntp\", \"localhost\");\n\n     /* NTP polling */\n    if(!NewThread(ThreadNtpPoller, NULL))\n      printf(\"Error: NewThread(ThreadNtpPoller) failed\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int MAX_OUTBOUND_CONNECTIONS = 16;",
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "bool fUseUPnP = false;",
      "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
      "static CNode* pnodeLocalHost = NULL;",
      "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);",
      "static CSemaphore *semOutbound = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadNtpPoller) failed\\n\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewThread",
          "args": [
            "ThreadNtpPoller",
            "NULL"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "NewThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1350-1360",
          "snippet": "bool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-ntp\"",
            "\"localhost\""
          ],
          "line": 1932
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadStakeMiner) failed\\n\""
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Staking disabled\\n\""
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-staking\"",
            "true"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "GetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "569-578",
          "snippet": "bool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nbool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error; NewThread(ThreadDumpAddress) failed\\n\""
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadMessageHandler) failed\\n\""
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadOpenConnections) failed\\n\""
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadOpenAddedConnections) failed\\n\""
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadSocketHandler) failed\\n\""
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadIRCSeed) failed\\n\""
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MapPort",
          "args": [],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "MapPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1151-1154",
          "snippet": "void MapPort()\n{\n    // Intentionally left blank.\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid MapPort()\n{\n    // Intentionally left blank.\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: NewThread(ThreadDNSAddressSeed) failed\\n\""
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"DNS seeding disabled\\n\""
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Discover",
          "args": [],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "Discover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1814-1868",
          "snippet": "void static Discover()\n{\n    if (!fDiscover)\n        return;\n\n#ifdef WIN32\n    // Get local host IP\n    char pszHostName[1000] = \"\";\n    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n    {\n        vector<CNetAddr> vaddr;\n        if (LookupHost(pszHostName, vaddr))\n        {\n            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n            {\n                AddLocal(addr, LOCAL_IF);\n            }\n        }\n    }\n#else\n    // Get local host ip\n    struct ifaddrs* myaddrs;\n    if (getifaddrs(&myaddrs) == 0)\n    {\n        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n        {\n            if (ifa->ifa_addr == NULL) continue;\n            if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n            if (ifa->ifa_addr->sa_family == AF_INET)\n            {\n                struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                CNetAddr addr(s4->sin_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#ifdef USE_IPV6\n            else if (ifa->ifa_addr->sa_family == AF_INET6)\n            {\n                struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                CNetAddr addr(s6->sin6_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#endif\n        }\n        freeifaddrs(myaddrs);\n    }\n#endif\n\n    // Don't use external IPv4 discovery, when -onlynet=\"IPv6\"\n    if (!IsLimited(NET_IPV4))\n        NewThread(ThreadGetMyExternalIP, NULL);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool fDiscover = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool fDiscover = true;\n\nvoid static Discover()\n{\n    if (!fDiscover)\n        return;\n\n#ifdef WIN32\n    // Get local host IP\n    char pszHostName[1000] = \"\";\n    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n    {\n        vector<CNetAddr> vaddr;\n        if (LookupHost(pszHostName, vaddr))\n        {\n            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n            {\n                AddLocal(addr, LOCAL_IF);\n            }\n        }\n    }\n#else\n    // Get local host ip\n    struct ifaddrs* myaddrs;\n    if (getifaddrs(&myaddrs) == 0)\n    {\n        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n        {\n            if (ifa->ifa_addr == NULL) continue;\n            if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n            if (ifa->ifa_addr->sa_family == AF_INET)\n            {\n                struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                CNetAddr addr(s4->sin_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#ifdef USE_IPV6\n            else if (ifa->ifa_addr->sa_family == AF_INET6)\n            {\n                struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                CNetAddr addr(s6->sin6_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#endif\n        }\n        freeifaddrs(myaddrs);\n    }\n#endif\n\n    // Don't use external IPv4 discovery, when -onlynet=\"IPv6\"\n    if (!IsLimited(NET_IPV4))\n        NewThread(ThreadGetMyExternalIP, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CAddress",
          "args": [
            "CService(\"127.0.0.1\", 0)",
            "nLocalServices"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "CAddress",
          "container": "CAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "83-87",
          "snippet": "CAddress::CAddress(CService ipIn, uint64_t nServicesIn) : CService(ipIn)\n{\n    Init();\n    nServices = nServicesIn;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nCAddress {\n  CAddress::CAddress(CService ipIn, uint64_t nServicesIn) : CService(ipIn)\n  {\n      Init();\n      nServices = nServicesIn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "\"127.0.0.1\"",
            "0"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "MAX_OUTBOUND_CONNECTIONS",
            "(int)GetArg(\"-maxconnections\", 125)"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "TimingResistantEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "569-576",
          "snippet": "bool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-start\""
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic const int MAX_OUTBOUND_CONNECTIONS = 16;\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\nbool fUseUPnP = false;\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nstatic CNode* pnodeLocalHost = NULL;\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\nstatic CSemaphore *semOutbound = NULL;\n\nvoid StartNode(void* parg)\n{\n    // Make this thread recognisable as the startup thread\n    RenameThread(\"hal-start\");\n\n    if (semOutbound == NULL) {\n        // initialize semaphore\n        int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n        semOutbound = new CSemaphore(nMaxOutbound);\n    }\n\n    if (pnodeLocalHost == NULL)\n        pnodeLocalHost = new CNode(INVALID_SOCKET, CAddress(CService(\"127.0.0.1\", 0), nLocalServices));\n\n    Discover();\n\n    //\n    // Start threads\n    //\n\n    if (!GetBoolArg(\"-dnsseed\", true))\n        printf(\"DNS seeding disabled\\n\");\n    else\n        if (!NewThread(ThreadDNSAddressSeed, NULL))\n            printf(\"Error: NewThread(ThreadDNSAddressSeed) failed\\n\");\n\n    // Map ports with UPnP\n    if (fUseUPnP)\n        MapPort();\n\n    // Get addresses from IRC and advertise ours\n    if (!NewThread(ThreadIRCSeed, NULL))\n        printf(\"Error: NewThread(ThreadIRCSeed) failed\\n\");\n\n    // Send and receive from sockets, accept connections\n    if (!NewThread(ThreadSocketHandler, NULL))\n        printf(\"Error: NewThread(ThreadSocketHandler) failed\\n\");\n\n    // Initiate outbound connections from -addnode\n    if (!NewThread(ThreadOpenAddedConnections, NULL))\n        printf(\"Error: NewThread(ThreadOpenAddedConnections) failed\\n\");\n\n    // Initiate outbound connections\n    if (!NewThread(ThreadOpenConnections, NULL))\n        printf(\"Error: NewThread(ThreadOpenConnections) failed\\n\");\n\n    // Process messages\n    if (!NewThread(ThreadMessageHandler, NULL))\n        printf(\"Error: NewThread(ThreadMessageHandler) failed\\n\");\n\n    // Dump network addresses\n    if (!NewThread(ThreadDumpAddress, NULL))\n        printf(\"Error; NewThread(ThreadDumpAddress) failed\\n\");\n\n    // Mine proof-of-stake blocks in the background\n    if (!GetBoolArg(\"-staking\", true))\n        printf(\"Staking disabled\\n\");\n    else\n        if (!NewThread(ThreadStakeMiner, pwalletMain))\n            printf(\"Error: NewThread(ThreadStakeMiner) failed\\n\");\n\n    /* Trusted NTP server */\n    strTrustedNTP = GetArg(\"-ntp\", \"localhost\");\n\n     /* NTP polling */\n    if(!NewThread(ThreadNtpPoller, NULL))\n      printf(\"Error: NewThread(ThreadNtpPoller) failed\\n\");\n}"
  },
  {
    "function_name": "Discover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1814-1868",
    "snippet": "void static Discover()\n{\n    if (!fDiscover)\n        return;\n\n#ifdef WIN32\n    // Get local host IP\n    char pszHostName[1000] = \"\";\n    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n    {\n        vector<CNetAddr> vaddr;\n        if (LookupHost(pszHostName, vaddr))\n        {\n            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n            {\n                AddLocal(addr, LOCAL_IF);\n            }\n        }\n    }\n#else\n    // Get local host ip\n    struct ifaddrs* myaddrs;\n    if (getifaddrs(&myaddrs) == 0)\n    {\n        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n        {\n            if (ifa->ifa_addr == NULL) continue;\n            if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n            if (ifa->ifa_addr->sa_family == AF_INET)\n            {\n                struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                CNetAddr addr(s4->sin_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#ifdef USE_IPV6\n            else if (ifa->ifa_addr->sa_family == AF_INET6)\n            {\n                struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                CNetAddr addr(s6->sin6_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#endif\n        }\n        freeifaddrs(myaddrs);\n    }\n#endif\n\n    // Don't use external IPv4 discovery, when -onlynet=\"IPv6\"\n    if (!IsLimited(NET_IPV4))\n        NewThread(ThreadGetMyExternalIP, NULL);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool fDiscover = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "NewThread",
          "args": [
            "ThreadGetMyExternalIP",
            "NULL"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "NewThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1350-1360",
          "snippet": "bool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLimited",
          "args": [
            "NET_IPV4"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "IsLimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "272-275",
          "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeifaddrs",
          "args": [
            "myaddrs"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IPv6 %s: %s\\n\"",
            "ifa->ifa_name",
            "addr.ToString().c_str()"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddLocal",
          "args": [
            "addr",
            "LOCAL_IF"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "AddLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "252-255",
          "snippet": "bool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"IPv4 %s: %s\\n\"",
            "ifa->ifa_name",
            "addr.ToString().c_str()"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "\"lo0\""
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ifa->ifa_name",
            "\"lo\""
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getifaddrs",
          "args": [
            "&myaddrs"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LookupHost",
          "args": [
            "pszHostName",
            "vaddr"
          ],
          "line": 1825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gethostname",
          "args": [
            "pszHostName",
            "sizeof(pszHostName)"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool fDiscover = true;\n\nvoid static Discover()\n{\n    if (!fDiscover)\n        return;\n\n#ifdef WIN32\n    // Get local host IP\n    char pszHostName[1000] = \"\";\n    if (gethostname(pszHostName, sizeof(pszHostName)) != SOCKET_ERROR)\n    {\n        vector<CNetAddr> vaddr;\n        if (LookupHost(pszHostName, vaddr))\n        {\n            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n            {\n                AddLocal(addr, LOCAL_IF);\n            }\n        }\n    }\n#else\n    // Get local host ip\n    struct ifaddrs* myaddrs;\n    if (getifaddrs(&myaddrs) == 0)\n    {\n        for (struct ifaddrs* ifa = myaddrs; ifa != NULL; ifa = ifa->ifa_next)\n        {\n            if (ifa->ifa_addr == NULL) continue;\n            if ((ifa->ifa_flags & IFF_UP) == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo\") == 0) continue;\n            if (strcmp(ifa->ifa_name, \"lo0\") == 0) continue;\n            if (ifa->ifa_addr->sa_family == AF_INET)\n            {\n                struct sockaddr_in* s4 = (struct sockaddr_in*)(ifa->ifa_addr);\n                CNetAddr addr(s4->sin_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv4 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#ifdef USE_IPV6\n            else if (ifa->ifa_addr->sa_family == AF_INET6)\n            {\n                struct sockaddr_in6* s6 = (struct sockaddr_in6*)(ifa->ifa_addr);\n                CNetAddr addr(s6->sin6_addr);\n                if (AddLocal(addr, LOCAL_IF))\n                    printf(\"IPv6 %s: %s\\n\", ifa->ifa_name, addr.ToString().c_str());\n            }\n#endif\n        }\n        freeifaddrs(myaddrs);\n    }\n#endif\n\n    // Don't use external IPv4 discovery, when -onlynet=\"IPv6\"\n    if (!IsLimited(NET_IPV4))\n        NewThread(ThreadGetMyExternalIP, NULL);\n}"
  },
  {
    "function_name": "ThreadMessageHandler2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1640-1696",
    "snippet": "void ThreadMessageHandler2(void* parg)\n{\n    printf(\"ThreadMessageHandler started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n    while (!fShutdown)\n    {\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n\n        // Poll the connected nodes for messages\n        CNode* pnodeTrickle = NULL;\n        if (!vNodesCopy.empty())\n            pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            // Receive messages\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                    ProcessMessages(pnode);\n            }\n            if (fShutdown)\n                return;\n\n            // Send messages\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                    SendMessages(pnode, pnode == pnodeTrickle);\n            }\n            if (fShutdown)\n                return;\n        }\n\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        // Wait and allow messages to bunch up.\n        // Reduce vnThreadsRunning so StopNode has permission to exit while\n        // we're sleeping, but we must always check fShutdown after doing this.\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        MilliSleep(100);\n        if (fRequestShutdown)\n            StartShutdown();\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n        if (fShutdown)\n            return;\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;",
      "vector<CNode*> vNodes;",
      "CCriticalSection cs_vNodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "StartShutdown",
          "args": [],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "StartShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "52-61",
          "snippet": "void StartShutdown()\n{\n#ifdef QT_GUI\n    // ensure we leave the Qt main loop for a clean GUI exit (Shutdown() is called in bitcoin.cpp afterwards)\n    uiInterface.QueueShutdown();\n#else\n    // Without UI, Shutdown() can simply be started in a new thread\n    NewThread(Shutdown, NULL);\n#endif\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CClientUIInterface uiInterface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nvoid StartShutdown()\n{\n#ifdef QT_GUI\n    // ensure we leave the Qt main loop for a clean GUI exit (Shutdown() is called in bitcoin.cpp afterwards)\n    uiInterface.QueueShutdown();\n#else\n    // Without UI, Shutdown() can simply be started in a new thread\n    NewThread(Shutdown, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "100"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnode->Release",
          "args": [],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "Release",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "276-279",
          "snippet": "void Release()\n    {\n        nRefCount--;\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void Release()\n      {\n          nRefCount--;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendMessages",
          "args": [
            "pnode",
            "pnode == pnodeTrickle"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "SendMessages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "3837-3995",
          "snippet": "bool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64_t nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64_t nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64_t nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_main;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64_t nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64_t nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64_t nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_vSend",
            "lockSend"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcessMessages",
          "args": [
            "pnode"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessMessages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "3715-3834",
          "snippet": "bool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while (true)\n    {\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %\"PRIpdd\" BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from under-length message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from over-long size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_main;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "unsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nunsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while (true)\n    {\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %\"PRIpdd\" BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from under-length message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from over-long size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_vRecv",
            "lockRecv"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRand",
          "args": [
            "vNodesCopy.size()"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNodesCopy.size",
          "args": [],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNodesCopy.empty",
          "args": [],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnode->AddRef",
          "args": [],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetThreadPriority",
          "args": [
            "THREAD_PRIORITY_BELOW_NORMAL"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "SetThreadPriority",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "648-657",
          "snippet": "inline void SetThreadPriority(int nPriority)\n{\n    // It's unclear if it's even possible to change thread priorities on Linux,\n    // but we really and truly need it for the generation threads.\n#ifdef PRIO_THREAD\n    setpriority(PRIO_THREAD, 0, nPriority);\n#else\n    setpriority(PRIO_PROCESS, 0, nPriority);\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void SetThreadPriority(int nPriority)\n{\n    // It's unclear if it's even possible to change thread priorities on Linux,\n    // but we really and truly need it for the generation threads.\n#ifdef PRIO_THREAD\n    setpriority(PRIO_THREAD, 0, nPriority);\n#else\n    setpriority(PRIO_PROCESS, 0, nPriority);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadMessageHandler started\\n\""
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\n\nvoid ThreadMessageHandler2(void* parg)\n{\n    printf(\"ThreadMessageHandler started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n    while (!fShutdown)\n    {\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n\n        // Poll the connected nodes for messages\n        CNode* pnodeTrickle = NULL;\n        if (!vNodesCopy.empty())\n            pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            // Receive messages\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                    ProcessMessages(pnode);\n            }\n            if (fShutdown)\n                return;\n\n            // Send messages\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                    SendMessages(pnode, pnode == pnodeTrickle);\n            }\n            if (fShutdown)\n                return;\n        }\n\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        // Wait and allow messages to bunch up.\n        // Reduce vnThreadsRunning so StopNode has permission to exit while\n        // we're sleeping, but we must always check fShutdown after doing this.\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        MilliSleep(100);\n        if (fRequestShutdown)\n            StartShutdown();\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n        if (fShutdown)\n            return;\n    }\n}"
  },
  {
    "function_name": "ThreadMessageHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1619-1638",
    "snippet": "void ThreadMessageHandler(void* parg)\n{\n    // Make this thread recognisable as the message handling thread\n    RenameThread(\"hal-msghand\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n        ThreadMessageHandler2(parg);\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        PrintException(&e, \"ThreadMessageHandler()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        PrintException(NULL, \"ThreadMessageHandler()\");\n    }\n    printf(\"ThreadMessageHandler exited\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadMessageHandler exited\\n\""
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "NULL",
            "\"ThreadMessageHandler()\""
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadMessageHandler2",
          "args": [
            "parg"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadMessageHandler2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1640-1696",
          "snippet": "void ThreadMessageHandler2(void* parg)\n{\n    printf(\"ThreadMessageHandler started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n    while (!fShutdown)\n    {\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n\n        // Poll the connected nodes for messages\n        CNode* pnodeTrickle = NULL;\n        if (!vNodesCopy.empty())\n            pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            // Receive messages\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                    ProcessMessages(pnode);\n            }\n            if (fShutdown)\n                return;\n\n            // Send messages\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                    SendMessages(pnode, pnode == pnodeTrickle);\n            }\n            if (fShutdown)\n                return;\n        }\n\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        // Wait and allow messages to bunch up.\n        // Reduce vnThreadsRunning so StopNode has permission to exit while\n        // we're sleeping, but we must always check fShutdown after doing this.\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        MilliSleep(100);\n        if (fRequestShutdown)\n            StartShutdown();\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n        if (fShutdown)\n            return;\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ThreadMessageHandler2(void* parg);",
            "void ThreadSocketHandler2(void* parg);",
            "void ThreadOpenConnections2(void* parg);",
            "void ThreadOpenAddedConnections2(void* parg);",
            "void ThreadDNSAddressSeed2(void* parg);",
            "array<int, THREAD_MAX> vnThreadsRunning;",
            "vector<CNode*> vNodes;",
            "CCriticalSection cs_vNodes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\n\nvoid ThreadMessageHandler2(void* parg)\n{\n    printf(\"ThreadMessageHandler started\\n\");\n    SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);\n    while (!fShutdown)\n    {\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n\n        // Poll the connected nodes for messages\n        CNode* pnodeTrickle = NULL;\n        if (!vNodesCopy.empty())\n            pnodeTrickle = vNodesCopy[GetRand(vNodesCopy.size())];\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            // Receive messages\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                    ProcessMessages(pnode);\n            }\n            if (fShutdown)\n                return;\n\n            // Send messages\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                    SendMessages(pnode, pnode == pnodeTrickle);\n            }\n            if (fShutdown)\n                return;\n        }\n\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        // Wait and allow messages to bunch up.\n        // Reduce vnThreadsRunning so StopNode has permission to exit while\n        // we're sleeping, but we must always check fShutdown after doing this.\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        MilliSleep(100);\n        if (fRequestShutdown)\n            StartShutdown();\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n        if (fShutdown)\n            return;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-msghand\""
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadMessageHandler(void* parg)\n{\n    // Make this thread recognisable as the message handling thread\n    RenameThread(\"hal-msghand\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]++;\n        ThreadMessageHandler2(parg);\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        PrintException(&e, \"ThreadMessageHandler()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_MESSAGEHANDLER]--;\n        PrintException(NULL, \"ThreadMessageHandler()\");\n    }\n    printf(\"ThreadMessageHandler exited\\n\");\n}"
  },
  {
    "function_name": "OpenNetworkConnection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1581-1610",
    "snippet": "bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *strDest, bool fOneShot)\n{\n    //\n    // Initiate outbound network connection\n    //\n    if (fShutdown)\n        return false;\n    if (!strDest)\n        if (IsLocal(addrConnect) ||\n            FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect) ||\n            FindNode(addrConnect.ToStringIPPort().c_str()))\n            return false;\n    if (strDest && FindNode(strDest))\n        return false;\n\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n    CNode* pnode = ConnectNode(addrConnect, strDest);\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n    if (fShutdown)\n        return false;\n    if (!pnode)\n        return false;\n    if (grantOutbound)\n        grantOutbound->MoveTo(pnode->grantOutbound);\n    pnode->fNetworkNode = true;\n    if (fOneShot)\n        pnode->fOneShot = true;\n\n    return true;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "grantOutbound->MoveTo",
          "args": [
            "pnode->grantOutbound"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "MoveTo",
          "container": "CSemaphoreGrant",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "186-192",
          "snippet": "void MoveTo(CSemaphoreGrant &grant) {\n        grant.Release();\n        grant.sem = sem;\n        grant.fHaveGrant = fHaveGrant;\n        sem = NULL;\n        fHaveGrant = false;\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  void MoveTo(CSemaphoreGrant &grant) {\n          grant.Release();\n          grant.sem = sem;\n          grant.fHaveGrant = fHaveGrant;\n          sem = NULL;\n          fHaveGrant = false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConnectNode",
          "args": [
            "addrConnect",
            "strDest"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FindNode",
          "args": [
            "strDest"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FindNode",
          "args": [
            "addrConnect.ToStringIPPort().c_str()"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrConnect.ToStringIPPort",
          "args": [],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIPPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1163-1170",
          "snippet": "std::string CService::ToStringIPPort() const\n{\n    if (IsIPv4() || IsTor() || IsI2P()) {\n        return ToStringIP() + \":\" + ToStringPort();\n    } else {\n        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToStringIPPort() const\n  {\n      if (IsIPv4() || IsTor() || IsI2P()) {\n          return ToStringIP() + \":\" + ToStringPort();\n      } else {\n          return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CNode::IsBanned",
          "args": [
            "addrConnect"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "IsBanned",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "590-604",
          "snippet": "bool CNode::IsBanned(CNetAddr ip)\n{\n    bool fResult = false;\n    {\n        LOCK(cs_setBanned);\n        std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n        if (i != setBanned.end())\n        {\n            int64_t t = (*i).second;\n            if (GetTime() < t)\n                fResult = true;\n        }\n    }\n    return fResult;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "std::map<CNetAddr, int64_t> CNode::setBanned;",
            "CCriticalSection CNode::cs_setBanned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstd::map<CNetAddr, int64_t> CNode::setBanned;\nCCriticalSection CNode::cs_setBanned;\n\nCNode {\n  bool CNode::IsBanned(CNetAddr ip)\n  {\n      bool fResult = false;\n      {\n          LOCK(cs_setBanned);\n          std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n          if (i != setBanned.end())\n          {\n              int64_t t = (*i).second;\n              if (GetTime() < t)\n                  fResult = true;\n          }\n      }\n      return fResult;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindNode",
          "args": [
            "(CNetAddr)addrConnect"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsLocal",
          "args": [
            "addrConnect"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "293-297",
          "snippet": "bool IsLocal(const CService& addr)\n{\n    LOCK(cs_mapLocalHost);\n    return mapLocalHost.count(addr) > 0;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CCriticalSection cs_mapLocalHost;",
            "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool IsLocal(const CService& addr)\n{\n    LOCK(cs_mapLocalHost);\n    return mapLocalHost.count(addr) > 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nbool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *strDest, bool fOneShot)\n{\n    //\n    // Initiate outbound network connection\n    //\n    if (fShutdown)\n        return false;\n    if (!strDest)\n        if (IsLocal(addrConnect) ||\n            FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect) ||\n            FindNode(addrConnect.ToStringIPPort().c_str()))\n            return false;\n    if (strDest && FindNode(strDest))\n        return false;\n\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n    CNode* pnode = ConnectNode(addrConnect, strDest);\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n    if (fShutdown)\n        return false;\n    if (!pnode)\n        return false;\n    if (grantOutbound)\n        grantOutbound->MoveTo(pnode->grantOutbound);\n    pnode->fNetworkNode = true;\n    if (fOneShot)\n        pnode->fOneShot = true;\n\n    return true;\n}"
  },
  {
    "function_name": "ThreadOpenAddedConnections2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1493-1578",
    "snippet": "void ThreadOpenAddedConnections2(void* parg)\n{\n    printf(\"ThreadOpenAddedConnections started\\n\");\n\n    {\n        LOCK(cs_vAddedNodes);\n        vAddedNodes = mapMultiArgs[\"-addnode\"];\n    }\n\n    if(HaveNameProxy()) {\n        while(!fShutdown) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                CAddress addr;\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(addr, &grant, strAddNode.c_str());\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n        }\n        return;\n    }\n\n    while(true) {\n        for(uint i = 0; true; i++) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n\n            list<vector<CService> > lservAddressesToAdd(0);\n\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                vector<CService> vservNode(0);\n                if(Lookup(strAddNode.c_str(), vservNode, GetDefaultPort(), fNameLookup, 0)) {\n                    lservAddressesToAdd.push_back(vservNode);\n                    {\n                        LOCK(cs_setservAddNodeAddresses);\n                        BOOST_FOREACH(CService& serv, vservNode)\n                        setservAddNodeAddresses.insert(serv);\n                    }\n                }\n            }\n\n            // Attempt to connect to each IP for each addnode entry until at least one is successful per addnode entry\n            // (keeping in mind that addnode entries can have many IPs if fNameLookup)\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                  for(list<vector<CService> >::iterator it = lservAddressesToAdd.begin();\n                    it != lservAddressesToAdd.end(); it++)\n                    BOOST_FOREACH(CService& addrNode, *(it))\n                      if(pnode->addr == addrNode) {\n                          it = lservAddressesToAdd.erase(it);\n                          it--;\n                          break;\n                      }\n            }\n\n            BOOST_FOREACH(vector<CService>& vserv, lservAddressesToAdd) {\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n\n            if(fShutdown) return;\n\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n\n            if(fShutdown) return;\n        }\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;",
      "vector<CNode*> vNodes;",
      "CCriticalSection cs_vNodes;",
      "set<CNetAddr> setservAddNodeAddresses;",
      "CCriticalSection cs_setservAddNodeAddresses;",
      "vector<std::string> vAddedNodes;",
      "CCriticalSection cs_vAddedNodes;",
      "static CSemaphore *semOutbound = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "120000"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenNetworkConnection",
          "args": [
            "CAddress(vserv[i % vserv.size()])",
            "&grant"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CAddress",
          "args": [
            "vserv[i % vserv.size()]"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vserv.size",
          "args": [],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lservAddressesToAdd.erase",
          "args": [
            "it"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BOOST_FOREACH",
          "args": [
            "CService& addrNode",
            "*(it)"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lservAddressesToAdd.end",
          "args": [],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lservAddressesToAdd.begin",
          "args": [],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setservAddNodeAddresses.insert",
          "args": [
            "serv"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_setservAddNodeAddresses"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lservAddressesToAdd.push_back",
          "args": [
            "vservNode"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "strAddNode.c_str()",
            "vservNode",
            "GetDefaultPort()",
            "fNameLookup",
            "0"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "141-157",
          "snippet": "bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n{\n    if (pszName[0] == 0)\n        return false;\n    int port = portDefault;\n    std::string hostname = \"\";\n    SplitHostPort(std::string(pszName), port, hostname);\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupIntern(hostname.c_str(), vIP, nMaxSolutions, fAllowLookup);\n    if (!fRet)\n        return false;\n    vAddr.resize(vIP.size());\n    for (unsigned int i = 0; i < vIP.size(); i++)\n        vAddr[i] = CService(vIP[i], port);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n{\n    if (pszName[0] == 0)\n        return false;\n    int port = portDefault;\n    std::string hostname = \"\";\n    SplitHostPort(std::string(pszName), port, hostname);\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupIntern(hostname.c_str(), vIP, nMaxSolutions, fAllowLookup);\n    if (!fRet)\n        return false;\n    vAddr.resize(vIP.size());\n    for (unsigned int i = 0; i < vIP.size(); i++)\n        vAddr[i] = CService(vIP[i], port);\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDefaultPort",
          "args": [],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "GetDefaultPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.h",
          "lines": "19-22",
          "snippet": "static inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}",
          "includes": [
            "#include \"uint256.h\"",
            "#include <string>",
            "#include \"netbase.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include <string>\n#include \"netbase.h\"\n#include \"serialize.h\"\n\nstatic inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strAddNode.c_str",
          "args": [],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lAddresses.push_back",
          "args": [
            "strAddNode"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vAddedNodes"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OpenNetworkConnection",
          "args": [
            "addr",
            "&grant",
            "strAddNode.c_str()"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strAddNode.c_str",
          "args": [],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lAddresses.push_back",
          "args": [
            "strAddNode"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vAddedNodes"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "HaveNameProxy",
          "args": [],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "HaveNameProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "470-473",
          "snippet": "bool HaveNameProxy() {\n    LOCK(cs_proxyInfos);\n    return nameproxyInfo.second != 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static proxyType nameproxyInfo;",
            "static CCriticalSection cs_proxyInfos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType nameproxyInfo;\nstatic CCriticalSection cs_proxyInfos;\n\nbool HaveNameProxy() {\n    LOCK(cs_proxyInfos);\n    return nameproxyInfo.second != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vAddedNodes"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadOpenAddedConnections started\\n\""
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\nset<CNetAddr> setservAddNodeAddresses;\nCCriticalSection cs_setservAddNodeAddresses;\nvector<std::string> vAddedNodes;\nCCriticalSection cs_vAddedNodes;\nstatic CSemaphore *semOutbound = NULL;\n\nvoid ThreadOpenAddedConnections2(void* parg)\n{\n    printf(\"ThreadOpenAddedConnections started\\n\");\n\n    {\n        LOCK(cs_vAddedNodes);\n        vAddedNodes = mapMultiArgs[\"-addnode\"];\n    }\n\n    if(HaveNameProxy()) {\n        while(!fShutdown) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                CAddress addr;\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(addr, &grant, strAddNode.c_str());\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n        }\n        return;\n    }\n\n    while(true) {\n        for(uint i = 0; true; i++) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n\n            list<vector<CService> > lservAddressesToAdd(0);\n\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                vector<CService> vservNode(0);\n                if(Lookup(strAddNode.c_str(), vservNode, GetDefaultPort(), fNameLookup, 0)) {\n                    lservAddressesToAdd.push_back(vservNode);\n                    {\n                        LOCK(cs_setservAddNodeAddresses);\n                        BOOST_FOREACH(CService& serv, vservNode)\n                        setservAddNodeAddresses.insert(serv);\n                    }\n                }\n            }\n\n            // Attempt to connect to each IP for each addnode entry until at least one is successful per addnode entry\n            // (keeping in mind that addnode entries can have many IPs if fNameLookup)\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                  for(list<vector<CService> >::iterator it = lservAddressesToAdd.begin();\n                    it != lservAddressesToAdd.end(); it++)\n                    BOOST_FOREACH(CService& addrNode, *(it))\n                      if(pnode->addr == addrNode) {\n                          it = lservAddressesToAdd.erase(it);\n                          it--;\n                          break;\n                      }\n            }\n\n            BOOST_FOREACH(vector<CService>& vserv, lservAddressesToAdd) {\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n\n            if(fShutdown) return;\n\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n\n            if(fShutdown) return;\n        }\n    }\n}"
  },
  {
    "function_name": "ThreadOpenAddedConnections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1472-1491",
    "snippet": "void ThreadOpenAddedConnections(void* parg)\n{\n    // Make this thread recognisable as the connection opening thread\n    RenameThread(\"hal-opencon\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n        ThreadOpenAddedConnections2(parg);\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n        PrintException(&e, \"ThreadOpenAddedConnections()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n        PrintException(NULL, \"ThreadOpenAddedConnections()\");\n    }\n    printf(\"ThreadOpenAddedConnections exited\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadOpenAddedConnections exited\\n\""
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "NULL",
            "\"ThreadOpenAddedConnections()\""
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadOpenAddedConnections2",
          "args": [
            "parg"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadOpenAddedConnections2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1493-1578",
          "snippet": "void ThreadOpenAddedConnections2(void* parg)\n{\n    printf(\"ThreadOpenAddedConnections started\\n\");\n\n    {\n        LOCK(cs_vAddedNodes);\n        vAddedNodes = mapMultiArgs[\"-addnode\"];\n    }\n\n    if(HaveNameProxy()) {\n        while(!fShutdown) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                CAddress addr;\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(addr, &grant, strAddNode.c_str());\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n        }\n        return;\n    }\n\n    while(true) {\n        for(uint i = 0; true; i++) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n\n            list<vector<CService> > lservAddressesToAdd(0);\n\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                vector<CService> vservNode(0);\n                if(Lookup(strAddNode.c_str(), vservNode, GetDefaultPort(), fNameLookup, 0)) {\n                    lservAddressesToAdd.push_back(vservNode);\n                    {\n                        LOCK(cs_setservAddNodeAddresses);\n                        BOOST_FOREACH(CService& serv, vservNode)\n                        setservAddNodeAddresses.insert(serv);\n                    }\n                }\n            }\n\n            // Attempt to connect to each IP for each addnode entry until at least one is successful per addnode entry\n            // (keeping in mind that addnode entries can have many IPs if fNameLookup)\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                  for(list<vector<CService> >::iterator it = lservAddressesToAdd.begin();\n                    it != lservAddressesToAdd.end(); it++)\n                    BOOST_FOREACH(CService& addrNode, *(it))\n                      if(pnode->addr == addrNode) {\n                          it = lservAddressesToAdd.erase(it);\n                          it--;\n                          break;\n                      }\n            }\n\n            BOOST_FOREACH(vector<CService>& vserv, lservAddressesToAdd) {\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n\n            if(fShutdown) return;\n\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n\n            if(fShutdown) return;\n        }\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ThreadMessageHandler2(void* parg);",
            "void ThreadSocketHandler2(void* parg);",
            "void ThreadOpenConnections2(void* parg);",
            "void ThreadOpenAddedConnections2(void* parg);",
            "void ThreadDNSAddressSeed2(void* parg);",
            "array<int, THREAD_MAX> vnThreadsRunning;",
            "vector<CNode*> vNodes;",
            "CCriticalSection cs_vNodes;",
            "set<CNetAddr> setservAddNodeAddresses;",
            "CCriticalSection cs_setservAddNodeAddresses;",
            "vector<std::string> vAddedNodes;",
            "CCriticalSection cs_vAddedNodes;",
            "static CSemaphore *semOutbound = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\nset<CNetAddr> setservAddNodeAddresses;\nCCriticalSection cs_setservAddNodeAddresses;\nvector<std::string> vAddedNodes;\nCCriticalSection cs_vAddedNodes;\nstatic CSemaphore *semOutbound = NULL;\n\nvoid ThreadOpenAddedConnections2(void* parg)\n{\n    printf(\"ThreadOpenAddedConnections started\\n\");\n\n    {\n        LOCK(cs_vAddedNodes);\n        vAddedNodes = mapMultiArgs[\"-addnode\"];\n    }\n\n    if(HaveNameProxy()) {\n        while(!fShutdown) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                CAddress addr;\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(addr, &grant, strAddNode.c_str());\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n        }\n        return;\n    }\n\n    while(true) {\n        for(uint i = 0; true; i++) {\n            list<string> lAddresses(0);\n            {\n                LOCK(cs_vAddedNodes);\n                BOOST_FOREACH(string& strAddNode, vAddedNodes)\n                  lAddresses.push_back(strAddNode);\n            }\n\n            list<vector<CService> > lservAddressesToAdd(0);\n\n            BOOST_FOREACH(string& strAddNode, lAddresses) {\n                vector<CService> vservNode(0);\n                if(Lookup(strAddNode.c_str(), vservNode, GetDefaultPort(), fNameLookup, 0)) {\n                    lservAddressesToAdd.push_back(vservNode);\n                    {\n                        LOCK(cs_setservAddNodeAddresses);\n                        BOOST_FOREACH(CService& serv, vservNode)\n                        setservAddNodeAddresses.insert(serv);\n                    }\n                }\n            }\n\n            // Attempt to connect to each IP for each addnode entry until at least one is successful per addnode entry\n            // (keeping in mind that addnode entries can have many IPs if fNameLookup)\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                  for(list<vector<CService> >::iterator it = lservAddressesToAdd.begin();\n                    it != lservAddressesToAdd.end(); it++)\n                    BOOST_FOREACH(CService& addrNode, *(it))\n                      if(pnode->addr == addrNode) {\n                          it = lservAddressesToAdd.erase(it);\n                          it--;\n                          break;\n                      }\n            }\n\n            BOOST_FOREACH(vector<CService>& vserv, lservAddressesToAdd) {\n                CSemaphoreGrant grant(*semOutbound);\n                OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);\n                MilliSleep(500);\n                if(fShutdown) return;\n            }\n\n            if(fShutdown) return;\n\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n            MilliSleep(120000);\n            vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n\n            if(fShutdown) return;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-opencon\""
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadOpenAddedConnections(void* parg)\n{\n    // Make this thread recognisable as the connection opening thread\n    RenameThread(\"hal-opencon\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]++;\n        ThreadOpenAddedConnections2(parg);\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n        PrintException(&e, \"ThreadOpenAddedConnections()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_ADDEDCONNECTIONS]--;\n        PrintException(NULL, \"ThreadOpenAddedConnections()\");\n    }\n    printf(\"ThreadOpenAddedConnections exited\\n\");\n}"
  },
  {
    "function_name": "ThreadOpenConnections2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1350-1470",
    "snippet": "void ThreadOpenConnections2(void* parg)\n{\n    printf(\"ThreadOpenConnections started\\n\");\n\n    // Connect to specific addresses\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0)\n    {\n        for (int64_t nLoop = 0;; nLoop++)\n        {\n            ProcessOneShot();\n            BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n            {\n                CAddress addr;\n                OpenNetworkConnection(addr, NULL, strAddr.c_str());\n                for (int i = 0; i < 10 && i < nLoop; i++)\n                {\n                    MilliSleep(500);\n                    if (fShutdown)\n                        return;\n                }\n            }\n            MilliSleep(500);\n        }\n    }\n\n    // Initiate network connections\n    int64_t nStart = GetTime();\n    while (true)\n    {\n        ProcessOneShot();\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        MilliSleep(500);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        CSemaphoreGrant grant(*semOutbound);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n        // Add seed nodes if IRC isn't working\n        if (addrman.size()==0 && (GetTime() - nStart > 60) && !fTestNet)\n        {\n            std::vector<CAddress> vAdd;\n            for (unsigned int i = 0; i < ARRAYLEN(pnSeed); i++)\n            {\n                // It'll only connect to one or two seed nodes because once it connects,\n                // it'll get a pile of addresses with newer timestamps.\n                // Seed nodes are given a random 'last seen time' of between one and two\n                // weeks ago.\n                const int64_t nOneWeek = 7*24*60*60;\n                struct in_addr ip;\n                memcpy(&ip, &pnSeed[i], sizeof(ip));\n                CAddress addr(CService(ip, GetDefaultPort()));\n                addr.nTime = GetTime()-GetRand(nOneWeek)-nOneWeek;\n                vAdd.push_back(addr);\n            }\n            addrman.Add(vAdd, CNetAddr(\"127.0.0.1\"));\n        }\n\n        //\n        // Choose an address to connect to based on most recently seen\n        //\n        CAddress addrConnect;\n\n        // Only connect out to one peer per network group (/16 for IPv4).\n        // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n        int nOutbound = 0;\n        set<vector<unsigned char> > setConnected;\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes) {\n                if (!pnode->fInbound) {\n                    setConnected.insert(pnode->addr.GetGroup());\n                    nOutbound++;\n                }\n            }\n        }\n\n        int64_t nANow = GetAdjustedTime();\n\n        int nTries = 0;\n        while (true)\n        {\n            // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n\n            // if we selected an invalid address, restart\n            if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n                break;\n\n            // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,\n            // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates\n            // already-connected network ranges, ...) before trying new addrman addresses.\n            nTries++;\n            if (nTries > 100)\n                break;\n\n            if (IsLimited(addr))\n                continue;\n\n            // only consider very recently tried nodes after 30 failed attempts\n            if (nANow - addr.nLastTry < 600 && nTries < 30)\n                continue;\n\n            // do not allow non-default ports, unless after 50 invalid addresses selected already\n            if (addr.GetPort() != GetDefaultPort() && nTries < 50)\n                continue;\n\n            addrConnect = addr;\n            break;\n        }\n\n        if (addrConnect.IsValid())\n            OpenNetworkConnection(addrConnect, &grant);\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;",
      "CAddrMan addrman;",
      "vector<CNode*> vNodes;",
      "CCriticalSection cs_vNodes;",
      "static CSemaphore *semOutbound = NULL;",
      "unsigned int pnSeed[] =\n{\n    0xdf4bd379, 0x7934d29b, 0x26bc02ad, 0x7ab743ad, 0x0ab3a7bc,\n    0x375ab5bc, 0xc90b1617, 0x5352fd17, 0x5efc6c18, 0xccdc7d18,\n    0x443d9118, 0x84031b18, 0x347c1e18, 0x86512418, 0xfcfe9031,\n    0xdb5eb936, 0xef8d2e3a, 0xcf51f23c, 0x18ab663e, 0x36e0df40,\n    0xde48b641, 0xad3e4e41, 0xd0f32b44, 0x09733b44, 0x6a51f545,\n    0xe593ef48, 0xc5f5ef48, 0x96f4f148, 0xd354d34a, 0x36206f4c,\n    0xceefe953, 0x50468c55, 0x89d38d55, 0x65e61a5a, 0x16b1b95d,\n    0x702b135e, 0x0f57245e, 0xdaab5f5f, 0xba15ef63,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "OpenNetworkConnection",
          "args": [
            "addrConnect",
            "&grant"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrConnect.IsValid",
          "args": [],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDefaultPort",
          "args": [],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "GetDefaultPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.h",
          "lines": "19-22",
          "snippet": "static inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}",
          "includes": [
            "#include \"uint256.h\"",
            "#include <string>",
            "#include \"netbase.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include <string>\n#include \"netbase.h\"\n#include \"serialize.h\"\n\nstatic inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.GetPort",
          "args": [],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "GetPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1097-1100",
          "snippet": "unsigned short CService::GetPort() const\n{\n    return port;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  unsigned short CService::GetPort() const\n  {\n      return port;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLimited",
          "args": [
            "addr"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "IsLimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "272-275",
          "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLocal",
          "args": [
            "addr"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "293-297",
          "snippet": "bool IsLocal(const CService& addr)\n{\n    LOCK(cs_mapLocalHost);\n    return mapLocalHost.count(addr) > 0;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CCriticalSection cs_mapLocalHost;",
            "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool IsLocal(const CService& addr)\n{\n    LOCK(cs_mapLocalHost);\n    return mapLocalHost.count(addr) > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setConnected.count",
          "args": [
            "addr.GetGroup()"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.GetGroup",
          "args": [],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "GetGroup",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "849-920",
          "snippet": "std::vector<unsigned char> CNetAddr::GetGroup() const\n{\n    std::vector<unsigned char> vchRet;\n    int nClass = NET_IPV6;\n    int nStartByte = 0;\n    int nBits = 16;\n\n    // all local addresses belong to the same group\n    if (IsLocal())\n    {\n        nClass = 255;\n        nBits = 0;\n    }\n\n    // all unroutable addresses belong to the same group\n    if (!IsRoutable())\n    {\n        nClass = NET_UNROUTABLE;\n        nBits = 0;\n    }\n    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 12;\n    }\n    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n    else if (IsRFC3964())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 2;\n    }\n    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n    else if (IsRFC4380())\n    {\n        vchRet.push_back(NET_IPV4);\n        vchRet.push_back(GetByte(3) ^ 0xFF);\n        vchRet.push_back(GetByte(2) ^ 0xFF);\n        return vchRet;\n    }\n    else if (IsTor())\n    {\n        nClass = NET_TOR;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    else if (IsI2P())\n    {\n        nClass = NET_I2P;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    // for he.net, use /36 groups\n    else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n        nBits = 36;\n    // for the rest of the IPv6 network, use /32 groups\n    else\n        nBits = 32;\n\n    vchRet.push_back(nClass);\n    while (nBits >= 8)\n    {\n        vchRet.push_back(GetByte(15 - nStartByte));\n        nStartByte++;\n        nBits -= 8;\n    }\n    if (nBits > 0)\n        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n\n    return vchRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::vector<unsigned char> CNetAddr::GetGroup() const\n  {\n      std::vector<unsigned char> vchRet;\n      int nClass = NET_IPV6;\n      int nStartByte = 0;\n      int nBits = 16;\n  \n      // all local addresses belong to the same group\n      if (IsLocal())\n      {\n          nClass = 255;\n          nBits = 0;\n      }\n  \n      // all unroutable addresses belong to the same group\n      if (!IsRoutable())\n      {\n          nClass = NET_UNROUTABLE;\n          nBits = 0;\n      }\n      // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n      // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n      else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 12;\n      }\n      // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n      else if (IsRFC3964())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 2;\n      }\n      // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n      else if (IsRFC4380())\n      {\n          vchRet.push_back(NET_IPV4);\n          vchRet.push_back(GetByte(3) ^ 0xFF);\n          vchRet.push_back(GetByte(2) ^ 0xFF);\n          return vchRet;\n      }\n      else if (IsTor())\n      {\n          nClass = NET_TOR;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      else if (IsI2P())\n      {\n          nClass = NET_I2P;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      // for he.net, use /36 groups\n      else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n          nBits = 36;\n      // for the rest of the IPv6 network, use /32 groups\n      else\n          nBits = 32;\n  \n      vchRet.push_back(nClass);\n      while (nBits >= 8)\n      {\n          vchRet.push_back(GetByte(15 - nStartByte));\n          nStartByte++;\n          nBits -= 8;\n      }\n      if (nBits > 0)\n          vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n  \n      return vchRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrman.Select",
          "args": [
            "10 + min(nOutbound,8)*10"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "Select",
          "container": "CCoinControl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/coincontrol.h",
          "lines": "32-35",
          "snippet": "void Select(COutPoint& output)\n    {\n        setSelected.insert(output);\n    }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "CCoinControl {\n  void Select(COutPoint& output)\n      {\n          setSelected.insert(output);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nOutbound",
            "8"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "TimingResistantEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "569-576",
          "snippet": "bool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setConnected.insert",
          "args": [
            "pnode->addr.GetGroup()"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrman.Add",
          "args": [
            "vAdd",
            "CNetAddr(\"127.0.0.1\")"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "427-440",
          "snippet": "bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nbool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "CNetAddr",
          "args": [
            "\"127.0.0.1\""
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "GetReachabilityFrom",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "949-1011",
          "snippet": "int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n{\n    enum Reachability {\n        REACH_UNREACHABLE,\n        REACH_DEFAULT,\n        REACH_TEREDO,\n        REACH_IPV6_WEAK,\n        REACH_IPV4,\n        REACH_IPV6_STRONG,\n        REACH_PRIVATE\n    };\n\n    if (!IsRoutable())\n        return REACH_UNREACHABLE;\n\n    int ourNet = GetExtNetwork(this);\n    int theirNet = GetExtNetwork(paddrPartner);\n    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n\n    switch(theirNet) {\n    case NET_IPV4:\n        switch(ourNet) {\n        default:       return REACH_DEFAULT;\n        case NET_IPV4: return REACH_IPV4;\n        }\n    case NET_IPV6:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_TEREDO: return REACH_TEREDO;\n        case NET_IPV4:   return REACH_IPV4;\n        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n        }\n    case NET_TOR:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n        case NET_TOR:    return REACH_PRIVATE;\n        }\n    case NET_I2P:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_I2P:    return REACH_PRIVATE;\n        }\n    case NET_TEREDO:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        }\n    case NET_UNKNOWN:\n    case NET_UNROUTABLE:\n    default:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n        case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n        }\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n  {\n      enum Reachability {\n          REACH_UNREACHABLE,\n          REACH_DEFAULT,\n          REACH_TEREDO,\n          REACH_IPV6_WEAK,\n          REACH_IPV4,\n          REACH_IPV6_STRONG,\n          REACH_PRIVATE\n      };\n  \n      if (!IsRoutable())\n          return REACH_UNREACHABLE;\n  \n      int ourNet = GetExtNetwork(this);\n      int theirNet = GetExtNetwork(paddrPartner);\n      bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n  \n      switch(theirNet) {\n      case NET_IPV4:\n          switch(ourNet) {\n          default:       return REACH_DEFAULT;\n          case NET_IPV4: return REACH_IPV4;\n          }\n      case NET_IPV6:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_TEREDO: return REACH_TEREDO;\n          case NET_IPV4:   return REACH_IPV4;\n          case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n          }\n      case NET_TOR:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n          case NET_TOR:    return REACH_PRIVATE;\n          }\n      case NET_I2P:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_I2P:    return REACH_PRIVATE;\n          }\n      case NET_TEREDO:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          }\n      case NET_UNKNOWN:\n      case NET_UNROUTABLE:\n      default:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n          case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vAdd.push_back",
          "args": [
            "addr"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRand",
          "args": [
            "nOneWeek"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&ip",
            "&pnSeed[i]",
            "sizeof(ip)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAYLEN",
          "args": [
            "pnSeed"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrman.size",
          "args": [],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "500"
          ],
          "line": 1382
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessOneShot",
          "args": [],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessOneShot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1312-1328",
          "snippet": "void static ProcessOneShot()\n{\n    string strDest;\n    {\n        LOCK(cs_vOneShots);\n        if (vOneShots.empty())\n            return;\n        strDest = vOneShots.front();\n        vOneShots.pop_front();\n    }\n    CAddress addr;\n    CSemaphoreGrant grant(*semOutbound, true);\n    if (grant) {\n        if (!OpenNetworkConnection(addr, &grant, strDest.c_str(), true))\n            AddOneShot(strDest);\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static deque<string> vOneShots;",
            "CCriticalSection cs_vOneShots;",
            "static CSemaphore *semOutbound = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic deque<string> vOneShots;\nCCriticalSection cs_vOneShots;\nstatic CSemaphore *semOutbound = NULL;\n\nvoid static ProcessOneShot()\n{\n    string strDest;\n    {\n        LOCK(cs_vOneShots);\n        if (vOneShots.empty())\n            return;\n        strDest = vOneShots.front();\n        vOneShots.pop_front();\n    }\n    CAddress addr;\n    CSemaphoreGrant grant(*semOutbound, true);\n    if (grant) {\n        if (!OpenNetworkConnection(addr, &grant, strDest.c_str(), true))\n            AddOneShot(strDest);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenNetworkConnection",
          "args": [
            "addr",
            "NULL",
            "strAddr.c_str()"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strAddr.c_str",
          "args": [],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadOpenConnections started\\n\""
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\nCAddrMan addrman;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\nstatic CSemaphore *semOutbound = NULL;\nunsigned int pnSeed[] =\n{\n    0xdf4bd379, 0x7934d29b, 0x26bc02ad, 0x7ab743ad, 0x0ab3a7bc,\n    0x375ab5bc, 0xc90b1617, 0x5352fd17, 0x5efc6c18, 0xccdc7d18,\n    0x443d9118, 0x84031b18, 0x347c1e18, 0x86512418, 0xfcfe9031,\n    0xdb5eb936, 0xef8d2e3a, 0xcf51f23c, 0x18ab663e, 0x36e0df40,\n    0xde48b641, 0xad3e4e41, 0xd0f32b44, 0x09733b44, 0x6a51f545,\n    0xe593ef48, 0xc5f5ef48, 0x96f4f148, 0xd354d34a, 0x36206f4c,\n    0xceefe953, 0x50468c55, 0x89d38d55, 0x65e61a5a, 0x16b1b95d,\n    0x702b135e, 0x0f57245e, 0xdaab5f5f, 0xba15ef63,\n};\n\nvoid ThreadOpenConnections2(void* parg)\n{\n    printf(\"ThreadOpenConnections started\\n\");\n\n    // Connect to specific addresses\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0)\n    {\n        for (int64_t nLoop = 0;; nLoop++)\n        {\n            ProcessOneShot();\n            BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n            {\n                CAddress addr;\n                OpenNetworkConnection(addr, NULL, strAddr.c_str());\n                for (int i = 0; i < 10 && i < nLoop; i++)\n                {\n                    MilliSleep(500);\n                    if (fShutdown)\n                        return;\n                }\n            }\n            MilliSleep(500);\n        }\n    }\n\n    // Initiate network connections\n    int64_t nStart = GetTime();\n    while (true)\n    {\n        ProcessOneShot();\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        MilliSleep(500);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        CSemaphoreGrant grant(*semOutbound);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n        // Add seed nodes if IRC isn't working\n        if (addrman.size()==0 && (GetTime() - nStart > 60) && !fTestNet)\n        {\n            std::vector<CAddress> vAdd;\n            for (unsigned int i = 0; i < ARRAYLEN(pnSeed); i++)\n            {\n                // It'll only connect to one or two seed nodes because once it connects,\n                // it'll get a pile of addresses with newer timestamps.\n                // Seed nodes are given a random 'last seen time' of between one and two\n                // weeks ago.\n                const int64_t nOneWeek = 7*24*60*60;\n                struct in_addr ip;\n                memcpy(&ip, &pnSeed[i], sizeof(ip));\n                CAddress addr(CService(ip, GetDefaultPort()));\n                addr.nTime = GetTime()-GetRand(nOneWeek)-nOneWeek;\n                vAdd.push_back(addr);\n            }\n            addrman.Add(vAdd, CNetAddr(\"127.0.0.1\"));\n        }\n\n        //\n        // Choose an address to connect to based on most recently seen\n        //\n        CAddress addrConnect;\n\n        // Only connect out to one peer per network group (/16 for IPv4).\n        // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n        int nOutbound = 0;\n        set<vector<unsigned char> > setConnected;\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes) {\n                if (!pnode->fInbound) {\n                    setConnected.insert(pnode->addr.GetGroup());\n                    nOutbound++;\n                }\n            }\n        }\n\n        int64_t nANow = GetAdjustedTime();\n\n        int nTries = 0;\n        while (true)\n        {\n            // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n\n            // if we selected an invalid address, restart\n            if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n                break;\n\n            // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,\n            // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates\n            // already-connected network ranges, ...) before trying new addrman addresses.\n            nTries++;\n            if (nTries > 100)\n                break;\n\n            if (IsLimited(addr))\n                continue;\n\n            // only consider very recently tried nodes after 30 failed attempts\n            if (nANow - addr.nLastTry < 600 && nTries < 30)\n                continue;\n\n            // do not allow non-default ports, unless after 50 invalid addresses selected already\n            if (addr.GetPort() != GetDefaultPort() && nTries < 50)\n                continue;\n\n            addrConnect = addr;\n            break;\n        }\n\n        if (addrConnect.IsValid())\n            OpenNetworkConnection(addrConnect, &grant);\n    }\n}"
  },
  {
    "function_name": "ThreadStakeMiner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1330-1348",
    "snippet": "void static ThreadStakeMiner(void* parg)\n{\n    printf(\"ThreadStakeMiner started\\n\");\n    CWallet* pwallet = (CWallet*)parg;\n    try\n    {\n        vnThreadsRunning[THREAD_STAKE_MINER]++;\n        StakeMiner(pwallet);\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n        PrintException(&e, \"ThreadStakeMiner()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n        PrintException(NULL, \"ThreadStakeMiner()\");\n    }\n    printf(\"ThreadStakeMiner exiting, %d threads remaining\\n\", vnThreadsRunning[THREAD_STAKE_MINER]);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadStakeMiner exiting, %d threads remaining\\n\"",
            "vnThreadsRunning[THREAD_STAKE_MINER]"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "NULL",
            "\"ThreadStakeMiner()\""
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "StakeMiner",
          "args": [
            "pwallet"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadStakeMiner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1330-1348",
          "snippet": "void static ThreadStakeMiner(void* parg)\n{\n    printf(\"ThreadStakeMiner started\\n\");\n    CWallet* pwallet = (CWallet*)parg;\n    try\n    {\n        vnThreadsRunning[THREAD_STAKE_MINER]++;\n        StakeMiner(pwallet);\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n        PrintException(&e, \"ThreadStakeMiner()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n        PrintException(NULL, \"ThreadStakeMiner()\");\n    }\n    printf(\"ThreadStakeMiner exiting, %d threads remaining\\n\", vnThreadsRunning[THREAD_STAKE_MINER]);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadStakeMiner started\\n\""
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid static ThreadStakeMiner(void* parg)\n{\n    printf(\"ThreadStakeMiner started\\n\");\n    CWallet* pwallet = (CWallet*)parg;\n    try\n    {\n        vnThreadsRunning[THREAD_STAKE_MINER]++;\n        StakeMiner(pwallet);\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n        PrintException(&e, \"ThreadStakeMiner()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_STAKE_MINER]--;\n        PrintException(NULL, \"ThreadStakeMiner()\");\n    }\n    printf(\"ThreadStakeMiner exiting, %d threads remaining\\n\", vnThreadsRunning[THREAD_STAKE_MINER]);\n}"
  },
  {
    "function_name": "ProcessOneShot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1312-1328",
    "snippet": "void static ProcessOneShot()\n{\n    string strDest;\n    {\n        LOCK(cs_vOneShots);\n        if (vOneShots.empty())\n            return;\n        strDest = vOneShots.front();\n        vOneShots.pop_front();\n    }\n    CAddress addr;\n    CSemaphoreGrant grant(*semOutbound, true);\n    if (grant) {\n        if (!OpenNetworkConnection(addr, &grant, strDest.c_str(), true))\n            AddOneShot(strDest);\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static deque<string> vOneShots;",
      "CCriticalSection cs_vOneShots;",
      "static CSemaphore *semOutbound = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddOneShot",
          "args": [
            "strDest"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "AddOneShot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "83-87",
          "snippet": "void AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static deque<string> vOneShots;",
            "CCriticalSection cs_vOneShots;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic deque<string> vOneShots;\nCCriticalSection cs_vOneShots;\n\nvoid AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OpenNetworkConnection",
          "args": [
            "addr",
            "&grant",
            "strDest.c_str()",
            "true"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "OpenNetworkConnection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1581-1610",
          "snippet": "bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *strDest, bool fOneShot)\n{\n    //\n    // Initiate outbound network connection\n    //\n    if (fShutdown)\n        return false;\n    if (!strDest)\n        if (IsLocal(addrConnect) ||\n            FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect) ||\n            FindNode(addrConnect.ToStringIPPort().c_str()))\n            return false;\n    if (strDest && FindNode(strDest))\n        return false;\n\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n    CNode* pnode = ConnectNode(addrConnect, strDest);\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n    if (fShutdown)\n        return false;\n    if (!pnode)\n        return false;\n    if (grantOutbound)\n        grantOutbound->MoveTo(pnode->grantOutbound);\n    pnode->fNetworkNode = true;\n    if (fOneShot)\n        pnode->fOneShot = true;\n\n    return true;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);",
            "array<int, THREAD_MAX> vnThreadsRunning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nbool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound, const char *strDest, bool fOneShot)\n{\n    //\n    // Initiate outbound network connection\n    //\n    if (fShutdown)\n        return false;\n    if (!strDest)\n        if (IsLocal(addrConnect) ||\n            FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect) ||\n            FindNode(addrConnect.ToStringIPPort().c_str()))\n            return false;\n    if (strDest && FindNode(strDest))\n        return false;\n\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n    CNode* pnode = ConnectNode(addrConnect, strDest);\n    vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n    if (fShutdown)\n        return false;\n    if (!pnode)\n        return false;\n    if (grantOutbound)\n        grantOutbound->MoveTo(pnode->grantOutbound);\n    pnode->fNetworkNode = true;\n    if (fOneShot)\n        pnode->fOneShot = true;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strDest.c_str",
          "args": [],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vOneShots.pop_front",
          "args": [],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vOneShots.front",
          "args": [],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vOneShots.empty",
          "args": [],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vOneShots"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic deque<string> vOneShots;\nCCriticalSection cs_vOneShots;\nstatic CSemaphore *semOutbound = NULL;\n\nvoid static ProcessOneShot()\n{\n    string strDest;\n    {\n        LOCK(cs_vOneShots);\n        if (vOneShots.empty())\n            return;\n        strDest = vOneShots.front();\n        vOneShots.pop_front();\n    }\n    CAddress addr;\n    CSemaphoreGrant grant(*semOutbound, true);\n    if (grant) {\n        if (!OpenNetworkConnection(addr, &grant, strDest.c_str(), true))\n            AddOneShot(strDest);\n    }\n}"
  },
  {
    "function_name": "ThreadOpenConnections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1291-1310",
    "snippet": "void ThreadOpenConnections(void* parg)\n{\n    // Make this thread recognisable as the connection opening thread\n    RenameThread(\"hal-opencon\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        ThreadOpenConnections2(parg);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        PrintException(&e, \"ThreadOpenConnections()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        PrintException(NULL, \"ThreadOpenConnections()\");\n    }\n    printf(\"ThreadOpenConnections exited\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadOpenConnections exited\\n\""
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "NULL",
            "\"ThreadOpenConnections()\""
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadOpenConnections2",
          "args": [
            "parg"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadOpenConnections2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1350-1470",
          "snippet": "void ThreadOpenConnections2(void* parg)\n{\n    printf(\"ThreadOpenConnections started\\n\");\n\n    // Connect to specific addresses\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0)\n    {\n        for (int64_t nLoop = 0;; nLoop++)\n        {\n            ProcessOneShot();\n            BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n            {\n                CAddress addr;\n                OpenNetworkConnection(addr, NULL, strAddr.c_str());\n                for (int i = 0; i < 10 && i < nLoop; i++)\n                {\n                    MilliSleep(500);\n                    if (fShutdown)\n                        return;\n                }\n            }\n            MilliSleep(500);\n        }\n    }\n\n    // Initiate network connections\n    int64_t nStart = GetTime();\n    while (true)\n    {\n        ProcessOneShot();\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        MilliSleep(500);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        CSemaphoreGrant grant(*semOutbound);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n        // Add seed nodes if IRC isn't working\n        if (addrman.size()==0 && (GetTime() - nStart > 60) && !fTestNet)\n        {\n            std::vector<CAddress> vAdd;\n            for (unsigned int i = 0; i < ARRAYLEN(pnSeed); i++)\n            {\n                // It'll only connect to one or two seed nodes because once it connects,\n                // it'll get a pile of addresses with newer timestamps.\n                // Seed nodes are given a random 'last seen time' of between one and two\n                // weeks ago.\n                const int64_t nOneWeek = 7*24*60*60;\n                struct in_addr ip;\n                memcpy(&ip, &pnSeed[i], sizeof(ip));\n                CAddress addr(CService(ip, GetDefaultPort()));\n                addr.nTime = GetTime()-GetRand(nOneWeek)-nOneWeek;\n                vAdd.push_back(addr);\n            }\n            addrman.Add(vAdd, CNetAddr(\"127.0.0.1\"));\n        }\n\n        //\n        // Choose an address to connect to based on most recently seen\n        //\n        CAddress addrConnect;\n\n        // Only connect out to one peer per network group (/16 for IPv4).\n        // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n        int nOutbound = 0;\n        set<vector<unsigned char> > setConnected;\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes) {\n                if (!pnode->fInbound) {\n                    setConnected.insert(pnode->addr.GetGroup());\n                    nOutbound++;\n                }\n            }\n        }\n\n        int64_t nANow = GetAdjustedTime();\n\n        int nTries = 0;\n        while (true)\n        {\n            // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n\n            // if we selected an invalid address, restart\n            if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n                break;\n\n            // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,\n            // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates\n            // already-connected network ranges, ...) before trying new addrman addresses.\n            nTries++;\n            if (nTries > 100)\n                break;\n\n            if (IsLimited(addr))\n                continue;\n\n            // only consider very recently tried nodes after 30 failed attempts\n            if (nANow - addr.nLastTry < 600 && nTries < 30)\n                continue;\n\n            // do not allow non-default ports, unless after 50 invalid addresses selected already\n            if (addr.GetPort() != GetDefaultPort() && nTries < 50)\n                continue;\n\n            addrConnect = addr;\n            break;\n        }\n\n        if (addrConnect.IsValid())\n            OpenNetworkConnection(addrConnect, &grant);\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ThreadMessageHandler2(void* parg);",
            "void ThreadSocketHandler2(void* parg);",
            "void ThreadOpenConnections2(void* parg);",
            "void ThreadOpenAddedConnections2(void* parg);",
            "void ThreadDNSAddressSeed2(void* parg);",
            "array<int, THREAD_MAX> vnThreadsRunning;",
            "CAddrMan addrman;",
            "vector<CNode*> vNodes;",
            "CCriticalSection cs_vNodes;",
            "static CSemaphore *semOutbound = NULL;",
            "unsigned int pnSeed[] =\n{\n    0xdf4bd379, 0x7934d29b, 0x26bc02ad, 0x7ab743ad, 0x0ab3a7bc,\n    0x375ab5bc, 0xc90b1617, 0x5352fd17, 0x5efc6c18, 0xccdc7d18,\n    0x443d9118, 0x84031b18, 0x347c1e18, 0x86512418, 0xfcfe9031,\n    0xdb5eb936, 0xef8d2e3a, 0xcf51f23c, 0x18ab663e, 0x36e0df40,\n    0xde48b641, 0xad3e4e41, 0xd0f32b44, 0x09733b44, 0x6a51f545,\n    0xe593ef48, 0xc5f5ef48, 0x96f4f148, 0xd354d34a, 0x36206f4c,\n    0xceefe953, 0x50468c55, 0x89d38d55, 0x65e61a5a, 0x16b1b95d,\n    0x702b135e, 0x0f57245e, 0xdaab5f5f, 0xba15ef63,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\nCAddrMan addrman;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\nstatic CSemaphore *semOutbound = NULL;\nunsigned int pnSeed[] =\n{\n    0xdf4bd379, 0x7934d29b, 0x26bc02ad, 0x7ab743ad, 0x0ab3a7bc,\n    0x375ab5bc, 0xc90b1617, 0x5352fd17, 0x5efc6c18, 0xccdc7d18,\n    0x443d9118, 0x84031b18, 0x347c1e18, 0x86512418, 0xfcfe9031,\n    0xdb5eb936, 0xef8d2e3a, 0xcf51f23c, 0x18ab663e, 0x36e0df40,\n    0xde48b641, 0xad3e4e41, 0xd0f32b44, 0x09733b44, 0x6a51f545,\n    0xe593ef48, 0xc5f5ef48, 0x96f4f148, 0xd354d34a, 0x36206f4c,\n    0xceefe953, 0x50468c55, 0x89d38d55, 0x65e61a5a, 0x16b1b95d,\n    0x702b135e, 0x0f57245e, 0xdaab5f5f, 0xba15ef63,\n};\n\nvoid ThreadOpenConnections2(void* parg)\n{\n    printf(\"ThreadOpenConnections started\\n\");\n\n    // Connect to specific addresses\n    if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0)\n    {\n        for (int64_t nLoop = 0;; nLoop++)\n        {\n            ProcessOneShot();\n            BOOST_FOREACH(string strAddr, mapMultiArgs[\"-connect\"])\n            {\n                CAddress addr;\n                OpenNetworkConnection(addr, NULL, strAddr.c_str());\n                for (int i = 0; i < 10 && i < nLoop; i++)\n                {\n                    MilliSleep(500);\n                    if (fShutdown)\n                        return;\n                }\n            }\n            MilliSleep(500);\n        }\n    }\n\n    // Initiate network connections\n    int64_t nStart = GetTime();\n    while (true)\n    {\n        ProcessOneShot();\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        MilliSleep(500);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        CSemaphoreGrant grant(*semOutbound);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        if (fShutdown)\n            return;\n\n        // Add seed nodes if IRC isn't working\n        if (addrman.size()==0 && (GetTime() - nStart > 60) && !fTestNet)\n        {\n            std::vector<CAddress> vAdd;\n            for (unsigned int i = 0; i < ARRAYLEN(pnSeed); i++)\n            {\n                // It'll only connect to one or two seed nodes because once it connects,\n                // it'll get a pile of addresses with newer timestamps.\n                // Seed nodes are given a random 'last seen time' of between one and two\n                // weeks ago.\n                const int64_t nOneWeek = 7*24*60*60;\n                struct in_addr ip;\n                memcpy(&ip, &pnSeed[i], sizeof(ip));\n                CAddress addr(CService(ip, GetDefaultPort()));\n                addr.nTime = GetTime()-GetRand(nOneWeek)-nOneWeek;\n                vAdd.push_back(addr);\n            }\n            addrman.Add(vAdd, CNetAddr(\"127.0.0.1\"));\n        }\n\n        //\n        // Choose an address to connect to based on most recently seen\n        //\n        CAddress addrConnect;\n\n        // Only connect out to one peer per network group (/16 for IPv4).\n        // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n        int nOutbound = 0;\n        set<vector<unsigned char> > setConnected;\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes) {\n                if (!pnode->fInbound) {\n                    setConnected.insert(pnode->addr.GetGroup());\n                    nOutbound++;\n                }\n            }\n        }\n\n        int64_t nANow = GetAdjustedTime();\n\n        int nTries = 0;\n        while (true)\n        {\n            // use an nUnkBias between 10 (no outgoing connections) and 90 (8 outgoing connections)\n            CAddress addr = addrman.Select(10 + min(nOutbound,8)*10);\n\n            // if we selected an invalid address, restart\n            if (!addr.IsValid() || setConnected.count(addr.GetGroup()) || IsLocal(addr))\n                break;\n\n            // If we didn't find an appropriate destination after trying 100 addresses fetched from addrman,\n            // stop this loop, and let the outer loop run again (which sleeps, adds seed nodes, recalculates\n            // already-connected network ranges, ...) before trying new addrman addresses.\n            nTries++;\n            if (nTries > 100)\n                break;\n\n            if (IsLimited(addr))\n                continue;\n\n            // only consider very recently tried nodes after 30 failed attempts\n            if (nANow - addr.nLastTry < 600 && nTries < 30)\n                continue;\n\n            // do not allow non-default ports, unless after 50 invalid addresses selected already\n            if (addr.GetPort() != GetDefaultPort() && nTries < 50)\n                continue;\n\n            addrConnect = addr;\n            break;\n        }\n\n        if (addrConnect.IsValid())\n            OpenNetworkConnection(addrConnect, &grant);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-opencon\""
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadOpenConnections(void* parg)\n{\n    // Make this thread recognisable as the connection opening thread\n    RenameThread(\"hal-opencon\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n        ThreadOpenConnections2(parg);\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        PrintException(&e, \"ThreadOpenConnections()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n        PrintException(NULL, \"ThreadOpenConnections()\");\n    }\n    printf(\"ThreadOpenConnections exited\\n\");\n}"
  },
  {
    "function_name": "ThreadDumpAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1276-1289",
    "snippet": "void ThreadDumpAddress(void* parg)\n{\n    // Make this thread recognisable as the address dumping thread\n    RenameThread(\"hal-adrdump\");\n\n    try\n    {\n        ThreadDumpAddress2(parg);\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"ThreadDumpAddress()\");\n    }\n    printf(\"ThreadDumpAddress exited\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadDumpAddress exited\\n\""
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "&e",
            "\"ThreadDumpAddress()\""
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadDumpAddress2",
          "args": [
            "parg"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadDumpAddress2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1263-1274",
          "snippet": "void ThreadDumpAddress2(void* parg)\n{\n    vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    while (!fShutdown)\n    {\n        DumpAddresses();\n        vnThreadsRunning[THREAD_DUMPADDRESS]--;\n        MilliSleep(600000);\n        vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    }\n    vnThreadsRunning[THREAD_DUMPADDRESS]--;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ThreadMessageHandler2(void* parg);",
            "void ThreadSocketHandler2(void* parg);",
            "void ThreadOpenConnections2(void* parg);",
            "void ThreadOpenAddedConnections2(void* parg);",
            "void ThreadDNSAddressSeed2(void* parg);",
            "array<int, THREAD_MAX> vnThreadsRunning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadDumpAddress2(void* parg)\n{\n    vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    while (!fShutdown)\n    {\n        DumpAddresses();\n        vnThreadsRunning[THREAD_DUMPADDRESS]--;\n        MilliSleep(600000);\n        vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    }\n    vnThreadsRunning[THREAD_DUMPADDRESS]--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-adrdump\""
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\n\nvoid ThreadDumpAddress(void* parg)\n{\n    // Make this thread recognisable as the address dumping thread\n    RenameThread(\"hal-adrdump\");\n\n    try\n    {\n        ThreadDumpAddress2(parg);\n    }\n    catch (std::exception& e) {\n        PrintException(&e, \"ThreadDumpAddress()\");\n    }\n    printf(\"ThreadDumpAddress exited\\n\");\n}"
  },
  {
    "function_name": "ThreadDumpAddress2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1263-1274",
    "snippet": "void ThreadDumpAddress2(void* parg)\n{\n    vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    while (!fShutdown)\n    {\n        DumpAddresses();\n        vnThreadsRunning[THREAD_DUMPADDRESS]--;\n        MilliSleep(600000);\n        vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    }\n    vnThreadsRunning[THREAD_DUMPADDRESS]--;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "600000"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "DumpAddresses",
          "args": [],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "DumpAddresses",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1252-1261",
          "snippet": "void DumpAddresses()\n{\n    int64_t nStart = GetTimeMillis();\n\n    CAddrDB adb;\n    adb.Write(addrman);\n\n    printf(\"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CAddrMan addrman;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCAddrMan addrman;\n\nvoid DumpAddresses()\n{\n    int64_t nStart = GetTimeMillis();\n\n    CAddrDB adb;\n    adb.Write(addrman);\n\n    printf(\"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadDumpAddress2(void* parg)\n{\n    vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    while (!fShutdown)\n    {\n        DumpAddresses();\n        vnThreadsRunning[THREAD_DUMPADDRESS]--;\n        MilliSleep(600000);\n        vnThreadsRunning[THREAD_DUMPADDRESS]++;\n    }\n    vnThreadsRunning[THREAD_DUMPADDRESS]--;\n}"
  },
  {
    "function_name": "DumpAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1252-1261",
    "snippet": "void DumpAddresses()\n{\n    int64_t nStart = GetTimeMillis();\n\n    CAddrDB adb;\n    adb.Write(addrman);\n\n    printf(\"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CAddrMan addrman;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\"",
            "addrman.size()",
            "GetTimeMillis() - nStart"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTimeMillis",
          "args": [],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrman.size",
          "args": [],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "adb.Write",
          "args": [
            "addrman"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CAddrDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.cpp",
          "lines": "502-538",
          "snippet": "bool CAddrDB::Write(const CAddrMan& addr)\n{\n    // Generate random temporary filename\n    unsigned short randv = 0;\n    RAND_bytes((unsigned char *)&randv, sizeof(randv));\n    std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n\n    // serialize addresses, checksum data up to that point, then append csum\n    CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n    ssPeers << FLATDATA(pchMessageStart);\n    ssPeers << addr;\n    uint256 hash = Hash(ssPeers.begin(), ssPeers.end());\n    ssPeers << hash;\n\n    // open temp output file, and associate with CAutoFile\n    boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n    FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n    CAutoFile fileout = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n    if (!fileout)\n        return error(\"CAddrman::Write() : open failed\");\n\n    // Write and commit header, data\n    try {\n        fileout << ssPeers;\n    }\n    catch (std::exception &e) {\n        return error(\"CAddrman::Write() : I/O error\");\n    }\n    FileCommit(fileout);\n    fileout.fclose();\n\n    // replace existing peers.dat, if any, with new peers.dat.XXXX\n    if (!RenameOver(pathTmp, pathAddr))\n        return error(\"CAddrman::Write() : Rename-into-place failed\");\n\n    return true;\n}",
          "includes": [
            "#include \"sys/stat.h\"",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys/stat.h\"\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"ui_interface.h\"\n#include \"main.h\"\n#include \"util.h\"\n#include \"net.h\"\n#include \"db.h\"\n\nCAddrDB {\n  bool CAddrDB::Write(const CAddrMan& addr)\n  {\n      // Generate random temporary filename\n      unsigned short randv = 0;\n      RAND_bytes((unsigned char *)&randv, sizeof(randv));\n      std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n  \n      // serialize addresses, checksum data up to that point, then append csum\n      CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n      ssPeers << FLATDATA(pchMessageStart);\n      ssPeers << addr;\n      uint256 hash = Hash(ssPeers.begin(), ssPeers.end());\n      ssPeers << hash;\n  \n      // open temp output file, and associate with CAutoFile\n      boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n      FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n      CAutoFile fileout = CAutoFile(file, SER_DISK, CLIENT_VERSION);\n      if (!fileout)\n          return error(\"CAddrman::Write() : open failed\");\n  \n      // Write and commit header, data\n      try {\n          fileout << ssPeers;\n      }\n      catch (std::exception &e) {\n          return error(\"CAddrman::Write() : I/O error\");\n      }\n      FileCommit(fileout);\n      fileout.fclose();\n  \n      // replace existing peers.dat, if any, with new peers.dat.XXXX\n      if (!RenameOver(pathTmp, pathAddr))\n          return error(\"CAddrman::Write() : Rename-into-place failed\");\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCAddrMan addrman;\n\nvoid DumpAddresses()\n{\n    int64_t nStart = GetTimeMillis();\n\n    CAddrDB adb;\n    adb.Write(addrman);\n\n    printf(\"Flushed %d addresses to peers.dat  %\"PRId64\"ms\\n\",\n           addrman.size(), GetTimeMillis() - nStart);\n}"
  },
  {
    "function_name": "ThreadDNSAddressSeed2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1195-1227",
    "snippet": "void ThreadDNSAddressSeed2(void* parg)\n{\n    printf(\"ThreadDNSAddressSeed started\\n\");\n    int found = 0;\n\n    if (!fTestNet)\n    {\n        printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n\n        for (unsigned int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n            if (HaveNameProxy()) {\n                AddOneShot(strDNSSeed[seed_idx][1]);\n            } else {\n                vector<CNetAddr> vaddr;\n                vector<CAddress> vAdd;\n                if (LookupHost(strDNSSeed[seed_idx][1], vaddr))\n                {\n                    BOOST_FOREACH(CNetAddr& ip, vaddr)\n                    {\n                        int nOneDay = 24*3600;\n                        CAddress addr = CAddress(CService(ip, GetDefaultPort()));\n                        addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                        vAdd.push_back(addr);\n                        found++;\n                    }\n                }\n                addrman.Add(vAdd, CNetAddr(strDNSSeed[seed_idx][0], true));\n            }\n        }\n    }\n\n    printf(\"%d addresses found from DNS seeds\\n\", found);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "CAddrMan addrman;",
      "static const char *strDNSSeed[][2] = {\n    {\"halseed0\", \"seed0.phoenixcoin.org\"},\n    {\"halseed1\", \"seed1.phoenixcoin.org\"}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d addresses found from DNS seeds\\n\"",
            "found"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrman.Add",
          "args": [
            "vAdd",
            "CNetAddr(strDNSSeed[seed_idx][0], true)"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "427-440",
          "snippet": "bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nbool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "CNetAddr",
          "args": [
            "strDNSSeed[seed_idx][0]",
            "true"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "CNetAddr",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "616-622",
          "snippet": "CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n{\n    Init();\n    std::vector<CNetAddr> vIP;\n    if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n        *this = vIP[0];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n  {\n      Init();\n      std::vector<CNetAddr> vIP;\n      if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n          *this = vIP[0];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vAdd.push_back",
          "args": [
            "addr"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRand",
          "args": [
            "4*nOneDay"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "CAddress",
          "args": [
            "CService(ip, GetDefaultPort())"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "ip",
            "GetDefaultPort()"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDefaultPort",
          "args": [],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "GetDefaultPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.h",
          "lines": "19-22",
          "snippet": "static inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}",
          "includes": [
            "#include \"uint256.h\"",
            "#include <string>",
            "#include \"netbase.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include <string>\n#include \"netbase.h\"\n#include \"serialize.h\"\n\nstatic inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LookupHost",
          "args": [
            "strDNSSeed[seed_idx][1]",
            "vaddr"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddOneShot",
          "args": [
            "strDNSSeed[seed_idx][1]"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "AddOneShot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "83-87",
          "snippet": "void AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static deque<string> vOneShots;",
            "CCriticalSection cs_vOneShots;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic deque<string> vOneShots;\nCCriticalSection cs_vOneShots;\n\nvoid AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "HaveNameProxy",
          "args": [],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "HaveNameProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "470-473",
          "snippet": "bool HaveNameProxy() {\n    LOCK(cs_proxyInfos);\n    return nameproxyInfo.second != 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static proxyType nameproxyInfo;",
            "static CCriticalSection cs_proxyInfos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType nameproxyInfo;\nstatic CCriticalSection cs_proxyInfos;\n\nbool HaveNameProxy() {\n    LOCK(cs_proxyInfos);\n    return nameproxyInfo.second != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAYLEN",
          "args": [
            "strDNSSeed"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Loading addresses from DNS seeds (could take a while)\\n\""
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadDNSAddressSeed started\\n\""
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\nCAddrMan addrman;\nstatic const char *strDNSSeed[][2] = {\n    {\"halseed0\", \"seed0.phoenixcoin.org\"},\n    {\"halseed1\", \"seed1.phoenixcoin.org\"}\n};\n\nvoid ThreadDNSAddressSeed2(void* parg)\n{\n    printf(\"ThreadDNSAddressSeed started\\n\");\n    int found = 0;\n\n    if (!fTestNet)\n    {\n        printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n\n        for (unsigned int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n            if (HaveNameProxy()) {\n                AddOneShot(strDNSSeed[seed_idx][1]);\n            } else {\n                vector<CNetAddr> vaddr;\n                vector<CAddress> vAdd;\n                if (LookupHost(strDNSSeed[seed_idx][1], vaddr))\n                {\n                    BOOST_FOREACH(CNetAddr& ip, vaddr)\n                    {\n                        int nOneDay = 24*3600;\n                        CAddress addr = CAddress(CService(ip, GetDefaultPort()));\n                        addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                        vAdd.push_back(addr);\n                        found++;\n                    }\n                }\n                addrman.Add(vAdd, CNetAddr(strDNSSeed[seed_idx][0], true));\n            }\n        }\n    }\n\n    printf(\"%d addresses found from DNS seeds\\n\", found);\n}"
  },
  {
    "function_name": "ThreadDNSAddressSeed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1174-1193",
    "snippet": "void ThreadDNSAddressSeed(void* parg)\n{\n    // Make this thread recognisable as the DNS seeding thread\n    RenameThread(\"hal-dnsseed\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_DNSSEED]++;\n        ThreadDNSAddressSeed2(parg);\n        vnThreadsRunning[THREAD_DNSSEED]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_DNSSEED]--;\n        PrintException(&e, \"ThreadDNSAddressSeed()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_DNSSEED]--;\n        throw; // support pthread_cancel()\n    }\n    printf(\"ThreadDNSAddressSeed exited\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadDNSAddressSeed exited\\n\""
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "&e",
            "\"ThreadDNSAddressSeed()\""
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadDNSAddressSeed2",
          "args": [
            "parg"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadDNSAddressSeed2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1195-1227",
          "snippet": "void ThreadDNSAddressSeed2(void* parg)\n{\n    printf(\"ThreadDNSAddressSeed started\\n\");\n    int found = 0;\n\n    if (!fTestNet)\n    {\n        printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n\n        for (unsigned int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n            if (HaveNameProxy()) {\n                AddOneShot(strDNSSeed[seed_idx][1]);\n            } else {\n                vector<CNetAddr> vaddr;\n                vector<CAddress> vAdd;\n                if (LookupHost(strDNSSeed[seed_idx][1], vaddr))\n                {\n                    BOOST_FOREACH(CNetAddr& ip, vaddr)\n                    {\n                        int nOneDay = 24*3600;\n                        CAddress addr = CAddress(CService(ip, GetDefaultPort()));\n                        addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                        vAdd.push_back(addr);\n                        found++;\n                    }\n                }\n                addrman.Add(vAdd, CNetAddr(strDNSSeed[seed_idx][0], true));\n            }\n        }\n    }\n\n    printf(\"%d addresses found from DNS seeds\\n\", found);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ThreadMessageHandler2(void* parg);",
            "void ThreadSocketHandler2(void* parg);",
            "void ThreadOpenConnections2(void* parg);",
            "void ThreadOpenAddedConnections2(void* parg);",
            "void ThreadDNSAddressSeed2(void* parg);",
            "CAddrMan addrman;",
            "static const char *strDNSSeed[][2] = {\n    {\"halseed0\", \"seed0.phoenixcoin.org\"},\n    {\"halseed1\", \"seed1.phoenixcoin.org\"}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\nCAddrMan addrman;\nstatic const char *strDNSSeed[][2] = {\n    {\"halseed0\", \"seed0.phoenixcoin.org\"},\n    {\"halseed1\", \"seed1.phoenixcoin.org\"}\n};\n\nvoid ThreadDNSAddressSeed2(void* parg)\n{\n    printf(\"ThreadDNSAddressSeed started\\n\");\n    int found = 0;\n\n    if (!fTestNet)\n    {\n        printf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n\n        for (unsigned int seed_idx = 0; seed_idx < ARRAYLEN(strDNSSeed); seed_idx++) {\n            if (HaveNameProxy()) {\n                AddOneShot(strDNSSeed[seed_idx][1]);\n            } else {\n                vector<CNetAddr> vaddr;\n                vector<CAddress> vAdd;\n                if (LookupHost(strDNSSeed[seed_idx][1], vaddr))\n                {\n                    BOOST_FOREACH(CNetAddr& ip, vaddr)\n                    {\n                        int nOneDay = 24*3600;\n                        CAddress addr = CAddress(CService(ip, GetDefaultPort()));\n                        addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                        vAdd.push_back(addr);\n                        found++;\n                    }\n                }\n                addrman.Add(vAdd, CNetAddr(strDNSSeed[seed_idx][0], true));\n            }\n        }\n    }\n\n    printf(\"%d addresses found from DNS seeds\\n\", found);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-dnsseed\""
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadDNSAddressSeed(void* parg)\n{\n    // Make this thread recognisable as the DNS seeding thread\n    RenameThread(\"hal-dnsseed\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_DNSSEED]++;\n        ThreadDNSAddressSeed2(parg);\n        vnThreadsRunning[THREAD_DNSSEED]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_DNSSEED]--;\n        PrintException(&e, \"ThreadDNSAddressSeed()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_DNSSEED]--;\n        throw; // support pthread_cancel()\n    }\n    printf(\"ThreadDNSAddressSeed exited\\n\");\n}"
  },
  {
    "function_name": "MapPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1151-1154",
    "snippet": "void MapPort()\n{\n    // Intentionally left blank.\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid MapPort()\n{\n    // Intentionally left blank.\n}"
  },
  {
    "function_name": "MapPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1142-1149",
    "snippet": "void MapPort()\n{\n    if (fUseUPnP && vnThreadsRunning[THREAD_UPNP] < 1)\n    {\n        if (!NewThread(ThreadMapPort, NULL))\n            printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool fUseUPnP = false;",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error: ThreadMapPort(ThreadMapPort) failed\\n\""
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewThread",
          "args": [
            "ThreadMapPort",
            "NULL"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "NewThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1350-1360",
          "snippet": "bool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool NewThread(void(*pfn)(void*), void* parg)\n{\n    try\n    {\n        boost::thread(pfn, parg); // thread detaches when out of scope\n    } catch(boost::thread_resource_error &e) {\n        printf(\"Error creating thread: %s\\n\", e.what());\n        return false;\n    }\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool fUseUPnP = false;\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid MapPort()\n{\n    if (fUseUPnP && vnThreadsRunning[THREAD_UPNP] < 1)\n    {\n        if (!NewThread(ThreadMapPort, NULL))\n            printf(\"Error: ThreadMapPort(ThreadMapPort) failed\\n\");\n    }\n}"
  },
  {
    "function_name": "ThreadMapPort2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1032-1140",
    "snippet": "void ThreadMapPort2(void* parg)\n{\n    printf(\"ThreadMapPort started\\n\");\n\n    std::string port = strprintf(\"%u\", GetListenPort());\n    const char * multicastif = 0;\n    const char * minissdpdpath = 0;\n    struct UPNPDev * devlist = 0;\n    char lanaddr[64];\n\n#ifndef UPNPDISCOVER_SUCCESS\n    /* miniUPnPc v1.5 */\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0);\n#elif (MINIUPNPC_API_VERSION < 14)\n    /* miniUPnPc v1.6 to v1.9 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n#else\n    /* miniUPnPc v1.9.20150730 and newer;\n     * CVE-2015-6031 may affect releases prior to v1.9.20150917 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n#endif\n\n    struct UPNPUrls urls;\n    struct IGDdatas data;\n    int r;\n\n    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n    if (r == 1)\n    {\n        if (fDiscover) {\n            char externalIPAddress[40];\n            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n            if(r != UPNPCOMMAND_SUCCESS)\n                printf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n            else\n            {\n                if(externalIPAddress[0])\n                {\n                    printf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n                    AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n                }\n                else\n                    printf(\"UPnP: GetExternalIPAddress failed.\\n\");\n            }\n        }\n\n        string strDesc = \"Halcyon \" + FormatFullVersion();\n#ifndef UPNPDISCOVER_SUCCESS\n        /* miniupnpc 1.5 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n        /* miniupnpc 1.6 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n        if(r!=UPNPCOMMAND_SUCCESS)\n            printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n        else\n            printf(\"UPnP Port Mapping successful.\\n\");\n        int i = 1;\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n            {\n                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n                printf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n                freeUPNPDevlist(devlist); devlist = 0;\n                FreeUPNPUrls(&urls);\n                return;\n            }\n            if (i % 600 == 0) // Refresh every 20 minutes\n            {\n#ifndef UPNPDISCOVER_SUCCESS\n                /* miniupnpc 1.5 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n                /* miniupnpc 1.6 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n                if(r!=UPNPCOMMAND_SUCCESS)\n                    printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                        port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n                else\n                    printf(\"UPnP Port Mapping successful.\\n\");;\n            }\n            MilliSleep(2000);\n            i++;\n        }\n    } else {\n        printf(\"No valid UPnP IGDs found\\n\");\n        freeUPNPDevlist(devlist); devlist = 0;\n        if (r != 0)\n            FreeUPNPUrls(&urls);\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n                return;\n            MilliSleep(2000);\n        }\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "bool fDiscover = true;",
      "bool fUseUPnP = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "2000"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "FreeUPNPUrls",
          "args": [
            "&urls"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeUPNPDevlist",
          "args": [
            "devlist"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"No valid UPnP IGDs found\\n\""
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"UPnP Port Mapping successful.\\n\""
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\"",
            "port.c_str()",
            "port.c_str()",
            "lanaddr",
            "r",
            "strupnperror(r)"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strupnperror",
          "args": [
            "r"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPNP_AddPortMapping",
          "args": [
            "urls.controlURL",
            "data.first.servicetype",
            "port.c_str()",
            "port.c_str()",
            "lanaddr",
            "strDesc.c_str()",
            "\"TCP\"",
            "0",
            "\"0\""
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDesc.c_str",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPNP_AddPortMapping",
          "args": [
            "urls.controlURL",
            "data.first.servicetype",
            "port.c_str()",
            "port.c_str()",
            "lanaddr",
            "strDesc.c_str()",
            "\"TCP\"",
            "0"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDesc.c_str",
          "args": [],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FreeUPNPUrls",
          "args": [
            "&urls"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freeUPNPDevlist",
          "args": [
            "devlist"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"UPNP_DeletePortMapping() returned : %d\\n\"",
            "r"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UPNP_DeletePortMapping",
          "args": [
            "urls.controlURL",
            "data.first.servicetype",
            "port.c_str()",
            "\"TCP\"",
            "0"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"UPnP Port Mapping successful.\\n\""
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\"",
            "port.c_str()",
            "port.c_str()",
            "lanaddr",
            "r",
            "strupnperror(r)"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strupnperror",
          "args": [
            "r"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPNP_AddPortMapping",
          "args": [
            "urls.controlURL",
            "data.first.servicetype",
            "port.c_str()",
            "port.c_str()",
            "lanaddr",
            "strDesc.c_str()",
            "\"TCP\"",
            "0",
            "\"0\""
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDesc.c_str",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPNP_AddPortMapping",
          "args": [
            "urls.controlURL",
            "data.first.servicetype",
            "port.c_str()",
            "port.c_str()",
            "lanaddr",
            "strDesc.c_str()",
            "\"TCP\"",
            "0"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDesc.c_str",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "port.c_str",
          "args": [],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatFullVersion",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "FormatFullVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1288-1291",
          "snippet": "string FormatFullVersion()\n{\n    return CLIENT_BUILD;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring FormatFullVersion()\n{\n    return CLIENT_BUILD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"UPnP: GetExternalIPAddress failed.\\n\""
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AddLocal",
          "args": [
            "CNetAddr(externalIPAddress)",
            "LOCAL_UPNP"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "AddLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "252-255",
          "snippet": "bool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CNetAddr",
          "args": [
            "externalIPAddress"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "GetReachabilityFrom",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "949-1011",
          "snippet": "int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n{\n    enum Reachability {\n        REACH_UNREACHABLE,\n        REACH_DEFAULT,\n        REACH_TEREDO,\n        REACH_IPV6_WEAK,\n        REACH_IPV4,\n        REACH_IPV6_STRONG,\n        REACH_PRIVATE\n    };\n\n    if (!IsRoutable())\n        return REACH_UNREACHABLE;\n\n    int ourNet = GetExtNetwork(this);\n    int theirNet = GetExtNetwork(paddrPartner);\n    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n\n    switch(theirNet) {\n    case NET_IPV4:\n        switch(ourNet) {\n        default:       return REACH_DEFAULT;\n        case NET_IPV4: return REACH_IPV4;\n        }\n    case NET_IPV6:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_TEREDO: return REACH_TEREDO;\n        case NET_IPV4:   return REACH_IPV4;\n        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n        }\n    case NET_TOR:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n        case NET_TOR:    return REACH_PRIVATE;\n        }\n    case NET_I2P:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_I2P:    return REACH_PRIVATE;\n        }\n    case NET_TEREDO:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        }\n    case NET_UNKNOWN:\n    case NET_UNROUTABLE:\n    default:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n        case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n        }\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n  {\n      enum Reachability {\n          REACH_UNREACHABLE,\n          REACH_DEFAULT,\n          REACH_TEREDO,\n          REACH_IPV6_WEAK,\n          REACH_IPV4,\n          REACH_IPV6_STRONG,\n          REACH_PRIVATE\n      };\n  \n      if (!IsRoutable())\n          return REACH_UNREACHABLE;\n  \n      int ourNet = GetExtNetwork(this);\n      int theirNet = GetExtNetwork(paddrPartner);\n      bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n  \n      switch(theirNet) {\n      case NET_IPV4:\n          switch(ourNet) {\n          default:       return REACH_DEFAULT;\n          case NET_IPV4: return REACH_IPV4;\n          }\n      case NET_IPV6:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_TEREDO: return REACH_TEREDO;\n          case NET_IPV4:   return REACH_IPV4;\n          case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n          }\n      case NET_TOR:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n          case NET_TOR:    return REACH_PRIVATE;\n          }\n      case NET_I2P:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_I2P:    return REACH_PRIVATE;\n          }\n      case NET_TEREDO:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          }\n      case NET_UNKNOWN:\n      case NET_UNROUTABLE:\n      default:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n          case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UPNP_GetExternalIPAddress",
          "args": [
            "urls.controlURL",
            "data.first.servicetype",
            "externalIPAddress"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UPNP_GetValidIGD",
          "args": [
            "devlist",
            "&urls",
            "&data",
            "lanaddr",
            "sizeof(lanaddr)"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upnpDiscover",
          "args": [
            "2000",
            "multicastif",
            "minissdpdpath",
            "0",
            "0",
            "2",
            "&error"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upnpDiscover",
          "args": [
            "2000",
            "multicastif",
            "minissdpdpath",
            "0",
            "0",
            "&error"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upnpDiscover",
          "args": [
            "2000",
            "multicastif",
            "minissdpdpath",
            "0"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetListenPort",
          "args": [],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "GetListenPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "89-92",
          "snippet": "unsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nunsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadMapPort started\\n\""
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\nbool fDiscover = true;\nbool fUseUPnP = false;\n\nvoid ThreadMapPort2(void* parg)\n{\n    printf(\"ThreadMapPort started\\n\");\n\n    std::string port = strprintf(\"%u\", GetListenPort());\n    const char * multicastif = 0;\n    const char * minissdpdpath = 0;\n    struct UPNPDev * devlist = 0;\n    char lanaddr[64];\n\n#ifndef UPNPDISCOVER_SUCCESS\n    /* miniUPnPc v1.5 */\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0);\n#elif (MINIUPNPC_API_VERSION < 14)\n    /* miniUPnPc v1.6 to v1.9 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n#else\n    /* miniUPnPc v1.9.20150730 and newer;\n     * CVE-2015-6031 may affect releases prior to v1.9.20150917 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n#endif\n\n    struct UPNPUrls urls;\n    struct IGDdatas data;\n    int r;\n\n    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n    if (r == 1)\n    {\n        if (fDiscover) {\n            char externalIPAddress[40];\n            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n            if(r != UPNPCOMMAND_SUCCESS)\n                printf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n            else\n            {\n                if(externalIPAddress[0])\n                {\n                    printf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n                    AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n                }\n                else\n                    printf(\"UPnP: GetExternalIPAddress failed.\\n\");\n            }\n        }\n\n        string strDesc = \"Halcyon \" + FormatFullVersion();\n#ifndef UPNPDISCOVER_SUCCESS\n        /* miniupnpc 1.5 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n        /* miniupnpc 1.6 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n        if(r!=UPNPCOMMAND_SUCCESS)\n            printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n        else\n            printf(\"UPnP Port Mapping successful.\\n\");\n        int i = 1;\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n            {\n                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n                printf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n                freeUPNPDevlist(devlist); devlist = 0;\n                FreeUPNPUrls(&urls);\n                return;\n            }\n            if (i % 600 == 0) // Refresh every 20 minutes\n            {\n#ifndef UPNPDISCOVER_SUCCESS\n                /* miniupnpc 1.5 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n                /* miniupnpc 1.6 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n                if(r!=UPNPCOMMAND_SUCCESS)\n                    printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                        port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n                else\n                    printf(\"UPnP Port Mapping successful.\\n\");;\n            }\n            MilliSleep(2000);\n            i++;\n        }\n    } else {\n        printf(\"No valid UPnP IGDs found\\n\");\n        freeUPNPDevlist(devlist); devlist = 0;\n        if (r != 0)\n            FreeUPNPUrls(&urls);\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n                return;\n            MilliSleep(2000);\n        }\n    }\n}"
  },
  {
    "function_name": "ThreadMapPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "1011-1030",
    "snippet": "void ThreadMapPort(void* parg)\n{\n    // Make this thread recognisable as the UPnP thread\n    RenameThread(\"hal-upnp\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_UPNP]++;\n        ThreadMapPort2(parg);\n        vnThreadsRunning[THREAD_UPNP]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_UPNP]--;\n        PrintException(&e, \"ThreadMapPort()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_UPNP]--;\n        PrintException(NULL, \"ThreadMapPort()\");\n    }\n    printf(\"ThreadMapPort exited\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadMapPort exited\\n\""
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "NULL",
            "\"ThreadMapPort()\""
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadMapPort2",
          "args": [
            "parg"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadMapPort2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "1032-1140",
          "snippet": "void ThreadMapPort2(void* parg)\n{\n    printf(\"ThreadMapPort started\\n\");\n\n    std::string port = strprintf(\"%u\", GetListenPort());\n    const char * multicastif = 0;\n    const char * minissdpdpath = 0;\n    struct UPNPDev * devlist = 0;\n    char lanaddr[64];\n\n#ifndef UPNPDISCOVER_SUCCESS\n    /* miniUPnPc v1.5 */\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0);\n#elif (MINIUPNPC_API_VERSION < 14)\n    /* miniUPnPc v1.6 to v1.9 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n#else\n    /* miniUPnPc v1.9.20150730 and newer;\n     * CVE-2015-6031 may affect releases prior to v1.9.20150917 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n#endif\n\n    struct UPNPUrls urls;\n    struct IGDdatas data;\n    int r;\n\n    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n    if (r == 1)\n    {\n        if (fDiscover) {\n            char externalIPAddress[40];\n            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n            if(r != UPNPCOMMAND_SUCCESS)\n                printf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n            else\n            {\n                if(externalIPAddress[0])\n                {\n                    printf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n                    AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n                }\n                else\n                    printf(\"UPnP: GetExternalIPAddress failed.\\n\");\n            }\n        }\n\n        string strDesc = \"Halcyon \" + FormatFullVersion();\n#ifndef UPNPDISCOVER_SUCCESS\n        /* miniupnpc 1.5 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n        /* miniupnpc 1.6 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n        if(r!=UPNPCOMMAND_SUCCESS)\n            printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n        else\n            printf(\"UPnP Port Mapping successful.\\n\");\n        int i = 1;\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n            {\n                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n                printf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n                freeUPNPDevlist(devlist); devlist = 0;\n                FreeUPNPUrls(&urls);\n                return;\n            }\n            if (i % 600 == 0) // Refresh every 20 minutes\n            {\n#ifndef UPNPDISCOVER_SUCCESS\n                /* miniupnpc 1.5 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n                /* miniupnpc 1.6 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n                if(r!=UPNPCOMMAND_SUCCESS)\n                    printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                        port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n                else\n                    printf(\"UPnP Port Mapping successful.\\n\");;\n            }\n            MilliSleep(2000);\n            i++;\n        }\n    } else {\n        printf(\"No valid UPnP IGDs found\\n\");\n        freeUPNPDevlist(devlist); devlist = 0;\n        if (r != 0)\n            FreeUPNPUrls(&urls);\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n                return;\n            MilliSleep(2000);\n        }\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "void ThreadMessageHandler2(void* parg);",
            "void ThreadSocketHandler2(void* parg);",
            "void ThreadOpenConnections2(void* parg);",
            "void ThreadOpenAddedConnections2(void* parg);",
            "void ThreadDNSAddressSeed2(void* parg);",
            "bool fDiscover = true;",
            "bool fUseUPnP = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\nbool fDiscover = true;\nbool fUseUPnP = false;\n\nvoid ThreadMapPort2(void* parg)\n{\n    printf(\"ThreadMapPort started\\n\");\n\n    std::string port = strprintf(\"%u\", GetListenPort());\n    const char * multicastif = 0;\n    const char * minissdpdpath = 0;\n    struct UPNPDev * devlist = 0;\n    char lanaddr[64];\n\n#ifndef UPNPDISCOVER_SUCCESS\n    /* miniUPnPc v1.5 */\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0);\n#elif (MINIUPNPC_API_VERSION < 14)\n    /* miniUPnPc v1.6 to v1.9 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n#else\n    /* miniUPnPc v1.9.20150730 and newer;\n     * CVE-2015-6031 may affect releases prior to v1.9.20150917 */\n    int error = 0;\n    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n#endif\n\n    struct UPNPUrls urls;\n    struct IGDdatas data;\n    int r;\n\n    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n    if (r == 1)\n    {\n        if (fDiscover) {\n            char externalIPAddress[40];\n            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n            if(r != UPNPCOMMAND_SUCCESS)\n                printf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n            else\n            {\n                if(externalIPAddress[0])\n                {\n                    printf(\"UPnP: ExternalIPAddress = %s\\n\", externalIPAddress);\n                    AddLocal(CNetAddr(externalIPAddress), LOCAL_UPNP);\n                }\n                else\n                    printf(\"UPnP: GetExternalIPAddress failed.\\n\");\n            }\n        }\n\n        string strDesc = \"Halcyon \" + FormatFullVersion();\n#ifndef UPNPDISCOVER_SUCCESS\n        /* miniupnpc 1.5 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n        /* miniupnpc 1.6 */\n        r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                            port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n        if(r!=UPNPCOMMAND_SUCCESS)\n            printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n        else\n            printf(\"UPnP Port Mapping successful.\\n\");\n        int i = 1;\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n            {\n                r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n                printf(\"UPNP_DeletePortMapping() returned : %d\\n\", r);\n                freeUPNPDevlist(devlist); devlist = 0;\n                FreeUPNPUrls(&urls);\n                return;\n            }\n            if (i % 600 == 0) // Refresh every 20 minutes\n            {\n#ifndef UPNPDISCOVER_SUCCESS\n                /* miniupnpc 1.5 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0);\n#else\n                /* miniupnpc 1.6 */\n                r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype,\n                                    port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n#endif\n\n                if(r!=UPNPCOMMAND_SUCCESS)\n                    printf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\",\n                        port.c_str(), port.c_str(), lanaddr, r, strupnperror(r));\n                else\n                    printf(\"UPnP Port Mapping successful.\\n\");;\n            }\n            MilliSleep(2000);\n            i++;\n        }\n    } else {\n        printf(\"No valid UPnP IGDs found\\n\");\n        freeUPNPDevlist(devlist); devlist = 0;\n        if (r != 0)\n            FreeUPNPUrls(&urls);\n        while (true)\n        {\n            if (fShutdown || !fUseUPnP)\n                return;\n            MilliSleep(2000);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-upnp\""
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadMapPort(void* parg)\n{\n    // Make this thread recognisable as the UPnP thread\n    RenameThread(\"hal-upnp\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_UPNP]++;\n        ThreadMapPort2(parg);\n        vnThreadsRunning[THREAD_UPNP]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_UPNP]--;\n        PrintException(&e, \"ThreadMapPort()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_UPNP]--;\n        PrintException(NULL, \"ThreadMapPort()\");\n    }\n    printf(\"ThreadMapPort exited\\n\");\n}"
  },
  {
    "function_name": "ThreadSocketHandler2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "678-1000",
    "snippet": "void ThreadSocketHandler2(void* parg)\n{\n    printf(\"ThreadSocketHandler started\\n\");\n    list<CNode*> vNodesDisconnected;\n    unsigned int nPrevNodeCount = 0;\n\n    while (true)\n    {\n        //\n        // Disconnect nodes\n        //\n        {\n            LOCK(cs_vNodes);\n            // Disconnect unused nodes\n            vector<CNode*> vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n            {\n                if (pnode->fDisconnect ||\n                    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n                {\n                    // remove from vNodes\n                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n\n                    // release outbound grant (if any)\n                    pnode->grantOutbound.Release();\n\n                    // close socket and cleanup\n                    pnode->CloseSocketDisconnect();\n                    pnode->Cleanup();\n\n                    // hold in disconnected pool until all refs are released\n                    if (pnode->fNetworkNode || pnode->fInbound)\n                        pnode->Release();\n                    vNodesDisconnected.push_back(pnode);\n                }\n            }\n\n            // Delete disconnected nodes\n            list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n            {\n                // wait until threads are done using it\n                if (pnode->GetRefCount() <= 0)\n                {\n                    bool fDelete = false;\n                    {\n                        TRY_LOCK(pnode->cs_vSend, lockSend);\n                        if (lockSend)\n                        {\n                            TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                            if (lockRecv)\n                            {\n                                TRY_LOCK(pnode->cs_mapRequests, lockReq);\n                                if (lockReq)\n                                {\n                                    TRY_LOCK(pnode->cs_inventory, lockInv);\n                                    if (lockInv)\n                                        fDelete = true;\n                                }\n                            }\n                        }\n                    }\n                    if (fDelete)\n                    {\n                        vNodesDisconnected.remove(pnode);\n                        delete pnode;\n                    }\n                }\n            }\n        }\n        if (vNodes.size() != nPrevNodeCount)\n        {\n            nPrevNodeCount = vNodes.size();\n            uiInterface.NotifyNumConnectionsChanged(vNodes.size());\n        }\n\n\n        //\n        // Find which sockets have data to receive\n        //\n        struct timeval timeout;\n        timeout.tv_sec  = 0;\n        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n\n        fd_set fdsetRecv;\n        fd_set fdsetSend;\n        fd_set fdsetError;\n        FD_ZERO(&fdsetRecv);\n        FD_ZERO(&fdsetSend);\n        FD_ZERO(&fdsetError);\n        SOCKET hSocketMax = 0;\n        bool have_fds = false;\n\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket) {\n            FD_SET(hListenSocket, &fdsetRecv);\n            hSocketMax = max(hSocketMax, hListenSocket);\n            have_fds = true;\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n            {\n                if (pnode->hSocket == INVALID_SOCKET)\n                    continue;\n                FD_SET(pnode->hSocket, &fdsetRecv);\n                FD_SET(pnode->hSocket, &fdsetError);\n                hSocketMax = max(hSocketMax, pnode->hSocket);\n                have_fds = true;\n                {\n                    TRY_LOCK(pnode->cs_vSend, lockSend);\n                    if (lockSend && !pnode->vSend.empty())\n                        FD_SET(pnode->hSocket, &fdsetSend);\n                }\n            }\n        }\n\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n        if (fShutdown)\n            return;\n        if (nSelect == SOCKET_ERROR)\n        {\n            if (have_fds)\n            {\n                int nErr = WSAGetLastError();\n                printf(\"socket select error %d\\n\", nErr);\n                for (unsigned int i = 0; i <= hSocketMax; i++)\n                    FD_SET(i, &fdsetRecv);\n            }\n            FD_ZERO(&fdsetSend);\n            FD_ZERO(&fdsetError);\n            MilliSleep(timeout.tv_usec/1000);\n        }\n\n\n        //\n        // Accept new connections\n        //\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket)\n        if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n        {\n#ifdef USE_IPV6\n            struct sockaddr_storage sockaddr;\n#else\n            struct sockaddr sockaddr;\n#endif\n            socklen_t len = sizeof(sockaddr);\n            SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n            CAddress addr;\n            int nInbound = 0;\n\n            if (hSocket != INVALID_SOCKET)\n                if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n                    printf(\"Warning: Unknown socket family\\n\");\n\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    if (pnode->fInbound)\n                        nInbound++;\n            }\n\n            if (hSocket == INVALID_SOCKET)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr != WSAEWOULDBLOCK)\n                    printf(\"socket error accept failed: %d\\n\", nErr);\n            }\n            else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n            {\n                closesocket(hSocket);\n            }\n            else if (CNode::IsBanned(addr))\n            {\n                printf(\"connection from %s dropped (banned)\\n\", addr.ToString().c_str());\n                closesocket(hSocket);\n            }\n            else\n            {\n                printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n                pnode->AddRef();\n                {\n                    LOCK(cs_vNodes);\n                    vNodes.push_back(pnode);\n                }\n            }\n        }\n\n\n        //\n        // Service each socket\n        //\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            if (fShutdown)\n                return;\n\n            //\n            // Receive\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                {\n                    CDataStream& vRecv = pnode->vRecv;\n                    unsigned int nPos = vRecv.size();\n\n                    if (nPos > ReceiveBufferSize()) {\n                        if (!pnode->fDisconnect)\n                            printf(\"socket recv flood control disconnect (%\"PRIszu\" bytes)\\n\", vRecv.size());\n                        pnode->CloseSocketDisconnect();\n                    }\n                    else {\n                        // typical socket buffer is 8K-64K\n                        char pchBuf[0x10000];\n                        int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vRecv.resize(nPos + nBytes);\n                            memcpy(&vRecv[nPos], pchBuf, nBytes);\n                            pnode->nLastRecv = GetTime();\n                        }\n                        else if (nBytes == 0)\n                        {\n                            // socket closed gracefully\n                            if (!pnode->fDisconnect)\n                                printf(\"socket closed\\n\");\n                            pnode->CloseSocketDisconnect();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                if (!pnode->fDisconnect)\n                                    printf(\"socket recv error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Send\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetSend))\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                {\n                    CDataStream& vSend = pnode->vSend;\n                    if (!vSend.empty())\n                    {\n                        int nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n                            pnode->nLastSend = GetTime();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                printf(\"socket send error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Inactivity checking\n            //\n            if (pnode->vSend.empty())\n                pnode->nLastSendEmpty = GetTime();\n            if (GetTime() - pnode->nTimeConnected > 60)\n            {\n                if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                {\n                    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n                {\n                    printf(\"socket not sending\\n\");\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastRecv > 90*60)\n                {\n                    printf(\"socket inactivity timeout\\n\");\n                    pnode->fDisconnect = true;\n                }\n            }\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        MilliSleep(10);\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int MAX_OUTBOUND_CONNECTIONS = 16;",
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);",
      "array<int, THREAD_MAX> vnThreadsRunning;",
      "static std::vector<SOCKET> vhListenSocket;",
      "vector<CNode*> vNodes;",
      "CCriticalSection cs_vNodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "10"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnode->Release",
          "args": [],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "Release",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "276-279",
          "snippet": "void Release()\n    {\n        nRefCount--;\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void Release()\n      {\n          nRefCount--;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"socket inactivity timeout\\n\""
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"socket not sending\\n\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"socket no message in first 60 seconds, %d %d\\n\"",
            "pnode->nLastRecv != 0",
            "pnode->nLastSend != 0"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnode->vSend.empty",
          "args": [],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pnode->CloseSocketDisconnect",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "CloseSocketDisconnect",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "550-560",
          "snippet": "void CNode::CloseSocketDisconnect()\n{\n    fDisconnect = true;\n    if (hSocket != INVALID_SOCKET)\n    {\n        printf(\"disconnecting node %s\\n\", addrName.c_str());\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n        vRecv.clear();\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::CloseSocketDisconnect()\n  {\n      fDisconnect = true;\n      if (hSocket != INVALID_SOCKET)\n      {\n          printf(\"disconnecting node %s\\n\", addrName.c_str());\n          closesocket(hSocket);\n          hSocket = INVALID_SOCKET;\n          vRecv.clear();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"socket send error %d\\n\"",
            "nErr"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vSend.erase",
          "args": [
            "vSend.begin()",
            "vSend.begin() + nBytes"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "870-888",
          "snippet": "iterator erase(iterator first, iterator last)\n    {\n        if (first == vch.begin() + nReadPos)\n        {\n            // special case for erasing from the front\n            if (last == vch.end())\n            {\n                nReadPos = 0;\n                return vch.erase(vch.begin(), vch.end());\n            }\n            else\n            {\n                nReadPos = (last - vch.begin());\n                return last;\n            }\n        }\n        else\n            return vch.erase(first, last);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  iterator erase(iterator first, iterator last)\n      {\n          if (first == vch.begin() + nReadPos)\n          {\n              // special case for erasing from the front\n              if (last == vch.end())\n              {\n                  nReadPos = 0;\n                  return vch.erase(vch.begin(), vch.end());\n              }\n              else\n              {\n                  nReadPos = (last - vch.begin());\n                  return last;\n              }\n          }\n          else\n              return vch.erase(first, last);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSend.begin",
          "args": [],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "pnode->hSocket",
            "&vSend[0]",
            "vSend.size()",
            "MSG_NOSIGNAL | MSG_DONTWAIT"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vSend.size",
          "args": [],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_vSend",
            "lockSend"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "pnode->hSocket",
            "&fdsetSend"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"socket closed\\n\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vRecv[nPos]",
            "pchBuf",
            "nBytes"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRecv.resize",
          "args": [
            "nPos + nBytes"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "pnode->hSocket",
            "pchBuf",
            "sizeof(pchBuf)",
            "MSG_DONTWAIT"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReceiveBufferSize",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ReceiveBufferSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "29-29",
          "snippet": "inline unsigned int ReceiveBufferSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\ninline unsigned int ReceiveBufferSize() { return 1000*GetArg(\"-maxreceivebuffer\", 5*1000); }"
        }
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_vRecv",
            "lockRecv"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "pnode->hSocket",
            "&fdsetError"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "pnode->hSocket",
            "&fdsetRecv"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnode->AddRef",
          "args": [],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vNodes.push_back",
          "args": [
            "pnode"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnode->AddRef",
          "args": [],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CNode::IsBanned",
          "args": [
            "addr"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "IsBanned",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "590-604",
          "snippet": "bool CNode::IsBanned(CNetAddr ip)\n{\n    bool fResult = false;\n    {\n        LOCK(cs_setBanned);\n        std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n        if (i != setBanned.end())\n        {\n            int64_t t = (*i).second;\n            if (GetTime() < t)\n                fResult = true;\n        }\n    }\n    return fResult;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "std::map<CNetAddr, int64_t> CNode::setBanned;",
            "CCriticalSection CNode::cs_setBanned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstd::map<CNetAddr, int64_t> CNode::setBanned;\nCCriticalSection CNode::cs_setBanned;\n\nCNode {\n  bool CNode::IsBanned(CNetAddr ip)\n  {\n      bool fResult = false;\n      {\n          LOCK(cs_setBanned);\n          std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n          if (i != setBanned.end())\n          {\n              int64_t t = (*i).second;\n              if (GetTime() < t)\n                  fResult = true;\n          }\n      }\n      return fResult;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-maxconnections\"",
            "125"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: Unknown socket family\\n\""
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.SetSockAddr",
          "args": [
            "(const struct sockaddr*)&sockaddr"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "SetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1049-1063",
          "snippet": "bool CService::SetSockAddr(const struct sockaddr *paddr)\n{\n    switch (paddr->sa_family) {\n    case AF_INET:\n        *this = CService(*(const struct sockaddr_in*)paddr);\n        return true;\n#ifdef USE_IPV6\n    case AF_INET6:\n        *this = CService(*(const struct sockaddr_in6*)paddr);\n        return true;\n#endif\n    default:\n        return false;\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::SetSockAddr(const struct sockaddr *paddr)\n  {\n      switch (paddr->sa_family) {\n      case AF_INET:\n          *this = CService(*(const struct sockaddr_in*)paddr);\n          return true;\n  #ifdef USE_IPV6\n      case AF_INET6:\n          *this = CService(*(const struct sockaddr_in6*)paddr);\n          return true;\n  #endif\n      default:\n          return false;\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "hListenSocket",
            "(struct sockaddr*)&sockaddr",
            "&len"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "hListenSocket",
            "&fdsetRecv"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fdsetError"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fdsetSend"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "i",
            "&fdsetRecv"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "have_fds ? hSocketMax + 1 : 0",
            "&fdsetRecv",
            "&fdsetSend",
            "&fdsetError",
            "&timeout"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "pnode->hSocket",
            "&fdsetSend"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_vSend",
            "lockSend"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "hSocketMax",
            "pnode->hSocket"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_max_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "433-435",
          "snippet": "void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "pnode->hSocket",
            "&fdsetError"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "pnode->hSocket",
            "&fdsetRecv"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "hListenSocket",
            "&fdsetRecv"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fdsetError"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fdsetSend"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_ZERO",
          "args": [
            "&fdsetRecv"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiInterface.NotifyNumConnectionsChanged",
          "args": [
            "vNodes.size()"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vNodesDisconnected.remove",
          "args": [
            "pnode"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_inventory",
            "lockInv"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_mapRequests",
            "lockReq"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_vRecv",
            "lockRecv"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "pnode->cs_vSend",
            "lockSend"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnode->GetRefCount",
          "args": [],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "GetRefCount",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "264-268",
          "snippet": "int GetRefCount()\n    {\n        assert(nRefCount >= 0);\n        return nRefCount;\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  int GetRefCount()\n      {\n          assert(nRefCount >= 0);\n          return nRefCount;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNodesDisconnected.push_back",
          "args": [
            "pnode"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnode->Cleanup",
          "args": [],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "Cleanup",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "562-564",
          "snippet": "void CNode::Cleanup()\n{\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::Cleanup()\n  {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNodes.end",
          "args": [],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "vNodes.begin()",
            "vNodes.end()",
            "pnode"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "removeRows",
          "container": "AddressTableModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/addresstablemodel.cpp",
          "lines": "376-391",
          "snippet": "bool AddressTableModel::removeRows(int row, int count, const QModelIndex &parent)\n{\n    Q_UNUSED(parent);\n    AddressTableEntry *rec = priv->index(row);\n    if(count != 1 || !rec || rec->type == AddressTableEntry::Receiving)\n    {\n        // Can only remove one row at a time, and cannot remove rows not in model.\n        // Also refuse to remove receiving addresses.\n        return false;\n    }\n    {\n        LOCK(wallet->cs_wallet);\n        wallet->DelAddressBookName(CBitcoinAddress(rec->address.toStdString()).Get());\n    }\n    return true;\n}",
          "includes": [
            "#include <QColor>",
            "#include <QFont>",
            "#include \"base58.h\"",
            "#include \"wallet.h\"",
            "#include \"walletmodel.h\"",
            "#include \"guiutil.h\"",
            "#include \"addresstablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QColor>\n#include <QFont>\n#include \"base58.h\"\n#include \"wallet.h\"\n#include \"walletmodel.h\"\n#include \"guiutil.h\"\n#include \"addresstablemodel.h\"\n\nAddressTableModel {\n  bool AddressTableModel::removeRows(int row, int count, const QModelIndex &parent)\n  {\n      Q_UNUSED(parent);\n      AddressTableEntry *rec = priv->index(row);\n      if(count != 1 || !rec || rec->type == AddressTableEntry::Receiving)\n      {\n          // Can only remove one row at a time, and cannot remove rows not in model.\n          // Also refuse to remove receiving addresses.\n          return false;\n      }\n      {\n          LOCK(wallet->cs_wallet);\n          wallet->DelAddressBookName(CBitcoinAddress(rec->address.toStdString()).Get());\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadSocketHandler started\\n\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic const int MAX_OUTBOUND_CONNECTIONS = 16;\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\nbool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\narray<int, THREAD_MAX> vnThreadsRunning;\nstatic std::vector<SOCKET> vhListenSocket;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\n\nvoid ThreadSocketHandler2(void* parg)\n{\n    printf(\"ThreadSocketHandler started\\n\");\n    list<CNode*> vNodesDisconnected;\n    unsigned int nPrevNodeCount = 0;\n\n    while (true)\n    {\n        //\n        // Disconnect nodes\n        //\n        {\n            LOCK(cs_vNodes);\n            // Disconnect unused nodes\n            vector<CNode*> vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n            {\n                if (pnode->fDisconnect ||\n                    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n                {\n                    // remove from vNodes\n                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n\n                    // release outbound grant (if any)\n                    pnode->grantOutbound.Release();\n\n                    // close socket and cleanup\n                    pnode->CloseSocketDisconnect();\n                    pnode->Cleanup();\n\n                    // hold in disconnected pool until all refs are released\n                    if (pnode->fNetworkNode || pnode->fInbound)\n                        pnode->Release();\n                    vNodesDisconnected.push_back(pnode);\n                }\n            }\n\n            // Delete disconnected nodes\n            list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n            {\n                // wait until threads are done using it\n                if (pnode->GetRefCount() <= 0)\n                {\n                    bool fDelete = false;\n                    {\n                        TRY_LOCK(pnode->cs_vSend, lockSend);\n                        if (lockSend)\n                        {\n                            TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                            if (lockRecv)\n                            {\n                                TRY_LOCK(pnode->cs_mapRequests, lockReq);\n                                if (lockReq)\n                                {\n                                    TRY_LOCK(pnode->cs_inventory, lockInv);\n                                    if (lockInv)\n                                        fDelete = true;\n                                }\n                            }\n                        }\n                    }\n                    if (fDelete)\n                    {\n                        vNodesDisconnected.remove(pnode);\n                        delete pnode;\n                    }\n                }\n            }\n        }\n        if (vNodes.size() != nPrevNodeCount)\n        {\n            nPrevNodeCount = vNodes.size();\n            uiInterface.NotifyNumConnectionsChanged(vNodes.size());\n        }\n\n\n        //\n        // Find which sockets have data to receive\n        //\n        struct timeval timeout;\n        timeout.tv_sec  = 0;\n        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n\n        fd_set fdsetRecv;\n        fd_set fdsetSend;\n        fd_set fdsetError;\n        FD_ZERO(&fdsetRecv);\n        FD_ZERO(&fdsetSend);\n        FD_ZERO(&fdsetError);\n        SOCKET hSocketMax = 0;\n        bool have_fds = false;\n\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket) {\n            FD_SET(hListenSocket, &fdsetRecv);\n            hSocketMax = max(hSocketMax, hListenSocket);\n            have_fds = true;\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n            {\n                if (pnode->hSocket == INVALID_SOCKET)\n                    continue;\n                FD_SET(pnode->hSocket, &fdsetRecv);\n                FD_SET(pnode->hSocket, &fdsetError);\n                hSocketMax = max(hSocketMax, pnode->hSocket);\n                have_fds = true;\n                {\n                    TRY_LOCK(pnode->cs_vSend, lockSend);\n                    if (lockSend && !pnode->vSend.empty())\n                        FD_SET(pnode->hSocket, &fdsetSend);\n                }\n            }\n        }\n\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n        if (fShutdown)\n            return;\n        if (nSelect == SOCKET_ERROR)\n        {\n            if (have_fds)\n            {\n                int nErr = WSAGetLastError();\n                printf(\"socket select error %d\\n\", nErr);\n                for (unsigned int i = 0; i <= hSocketMax; i++)\n                    FD_SET(i, &fdsetRecv);\n            }\n            FD_ZERO(&fdsetSend);\n            FD_ZERO(&fdsetError);\n            MilliSleep(timeout.tv_usec/1000);\n        }\n\n\n        //\n        // Accept new connections\n        //\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket)\n        if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n        {\n#ifdef USE_IPV6\n            struct sockaddr_storage sockaddr;\n#else\n            struct sockaddr sockaddr;\n#endif\n            socklen_t len = sizeof(sockaddr);\n            SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n            CAddress addr;\n            int nInbound = 0;\n\n            if (hSocket != INVALID_SOCKET)\n                if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n                    printf(\"Warning: Unknown socket family\\n\");\n\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    if (pnode->fInbound)\n                        nInbound++;\n            }\n\n            if (hSocket == INVALID_SOCKET)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr != WSAEWOULDBLOCK)\n                    printf(\"socket error accept failed: %d\\n\", nErr);\n            }\n            else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n            {\n                closesocket(hSocket);\n            }\n            else if (CNode::IsBanned(addr))\n            {\n                printf(\"connection from %s dropped (banned)\\n\", addr.ToString().c_str());\n                closesocket(hSocket);\n            }\n            else\n            {\n                printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n                pnode->AddRef();\n                {\n                    LOCK(cs_vNodes);\n                    vNodes.push_back(pnode);\n                }\n            }\n        }\n\n\n        //\n        // Service each socket\n        //\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            if (fShutdown)\n                return;\n\n            //\n            // Receive\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                {\n                    CDataStream& vRecv = pnode->vRecv;\n                    unsigned int nPos = vRecv.size();\n\n                    if (nPos > ReceiveBufferSize()) {\n                        if (!pnode->fDisconnect)\n                            printf(\"socket recv flood control disconnect (%\"PRIszu\" bytes)\\n\", vRecv.size());\n                        pnode->CloseSocketDisconnect();\n                    }\n                    else {\n                        // typical socket buffer is 8K-64K\n                        char pchBuf[0x10000];\n                        int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vRecv.resize(nPos + nBytes);\n                            memcpy(&vRecv[nPos], pchBuf, nBytes);\n                            pnode->nLastRecv = GetTime();\n                        }\n                        else if (nBytes == 0)\n                        {\n                            // socket closed gracefully\n                            if (!pnode->fDisconnect)\n                                printf(\"socket closed\\n\");\n                            pnode->CloseSocketDisconnect();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                if (!pnode->fDisconnect)\n                                    printf(\"socket recv error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Send\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetSend))\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                {\n                    CDataStream& vSend = pnode->vSend;\n                    if (!vSend.empty())\n                    {\n                        int nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n                            pnode->nLastSend = GetTime();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                printf(\"socket send error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Inactivity checking\n            //\n            if (pnode->vSend.empty())\n                pnode->nLastSendEmpty = GetTime();\n            if (GetTime() - pnode->nTimeConnected > 60)\n            {\n                if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                {\n                    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n                {\n                    printf(\"socket not sending\\n\");\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastRecv > 90*60)\n                {\n                    printf(\"socket inactivity timeout\\n\");\n                    pnode->fDisconnect = true;\n                }\n            }\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        MilliSleep(10);\n    }\n}"
  },
  {
    "function_name": "ThreadSocketHandler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "657-676",
    "snippet": "void ThreadSocketHandler(void* parg)\n{\n    // Make this thread recognisable as the networking thread\n    RenameThread(\"hal-net\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n        ThreadSocketHandler2(parg);\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        PrintException(&e, \"ThreadSocketHandler()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        throw; // support pthread_cancel()\n    }\n    printf(\"ThreadSocketHandler exited\\n\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);",
      "array<int, THREAD_MAX> vnThreadsRunning;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ThreadSocketHandler exited\\n\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintException",
          "args": [
            "&e",
            "\"ThreadSocketHandler()\""
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ThreadSocketHandler2",
          "args": [
            "parg"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadSocketHandler2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "678-1000",
          "snippet": "void ThreadSocketHandler2(void* parg)\n{\n    printf(\"ThreadSocketHandler started\\n\");\n    list<CNode*> vNodesDisconnected;\n    unsigned int nPrevNodeCount = 0;\n\n    while (true)\n    {\n        //\n        // Disconnect nodes\n        //\n        {\n            LOCK(cs_vNodes);\n            // Disconnect unused nodes\n            vector<CNode*> vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n            {\n                if (pnode->fDisconnect ||\n                    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n                {\n                    // remove from vNodes\n                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n\n                    // release outbound grant (if any)\n                    pnode->grantOutbound.Release();\n\n                    // close socket and cleanup\n                    pnode->CloseSocketDisconnect();\n                    pnode->Cleanup();\n\n                    // hold in disconnected pool until all refs are released\n                    if (pnode->fNetworkNode || pnode->fInbound)\n                        pnode->Release();\n                    vNodesDisconnected.push_back(pnode);\n                }\n            }\n\n            // Delete disconnected nodes\n            list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n            {\n                // wait until threads are done using it\n                if (pnode->GetRefCount() <= 0)\n                {\n                    bool fDelete = false;\n                    {\n                        TRY_LOCK(pnode->cs_vSend, lockSend);\n                        if (lockSend)\n                        {\n                            TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                            if (lockRecv)\n                            {\n                                TRY_LOCK(pnode->cs_mapRequests, lockReq);\n                                if (lockReq)\n                                {\n                                    TRY_LOCK(pnode->cs_inventory, lockInv);\n                                    if (lockInv)\n                                        fDelete = true;\n                                }\n                            }\n                        }\n                    }\n                    if (fDelete)\n                    {\n                        vNodesDisconnected.remove(pnode);\n                        delete pnode;\n                    }\n                }\n            }\n        }\n        if (vNodes.size() != nPrevNodeCount)\n        {\n            nPrevNodeCount = vNodes.size();\n            uiInterface.NotifyNumConnectionsChanged(vNodes.size());\n        }\n\n\n        //\n        // Find which sockets have data to receive\n        //\n        struct timeval timeout;\n        timeout.tv_sec  = 0;\n        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n\n        fd_set fdsetRecv;\n        fd_set fdsetSend;\n        fd_set fdsetError;\n        FD_ZERO(&fdsetRecv);\n        FD_ZERO(&fdsetSend);\n        FD_ZERO(&fdsetError);\n        SOCKET hSocketMax = 0;\n        bool have_fds = false;\n\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket) {\n            FD_SET(hListenSocket, &fdsetRecv);\n            hSocketMax = max(hSocketMax, hListenSocket);\n            have_fds = true;\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n            {\n                if (pnode->hSocket == INVALID_SOCKET)\n                    continue;\n                FD_SET(pnode->hSocket, &fdsetRecv);\n                FD_SET(pnode->hSocket, &fdsetError);\n                hSocketMax = max(hSocketMax, pnode->hSocket);\n                have_fds = true;\n                {\n                    TRY_LOCK(pnode->cs_vSend, lockSend);\n                    if (lockSend && !pnode->vSend.empty())\n                        FD_SET(pnode->hSocket, &fdsetSend);\n                }\n            }\n        }\n\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n        if (fShutdown)\n            return;\n        if (nSelect == SOCKET_ERROR)\n        {\n            if (have_fds)\n            {\n                int nErr = WSAGetLastError();\n                printf(\"socket select error %d\\n\", nErr);\n                for (unsigned int i = 0; i <= hSocketMax; i++)\n                    FD_SET(i, &fdsetRecv);\n            }\n            FD_ZERO(&fdsetSend);\n            FD_ZERO(&fdsetError);\n            MilliSleep(timeout.tv_usec/1000);\n        }\n\n\n        //\n        // Accept new connections\n        //\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket)\n        if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n        {\n#ifdef USE_IPV6\n            struct sockaddr_storage sockaddr;\n#else\n            struct sockaddr sockaddr;\n#endif\n            socklen_t len = sizeof(sockaddr);\n            SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n            CAddress addr;\n            int nInbound = 0;\n\n            if (hSocket != INVALID_SOCKET)\n                if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n                    printf(\"Warning: Unknown socket family\\n\");\n\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    if (pnode->fInbound)\n                        nInbound++;\n            }\n\n            if (hSocket == INVALID_SOCKET)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr != WSAEWOULDBLOCK)\n                    printf(\"socket error accept failed: %d\\n\", nErr);\n            }\n            else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n            {\n                closesocket(hSocket);\n            }\n            else if (CNode::IsBanned(addr))\n            {\n                printf(\"connection from %s dropped (banned)\\n\", addr.ToString().c_str());\n                closesocket(hSocket);\n            }\n            else\n            {\n                printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n                pnode->AddRef();\n                {\n                    LOCK(cs_vNodes);\n                    vNodes.push_back(pnode);\n                }\n            }\n        }\n\n\n        //\n        // Service each socket\n        //\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            if (fShutdown)\n                return;\n\n            //\n            // Receive\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                {\n                    CDataStream& vRecv = pnode->vRecv;\n                    unsigned int nPos = vRecv.size();\n\n                    if (nPos > ReceiveBufferSize()) {\n                        if (!pnode->fDisconnect)\n                            printf(\"socket recv flood control disconnect (%\"PRIszu\" bytes)\\n\", vRecv.size());\n                        pnode->CloseSocketDisconnect();\n                    }\n                    else {\n                        // typical socket buffer is 8K-64K\n                        char pchBuf[0x10000];\n                        int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vRecv.resize(nPos + nBytes);\n                            memcpy(&vRecv[nPos], pchBuf, nBytes);\n                            pnode->nLastRecv = GetTime();\n                        }\n                        else if (nBytes == 0)\n                        {\n                            // socket closed gracefully\n                            if (!pnode->fDisconnect)\n                                printf(\"socket closed\\n\");\n                            pnode->CloseSocketDisconnect();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                if (!pnode->fDisconnect)\n                                    printf(\"socket recv error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Send\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetSend))\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                {\n                    CDataStream& vSend = pnode->vSend;\n                    if (!vSend.empty())\n                    {\n                        int nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n                            pnode->nLastSend = GetTime();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                printf(\"socket send error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Inactivity checking\n            //\n            if (pnode->vSend.empty())\n                pnode->nLastSendEmpty = GetTime();\n            if (GetTime() - pnode->nTimeConnected > 60)\n            {\n                if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                {\n                    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n                {\n                    printf(\"socket not sending\\n\");\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastRecv > 90*60)\n                {\n                    printf(\"socket inactivity timeout\\n\");\n                    pnode->fDisconnect = true;\n                }\n            }\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        MilliSleep(10);\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int MAX_OUTBOUND_CONNECTIONS = 16;",
            "void ThreadMessageHandler2(void* parg);",
            "void ThreadSocketHandler2(void* parg);",
            "void ThreadOpenConnections2(void* parg);",
            "void ThreadOpenAddedConnections2(void* parg);",
            "void ThreadDNSAddressSeed2(void* parg);",
            "bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);",
            "array<int, THREAD_MAX> vnThreadsRunning;",
            "static std::vector<SOCKET> vhListenSocket;",
            "vector<CNode*> vNodes;",
            "CCriticalSection cs_vNodes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic const int MAX_OUTBOUND_CONNECTIONS = 16;\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\nbool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\narray<int, THREAD_MAX> vnThreadsRunning;\nstatic std::vector<SOCKET> vhListenSocket;\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\n\nvoid ThreadSocketHandler2(void* parg)\n{\n    printf(\"ThreadSocketHandler started\\n\");\n    list<CNode*> vNodesDisconnected;\n    unsigned int nPrevNodeCount = 0;\n\n    while (true)\n    {\n        //\n        // Disconnect nodes\n        //\n        {\n            LOCK(cs_vNodes);\n            // Disconnect unused nodes\n            vector<CNode*> vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n            {\n                if (pnode->fDisconnect ||\n                    (pnode->GetRefCount() <= 0 && pnode->vRecv.empty() && pnode->vSend.empty()))\n                {\n                    // remove from vNodes\n                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n\n                    // release outbound grant (if any)\n                    pnode->grantOutbound.Release();\n\n                    // close socket and cleanup\n                    pnode->CloseSocketDisconnect();\n                    pnode->Cleanup();\n\n                    // hold in disconnected pool until all refs are released\n                    if (pnode->fNetworkNode || pnode->fInbound)\n                        pnode->Release();\n                    vNodesDisconnected.push_back(pnode);\n                }\n            }\n\n            // Delete disconnected nodes\n            list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n            {\n                // wait until threads are done using it\n                if (pnode->GetRefCount() <= 0)\n                {\n                    bool fDelete = false;\n                    {\n                        TRY_LOCK(pnode->cs_vSend, lockSend);\n                        if (lockSend)\n                        {\n                            TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                            if (lockRecv)\n                            {\n                                TRY_LOCK(pnode->cs_mapRequests, lockReq);\n                                if (lockReq)\n                                {\n                                    TRY_LOCK(pnode->cs_inventory, lockInv);\n                                    if (lockInv)\n                                        fDelete = true;\n                                }\n                            }\n                        }\n                    }\n                    if (fDelete)\n                    {\n                        vNodesDisconnected.remove(pnode);\n                        delete pnode;\n                    }\n                }\n            }\n        }\n        if (vNodes.size() != nPrevNodeCount)\n        {\n            nPrevNodeCount = vNodes.size();\n            uiInterface.NotifyNumConnectionsChanged(vNodes.size());\n        }\n\n\n        //\n        // Find which sockets have data to receive\n        //\n        struct timeval timeout;\n        timeout.tv_sec  = 0;\n        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n\n        fd_set fdsetRecv;\n        fd_set fdsetSend;\n        fd_set fdsetError;\n        FD_ZERO(&fdsetRecv);\n        FD_ZERO(&fdsetSend);\n        FD_ZERO(&fdsetError);\n        SOCKET hSocketMax = 0;\n        bool have_fds = false;\n\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket) {\n            FD_SET(hListenSocket, &fdsetRecv);\n            hSocketMax = max(hSocketMax, hListenSocket);\n            have_fds = true;\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n            {\n                if (pnode->hSocket == INVALID_SOCKET)\n                    continue;\n                FD_SET(pnode->hSocket, &fdsetRecv);\n                FD_SET(pnode->hSocket, &fdsetError);\n                hSocketMax = max(hSocketMax, pnode->hSocket);\n                have_fds = true;\n                {\n                    TRY_LOCK(pnode->cs_vSend, lockSend);\n                    if (lockSend && !pnode->vSend.empty())\n                        FD_SET(pnode->hSocket, &fdsetSend);\n                }\n            }\n        }\n\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n        if (fShutdown)\n            return;\n        if (nSelect == SOCKET_ERROR)\n        {\n            if (have_fds)\n            {\n                int nErr = WSAGetLastError();\n                printf(\"socket select error %d\\n\", nErr);\n                for (unsigned int i = 0; i <= hSocketMax; i++)\n                    FD_SET(i, &fdsetRecv);\n            }\n            FD_ZERO(&fdsetSend);\n            FD_ZERO(&fdsetError);\n            MilliSleep(timeout.tv_usec/1000);\n        }\n\n\n        //\n        // Accept new connections\n        //\n        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket)\n        if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n        {\n#ifdef USE_IPV6\n            struct sockaddr_storage sockaddr;\n#else\n            struct sockaddr sockaddr;\n#endif\n            socklen_t len = sizeof(sockaddr);\n            SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n            CAddress addr;\n            int nInbound = 0;\n\n            if (hSocket != INVALID_SOCKET)\n                if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n                    printf(\"Warning: Unknown socket family\\n\");\n\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    if (pnode->fInbound)\n                        nInbound++;\n            }\n\n            if (hSocket == INVALID_SOCKET)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr != WSAEWOULDBLOCK)\n                    printf(\"socket error accept failed: %d\\n\", nErr);\n            }\n            else if (nInbound >= GetArg(\"-maxconnections\", 125) - MAX_OUTBOUND_CONNECTIONS)\n            {\n                closesocket(hSocket);\n            }\n            else if (CNode::IsBanned(addr))\n            {\n                printf(\"connection from %s dropped (banned)\\n\", addr.ToString().c_str());\n                closesocket(hSocket);\n            }\n            else\n            {\n                printf(\"accepted connection %s\\n\", addr.ToString().c_str());\n                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n                pnode->AddRef();\n                {\n                    LOCK(cs_vNodes);\n                    vNodes.push_back(pnode);\n                }\n            }\n        }\n\n\n        //\n        // Service each socket\n        //\n        vector<CNode*> vNodesCopy;\n        {\n            LOCK(cs_vNodes);\n            vNodesCopy = vNodes;\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->AddRef();\n        }\n        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n        {\n            if (fShutdown)\n                return;\n\n            //\n            // Receive\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetRecv) || FD_ISSET(pnode->hSocket, &fdsetError))\n            {\n                TRY_LOCK(pnode->cs_vRecv, lockRecv);\n                if (lockRecv)\n                {\n                    CDataStream& vRecv = pnode->vRecv;\n                    unsigned int nPos = vRecv.size();\n\n                    if (nPos > ReceiveBufferSize()) {\n                        if (!pnode->fDisconnect)\n                            printf(\"socket recv flood control disconnect (%\"PRIszu\" bytes)\\n\", vRecv.size());\n                        pnode->CloseSocketDisconnect();\n                    }\n                    else {\n                        // typical socket buffer is 8K-64K\n                        char pchBuf[0x10000];\n                        int nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vRecv.resize(nPos + nBytes);\n                            memcpy(&vRecv[nPos], pchBuf, nBytes);\n                            pnode->nLastRecv = GetTime();\n                        }\n                        else if (nBytes == 0)\n                        {\n                            // socket closed gracefully\n                            if (!pnode->fDisconnect)\n                                printf(\"socket closed\\n\");\n                            pnode->CloseSocketDisconnect();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                if (!pnode->fDisconnect)\n                                    printf(\"socket recv error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Send\n            //\n            if (pnode->hSocket == INVALID_SOCKET)\n                continue;\n            if (FD_ISSET(pnode->hSocket, &fdsetSend))\n            {\n                TRY_LOCK(pnode->cs_vSend, lockSend);\n                if (lockSend)\n                {\n                    CDataStream& vSend = pnode->vSend;\n                    if (!vSend.empty())\n                    {\n                        int nBytes = send(pnode->hSocket, &vSend[0], vSend.size(), MSG_NOSIGNAL | MSG_DONTWAIT);\n                        if (nBytes > 0)\n                        {\n                            vSend.erase(vSend.begin(), vSend.begin() + nBytes);\n                            pnode->nLastSend = GetTime();\n                        }\n                        else if (nBytes < 0)\n                        {\n                            // error\n                            int nErr = WSAGetLastError();\n                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n                            {\n                                printf(\"socket send error %d\\n\", nErr);\n                                pnode->CloseSocketDisconnect();\n                            }\n                        }\n                    }\n                }\n            }\n\n            //\n            // Inactivity checking\n            //\n            if (pnode->vSend.empty())\n                pnode->nLastSendEmpty = GetTime();\n            if (GetTime() - pnode->nTimeConnected > 60)\n            {\n                if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                {\n                    printf(\"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastSend > 90*60 && GetTime() - pnode->nLastSendEmpty > 90*60)\n                {\n                    printf(\"socket not sending\\n\");\n                    pnode->fDisconnect = true;\n                }\n                else if (GetTime() - pnode->nLastRecv > 90*60)\n                {\n                    printf(\"socket inactivity timeout\\n\");\n                    pnode->fDisconnect = true;\n                }\n            }\n        }\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n                pnode->Release();\n        }\n\n        MilliSleep(10);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-net\""
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\narray<int, THREAD_MAX> vnThreadsRunning;\n\nvoid ThreadSocketHandler(void* parg)\n{\n    // Make this thread recognisable as the networking thread\n    RenameThread(\"hal-net\");\n\n    try\n    {\n        vnThreadsRunning[THREAD_SOCKETHANDLER]++;\n        ThreadSocketHandler2(parg);\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n    }\n    catch (std::exception& e) {\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        PrintException(&e, \"ThreadSocketHandler()\");\n    } catch (...) {\n        vnThreadsRunning[THREAD_SOCKETHANDLER]--;\n        throw; // support pthread_cancel()\n    }\n    printf(\"ThreadSocketHandler exited\\n\");\n}"
  },
  {
    "function_name": "copyStats",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "633-645",
    "snippet": "void CNode::copyStats(CNodeStats &stats)\n{\n    X(nServices);\n    X(nLastSend);\n    X(nLastRecv);\n    X(nTimeConnected);\n    X(addrName);\n    X(nVersion);\n    X(strSubVer);\n    X(fInbound);\n    X(nStartingHeight);\n    X(nMisbehavior);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "X",
          "args": [
            "nMisbehavior"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "nStartingHeight"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "fInbound"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "strSubVer"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "nVersion"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "addrName"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "nTimeConnected"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "nLastRecv"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "nLastSend"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X",
          "args": [
            "nServices"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::copyStats(CNodeStats &stats)\n  {\n      X(nServices);\n      X(nLastSend);\n      X(nLastRecv);\n      X(nTimeConnected);\n      X(addrName);\n      X(nVersion);\n      X(strSubVer);\n      X(fInbound);\n      X(nStartingHeight);\n      X(nMisbehavior);\n  }\n}"
  },
  {
    "function_name": "Misbehaving",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "606-629",
    "snippet": "bool CNode::Misbehaving(int howmuch)\n{\n    if (addr.IsLocal())\n    {\n        printf(\"Warning: Local node %s misbehaving (delta: %d)!\\n\", addrName.c_str(), howmuch);\n        return false;\n    }\n\n    nMisbehavior += howmuch;\n    if (nMisbehavior >= GetArg(\"-banscore\", 100))\n    {\n        int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n        printf(\"Misbehaving: %s (%d -> %d) DISCONNECTING\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n        {\n            LOCK(cs_setBanned);\n            if (setBanned[addr] < banTime)\n                setBanned[addr] = banTime;\n        }\n        CloseSocketDisconnect();\n        return true;\n    } else\n        printf(\"Misbehaving: %s (%d -> %d)\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n    return false;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "std::map<CNetAddr, int64_t> CNode::setBanned;",
      "CCriticalSection CNode::cs_setBanned;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Misbehaving: %s (%d -> %d)\\n\"",
            "addr.ToString().c_str()",
            "nMisbehavior-howmuch",
            "nMisbehavior"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CloseSocketDisconnect",
          "args": [],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "CloseSocketDisconnect",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "550-560",
          "snippet": "void CNode::CloseSocketDisconnect()\n{\n    fDisconnect = true;\n    if (hSocket != INVALID_SOCKET)\n    {\n        printf(\"disconnecting node %s\\n\", addrName.c_str());\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n        vRecv.clear();\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::CloseSocketDisconnect()\n  {\n      fDisconnect = true;\n      if (hSocket != INVALID_SOCKET)\n      {\n          printf(\"disconnecting node %s\\n\", addrName.c_str());\n          closesocket(hSocket);\n          hSocket = INVALID_SOCKET;\n          vRecv.clear();\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_setBanned"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Misbehaving: %s (%d -> %d) DISCONNECTING\\n\"",
            "addr.ToString().c_str()",
            "nMisbehavior-howmuch",
            "nMisbehavior"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-bantime\"",
            "60*60*24"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Warning: Local node %s misbehaving (delta: %d)!\\n\"",
            "addrName.c_str()",
            "howmuch"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrName.c_str",
          "args": [],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.IsLocal",
          "args": [],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocal",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "705-717",
          "snippet": "bool CNetAddr::IsLocal() const\n{\n    // IPv4 loopback\n   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n       return true;\n\n   // IPv6 loopback (::1/128)\n   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n   if (memcmp(ip, pchLocal, 16) == 0)\n       return true;\n\n   return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsLocal() const\n  {\n      // IPv4 loopback\n     if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n         return true;\n  \n     // IPv6 loopback (::1/128)\n     static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n     if (memcmp(ip, pchLocal, 16) == 0)\n         return true;\n  \n     return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstd::map<CNetAddr, int64_t> CNode::setBanned;\nCCriticalSection CNode::cs_setBanned;\n\nCNode {\n  bool CNode::Misbehaving(int howmuch)\n  {\n      if (addr.IsLocal())\n      {\n          printf(\"Warning: Local node %s misbehaving (delta: %d)!\\n\", addrName.c_str(), howmuch);\n          return false;\n      }\n  \n      nMisbehavior += howmuch;\n      if (nMisbehavior >= GetArg(\"-banscore\", 100))\n      {\n          int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n          printf(\"Misbehaving: %s (%d -> %d) DISCONNECTING\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n          {\n              LOCK(cs_setBanned);\n              if (setBanned[addr] < banTime)\n                  setBanned[addr] = banTime;\n          }\n          CloseSocketDisconnect();\n          return true;\n      } else\n          printf(\"Misbehaving: %s (%d -> %d)\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n      return false;\n  }\n}"
  },
  {
    "function_name": "IsBanned",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "590-604",
    "snippet": "bool CNode::IsBanned(CNetAddr ip)\n{\n    bool fResult = false;\n    {\n        LOCK(cs_setBanned);\n        std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n        if (i != setBanned.end())\n        {\n            int64_t t = (*i).second;\n            if (GetTime() < t)\n                fResult = true;\n        }\n    }\n    return fResult;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "std::map<CNetAddr, int64_t> CNode::setBanned;",
      "CCriticalSection CNode::cs_setBanned;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "setBanned.end",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setBanned.find",
          "args": [
            "ip"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_setBanned"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstd::map<CNetAddr, int64_t> CNode::setBanned;\nCCriticalSection CNode::cs_setBanned;\n\nCNode {\n  bool CNode::IsBanned(CNetAddr ip)\n  {\n      bool fResult = false;\n      {\n          LOCK(cs_setBanned);\n          std::map<CNetAddr, int64_t>::iterator i = setBanned.find(ip);\n          if (i != setBanned.end())\n          {\n              int64_t t = (*i).second;\n              if (GetTime() < t)\n                  fResult = true;\n          }\n      }\n      return fResult;\n  }\n}"
  },
  {
    "function_name": "ClearBanned",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "585-588",
    "snippet": "void CNode::ClearBanned()\n{\n    setBanned.clear();\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "std::map<CNetAddr, int64_t> CNode::setBanned;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setBanned.clear",
          "args": [],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstd::map<CNetAddr, int64_t> CNode::setBanned;\n\nCNode {\n  void CNode::ClearBanned()\n  {\n      setBanned.clear();\n  }\n}"
  },
  {
    "function_name": "PushVersion",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "567-576",
    "snippet": "void CNode::PushVersion()\n{\n    int64 nTime = GetAdjustedTime();\n    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n    CAddress addrMe = GetLocalAddress(&addr);\n    RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n    printf(\"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n    PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
      "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);",
      "uint64_t nLocalHostNonce = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PushMessage",
          "args": [
            "\"version\"",
            "PROTOCOL_VERSION",
            "nLocalServices",
            "nTime",
            "addrYou",
            "addrMe",
            "nLocalHostNonce",
            "FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>())",
            "nBestHeight"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "PushMessage",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "537-550",
          "snippet": "void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n    {\n        try\n        {\n            BeginMessage(pszCommand);\n            vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n            EndMessage();\n        }\n        catch (...)\n        {\n            AbortMessage();\n            throw;\n        }\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushMessage(const char* pszCommand, const T1& a1, const T2& a2, const T3& a3, const T4& a4, const T5& a5, const T6& a6, const T7& a7, const T8& a8)\n      {\n          try\n          {\n              BeginMessage(pszCommand);\n              vSend << a1 << a2 << a3 << a4 << a5 << a6 << a7 << a8;\n              EndMessage();\n          }\n          catch (...)\n          {\n              AbortMessage();\n              throw;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FormatSubVersion",
          "args": [
            "CLIENT_NAME",
            "CLIENT_VERSION",
            "std::vector<string>()"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "FormatSubVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1294-1303",
          "snippet": "std::string FormatSubVersion(const std::string& name, uint nClientVersion,\n  const std::vector<std::string>& comments) {\n    std::ostringstream ss;\n    ss << \"/\";\n    ss << name << \":\" << FormatVersion(nClientVersion);\n    if (!comments.empty())\n        ss << \"(\" << boost::algorithm::join(comments, \"; \") << \")\";\n    ss << \"/\";\n    return ss.str();\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstd::string FormatSubVersion(const std::string& name, uint nClientVersion,\n  const std::vector<std::string>& comments) {\n    std::ostringstream ss;\n    ss << \"/\";\n    ss << name << \":\" << FormatVersion(nClientVersion);\n    if (!comments.empty())\n        ss << \"(\" << boost::algorithm::join(comments, \"; \") << \")\";\n    ss << \"/\";\n    return ss.str();\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::vector<string>",
          "args": [],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\"",
            "PROTOCOL_VERSION",
            "nBestHeight",
            "addrMe.ToString().c_str()",
            "addrYou.ToString().c_str()",
            "addr.ToString().c_str()"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RAND_bytes",
          "args": [
            "(unsigned char*)&nLocalHostNonce",
            "sizeof(nLocalHostNonce)"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLocalAddress",
          "args": [
            "&addr"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "GetLocalAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "131-142",
          "snippet": "CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
            "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\n\nCAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CAddress",
          "args": [
            "CService(\"0.0.0.0\",0)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "\"0.0.0.0\"",
            "0"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProxy",
          "args": [
            "addr"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "IsProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "475-482",
          "snippet": "bool IsProxy(const CNetAddr &addr) {\n    LOCK(cs_proxyInfos);\n    for (int i = 0; i < NET_MAX; i++) {\n        if (proxyInfo[i].second && (addr == (CNetAddr)proxyInfo[i].first))\n            return true;\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static proxyType proxyInfo[NET_MAX];",
            "static CCriticalSection cs_proxyInfos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType proxyInfo[NET_MAX];\nstatic CCriticalSection cs_proxyInfos;\n\nbool IsProxy(const CNetAddr &addr) {\n    LOCK(cs_proxyInfos);\n    for (int i = 0; i < NET_MAX; i++) {\n        if (proxyInfo[i].second && (addr == (CNetAddr)proxyInfo[i].first))\n            return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.IsRoutable",
          "args": [],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\nuint64_t nLocalHostNonce = 0;\n\nCNode {\n  void CNode::PushVersion()\n  {\n      int64 nTime = GetAdjustedTime();\n      CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n      CAddress addrMe = GetLocalAddress(&addr);\n      RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n      printf(\"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n      PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                  nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight);\n  }\n}"
  },
  {
    "function_name": "Cleanup",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "562-564",
    "snippet": "void CNode::Cleanup()\n{\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::Cleanup()\n  {\n  }\n}"
  },
  {
    "function_name": "CloseSocketDisconnect",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "550-560",
    "snippet": "void CNode::CloseSocketDisconnect()\n{\n    fDisconnect = true;\n    if (hSocket != INVALID_SOCKET)\n    {\n        printf(\"disconnecting node %s\\n\", addrName.c_str());\n        closesocket(hSocket);\n        hSocket = INVALID_SOCKET;\n        vRecv.clear();\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vRecv.clear",
          "args": [],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"disconnecting node %s\\n\"",
            "addrName.c_str()"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrName.c_str",
          "args": [],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::CloseSocketDisconnect()\n  {\n      fDisconnect = true;\n      if (hSocket != INVALID_SOCKET)\n      {\n          printf(\"disconnecting node %s\\n\", addrName.c_str());\n          closesocket(hSocket);\n          hSocket = INVALID_SOCKET;\n          vRecv.clear();\n      }\n  }\n}"
  },
  {
    "function_name": "AddressCurrentlyConnected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "450-453",
    "snippet": "void AddressCurrentlyConnected(const CService& addr)\n{\n    addrman.Connected(addr);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CAddrMan addrman;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addrman.Connected",
          "args": [
            "addr"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "Connected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "492-500",
          "snippet": "void Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Connected_(addr, nTime);\n            Check();\n        }\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nvoid Connected(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Connected_(addr, nTime);\n            Check();\n        }\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCAddrMan addrman;\n\nvoid AddressCurrentlyConnected(const CService& addr)\n{\n    addrman.Connected(addr);\n}"
  },
  {
    "function_name": "ThreadGetMyExternalIP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "433-444",
    "snippet": "void ThreadGetMyExternalIP(void* parg)\n{\n    // Make this thread recognisable as the external IP detection thread\n    RenameThread(\"hal-ext-ip\");\n\n    CNetAddr addrLocalHost;\n    if (GetMyExternalIP(addrLocalHost))\n    {\n        printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n        AddLocal(addrLocalHost, LOCAL_HTTP);\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "void ThreadMessageHandler2(void* parg);",
      "void ThreadSocketHandler2(void* parg);",
      "void ThreadOpenConnections2(void* parg);",
      "void ThreadOpenAddedConnections2(void* parg);",
      "void ThreadDNSAddressSeed2(void* parg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddLocal",
          "args": [
            "addrLocalHost",
            "LOCAL_HTTP"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "AddLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "252-255",
          "snippet": "bool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GetMyExternalIP() returned %s\\n\"",
            "addrLocalHost.ToStringIP().c_str()"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrLocalHost.ToStringIP",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIP",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "783-809",
          "snippet": "std::string CNetAddr::ToStringIP() const\n{\n    if (IsTor())\n        return EncodeBase32(&ip[6], 10) + \".onion\";\n    if (IsI2P())\n        return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n    CService serv(*this, 0);\n#ifdef USE_IPV6\n    struct sockaddr_storage sockaddr;\n#else\n    struct sockaddr sockaddr;\n#endif\n    socklen_t socklen = sizeof(sockaddr);\n    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n        char name[1025] = \"\";\n        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n            return std::string(name);\n    }\n    if (IsIPv4())\n        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n    else\n        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::string CNetAddr::ToStringIP() const\n  {\n      if (IsTor())\n          return EncodeBase32(&ip[6], 10) + \".onion\";\n      if (IsI2P())\n          return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n      CService serv(*this, 0);\n  #ifdef USE_IPV6\n      struct sockaddr_storage sockaddr;\n  #else\n      struct sockaddr sockaddr;\n  #endif\n      socklen_t socklen = sizeof(sockaddr);\n      if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n          char name[1025] = \"\";\n          if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n              return std::string(name);\n      }\n      if (IsIPv4())\n          return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n      else\n          return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                           GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                           GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                           GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                           GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetMyExternalIP",
          "args": [
            "addrLocalHost"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadGetMyExternalIP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "433-444",
          "snippet": "void ThreadGetMyExternalIP(void* parg)\n{\n    // Make this thread recognisable as the external IP detection thread\n    RenameThread(\"hal-ext-ip\");\n\n    CNetAddr addrLocalHost;\n    if (GetMyExternalIP(addrLocalHost))\n    {\n        printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n        AddLocal(addrLocalHost, LOCAL_HTTP);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "RenameThread",
          "args": [
            "\"hal-ext-ip\""
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "RenameThread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1329-1348",
          "snippet": "void RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RenameThread(const char* name)\n{\n#if defined(PR_SET_NAME)\n    // Only the first 15 characters are used (16 - NUL terminator)\n    ::prctl(PR_SET_NAME, name, 0, 0, 0);\n#elif 0 && (defined(__FreeBSD__) || defined(__OpenBSD__))\n    // TODO: This is currently disabled because it needs to be verified to work\n    //       on FreeBSD or OpenBSD first. When verified the '0 &&' part can be\n    //       removed.\n    pthread_set_name_np(pthread_self(), name);\n\n// This is XCode 10.6-and-later; bring back if we drop 10.5 support:\n// #elif defined(MAC_OSX)\n//    pthread_setname_np(name);\n\n#else\n    // Prevent warnings for unused parameters...\n    (void)name;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid ThreadMessageHandler2(void* parg);\nvoid ThreadSocketHandler2(void* parg);\nvoid ThreadOpenConnections2(void* parg);\nvoid ThreadOpenAddedConnections2(void* parg);\nvoid ThreadDNSAddressSeed2(void* parg);\n\nvoid ThreadGetMyExternalIP(void* parg)\n{\n    // Make this thread recognisable as the external IP detection thread\n    RenameThread(\"hal-ext-ip\");\n\n    CNetAddr addrLocalHost;\n    if (GetMyExternalIP(addrLocalHost))\n    {\n        printf(\"GetMyExternalIP() returned %s\\n\", addrLocalHost.ToStringIP().c_str());\n        AddLocal(addrLocalHost, LOCAL_HTTP);\n    }\n}"
  },
  {
    "function_name": "GetMyExternalIP",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "354-431",
    "snippet": "bool GetMyExternalIP(CNetAddr& ipRet) {\n    CService addrConnect;\n    bool addrConnectValid, pszGetMode;\n    const char* pszGet = NULL;\n    const char* pszKeyword = NULL;\n    uint nLookup;\n\n    for(nLookup = 0; nLookup < 4; nLookup++) {\n\n        /* Public IP detectors with their IPs in case DNS isn't available;\n         * DynDNS CheckIP: nLookup 1 to 2, Google AppSpot: nLookup 3 */\n\n        switch(nLookup) {\n\n            case(0):\n                addrConnect = CService(\"91.198.22.70\", 80);\n                addrConnectValid = true;\n                pszGetMode = true;\n                break;\n\n            case(1):\n                addrConnect = CService(\"216.146.38.70\", 80);\n                addrConnectValid = true;\n                pszGetMode = true;\n                break;\n\n            case(2):\n                addrConnect = CService(\"checkip.dyndns.org\", 80, true);\n                if(addrConnect.IsValid())\n                  addrConnectValid = true;\n                else\n                  addrConnectValid = false;\n                pszGetMode = true;\n                break;\n\n            case(3):\n                addrConnect = CService(\"ip.appspot.com\", 80, true);\n                if(addrConnect.IsValid())\n                  addrConnectValid = true;\n                else\n                  addrConnectValid = false;\n                pszGetMode = false;\n                break;\n\n            default:\n                return(false);\n\n        }\n\n        if(pszGetMode) {\n            \n            pszGet = \"GET / HTTP/1.1\\r\\n\"\n                     \"Host: checkip.dyndns.org\\r\\n\"\n                     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\";\n\n            pszKeyword = \"Address:\";\n\n        } else {\n\n            pszGet = \"GET / HTTP/1.1\\r\\n\"\n                     \"Host: ip.appspot.com\\r\\n\"\n                     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\";\n\n            pszKeyword = NULL;\n\n        }\n\n        if(addrConnectValid)\n          if(GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n            return(true);\n    }\n\n    return(false);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetMyExternalIP2",
          "args": [
            "addrConnect",
            "pszGet",
            "pszKeyword",
            "ipRet"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "GetMyExternalIP2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "307-351",
          "snippet": "bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const char* pszKeyword, CNetAddr& ipRet)\n{\n    SOCKET hSocket;\n    if (!ConnectSocket(addrConnect, hSocket))\n        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n\n    send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n\n    string strLine;\n    while (RecvLine(hSocket, strLine))\n    {\n        if (strLine.empty()) // HTTP response is separated from headers by blank line\n        {\n            while (true)\n            {\n                if (!RecvLine(hSocket, strLine))\n                {\n                    closesocket(hSocket);\n                    return false;\n                }\n                if (pszKeyword == NULL)\n                    break;\n                if (strLine.find(pszKeyword) != string::npos)\n                {\n                    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n                    break;\n                }\n            }\n            closesocket(hSocket);\n            if (strLine.find(\"<\") != string::npos)\n                strLine = strLine.substr(0, strLine.find(\"<\"));\n            strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n            while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                strLine.resize(strLine.size()-1);\n            CService addr(strLine,0,true);\n            printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n            if (!addr.IsValid() || !addr.IsRoutable())\n                return false;\n            ipRet.SetIP(addr);\n            return true;\n        }\n    }\n    closesocket(hSocket);\n    return error(\"GetMyExternalIP() : connection closed\");\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const char* pszKeyword, CNetAddr& ipRet)\n{\n    SOCKET hSocket;\n    if (!ConnectSocket(addrConnect, hSocket))\n        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n\n    send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n\n    string strLine;\n    while (RecvLine(hSocket, strLine))\n    {\n        if (strLine.empty()) // HTTP response is separated from headers by blank line\n        {\n            while (true)\n            {\n                if (!RecvLine(hSocket, strLine))\n                {\n                    closesocket(hSocket);\n                    return false;\n                }\n                if (pszKeyword == NULL)\n                    break;\n                if (strLine.find(pszKeyword) != string::npos)\n                {\n                    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n                    break;\n                }\n            }\n            closesocket(hSocket);\n            if (strLine.find(\"<\") != string::npos)\n                strLine = strLine.substr(0, strLine.find(\"<\"));\n            strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n            while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                strLine.resize(strLine.size()-1);\n            CService addr(strLine,0,true);\n            printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n            if (!addr.IsValid() || !addr.IsRoutable())\n                return false;\n            ipRet.SetIP(addr);\n            return true;\n        }\n    }\n    closesocket(hSocket);\n    return error(\"GetMyExternalIP() : connection closed\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrConnect.IsValid",
          "args": [],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "\"ip.appspot.com\"",
            "80",
            "true"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "CService",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1089-1095",
          "snippet": "CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n{\n    Init();\n    CService ip;\n    if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n        *this = ip;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n  {\n      Init();\n      CService ip;\n      if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n          *this = ip;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "\"216.146.38.70\"",
            "80"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool GetMyExternalIP(CNetAddr& ipRet) {\n    CService addrConnect;\n    bool addrConnectValid, pszGetMode;\n    const char* pszGet = NULL;\n    const char* pszKeyword = NULL;\n    uint nLookup;\n\n    for(nLookup = 0; nLookup < 4; nLookup++) {\n\n        /* Public IP detectors with their IPs in case DNS isn't available;\n         * DynDNS CheckIP: nLookup 1 to 2, Google AppSpot: nLookup 3 */\n\n        switch(nLookup) {\n\n            case(0):\n                addrConnect = CService(\"91.198.22.70\", 80);\n                addrConnectValid = true;\n                pszGetMode = true;\n                break;\n\n            case(1):\n                addrConnect = CService(\"216.146.38.70\", 80);\n                addrConnectValid = true;\n                pszGetMode = true;\n                break;\n\n            case(2):\n                addrConnect = CService(\"checkip.dyndns.org\", 80, true);\n                if(addrConnect.IsValid())\n                  addrConnectValid = true;\n                else\n                  addrConnectValid = false;\n                pszGetMode = true;\n                break;\n\n            case(3):\n                addrConnect = CService(\"ip.appspot.com\", 80, true);\n                if(addrConnect.IsValid())\n                  addrConnectValid = true;\n                else\n                  addrConnectValid = false;\n                pszGetMode = false;\n                break;\n\n            default:\n                return(false);\n\n        }\n\n        if(pszGetMode) {\n            \n            pszGet = \"GET / HTTP/1.1\\r\\n\"\n                     \"Host: checkip.dyndns.org\\r\\n\"\n                     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\";\n\n            pszKeyword = \"Address:\";\n\n        } else {\n\n            pszGet = \"GET / HTTP/1.1\\r\\n\"\n                     \"Host: ip.appspot.com\\r\\n\"\n                     \"User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\\r\\n\"\n                     \"Connection: close\\r\\n\"\n                     \"\\r\\n\";\n\n            pszKeyword = NULL;\n\n        }\n\n        if(addrConnectValid)\n          if(GetMyExternalIP2(addrConnect, pszGet, pszKeyword, ipRet))\n            return(true);\n    }\n\n    return(false);\n}"
  },
  {
    "function_name": "GetMyExternalIP2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "307-351",
    "snippet": "bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const char* pszKeyword, CNetAddr& ipRet)\n{\n    SOCKET hSocket;\n    if (!ConnectSocket(addrConnect, hSocket))\n        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n\n    send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n\n    string strLine;\n    while (RecvLine(hSocket, strLine))\n    {\n        if (strLine.empty()) // HTTP response is separated from headers by blank line\n        {\n            while (true)\n            {\n                if (!RecvLine(hSocket, strLine))\n                {\n                    closesocket(hSocket);\n                    return false;\n                }\n                if (pszKeyword == NULL)\n                    break;\n                if (strLine.find(pszKeyword) != string::npos)\n                {\n                    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n                    break;\n                }\n            }\n            closesocket(hSocket);\n            if (strLine.find(\"<\") != string::npos)\n                strLine = strLine.substr(0, strLine.find(\"<\"));\n            strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n            while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                strLine.resize(strLine.size()-1);\n            CService addr(strLine,0,true);\n            printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n            if (!addr.IsValid() || !addr.IsRoutable())\n                return false;\n            ipRet.SetIP(addr);\n            return true;\n        }\n    }\n    closesocket(hSocket);\n    return error(\"GetMyExternalIP() : connection closed\");\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"GetMyExternalIP() : connection closed\""
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipRet.SetIP",
          "args": [
            "addr"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "SetIP",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "559-562",
          "snippet": "void CNetAddr::SetIP(const CNetAddr& ipIn)\n{\n    memcpy(ip, ipIn.ip, sizeof(ip));\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  void CNetAddr::SetIP(const CNetAddr& ipIn)\n  {\n      memcpy(ip, ipIn.ip, sizeof(ip));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.IsRoutable",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.IsValid",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"GetMyExternalIP() received [%s] %s\\n\"",
            "strLine.c_str()",
            "addr.ToString().c_str()"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.c_str",
          "args": [],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strLine.resize",
          "args": [
            "strLine.size()-1"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.size",
          "args": [],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "strLine[strLine.size()-1]"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strLine.substr",
          "args": [
            "strspn(strLine.c_str(), \" \\t\\n\\r\")"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "strLine.c_str()",
            "\" \\t\\n\\r\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strLine.c_str",
          "args": [],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strLine.substr",
          "args": [
            "0",
            "strLine.find(\"<\")"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strLine.find",
          "args": [
            "\"<\""
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.substr",
          "args": [
            "strLine.find(pszKeyword) + strlen(pszKeyword)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pszKeyword"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RecvLine",
          "args": [
            "hSocket",
            "strLine"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "RecvLine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "144-193",
          "snippet": "bool RecvLine(SOCKET hSocket, string& strLine)\n{\n    strLine = \"\";\n    while (true)\n    {\n        char c;\n        int nBytes = recv(hSocket, &c, 1, 0);\n        if (nBytes > 0)\n        {\n            if (c == '\\n')\n                continue;\n            if (c == '\\r')\n                return true;\n            strLine += c;\n            if (strLine.size() >= 9000)\n                return true;\n        }\n        else if (nBytes <= 0)\n        {\n            if (fShutdown)\n                return false;\n            if (nBytes < 0)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr == WSAEMSGSIZE)\n                    continue;\n                if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n                {\n                    MilliSleep(10);\n                    continue;\n                }\n            }\n            if (!strLine.empty())\n                return true;\n            if (nBytes == 0)\n            {\n                // socket closed\n                printf(\"socket closed\\n\");\n                return false;\n            }\n            else\n            {\n                // socket error\n                int nErr = WSAGetLastError();\n                printf(\"recv failed: %d\\n\", nErr);\n                return false;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool RecvLine(SOCKET hSocket, string& strLine)\n{\n    strLine = \"\";\n    while (true)\n    {\n        char c;\n        int nBytes = recv(hSocket, &c, 1, 0);\n        if (nBytes > 0)\n        {\n            if (c == '\\n')\n                continue;\n            if (c == '\\r')\n                return true;\n            strLine += c;\n            if (strLine.size() >= 9000)\n                return true;\n        }\n        else if (nBytes <= 0)\n        {\n            if (fShutdown)\n                return false;\n            if (nBytes < 0)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr == WSAEMSGSIZE)\n                    continue;\n                if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n                {\n                    MilliSleep(10);\n                    continue;\n                }\n            }\n            if (!strLine.empty())\n                return true;\n            if (nBytes == 0)\n            {\n                // socket closed\n                printf(\"socket closed\\n\");\n                return false;\n            }\n            else\n            {\n                // socket error\n                int nErr = WSAGetLastError();\n                printf(\"recv failed: %d\\n\", nErr);\n                return false;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strLine.empty",
          "args": [],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "hSocket",
            "pszGet",
            "strlen(pszGet)",
            "MSG_NOSIGNAL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pszGet"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"GetMyExternalIP() : connection to %s failed\"",
            "addrConnect.ToString().c_str()"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConnectSocket",
          "args": [
            "addrConnect",
            "hSocket"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const char* pszKeyword, CNetAddr& ipRet)\n{\n    SOCKET hSocket;\n    if (!ConnectSocket(addrConnect, hSocket))\n        return error(\"GetMyExternalIP() : connection to %s failed\", addrConnect.ToString().c_str());\n\n    send(hSocket, pszGet, strlen(pszGet), MSG_NOSIGNAL);\n\n    string strLine;\n    while (RecvLine(hSocket, strLine))\n    {\n        if (strLine.empty()) // HTTP response is separated from headers by blank line\n        {\n            while (true)\n            {\n                if (!RecvLine(hSocket, strLine))\n                {\n                    closesocket(hSocket);\n                    return false;\n                }\n                if (pszKeyword == NULL)\n                    break;\n                if (strLine.find(pszKeyword) != string::npos)\n                {\n                    strLine = strLine.substr(strLine.find(pszKeyword) + strlen(pszKeyword));\n                    break;\n                }\n            }\n            closesocket(hSocket);\n            if (strLine.find(\"<\") != string::npos)\n                strLine = strLine.substr(0, strLine.find(\"<\"));\n            strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n            while (strLine.size() > 0 && isspace(strLine[strLine.size()-1]))\n                strLine.resize(strLine.size()-1);\n            CService addr(strLine,0,true);\n            printf(\"GetMyExternalIP() received [%s] %s\\n\", strLine.c_str(), addr.ToString().c_str());\n            if (!addr.IsValid() || !addr.IsRoutable())\n                return false;\n            ipRet.SetIP(addr);\n            return true;\n        }\n    }\n    closesocket(hSocket);\n    return error(\"GetMyExternalIP() : connection closed\");\n}"
  },
  {
    "function_name": "IsReachable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "300-305",
    "snippet": "bool IsReachable(const CNetAddr& addr)\n{\n    LOCK(cs_mapLocalHost);\n    enum Network net = addr.GetNetwork();\n    return vfReachable[net] && !vfLimited[net];\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CCriticalSection cs_mapLocalHost;",
      "static bool vfReachable[NET_MAX] = {};",
      "static bool vfLimited[NET_MAX] = {};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr.GetNetwork",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "GetNetwork",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "766-781",
          "snippet": "enum Network CNetAddr::GetNetwork() const\n{\n    if (!IsRoutable())\n        return NET_UNROUTABLE;\n\n    if (IsIPv4())\n        return NET_IPV4;\n\n    if (IsTor())\n        return NET_TOR;\n\n    if (IsI2P())\n        return NET_I2P;\n\n    return NET_IPV6;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  enum Network CNetAddr::GetNetwork() const\n  {\n      if (!IsRoutable())\n          return NET_UNROUTABLE;\n  \n      if (IsIPv4())\n          return NET_IPV4;\n  \n      if (IsTor())\n          return NET_TOR;\n  \n      if (IsI2P())\n          return NET_I2P;\n  \n      return NET_IPV6;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic bool vfReachable[NET_MAX] = {};\nstatic bool vfLimited[NET_MAX] = {};\n\nbool IsReachable(const CNetAddr& addr)\n{\n    LOCK(cs_mapLocalHost);\n    enum Network net = addr.GetNetwork();\n    return vfReachable[net] && !vfLimited[net];\n}"
  },
  {
    "function_name": "IsLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "293-297",
    "snippet": "bool IsLocal(const CService& addr)\n{\n    LOCK(cs_mapLocalHost);\n    return mapLocalHost.count(addr) > 0;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CCriticalSection cs_mapLocalHost;",
      "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapLocalHost.count",
          "args": [
            "addr"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool IsLocal(const CService& addr)\n{\n    LOCK(cs_mapLocalHost);\n    return mapLocalHost.count(addr) > 0;\n}"
  },
  {
    "function_name": "SeenLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "278-290",
    "snippet": "bool SeenLocal(const CService& addr)\n{\n    {\n        LOCK(cs_mapLocalHost);\n        if (mapLocalHost.count(addr) == 0)\n            return false;\n        mapLocalHost[addr].nScore++;\n    }\n\n    AdvertizeLocal();\n\n    return true;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CCriticalSection cs_mapLocalHost;",
      "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvertizeLocal",
          "args": [],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "AdvertizeLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "197-212",
          "snippet": "void static AdvertizeLocal()\n{\n    LOCK(cs_vNodes);\n    BOOST_FOREACH(CNode* pnode, vNodes)\n    {\n        if (pnode->fSuccessfullyConnected)\n        {\n            CAddress addrLocal = GetLocalAddress(&pnode->addr);\n            if (addrLocal.IsRoutable() && (CService)addrLocal != (CService)pnode->addrLocal)\n            {\n                pnode->PushAddress(addrLocal);\n                pnode->addrLocal = addrLocal;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "vector<CNode*> vNodes;",
            "CCriticalSection cs_vNodes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\n\nvoid static AdvertizeLocal()\n{\n    LOCK(cs_vNodes);\n    BOOST_FOREACH(CNode* pnode, vNodes)\n    {\n        if (pnode->fSuccessfullyConnected)\n        {\n            CAddress addrLocal = GetLocalAddress(&pnode->addr);\n            if (addrLocal.IsRoutable() && (CService)addrLocal != (CService)pnode->addrLocal)\n            {\n                pnode->PushAddress(addrLocal);\n                pnode->addrLocal = addrLocal;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapLocalHost.count",
          "args": [
            "addr"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool SeenLocal(const CService& addr)\n{\n    {\n        LOCK(cs_mapLocalHost);\n        if (mapLocalHost.count(addr) == 0)\n            return false;\n        mapLocalHost[addr].nScore++;\n    }\n\n    AdvertizeLocal();\n\n    return true;\n}"
  },
  {
    "function_name": "IsLimited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "272-275",
    "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsLimited",
          "args": [
            "addr.GetNetwork()"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "IsLimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "272-275",
          "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "addr.GetNetwork",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "GetNetwork",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "766-781",
          "snippet": "enum Network CNetAddr::GetNetwork() const\n{\n    if (!IsRoutable())\n        return NET_UNROUTABLE;\n\n    if (IsIPv4())\n        return NET_IPV4;\n\n    if (IsTor())\n        return NET_TOR;\n\n    if (IsI2P())\n        return NET_I2P;\n\n    return NET_IPV6;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  enum Network CNetAddr::GetNetwork() const\n  {\n      if (!IsRoutable())\n          return NET_UNROUTABLE;\n  \n      if (IsIPv4())\n          return NET_IPV4;\n  \n      if (IsTor())\n          return NET_TOR;\n  \n      if (IsI2P())\n          return NET_I2P;\n  \n      return NET_IPV6;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}"
  },
  {
    "function_name": "IsLimited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "266-270",
    "snippet": "bool IsLimited(enum Network net)\n{\n    LOCK(cs_mapLocalHost);\n    return vfLimited[net];\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CCriticalSection cs_mapLocalHost;",
      "static bool vfLimited[NET_MAX] = {};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic bool vfLimited[NET_MAX] = {};\n\nbool IsLimited(enum Network net)\n{\n    LOCK(cs_mapLocalHost);\n    return vfLimited[net];\n}"
  },
  {
    "function_name": "SetLimited",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "258-264",
    "snippet": "void SetLimited(enum Network net, bool fLimited)\n{\n    if (net == NET_UNROUTABLE)\n        return;\n    LOCK(cs_mapLocalHost);\n    vfLimited[net] = fLimited;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CCriticalSection cs_mapLocalHost;",
      "static bool vfLimited[NET_MAX] = {};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic bool vfLimited[NET_MAX] = {};\n\nvoid SetLimited(enum Network net, bool fLimited)\n{\n    if (net == NET_UNROUTABLE)\n        return;\n    LOCK(cs_mapLocalHost);\n    vfLimited[net] = fLimited;\n}"
  },
  {
    "function_name": "AddLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "252-255",
    "snippet": "bool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddLocal",
          "args": [
            "CService(addr, GetListenPort())",
            "nScore"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "AddLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "252-255",
          "snippet": "bool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "addr",
            "GetListenPort()"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetListenPort",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "GetListenPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "89-92",
          "snippet": "unsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nunsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool AddLocal(const CNetAddr &addr, int nScore)\n{\n    return AddLocal(CService(addr, GetListenPort()), nScore);\n}"
  },
  {
    "function_name": "AddLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "223-250",
    "snippet": "bool AddLocal(const CService& addr, int nScore)\n{\n    if (!addr.IsRoutable())\n        return false;\n\n    if (!fDiscover && nScore < LOCAL_MANUAL)\n        return false;\n\n    if (IsLimited(addr))\n        return false;\n\n    printf(\"AddLocal(%s,%i)\\n\", addr.ToString().c_str(), nScore);\n\n    {\n        LOCK(cs_mapLocalHost);\n        bool fAlready = mapLocalHost.count(addr) > 0;\n        LocalServiceInfo &info = mapLocalHost[addr];\n        if (!fAlready || nScore >= info.nScore) {\n            info.nScore = nScore + (fAlready ? 1 : 0);\n            info.nPort = addr.GetPort();\n        }\n        SetReachable(addr.GetNetwork());\n    }\n\n    AdvertizeLocal();\n\n    return true;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool fDiscover = true;",
      "static CCriticalSection cs_mapLocalHost;",
      "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AdvertizeLocal",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "AdvertizeLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "197-212",
          "snippet": "void static AdvertizeLocal()\n{\n    LOCK(cs_vNodes);\n    BOOST_FOREACH(CNode* pnode, vNodes)\n    {\n        if (pnode->fSuccessfullyConnected)\n        {\n            CAddress addrLocal = GetLocalAddress(&pnode->addr);\n            if (addrLocal.IsRoutable() && (CService)addrLocal != (CService)pnode->addrLocal)\n            {\n                pnode->PushAddress(addrLocal);\n                pnode->addrLocal = addrLocal;\n            }\n        }\n    }\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "vector<CNode*> vNodes;",
            "CCriticalSection cs_vNodes;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\n\nvoid static AdvertizeLocal()\n{\n    LOCK(cs_vNodes);\n    BOOST_FOREACH(CNode* pnode, vNodes)\n    {\n        if (pnode->fSuccessfullyConnected)\n        {\n            CAddress addrLocal = GetLocalAddress(&pnode->addr);\n            if (addrLocal.IsRoutable() && (CService)addrLocal != (CService)pnode->addrLocal)\n            {\n                pnode->PushAddress(addrLocal);\n                pnode->addrLocal = addrLocal;\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetReachable",
          "args": [
            "addr.GetNetwork()"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.GetNetwork",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "GetNetwork",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "766-781",
          "snippet": "enum Network CNetAddr::GetNetwork() const\n{\n    if (!IsRoutable())\n        return NET_UNROUTABLE;\n\n    if (IsIPv4())\n        return NET_IPV4;\n\n    if (IsTor())\n        return NET_TOR;\n\n    if (IsI2P())\n        return NET_I2P;\n\n    return NET_IPV6;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  enum Network CNetAddr::GetNetwork() const\n  {\n      if (!IsRoutable())\n          return NET_UNROUTABLE;\n  \n      if (IsIPv4())\n          return NET_IPV4;\n  \n      if (IsTor())\n          return NET_TOR;\n  \n      if (IsI2P())\n          return NET_I2P;\n  \n      return NET_IPV6;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.GetPort",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "GetPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1097-1100",
          "snippet": "unsigned short CService::GetPort() const\n{\n    return port;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  unsigned short CService::GetPort() const\n  {\n      return port;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapLocalHost.count",
          "args": [
            "addr"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"AddLocal(%s,%i)\\n\"",
            "addr.ToString().c_str()",
            "nScore"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLimited",
          "args": [
            "addr"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "IsLimited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "272-275",
          "snippet": "bool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool IsLimited(const CNetAddr &addr)\n{\n    return IsLimited(addr.GetNetwork());\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.IsRoutable",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool fDiscover = true;\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool AddLocal(const CService& addr, int nScore)\n{\n    if (!addr.IsRoutable())\n        return false;\n\n    if (!fDiscover && nScore < LOCAL_MANUAL)\n        return false;\n\n    if (IsLimited(addr))\n        return false;\n\n    printf(\"AddLocal(%s,%i)\\n\", addr.ToString().c_str(), nScore);\n\n    {\n        LOCK(cs_mapLocalHost);\n        bool fAlready = mapLocalHost.count(addr) > 0;\n        LocalServiceInfo &info = mapLocalHost[addr];\n        if (!fAlready || nScore >= info.nScore) {\n            info.nScore = nScore + (fAlready ? 1 : 0);\n            info.nPort = addr.GetPort();\n        }\n        SetReachable(addr.GetNetwork());\n    }\n\n    AdvertizeLocal();\n\n    return true;\n}"
  },
  {
    "function_name": "SetReachable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "214-220",
    "snippet": "void SetReachable(enum Network net, bool fFlag)\n{\n    LOCK(cs_mapLocalHost);\n    vfReachable[net] = fFlag;\n    if (net == NET_IPV6 && fFlag)\n        vfReachable[NET_IPV4] = true;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CCriticalSection cs_mapLocalHost;",
      "static bool vfReachable[NET_MAX] = {};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic bool vfReachable[NET_MAX] = {};\n\nvoid SetReachable(enum Network net, bool fFlag)\n{\n    LOCK(cs_mapLocalHost);\n    vfReachable[net] = fFlag;\n    if (net == NET_IPV6 && fFlag)\n        vfReachable[NET_IPV4] = true;\n}"
  },
  {
    "function_name": "AdvertizeLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "197-212",
    "snippet": "void static AdvertizeLocal()\n{\n    LOCK(cs_vNodes);\n    BOOST_FOREACH(CNode* pnode, vNodes)\n    {\n        if (pnode->fSuccessfullyConnected)\n        {\n            CAddress addrLocal = GetLocalAddress(&pnode->addr);\n            if (addrLocal.IsRoutable() && (CService)addrLocal != (CService)pnode->addrLocal)\n            {\n                pnode->PushAddress(addrLocal);\n                pnode->addrLocal = addrLocal;\n            }\n        }\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "vector<CNode*> vNodes;",
      "CCriticalSection cs_vNodes;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pnode->PushAddress",
          "args": [
            "addrLocal"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "PushAddress",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "288-295",
          "snippet": "void PushAddress(const CAddress& addr)\n    {\n        // Known checking here is only to save space from duplicates.\n        // SendMessages will filter it again for knowns that were added\n        // after addresses were pushed.\n        if (addr.IsValid() && !setAddrKnown.count(addr))\n            vAddrToSend.push_back(addr);\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushAddress(const CAddress& addr)\n      {\n          // Known checking here is only to save space from duplicates.\n          // SendMessages will filter it again for knowns that were added\n          // after addresses were pushed.\n          if (addr.IsValid() && !setAddrKnown.count(addr))\n              vAddrToSend.push_back(addr);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrLocal.IsRoutable",
          "args": [],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLocalAddress",
          "args": [
            "&pnode->addr"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "GetLocalAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "131-142",
          "snippet": "CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
            "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\n\nCAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvector<CNode*> vNodes;\nCCriticalSection cs_vNodes;\n\nvoid static AdvertizeLocal()\n{\n    LOCK(cs_vNodes);\n    BOOST_FOREACH(CNode* pnode, vNodes)\n    {\n        if (pnode->fSuccessfullyConnected)\n        {\n            CAddress addrLocal = GetLocalAddress(&pnode->addr);\n            if (addrLocal.IsRoutable() && (CService)addrLocal != (CService)pnode->addrLocal)\n            {\n                pnode->PushAddress(addrLocal);\n                pnode->addrLocal = addrLocal;\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "RecvLine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "144-193",
    "snippet": "bool RecvLine(SOCKET hSocket, string& strLine)\n{\n    strLine = \"\";\n    while (true)\n    {\n        char c;\n        int nBytes = recv(hSocket, &c, 1, 0);\n        if (nBytes > 0)\n        {\n            if (c == '\\n')\n                continue;\n            if (c == '\\r')\n                return true;\n            strLine += c;\n            if (strLine.size() >= 9000)\n                return true;\n        }\n        else if (nBytes <= 0)\n        {\n            if (fShutdown)\n                return false;\n            if (nBytes < 0)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr == WSAEMSGSIZE)\n                    continue;\n                if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n                {\n                    MilliSleep(10);\n                    continue;\n                }\n            }\n            if (!strLine.empty())\n                return true;\n            if (nBytes == 0)\n            {\n                // socket closed\n                printf(\"socket closed\\n\");\n                return false;\n            }\n            else\n            {\n                // socket error\n                int nErr = WSAGetLastError();\n                printf(\"recv failed: %d\\n\", nErr);\n                return false;\n            }\n        }\n    }\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"recv failed: %d\\n\"",
            "nErr"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"socket closed\\n\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strLine.empty",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MilliSleep",
          "args": [
            "10"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "MilliSleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "132-139",
          "snippet": "inline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline void MilliSleep(int64_t n)\n{\n#if BOOST_VERSION >= 105000\n    boost::this_thread::sleep_for(boost::chrono::milliseconds(n));\n#else\n    boost::this_thread::sleep(boost::posix_time::milliseconds(n));\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "WSAGetLastError",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strLine.size",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "&c",
            "1",
            "0"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nbool RecvLine(SOCKET hSocket, string& strLine)\n{\n    strLine = \"\";\n    while (true)\n    {\n        char c;\n        int nBytes = recv(hSocket, &c, 1, 0);\n        if (nBytes > 0)\n        {\n            if (c == '\\n')\n                continue;\n            if (c == '\\r')\n                return true;\n            strLine += c;\n            if (strLine.size() >= 9000)\n                return true;\n        }\n        else if (nBytes <= 0)\n        {\n            if (fShutdown)\n                return false;\n            if (nBytes < 0)\n            {\n                int nErr = WSAGetLastError();\n                if (nErr == WSAEMSGSIZE)\n                    continue;\n                if (nErr == WSAEWOULDBLOCK || nErr == WSAEINTR || nErr == WSAEINPROGRESS)\n                {\n                    MilliSleep(10);\n                    continue;\n                }\n            }\n            if (!strLine.empty())\n                return true;\n            if (nBytes == 0)\n            {\n                // socket closed\n                printf(\"socket closed\\n\");\n                return false;\n            }\n            else\n            {\n                // socket error\n                int nErr = WSAGetLastError();\n                printf(\"recv failed: %d\\n\", nErr);\n                return false;\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "GetLocalAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "131-142",
    "snippet": "CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
      "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CAddress",
          "args": [
            "addr"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLocal",
          "args": [
            "addr",
            "paddrPeer"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "GetLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "106-128",
          "snippet": "bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n{\n    if (fNoListen)\n        return false;\n\n    int nBestScore = -1;\n    int nBestReachability = -1;\n    {\n        LOCK(cs_mapLocalHost);\n        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n        {\n            int nScore = (*it).second.nScore;\n            int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n            {\n                addr = CService((*it).first, (*it).second.nPort);\n                nBestReachability = nReachability;\n                nBestScore = nScore;\n            }\n        }\n    }\n    return nBestScore >= 0;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CCriticalSection cs_mapLocalHost;",
            "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n{\n    if (fNoListen)\n        return false;\n\n    int nBestScore = -1;\n    int nBestReachability = -1;\n    {\n        LOCK(cs_mapLocalHost);\n        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n        {\n            int nScore = (*it).second.nScore;\n            int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n            {\n                addr = CService((*it).first, (*it).second.nPort);\n                nBestReachability = nReachability;\n                nBestScore = nScore;\n            }\n        }\n    }\n    return nBestScore >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "\"0.0.0.0\"",
            "0"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\n\nCAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}"
  },
  {
    "function_name": "GetLocal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "106-128",
    "snippet": "bool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n{\n    if (fNoListen)\n        return false;\n\n    int nBestScore = -1;\n    int nBestReachability = -1;\n    {\n        LOCK(cs_mapLocalHost);\n        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n        {\n            int nScore = (*it).second.nScore;\n            int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n            {\n                addr = CService((*it).first, (*it).second.nPort);\n                nBestReachability = nReachability;\n                nBestScore = nScore;\n            }\n        }\n    }\n    return nBestScore >= 0;\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static CCriticalSection cs_mapLocalHost;",
      "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "(*it).first",
            "(*it).second.nPort"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "paddrPeer"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapLocalHost.end",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapLocalHost.begin",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapLocalHost"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool GetLocal(CService& addr, const CNetAddr *paddrPeer)\n{\n    if (fNoListen)\n        return false;\n\n    int nBestScore = -1;\n    int nBestReachability = -1;\n    {\n        LOCK(cs_mapLocalHost);\n        for (map<CNetAddr, LocalServiceInfo>::iterator it = mapLocalHost.begin(); it != mapLocalHost.end(); it++)\n        {\n            int nScore = (*it).second.nScore;\n            int nReachability = (*it).first.GetReachabilityFrom(paddrPeer);\n            if (nReachability > nBestReachability || (nReachability == nBestReachability && nScore > nBestScore))\n            {\n                addr = CService((*it).first, (*it).second.nPort);\n                nBestReachability = nReachability;\n                nBestScore = nScore;\n            }\n        }\n    }\n    return nBestScore >= 0;\n}"
  },
  {
    "function_name": "PushGetBlocks",
    "container": "CNode",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "94-103",
    "snippet": "void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n{\n    // Filter out duplicate requests\n    if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n        return;\n    pindexLastGetBlocksBegin = pindexBegin;\n    hashLastGetBlocksEnd = hashEnd;\n\n    PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PushMessage",
          "args": [
            "\"getblocks\"",
            "CBlockLocator(pindexBegin)",
            "hashEnd"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "PushMessage",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "441-454",
          "snippet": "void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n    {\n        try\n        {\n            BeginMessage(pszCommand);\n            vSend << a1 << a2;\n            EndMessage();\n        }\n        catch (...)\n        {\n            AbortMessage();\n            throw;\n        }\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushMessage(const char* pszCommand, const T1& a1, const T2& a2)\n      {\n          try\n          {\n              BeginMessage(pszCommand);\n              vSend << a1 << a2;\n              EndMessage();\n          }\n          catch (...)\n          {\n              AbortMessage();\n              throw;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBlockLocator",
          "args": [
            "pindexBegin"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "Set",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1590-1605",
          "snippet": "void Set(const CBlockIndex* pindex)\n    {\n        vHave.clear();\n        int nStep = 1;\n        while (pindex)\n        {\n            vHave.push_back(pindex->GetBlockHash());\n\n            // Exponentially larger steps back\n            for (int i = 0; pindex && i < nStep; i++)\n                pindex = pindex->pprev;\n            if (vHave.size() > 10)\n                nStep *= 2;\n        }\n        vHave.push_back((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  void Set(const CBlockIndex* pindex)\n      {\n          vHave.clear();\n          int nStep = 1;\n          while (pindex)\n          {\n              vHave.push_back(pindex->GetBlockHash());\n  \n              // Exponentially larger steps back\n              for (int i = 0; pindex && i < nStep; i++)\n                  pindex = pindex->pprev;\n              if (vHave.size() > 10)\n                  nStep *= 2;\n          }\n          vHave.push_back((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n  {\n      // Filter out duplicate requests\n      if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n          return;\n      pindexLastGetBlocksBegin = pindexBegin;\n      hashLastGetBlocksEnd = hashEnd;\n  \n      PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n  }\n}"
  },
  {
    "function_name": "GetListenPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "89-92",
    "snippet": "unsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-port\"",
            "GetDefaultPort()"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDefaultPort",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "GetDefaultPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.h",
          "lines": "19-22",
          "snippet": "static inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}",
          "includes": [
            "#include \"uint256.h\"",
            "#include <string>",
            "#include \"netbase.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include <string>\n#include \"netbase.h\"\n#include \"serialize.h\"\n\nstatic inline unsigned short GetDefaultPort(const bool testnet = fTestNet)\n{\n    return testnet ? 11108 : 21108;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nunsigned short GetListenPort()\n{\n    return (unsigned short)(GetArg(\"-port\", GetDefaultPort()));\n}"
  },
  {
    "function_name": "AddOneShot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
    "lines": "83-87",
    "snippet": "void AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}",
    "includes": [
      "#include <miniupnpc/upnperrors.h>",
      "#include <miniupnpc/upnpcommands.h>",
      "#include <miniupnpc/miniupnpc.h>",
      "#include <miniupnpc/miniwget.h>",
      "#include <string.h>",
      "#include \"ui_interface.h\"",
      "#include \"addrman.h\"",
      "#include \"strlcpy.h\"",
      "#include \"init.h\"",
      "#include \"ntp.h\"",
      "#include \"net.h\"",
      "#include \"db.h\"",
      "#include \"irc.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static deque<string> vOneShots;",
      "CCriticalSection cs_vOneShots;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vOneShots.push_back",
          "args": [
            "strDest"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vOneShots"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic deque<string> vOneShots;\nCCriticalSection cs_vOneShots;\n\nvoid AddOneShot(string strDest)\n{\n    LOCK(cs_vOneShots);\n    vOneShots.push_back(strDest);\n}"
  }
]