[
  {
    "function_name": "ApproximateOffsetOf",
    "container": "Table",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "248-273",
    "snippet": "uint64_t Table::ApproximateOffsetOf(const Slice& key) const {\n  Iterator* index_iter =\n      rep_->index_block->NewIterator(rep_->options.comparator);\n  index_iter->Seek(key);\n  uint64_t result;\n  if (index_iter->Valid()) {\n    BlockHandle handle;\n    Slice input = index_iter->value();\n    Status s = handle.DecodeFrom(&input);\n    if (s.ok()) {\n      result = handle.offset();\n    } else {\n      // Strange: we can't decode the block handle in the index block.\n      // We'll just return the offset of the metaindex block, which is\n      // close to the whole file size for this case.\n      result = rep_->metaindex_handle.offset();\n    }\n  } else {\n    // key is past the last key in the file.  Approximate the offset\n    // by returning the offset of the metaindex block (which is\n    // right near the end of the file).\n    result = rep_->metaindex_handle.offset();\n  }\n  delete index_iter;\n  return result;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rep_->metaindex_handle.offset",
          "args": [],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "offset",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "27-27",
          "snippet": "uint64_t offset() const { return offset_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t offset() const { return offset_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle.DecodeFrom",
          "args": [
            "&input"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "Footer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "44-64",
          "snippet": "Status Footer::DecodeFrom(Slice* input) {\n  const char* magic_ptr = input->data() + kEncodedLength - 8;\n  const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                          (static_cast<uint64_t>(magic_lo)));\n  if (magic != kTableMagicNumber) {\n    return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n  }\n\n  Status result = metaindex_handle_.DecodeFrom(input);\n  if (result.ok()) {\n    result = index_handle_.DecodeFrom(input);\n  }\n  if (result.ok()) {\n    // We skip over any leftover data (just padding for now) in \"input\"\n    const char* end = magic_ptr + 8;\n    *input = Slice(end, input->data() + input->size() - end);\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"table/format.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nFooter {\n  Status Footer::DecodeFrom(Slice* input) {\n    const char* magic_ptr = input->data() + kEncodedLength - 8;\n    const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n    const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n    const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                            (static_cast<uint64_t>(magic_lo)));\n    if (magic != kTableMagicNumber) {\n      return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n    }\n  \n    Status result = metaindex_handle_.DecodeFrom(input);\n    if (result.ok()) {\n      result = index_handle_.DecodeFrom(input);\n    }\n    if (result.ok()) {\n      // We skip over any leftover data (just padding for now) in \"input\"\n      const char* end = magic_ptr + 8;\n      *input = Slice(end, input->data() + input->size() - end);\n    }\n    return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iter->value",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "302-302",
          "snippet": "virtual Slice value() const { return iter_->value(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual Slice value() const { return iter_->value(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iter->Valid",
          "args": [],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "280-280",
          "snippet": "virtual bool Valid() const { return iter_->Valid(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual bool Valid() const { return iter_->Valid(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_iter->Seek",
          "args": [
            "key"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "281-286",
          "snippet": "virtual void Seek(const Slice& target) {\n    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n    std::string encoded;\n    AppendInternalKey(&encoded, ikey);\n    iter_->Seek(encoded);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void Seek(const Slice& target) {\n      ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n      std::string encoded;\n      AppendInternalKey(&encoded, ikey);\n      iter_->Seek(encoded);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rep_->index_block->NewIterator",
          "args": [
            "rep_->options.comparator"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  uint64_t Table::ApproximateOffsetOf(const Slice& key) const {\n    Iterator* index_iter =\n        rep_->index_block->NewIterator(rep_->options.comparator);\n    index_iter->Seek(key);\n    uint64_t result;\n    if (index_iter->Valid()) {\n      BlockHandle handle;\n      Slice input = index_iter->value();\n      Status s = handle.DecodeFrom(&input);\n      if (s.ok()) {\n        result = handle.offset();\n      } else {\n        // Strange: we can't decode the block handle in the index block.\n        // We'll just return the offset of the metaindex block, which is\n        // close to the whole file size for this case.\n        result = rep_->metaindex_handle.offset();\n      }\n    } else {\n      // key is past the last key in the file.  Approximate the offset\n      // by returning the offset of the metaindex block (which is\n      // right near the end of the file).\n      result = rep_->metaindex_handle.offset();\n    }\n    delete index_iter;\n    return result;\n  }\n}"
  },
  {
    "function_name": "InternalGet",
    "container": "Table",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "216-245",
    "snippet": "Status Table::InternalGet(const ReadOptions& options, const Slice& k,\n                          void* arg,\n                          void (*saver)(void*, const Slice&, const Slice&)) {\n  Status s;\n  Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);\n  iiter->Seek(k);\n  if (iiter->Valid()) {\n    Slice handle_value = iiter->value();\n    FilterBlockReader* filter = rep_->filter;\n    BlockHandle handle;\n    if (filter != NULL &&\n        handle.DecodeFrom(&handle_value).ok() &&\n        !filter->KeyMayMatch(handle.offset(), k)) {\n      // Not found\n    } else {\n      Iterator* block_iter = BlockReader(this, options, iiter->value());\n      block_iter->Seek(k);\n      if (block_iter->Valid()) {\n        (*saver)(arg, block_iter->key(), block_iter->value());\n      }\n      s = block_iter->status();\n      delete block_iter;\n    }\n  }\n  if (s.ok()) {\n    s = iiter->status();\n  }\n  delete iiter;\n  return s;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iiter->status",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "303-305",
          "snippet": "virtual Status status() const {\n    return status_.ok() ? iter_->status() : status_;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual Status status() const {\n      return status_.ok() ? iter_->status() : status_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg",
            "block_iter->key()",
            "block_iter->value()"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_iter->value",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "302-302",
          "snippet": "virtual Slice value() const { return iter_->value(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual Slice value() const { return iter_->value(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_iter->key",
          "args": [],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "292-300",
          "snippet": "virtual Slice key() const {\n    assert(Valid());\n    ParsedInternalKey key;\n    if (!ParseInternalKey(iter_->key(), &key)) {\n      status_ = Status::Corruption(\"malformed internal key\");\n      return Slice(\"corrupted key\");\n    }\n    return key.user_key;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual Slice key() const {\n      assert(Valid());\n      ParsedInternalKey key;\n      if (!ParseInternalKey(iter_->key(), &key)) {\n        status_ = Status::Corruption(\"malformed internal key\");\n        return Slice(\"corrupted key\");\n      }\n      return key.user_key;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_iter->Valid",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "280-280",
          "snippet": "virtual bool Valid() const { return iter_->Valid(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual bool Valid() const { return iter_->Valid(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block_iter->Seek",
          "args": [
            "k"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "281-286",
          "snippet": "virtual void Seek(const Slice& target) {\n    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n    std::string encoded;\n    AppendInternalKey(&encoded, ikey);\n    iter_->Seek(encoded);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void Seek(const Slice& target) {\n      ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n      std::string encoded;\n      AppendInternalKey(&encoded, ikey);\n      iter_->Seek(encoded);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BlockReader",
          "args": [
            "this",
            "options",
            "iiter->value()"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter->KeyMayMatch",
          "args": [
            "handle.offset()",
            "k"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "KeyMayMatch",
          "container": "leveldb_filterpolicy_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "121-124",
          "snippet": "virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n    return (*key_match_)(state_, key.data(), key.size(),\n                         filter.data(), filter.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_filterpolicy_t {\n  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n      return (*key_match_)(state_, key.data(), key.size(),\n                           filter.data(), filter.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle.offset",
          "args": [],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "offset",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "27-27",
          "snippet": "uint64_t offset() const { return offset_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t offset() const { return offset_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle.DecodeFrom",
          "args": [],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle.DecodeFrom",
          "args": [
            "&handle_value"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "Footer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "44-64",
          "snippet": "Status Footer::DecodeFrom(Slice* input) {\n  const char* magic_ptr = input->data() + kEncodedLength - 8;\n  const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                          (static_cast<uint64_t>(magic_lo)));\n  if (magic != kTableMagicNumber) {\n    return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n  }\n\n  Status result = metaindex_handle_.DecodeFrom(input);\n  if (result.ok()) {\n    result = index_handle_.DecodeFrom(input);\n  }\n  if (result.ok()) {\n    // We skip over any leftover data (just padding for now) in \"input\"\n    const char* end = magic_ptr + 8;\n    *input = Slice(end, input->data() + input->size() - end);\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"table/format.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nFooter {\n  Status Footer::DecodeFrom(Slice* input) {\n    const char* magic_ptr = input->data() + kEncodedLength - 8;\n    const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n    const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n    const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                            (static_cast<uint64_t>(magic_lo)));\n    if (magic != kTableMagicNumber) {\n      return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n    }\n  \n    Status result = metaindex_handle_.DecodeFrom(input);\n    if (result.ok()) {\n      result = index_handle_.DecodeFrom(input);\n    }\n    if (result.ok()) {\n      // We skip over any leftover data (just padding for now) in \"input\"\n      const char* end = magic_ptr + 8;\n      *input = Slice(end, input->data() + input->size() - end);\n    }\n    return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rep_->index_block->NewIterator",
          "args": [
            "rep_->options.comparator"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  Status Table::InternalGet(const ReadOptions& options, const Slice& k,\n                            void* arg,\n                            void (*saver)(void*, const Slice&, const Slice&)) {\n    Status s;\n    Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);\n    iiter->Seek(k);\n    if (iiter->Valid()) {\n      Slice handle_value = iiter->value();\n      FilterBlockReader* filter = rep_->filter;\n      BlockHandle handle;\n      if (filter != NULL &&\n          handle.DecodeFrom(&handle_value).ok() &&\n          !filter->KeyMayMatch(handle.offset(), k)) {\n        // Not found\n      } else {\n        Iterator* block_iter = BlockReader(this, options, iiter->value());\n        block_iter->Seek(k);\n        if (block_iter->Valid()) {\n          (*saver)(arg, block_iter->key(), block_iter->value());\n        }\n        s = block_iter->status();\n        delete block_iter;\n      }\n    }\n    if (s.ok()) {\n      s = iiter->status();\n    }\n    delete iiter;\n    return s;\n  }\n}"
  },
  {
    "function_name": "ReleaseBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "146-150",
    "snippet": "static void ReleaseBlock(void* arg, void* h) {\n  Cache* cache = reinterpret_cast<Cache*>(arg);\n  Cache::Handle* handle = reinterpret_cast<Cache::Handle*>(h);\n  cache->Release(handle);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache->Release",
          "args": [
            "handle"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "Release",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "302-305",
          "snippet": "virtual void Release(Handle* handle) {\n    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n    shard_[Shard(h->hash)].Release(handle);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual void Release(Handle* handle) {\n      LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);\n      shard_[Shard(h->hash)].Release(handle);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Cache::Handle*>",
          "args": [
            "h"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Cache*>",
          "args": [
            "arg"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nstatic void ReleaseBlock(void* arg, void* h) {\n  Cache* cache = reinterpret_cast<Cache*>(arg);\n  Cache::Handle* handle = reinterpret_cast<Cache::Handle*>(h);\n  cache->Release(handle);\n}"
  },
  {
    "function_name": "DeleteCachedBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "141-144",
    "snippet": "static void DeleteCachedBlock(const Slice& key, void* value) {\n  Block* block = reinterpret_cast<Block*>(value);\n  delete block;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<Block*>",
          "args": [
            "value"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nstatic void DeleteCachedBlock(const Slice& key, void* value) {\n  Block* block = reinterpret_cast<Block*>(value);\n  delete block;\n}"
  },
  {
    "function_name": "DeleteBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "137-139",
    "snippet": "static void DeleteBlock(void* arg, void* ignored) {\n  delete reinterpret_cast<Block*>(arg);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reinterpret_cast<Block*>",
          "args": [
            "arg"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nstatic void DeleteBlock(void* arg, void* ignored) {\n  delete reinterpret_cast<Block*>(arg);\n}"
  },
  {
    "function_name": "~Table",
    "container": "Table",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "133-135",
    "snippet": "Table::~Table() {\n  delete rep_;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  Table::~Table() {\n    delete rep_;\n  }\n}"
  },
  {
    "function_name": "ReadFilter",
    "container": "Table",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "113-131",
    "snippet": "void Table::ReadFilter(const Slice& filter_handle_value) {\n  Slice v = filter_handle_value;\n  BlockHandle filter_handle;\n  if (!filter_handle.DecodeFrom(&v).ok()) {\n    return;\n  }\n\n  // We might want to unify with ReadBlock() if we start\n  // requiring checksum verification in Table::Open.\n  ReadOptions opt;\n  BlockContents block;\n  if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {\n    return;\n  }\n  if (block.heap_allocated) {\n    rep_->filter_data = block.data.data();     // Will need to delete later\n  }\n  rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block.data.data",
          "args": [],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadBlock",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadBlock",
          "args": [
            "rep_->file",
            "opt",
            "filter_handle",
            "&block"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "ReadBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "66-143",
          "snippet": "Status ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"table/format.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nStatus ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_handle.DecodeFrom",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_handle.DecodeFrom",
          "args": [
            "&v"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "Footer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "44-64",
          "snippet": "Status Footer::DecodeFrom(Slice* input) {\n  const char* magic_ptr = input->data() + kEncodedLength - 8;\n  const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                          (static_cast<uint64_t>(magic_lo)));\n  if (magic != kTableMagicNumber) {\n    return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n  }\n\n  Status result = metaindex_handle_.DecodeFrom(input);\n  if (result.ok()) {\n    result = index_handle_.DecodeFrom(input);\n  }\n  if (result.ok()) {\n    // We skip over any leftover data (just padding for now) in \"input\"\n    const char* end = magic_ptr + 8;\n    *input = Slice(end, input->data() + input->size() - end);\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"table/format.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nFooter {\n  Status Footer::DecodeFrom(Slice* input) {\n    const char* magic_ptr = input->data() + kEncodedLength - 8;\n    const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n    const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n    const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                            (static_cast<uint64_t>(magic_lo)));\n    if (magic != kTableMagicNumber) {\n      return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n    }\n  \n    Status result = metaindex_handle_.DecodeFrom(input);\n    if (result.ok()) {\n      result = index_handle_.DecodeFrom(input);\n    }\n    if (result.ok()) {\n      // We skip over any leftover data (just padding for now) in \"input\"\n      const char* end = magic_ptr + 8;\n      *input = Slice(end, input->data() + input->size() - end);\n    }\n    return result;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  void Table::ReadFilter(const Slice& filter_handle_value) {\n    Slice v = filter_handle_value;\n    BlockHandle filter_handle;\n    if (!filter_handle.DecodeFrom(&v).ok()) {\n      return;\n    }\n  \n    // We might want to unify with ReadBlock() if we start\n    // requiring checksum verification in Table::Open.\n    ReadOptions opt;\n    BlockContents block;\n    if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {\n      return;\n    }\n    if (block.heap_allocated) {\n      rep_->filter_data = block.data.data();     // Will need to delete later\n    }\n    rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);\n  }\n}"
  },
  {
    "function_name": "ReadMeta",
    "container": "Table",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "87-111",
    "snippet": "void Table::ReadMeta(const Footer& footer) {\n  if (rep_->options.filter_policy == NULL) {\n    return;  // Do not need any metadata\n  }\n\n  // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates\n  // it is an empty block.\n  ReadOptions opt;\n  BlockContents contents;\n  if (!ReadBlock(rep_->file, opt, footer.metaindex_handle(), &contents).ok()) {\n    // Do not propagate errors since meta info is not needed for operation\n    return;\n  }\n  Block* meta = new Block(contents);\n\n  Iterator* iter = meta->NewIterator(BytewiseComparator());\n  std::string key = \"filter.\";\n  key.append(rep_->options.filter_policy->Name());\n  iter->Seek(key);\n  if (iter->Valid() && iter->key() == Slice(key)) {\n    ReadFilter(iter->value());\n  }\n  delete iter;\n  delete meta;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadFilter",
          "args": [
            "iter->value()"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFilter",
          "container": "Table",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
          "lines": "113-131",
          "snippet": "void Table::ReadFilter(const Slice& filter_handle_value) {\n  Slice v = filter_handle_value;\n  BlockHandle filter_handle;\n  if (!filter_handle.DecodeFrom(&v).ok()) {\n    return;\n  }\n\n  // We might want to unify with ReadBlock() if we start\n  // requiring checksum verification in Table::Open.\n  ReadOptions opt;\n  BlockContents block;\n  if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {\n    return;\n  }\n  if (block.heap_allocated) {\n    rep_->filter_data = block.data.data();     // Will need to delete later\n  }\n  rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  void Table::ReadFilter(const Slice& filter_handle_value) {\n    Slice v = filter_handle_value;\n    BlockHandle filter_handle;\n    if (!filter_handle.DecodeFrom(&v).ok()) {\n      return;\n    }\n  \n    // We might want to unify with ReadBlock() if we start\n    // requiring checksum verification in Table::Open.\n    ReadOptions opt;\n    BlockContents block;\n    if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {\n      return;\n    }\n    if (block.heap_allocated) {\n      rep_->filter_data = block.data.data();     // Will need to delete later\n    }\n    rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "302-302",
          "snippet": "virtual Slice value() const { return iter_->value(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual Slice value() const { return iter_->value(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "key"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "292-300",
          "snippet": "virtual Slice key() const {\n    assert(Valid());\n    ParsedInternalKey key;\n    if (!ParseInternalKey(iter_->key(), &key)) {\n      status_ = Status::Corruption(\"malformed internal key\");\n      return Slice(\"corrupted key\");\n    }\n    return key.user_key;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual Slice key() const {\n      assert(Valid());\n      ParsedInternalKey key;\n      if (!ParseInternalKey(iter_->key(), &key)) {\n        status_ = Status::Corruption(\"malformed internal key\");\n        return Slice(\"corrupted key\");\n      }\n      return key.user_key;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "280-280",
          "snippet": "virtual bool Valid() const { return iter_->Valid(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual bool Valid() const { return iter_->Valid(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Seek",
          "args": [
            "key"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "281-286",
          "snippet": "virtual void Seek(const Slice& target) {\n    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n    std::string encoded;\n    AppendInternalKey(&encoded, ikey);\n    iter_->Seek(encoded);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void Seek(const Slice& target) {\n      ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n      std::string encoded;\n      AppendInternalKey(&encoded, ikey);\n      iter_->Seek(encoded);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.append",
          "args": [
            "rep_->options.filter_policy->Name()"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rep_->options.filter_policy->Name",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "meta->NewIterator",
          "args": [
            "BytewiseComparator()"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BytewiseComparator",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "BytewiseComparatorImpl",
          "container": "BytewiseComparatorImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/comparator.cc",
          "lines": "19-19",
          "snippet": "BytewiseComparatorImpl() { }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdint.h>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/comparator.h\"\n#include <stdint.h>\n#include <algorithm>\n\nBytewiseComparatorImpl {\n  BytewiseComparatorImpl() { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadBlock",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadBlock",
          "args": [
            "rep_->file",
            "opt",
            "footer.metaindex_handle()",
            "&contents"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ReadBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "66-143",
          "snippet": "Status ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"table/format.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nStatus ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "footer.metaindex_handle",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  void Table::ReadMeta(const Footer& footer) {\n    if (rep_->options.filter_policy == NULL) {\n      return;  // Do not need any metadata\n    }\n  \n    // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates\n    // it is an empty block.\n    ReadOptions opt;\n    BlockContents contents;\n    if (!ReadBlock(rep_->file, opt, footer.metaindex_handle(), &contents).ok()) {\n      // Do not propagate errors since meta info is not needed for operation\n      return;\n    }\n    Block* meta = new Block(contents);\n  \n    Iterator* iter = meta->NewIterator(BytewiseComparator());\n    std::string key = \"filter.\";\n    key.append(rep_->options.filter_policy->Name());\n    iter->Seek(key);\n    if (iter->Valid() && iter->key() == Slice(key)) {\n      ReadFilter(iter->value());\n    }\n    delete iter;\n    delete meta;\n  }\n}"
  },
  {
    "function_name": "Open",
    "container": "Table",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
    "lines": "38-85",
    "snippet": "Status Table::Open(const Options& options,\n                   RandomAccessFile* file,\n                   uint64_t size,\n                   Table** table) {\n  *table = NULL;\n  if (size < Footer::kEncodedLength) {\n    return Status::InvalidArgument(\"file is too short to be an sstable\");\n  }\n\n  char footer_space[Footer::kEncodedLength];\n  Slice footer_input;\n  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,\n                        &footer_input, footer_space);\n  if (!s.ok()) return s;\n\n  Footer footer;\n  s = footer.DecodeFrom(&footer_input);\n  if (!s.ok()) return s;\n\n  // Read the index block\n  BlockContents contents;\n  Block* index_block = NULL;\n  if (s.ok()) {\n    s = ReadBlock(file, ReadOptions(), footer.index_handle(), &contents);\n    if (s.ok()) {\n      index_block = new Block(contents);\n    }\n  }\n\n  if (s.ok()) {\n    // We've successfully read the footer and the index block: we're\n    // ready to serve requests.\n    Rep* rep = new Table::Rep;\n    rep->options = options;\n    rep->file = file;\n    rep->metaindex_handle = footer.metaindex_handle();\n    rep->index_block = index_block;\n    rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);\n    rep->filter_data = NULL;\n    rep->filter = NULL;\n    *table = new Table(rep);\n    (*table)->ReadMeta(footer);\n  } else {\n    if (index_block) delete index_block;\n  }\n\n  return s;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/format.h\"",
      "#include \"table/filter_block.h\"",
      "#include \"table/block.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/comparator.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"leveldb/table.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "footer"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "options.block_cache->NewId",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "NewId",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "313-316",
          "snippet": "virtual uint64_t NewId() {\n    MutexLock l(&id_mutex_);\n    return ++(last_id_);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  virtual uint64_t NewId() {\n      MutexLock l(&id_mutex_);\n      return ++(last_id_);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "footer.metaindex_handle",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadBlock",
          "args": [
            "file",
            "ReadOptions()",
            "footer.index_handle()",
            "&contents"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ReadBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "66-143",
          "snippet": "Status ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"table/format.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nStatus ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}"
        }
      },
      {
        "call_info": {
          "callee": "footer.index_handle",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "footer.DecodeFrom",
          "args": [
            "&footer_input"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "Footer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "44-64",
          "snippet": "Status Footer::DecodeFrom(Slice* input) {\n  const char* magic_ptr = input->data() + kEncodedLength - 8;\n  const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                          (static_cast<uint64_t>(magic_lo)));\n  if (magic != kTableMagicNumber) {\n    return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n  }\n\n  Status result = metaindex_handle_.DecodeFrom(input);\n  if (result.ok()) {\n    result = index_handle_.DecodeFrom(input);\n  }\n  if (result.ok()) {\n    // We skip over any leftover data (just padding for now) in \"input\"\n    const char* end = magic_ptr + 8;\n    *input = Slice(end, input->data() + input->size() - end);\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"table/format.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nFooter {\n  Status Footer::DecodeFrom(Slice* input) {\n    const char* magic_ptr = input->data() + kEncodedLength - 8;\n    const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n    const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n    const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                            (static_cast<uint64_t>(magic_lo)));\n    if (magic != kTableMagicNumber) {\n      return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n    }\n  \n    Status result = metaindex_handle_.DecodeFrom(input);\n    if (result.ok()) {\n      result = index_handle_.DecodeFrom(input);\n    }\n    if (result.ok()) {\n      // We skip over any leftover data (just padding for now) in \"input\"\n      const char* end = magic_ptr + 8;\n      *input = Slice(end, input->data() + input->size() - end);\n    }\n    return result;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Read",
          "args": [
            "size - Footer::kEncodedLength",
            "Footer::kEncodedLength",
            "&footer_input",
            "footer_space"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "StringSource",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "120-131",
          "snippet": "virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const {\n    if (offset > contents_.size()) {\n      return Status::InvalidArgument(\"invalid Read offset\");\n    }\n    if (offset + n > contents_.size()) {\n      n = contents_.size() - offset;\n    }\n    memcpy(scratch, &contents_[offset], n);\n    *result = Slice(scratch, n);\n    return Status::OK();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nStringSource {\n  virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                         char* scratch) const {\n      if (offset > contents_.size()) {\n        return Status::InvalidArgument(\"invalid Read offset\");\n      }\n      if (offset + n > contents_.size()) {\n        n = contents_.size() - offset;\n      }\n      memcpy(scratch, &contents_[offset], n);\n      *result = Slice(scratch, n);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::InvalidArgument",
          "args": [
            "\"file is too short to be an sstable\""
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidArgument",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "44-46",
          "snippet": "static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kInvalidArgument, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kInvalidArgument, msg, msg2);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  Status Table::Open(const Options& options,\n                     RandomAccessFile* file,\n                     uint64_t size,\n                     Table** table) {\n    *table = NULL;\n    if (size < Footer::kEncodedLength) {\n      return Status::InvalidArgument(\"file is too short to be an sstable\");\n    }\n  \n    char footer_space[Footer::kEncodedLength];\n    Slice footer_input;\n    Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,\n                          &footer_input, footer_space);\n    if (!s.ok()) return s;\n  \n    Footer footer;\n    s = footer.DecodeFrom(&footer_input);\n    if (!s.ok()) return s;\n  \n    // Read the index block\n    BlockContents contents;\n    Block* index_block = NULL;\n    if (s.ok()) {\n      s = ReadBlock(file, ReadOptions(), footer.index_handle(), &contents);\n      if (s.ok()) {\n        index_block = new Block(contents);\n      }\n    }\n  \n    if (s.ok()) {\n      // We've successfully read the footer and the index block: we're\n      // ready to serve requests.\n      Rep* rep = new Table::Rep;\n      rep->options = options;\n      rep->file = file;\n      rep->metaindex_handle = footer.metaindex_handle();\n      rep->index_block = index_block;\n      rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);\n      rep->filter_data = NULL;\n      rep->filter = NULL;\n      *table = new Table(rep);\n      (*table)->ReadMeta(footer);\n    } else {\n      if (index_block) delete index_block;\n    }\n  \n    return s;\n  }\n}"
  }
]