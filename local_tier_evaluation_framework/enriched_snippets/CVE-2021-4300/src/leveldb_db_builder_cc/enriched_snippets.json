[
  {
    "function_name": "BuildTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/builder.cc",
    "lines": "17-86",
    "snippet": "Status BuildTable(const std::string& dbname,\n                  Env* env,\n                  const Options& options,\n                  TableCache* table_cache,\n                  Iterator* iter,\n                  FileMetaData* meta) {\n  Status s;\n  meta->file_size = 0;\n  iter->SeekToFirst();\n\n  std::string fname = TableFileName(dbname, meta->number);\n  if (iter->Valid()) {\n    WritableFile* file;\n    s = env->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n\n    TableBuilder* builder = new TableBuilder(options, file);\n    meta->smallest.DecodeFrom(iter->key());\n    for (; iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      meta->largest.DecodeFrom(key);\n      builder->Add(key, iter->value());\n    }\n\n    // Finish and check for builder errors\n    if (s.ok()) {\n      s = builder->Finish();\n      if (s.ok()) {\n        meta->file_size = builder->FileSize();\n        assert(meta->file_size > 0);\n      }\n    } else {\n      builder->Abandon();\n    }\n    delete builder;\n\n    // Finish and check for file errors\n    if (s.ok()) {\n      s = file->Sync();\n    }\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (s.ok()) {\n      // Verify that the table is usable\n      Iterator* it = table_cache->NewIterator(ReadOptions(),\n                                              meta->number,\n                                              meta->file_size);\n      s = it->status();\n      delete it;\n    }\n  }\n\n  // Check for input iterator errors\n  if (!iter->status().ok()) {\n    s = iter->status();\n  }\n\n  if (s.ok() && meta->file_size > 0) {\n    // Keep it\n  } else {\n    env->DeleteFile(fname);\n  }\n  return s;\n}",
    "includes": [
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"leveldb/db.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/builder.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env->DeleteFile",
          "args": [
            "fname"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "801-812",
          "snippet": "Status Win32Env::DeleteFile( const std::string& fname )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    if(!::DeleteFileW(wpath.c_str())) {\n        sRet = Status::IOError(path, \"Could not delete file.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteFile( const std::string& fname )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      if(!::DeleteFileW(wpath.c_str())) {\n          sRet = Status::IOError(path, \"Could not delete file.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->status",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "74-80",
          "snippet": "virtual Status status() const {\n    if (status_.ok()) {\n      return iter_->status();\n    } else {\n      return status_;\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Status status() const {\n      if (status_.ok()) {\n        return iter_->status();\n      } else {\n        return status_;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_cache->NewIterator",
          "args": [
            "ReadOptions()",
            "meta->number",
            "meta->file_size"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Close",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "Close",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "261-264",
          "snippet": "void Close() {\n    delete db_;\n    db_ = NULL;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  void Close() {\n      delete db_;\n      db_ = NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Sync",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "Sync",
          "container": "LogTest::StringDest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "47-47",
          "snippet": "virtual Status Sync() { return Status::OK(); }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringDest {\n    virtual Status Sync() { return Status::OK(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder->Abandon",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "Abandon",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "256-260",
          "snippet": "void TableBuilder::Abandon() {\n  Rep* r = rep_;\n  assert(!r->closed);\n  r->closed = true;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  void TableBuilder::Abandon() {\n    Rep* r = rep_;\n    assert(!r->closed);\n    r->closed = true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "meta->file_size > 0"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "builder->FileSize",
          "args": [],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "FileSize",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_builder.cc",
          "lines": "266-268",
          "snippet": "uint64_t TableBuilder::FileSize() const {\n  return rep_->offset;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <assert.h>",
            "#include \"leveldb/table_builder.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block_builder.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include <assert.h>\n#include \"leveldb/table_builder.h\"\n\nTableBuilder {\n  uint64_t TableBuilder::FileSize() const {\n    return rep_->offset;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder->Finish",
          "args": [],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "Finish",
          "container": "FilterBlockBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
          "lines": "36-50",
          "snippet": "Slice FilterBlockBuilder::Finish() {\n  if (!start_.empty()) {\n    GenerateFilter();\n  }\n\n  // Append array of per-filter offsets\n  const uint32_t array_offset = result_.size();\n  for (size_t i = 0; i < filter_offsets_.size(); i++) {\n    PutFixed32(&result_, filter_offsets_[i]);\n  }\n\n  PutFixed32(&result_, array_offset);\n  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n  return Slice(result_);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"table/filter_block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  Slice FilterBlockBuilder::Finish() {\n    if (!start_.empty()) {\n      GenerateFilter();\n    }\n  \n    // Append array of per-filter offsets\n    const uint32_t array_offset = result_.size();\n    for (size_t i = 0; i < filter_offsets_.size(); i++) {\n      PutFixed32(&result_, filter_offsets_[i]);\n    }\n  \n    PutFixed32(&result_, array_offset);\n    result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n    return Slice(result_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder->Add",
          "args": [
            "key",
            "iter->value()"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": "FindFileTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set_test.cc",
          "lines": "25-33",
          "snippet": "void Add(const char* smallest, const char* largest,\n           SequenceNumber smallest_seq = 100,\n           SequenceNumber largest_seq = 100) {\n    FileMetaData* f = new FileMetaData;\n    f->number = files_.size() + 1;\n    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);\n    f->largest = InternalKey(largest, largest_seq, kTypeValue);\n    files_.push_back(f);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n\nFindFileTest {\n  void Add(const char* smallest, const char* largest,\n             SequenceNumber smallest_seq = 100,\n             SequenceNumber largest_seq = 100) {\n      FileMetaData* f = new FileMetaData;\n      f->number = files_.size() + 1;\n      f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);\n      f->largest = InternalKey(largest, largest_seq, kTypeValue);\n      files_.push_back(f);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "meta->largest.DecodeFrom",
          "args": [
            "key"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "153-153",
          "snippet": "void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->NewWritableFile",
          "args": [
            "fname",
            "&file"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TableFileName",
          "args": [
            "dbname",
            "meta->number"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "SSTTableFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "42-45",
          "snippet": "std::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string SSTTableFileName(const std::string& name, uint64_t number) {\n  assert(number > 0);\n  return MakeFileName(name, number, \"ldb\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/version_edit.h\"\n#include \"db/table_cache.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include \"db/builder.h\"\n\nStatus BuildTable(const std::string& dbname,\n                  Env* env,\n                  const Options& options,\n                  TableCache* table_cache,\n                  Iterator* iter,\n                  FileMetaData* meta) {\n  Status s;\n  meta->file_size = 0;\n  iter->SeekToFirst();\n\n  std::string fname = TableFileName(dbname, meta->number);\n  if (iter->Valid()) {\n    WritableFile* file;\n    s = env->NewWritableFile(fname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n\n    TableBuilder* builder = new TableBuilder(options, file);\n    meta->smallest.DecodeFrom(iter->key());\n    for (; iter->Valid(); iter->Next()) {\n      Slice key = iter->key();\n      meta->largest.DecodeFrom(key);\n      builder->Add(key, iter->value());\n    }\n\n    // Finish and check for builder errors\n    if (s.ok()) {\n      s = builder->Finish();\n      if (s.ok()) {\n        meta->file_size = builder->FileSize();\n        assert(meta->file_size > 0);\n      }\n    } else {\n      builder->Abandon();\n    }\n    delete builder;\n\n    // Finish and check for file errors\n    if (s.ok()) {\n      s = file->Sync();\n    }\n    if (s.ok()) {\n      s = file->Close();\n    }\n    delete file;\n    file = NULL;\n\n    if (s.ok()) {\n      // Verify that the table is usable\n      Iterator* it = table_cache->NewIterator(ReadOptions(),\n                                              meta->number,\n                                              meta->file_size);\n      s = it->status();\n      delete it;\n    }\n  }\n\n  // Check for input iterator errors\n  if (!iter->status().ok()) {\n    s = iter->status();\n  }\n\n  if (s.ok() && meta->file_size > 0) {\n    // Keep it\n  } else {\n    env->DeleteFile(fname);\n  }\n  return s;\n}"
  }
]