[
  {
    "function_name": "ReadBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
    "lines": "66-143",
    "snippet": "Status ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"table/format.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"bad block type\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "ubuf",
            "ulength"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "port::Snappy_Uncompress",
          "args": [
            "data",
            "n",
            "ubuf"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "Snappy_Uncompress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.h",
          "lines": "158-165",
          "snippet": "inline bool Snappy_Uncompress(const char* input, size_t length,\n                              char* output) {\n#ifdef SNAPPY\n  return snappy::RawUncompress(input, length, output);\n#else\n  return false;\n#endif\n}",
          "includes": [
            "#include <snappy.h>",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy.h>\n#include <stdint.h>\n#include <string>\n\ninline bool Snappy_Uncompress(const char* input, size_t length,\n                              char* output) {\n#ifdef SNAPPY\n  return snappy::RawUncompress(input, length, output);\n#else\n  return false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "port::Snappy_GetUncompressedLength",
          "args": [
            "data",
            "n",
            "&ulength"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "Snappy_GetUncompressedLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.h",
          "lines": "149-156",
          "snippet": "inline bool Snappy_GetUncompressedLength(const char* input, size_t length,\n                                         size_t* result) {\n#ifdef SNAPPY\n  return snappy::GetUncompressedLength(input, length, result);\n#else\n  return false;\n#endif\n}",
          "includes": [
            "#include <snappy.h>",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <snappy.h>\n#include <stdint.h>\n#include <string>\n\ninline bool Snappy_GetUncompressedLength(const char* input, size_t length,\n                                         size_t* result) {\n#ifdef SNAPPY\n  return snappy::GetUncompressedLength(input, length, result);\n#else\n  return false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c::Value",
          "args": [
            "data",
            "n + 1"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/crc32c.h",
          "lines": "20-22",
          "snippet": "inline uint32_t Value(const char* data, size_t n) {\n  return Extend(0, data, n);\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stddef.h>\n\ninline uint32_t Value(const char* data, size_t n) {\n  return Extend(0, data, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c::Unmask",
          "args": [
            "DecodeFixed32(data + n + 1)"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "Unmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/crc32c.h",
          "lines": "37-40",
          "snippet": "inline uint32_t Unmask(uint32_t masked_crc) {\n  uint32_t rot = masked_crc - kMaskDelta;\n  return ((rot >> 17) | (rot << 15));\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stddef.h>\n\ninline uint32_t Unmask(uint32_t masked_crc) {\n  uint32_t rot = masked_crc - kMaskDelta;\n  return ((rot >> 17) | (rot << 15));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeFixed32",
          "args": [
            "data + n + 1"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "58-70",
          "snippet": "inline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.data",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contents.size",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file->Read",
          "args": [
            "handle.offset()",
            "n + kBlockTrailerSize",
            "&contents",
            "buf"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "StringSource",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "120-131",
          "snippet": "virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const {\n    if (offset > contents_.size()) {\n      return Status::InvalidArgument(\"invalid Read offset\");\n    }\n    if (offset + n > contents_.size()) {\n      n = contents_.size() - offset;\n    }\n    memcpy(scratch, &contents_[offset], n);\n    *result = Slice(scratch, n);\n    return Status::OK();\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nStringSource {\n  virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                         char* scratch) const {\n      if (offset > contents_.size()) {\n        return Status::InvalidArgument(\"invalid Read offset\");\n      }\n      if (offset + n > contents_.size()) {\n        n = contents_.size() - offset;\n      }\n      memcpy(scratch, &contents_[offset], n);\n      *result = Slice(scratch, n);\n      return Status::OK();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle.offset",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "offset",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "27-27",
          "snippet": "uint64_t offset() const { return offset_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t offset() const { return offset_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<size_t>",
          "args": [
            "handle.size()"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "66-66",
          "snippet": "std::string ToString() const { return std::string(data_, size_); }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  std::string ToString() const { return std::string(data_, size_); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nStatus ReadBlock(RandomAccessFile* file,\n                 const ReadOptions& options,\n                 const BlockHandle& handle,\n                 BlockContents* result) {\n  result->data = Slice();\n  result->cachable = false;\n  result->heap_allocated = false;\n\n  // Read the block contents as well as the type/crc footer.\n  // See table_builder.cc for the code that built this structure.\n  size_t n = static_cast<size_t>(handle.size());\n  char* buf = new char[n + kBlockTrailerSize];\n  Slice contents;\n  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);\n  if (!s.ok()) {\n    delete[] buf;\n    return s;\n  }\n  if (contents.size() != n + kBlockTrailerSize) {\n    delete[] buf;\n    return Status::Corruption(\"truncated block read\");\n  }\n\n  // Check the crc of the type and the block contents\n  const char* data = contents.data();    // Pointer to where Read put the data\n  if (options.verify_checksums) {\n    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));\n    const uint32_t actual = crc32c::Value(data, n + 1);\n    if (actual != crc) {\n      delete[] buf;\n      s = Status::Corruption(\"block checksum mismatch\");\n      return s;\n    }\n  }\n\n  switch (data[n]) {\n    case kNoCompression:\n      if (data != buf) {\n        // File implementation gave us pointer to some other data.\n        // Use it directly under the assumption that it will be live\n        // while the file is open.\n        delete[] buf;\n        result->data = Slice(data, n);\n        result->heap_allocated = false;\n        result->cachable = false;  // Do not double-cache\n      } else {\n        result->data = Slice(buf, n);\n        result->heap_allocated = true;\n        result->cachable = true;\n      }\n\n      // Ok\n      break;\n    case kSnappyCompression: {\n      size_t ulength = 0;\n      if (!port::Snappy_GetUncompressedLength(data, n, &ulength)) {\n        delete[] buf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      char* ubuf = new char[ulength];\n      if (!port::Snappy_Uncompress(data, n, ubuf)) {\n        delete[] buf;\n        delete[] ubuf;\n        return Status::Corruption(\"corrupted compressed block contents\");\n      }\n      delete[] buf;\n      result->data = Slice(ubuf, ulength);\n      result->heap_allocated = true;\n      result->cachable = true;\n      break;\n    }\n    default:\n      delete[] buf;\n      return Status::Corruption(\"bad block type\");\n  }\n\n  return Status::OK();\n}"
  },
  {
    "function_name": "DecodeFrom",
    "container": "Footer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
    "lines": "44-64",
    "snippet": "Status Footer::DecodeFrom(Slice* input) {\n  const char* magic_ptr = input->data() + kEncodedLength - 8;\n  const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                          (static_cast<uint64_t>(magic_lo)));\n  if (magic != kTableMagicNumber) {\n    return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n  }\n\n  Status result = metaindex_handle_.DecodeFrom(input);\n  if (result.ok()) {\n    result = index_handle_.DecodeFrom(input);\n  }\n  if (result.ok()) {\n    // We skip over any leftover data (just padding for now) in \"input\"\n    const char* end = magic_ptr + 8;\n    *input = Slice(end, input->data() + input->size() - end);\n  }\n  return result;\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"table/format.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "end",
            "input->data() + input->size() - end"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->size",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->data",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result.ok",
          "args": [],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_handle_.DecodeFrom",
          "args": [
            "input"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "Footer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "44-64",
          "snippet": "Status Footer::DecodeFrom(Slice* input) {\n  const char* magic_ptr = input->data() + kEncodedLength - 8;\n  const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                          (static_cast<uint64_t>(magic_lo)));\n  if (magic != kTableMagicNumber) {\n    return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n  }\n\n  Status result = metaindex_handle_.DecodeFrom(input);\n  if (result.ok()) {\n    result = index_handle_.DecodeFrom(input);\n  }\n  if (result.ok()) {\n    // We skip over any leftover data (just padding for now) in \"input\"\n    const char* end = magic_ptr + 8;\n    *input = Slice(end, input->data() + input->size() - end);\n  }\n  return result;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Status::InvalidArgument",
          "args": [
            "\"not an sstable (bad magic number)\""
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidArgument",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "44-46",
          "snippet": "static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kInvalidArgument, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kInvalidArgument, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint64_t>",
          "args": [
            "magic_lo"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint64_t>",
          "args": [
            "magic_hi"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeFixed32",
          "args": [
            "magic_ptr + 4"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "58-70",
          "snippet": "inline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input->data",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nFooter {\n  Status Footer::DecodeFrom(Slice* input) {\n    const char* magic_ptr = input->data() + kEncodedLength - 8;\n    const uint32_t magic_lo = DecodeFixed32(magic_ptr);\n    const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);\n    const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |\n                            (static_cast<uint64_t>(magic_lo)));\n    if (magic != kTableMagicNumber) {\n      return Status::InvalidArgument(\"not an sstable (bad magic number)\");\n    }\n  \n    Status result = metaindex_handle_.DecodeFrom(input);\n    if (result.ok()) {\n      result = index_handle_.DecodeFrom(input);\n    }\n    if (result.ok()) {\n      // We skip over any leftover data (just padding for now) in \"input\"\n      const char* end = magic_ptr + 8;\n      *input = Slice(end, input->data() + input->size() - end);\n    }\n    return result;\n  }\n}"
  },
  {
    "function_name": "EncodeTo",
    "container": "Footer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
    "lines": "32-42",
    "snippet": "void Footer::EncodeTo(std::string* dst) const {\n#ifndef NDEBUG\n  const size_t original_size = dst->size();\n#endif\n  metaindex_handle_.EncodeTo(dst);\n  index_handle_.EncodeTo(dst);\n  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding\n  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));\n  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));\n  assert(dst->size() == original_size + kEncodedLength);\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"table/format.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dst->size() == original_size + kEncodedLength"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->size",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "PutFixed32",
          "args": [
            "dst",
            "static_cast<uint32_t>(kTableMagicNumber >> 32)"
          ],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "PutFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "35-39",
          "snippet": "void PutFixed32(std::string* dst, uint32_t value) {\n  char buf[sizeof(value)];\n  EncodeFixed32(buf, value);\n  dst->append(buf, sizeof(buf));\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid PutFixed32(std::string* dst, uint32_t value) {\n  char buf[sizeof(value)];\n  EncodeFixed32(buf, value);\n  dst->append(buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint32_t>",
          "args": [
            "kTableMagicNumber >> 32"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint32_t>",
          "args": [
            "kTableMagicNumber & 0xffffffffu"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dst->resize",
          "args": [
            "2 * BlockHandle::kMaxEncodedLength"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "index_handle_.EncodeTo",
          "args": [
            "dst"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTo",
          "container": "Footer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
          "lines": "32-42",
          "snippet": "void Footer::EncodeTo(std::string* dst) const {\n#ifndef NDEBUG\n  const size_t original_size = dst->size();\n#endif\n  metaindex_handle_.EncodeTo(dst);\n  index_handle_.EncodeTo(dst);\n  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding\n  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));\n  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));\n  assert(dst->size() == original_size + kEncodedLength);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nFooter {\n  void Footer::EncodeTo(std::string* dst) const {\n  #ifndef NDEBUG\n    const size_t original_size = dst->size();\n  #endif\n    metaindex_handle_.EncodeTo(dst);\n    index_handle_.EncodeTo(dst);\n    dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding\n    PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));\n    PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));\n    assert(dst->size() == original_size + kEncodedLength);\n  }\n}"
  },
  {
    "function_name": "DecodeFrom",
    "container": "BlockHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
    "lines": "23-30",
    "snippet": "Status BlockHandle::DecodeFrom(Slice* input) {\n  if (GetVarint64(input, &offset_) &&\n      GetVarint64(input, &size_)) {\n    return Status::OK();\n  } else {\n    return Status::Corruption(\"bad block handle\");\n  }\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"table/format.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"bad block handle\""
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetVarint64",
          "args": [
            "input",
            "&size_"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "GetVarint64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "160-170",
          "snippet": "bool GetVarint64(Slice* input, uint64_t* value) {\n  const char* p = input->data();\n  const char* limit = p + input->size();\n  const char* q = GetVarint64Ptr(p, limit, value);\n  if (q == NULL) {\n    return false;\n  } else {\n    *input = Slice(q, limit - q);\n    return true;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetVarint64(Slice* input, uint64_t* value) {\n  const char* p = input->data();\n  const char* limit = p + input->size();\n  const char* q = GetVarint64Ptr(p, limit, value);\n  if (q == NULL) {\n    return false;\n  } else {\n    *input = Slice(q, limit - q);\n    return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nBlockHandle {\n  Status BlockHandle::DecodeFrom(Slice* input) {\n    if (GetVarint64(input, &offset_) &&\n        GetVarint64(input, &size_)) {\n      return Status::OK();\n    } else {\n      return Status::Corruption(\"bad block handle\");\n    }\n  }\n}"
  },
  {
    "function_name": "EncodeTo",
    "container": "BlockHandle",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.cc",
    "lines": "15-21",
    "snippet": "void BlockHandle::EncodeTo(std::string* dst) const {\n  // Sanity check that all fields have been set\n  assert(offset_ != ~static_cast<uint64_t>(0));\n  assert(size_ != ~static_cast<uint64_t>(0));\n  PutVarint64(dst, offset_);\n  PutVarint64(dst, size_);\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/block.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"table/format.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PutVarint64",
          "args": [
            "dst",
            "size_"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "PutVarint64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "92-96",
          "snippet": "void PutVarint64(std::string* dst, uint64_t v) {\n  char buf[10];\n  char* ptr = EncodeVarint64(buf, v);\n  dst->append(buf, ptr - buf);\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid PutVarint64(std::string* dst, uint64_t v) {\n  char buf[10];\n  char* ptr = EncodeVarint64(buf, v);\n  dst->append(buf, ptr - buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "size_ != ~static_cast<uint64_t>(0)"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint64_t>",
          "args": [
            "0"
          ],
          "line": 18
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "offset_ != ~static_cast<uint64_t>(0)"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint64_t>",
          "args": [
            "0"
          ],
          "line": 17
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include \"table/format.h\"\n\nBlockHandle {\n  void BlockHandle::EncodeTo(std::string* dst) const {\n    // Sanity check that all fields have been set\n    assert(offset_ != ~static_cast<uint64_t>(0));\n    assert(size_ != ~static_cast<uint64_t>(0));\n    PutVarint64(dst, offset_);\n    PutVarint64(dst, size_);\n  }\n}"
  }
]