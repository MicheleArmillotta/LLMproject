[
  {
    "function_name": "KeyMayMatch",
    "container": "FilterBlockReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
    "lines": "95-109",
    "snippet": "bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {\n  uint64_t index = block_offset >> base_lg_;\n  if (index < num_) {\n    uint32_t start = DecodeFixed32(offset_ + index*4);\n    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);\n    if (start <= limit && limit <= (offset_ - data_)) {\n      Slice filter = Slice(data_ + start, limit - start);\n      return policy_->KeyMayMatch(key, filter);\n    } else if (start == limit) {\n      // Empty filters do not match any keys\n      return false;\n    }\n  }\n  return true;  // Errors are treated as potential matches\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"table/filter_block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "policy_->KeyMayMatch",
          "args": [
            "key",
            "filter"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "KeyMayMatch",
          "container": "FilterBlockReader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
          "lines": "95-109",
          "snippet": "bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {\n  uint64_t index = block_offset >> base_lg_;\n  if (index < num_) {\n    uint32_t start = DecodeFixed32(offset_ + index*4);\n    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);\n    if (start <= limit && limit <= (offset_ - data_)) {\n      Slice filter = Slice(data_ + start, limit - start);\n      return policy_->KeyMayMatch(key, filter);\n    } else if (start == limit) {\n      // Empty filters do not match any keys\n      return false;\n    }\n  }\n  return true;  // Errors are treated as potential matches\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "data_ + start",
            "limit - start"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeFixed32",
          "args": [
            "offset_ + index*4 + 4"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "58-70",
          "snippet": "inline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockReader {\n  bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {\n    uint64_t index = block_offset >> base_lg_;\n    if (index < num_) {\n      uint32_t start = DecodeFixed32(offset_ + index*4);\n      uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);\n      if (start <= limit && limit <= (offset_ - data_)) {\n        Slice filter = Slice(data_ + start, limit - start);\n        return policy_->KeyMayMatch(key, filter);\n      } else if (start == limit) {\n        // Empty filters do not match any keys\n        return false;\n      }\n    }\n    return true;  // Errors are treated as potential matches\n  }\n}"
  },
  {
    "function_name": "FilterBlockReader",
    "container": "FilterBlockReader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
    "lines": "78-93",
    "snippet": "FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,\n                                     const Slice& contents)\n    : policy_(policy),\n      data_(NULL),\n      offset_(NULL),\n      num_(0),\n      base_lg_(0) {\n  size_t n = contents.size();\n  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array\n  base_lg_ = contents[n-1];\n  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);\n  if (last_word > n - 5) return;\n  data_ = contents.data();\n  offset_ = data_ + last_word;\n  num_ = (n - 5 - last_word) / 4;\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"table/filter_block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "contents.data",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DecodeFixed32",
          "args": [
            "contents.data() + n - 5"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "58-70",
          "snippet": "inline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.data",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "contents.size",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockReader {\n  FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,\n                                       const Slice& contents)\n      : policy_(policy),\n        data_(NULL),\n        offset_(NULL),\n        num_(0),\n        base_lg_(0) {\n    size_t n = contents.size();\n    if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array\n    base_lg_ = contents[n-1];\n    uint32_t last_word = DecodeFixed32(contents.data() + n - 5);\n    if (last_word > n - 5) return;\n    data_ = contents.data();\n    offset_ = data_ + last_word;\n    num_ = (n - 5 - last_word) / 4;\n  }\n}"
  },
  {
    "function_name": "GenerateFilter",
    "container": "FilterBlockBuilder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
    "lines": "52-76",
    "snippet": "void FilterBlockBuilder::GenerateFilter() {\n  const size_t num_keys = start_.size();\n  if (num_keys == 0) {\n    // Fast path if there are no keys for this filter\n    filter_offsets_.push_back(result_.size());\n    return;\n  }\n\n  // Make list of keys from flattened key structure\n  start_.push_back(keys_.size());  // Simplify length computation\n  tmp_keys_.resize(num_keys);\n  for (size_t i = 0; i < num_keys; i++) {\n    const char* base = keys_.data() + start_[i];\n    size_t length = start_[i+1] - start_[i];\n    tmp_keys_[i] = Slice(base, length);\n  }\n\n  // Generate filter for current set of keys and append to result_.\n  filter_offsets_.push_back(result_.size());\n  policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);\n\n  tmp_keys_.clear();\n  keys_.clear();\n  start_.clear();\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"table/filter_block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_.clear",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_->CreateFilter",
          "args": [
            "&tmp_keys_[0]",
            "num_keys",
            "&result_"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "CreateFilter",
          "container": "leveldb_filterpolicy_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "108-119",
          "snippet": "virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n    std::vector<const char*> key_pointers(n);\n    std::vector<size_t> key_sizes(n);\n    for (int i = 0; i < n; i++) {\n      key_pointers[i] = keys[i].data();\n      key_sizes[i] = keys[i].size();\n    }\n    size_t len;\n    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);\n    dst->append(filter, len);\n    free(filter);\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_filterpolicy_t {\n  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n      std::vector<const char*> key_pointers(n);\n      std::vector<size_t> key_sizes(n);\n      for (int i = 0; i < n; i++) {\n        key_pointers[i] = keys[i].data();\n        key_sizes[i] = keys[i].size();\n      }\n      size_t len;\n      char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);\n      dst->append(filter, len);\n      free(filter);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_offsets_.push_back",
          "args": [
            "result_.size()"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "result_.size",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "base",
            "length"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "keys_.data",
          "args": [],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp_keys_.resize",
          "args": [
            "num_keys"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_.push_back",
          "args": [
            "keys_.size()"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filter_offsets_.push_back",
          "args": [
            "result_.size()"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  void FilterBlockBuilder::GenerateFilter() {\n    const size_t num_keys = start_.size();\n    if (num_keys == 0) {\n      // Fast path if there are no keys for this filter\n      filter_offsets_.push_back(result_.size());\n      return;\n    }\n  \n    // Make list of keys from flattened key structure\n    start_.push_back(keys_.size());  // Simplify length computation\n    tmp_keys_.resize(num_keys);\n    for (size_t i = 0; i < num_keys; i++) {\n      const char* base = keys_.data() + start_[i];\n      size_t length = start_[i+1] - start_[i];\n      tmp_keys_[i] = Slice(base, length);\n    }\n  \n    // Generate filter for current set of keys and append to result_.\n    filter_offsets_.push_back(result_.size());\n    policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);\n  \n    tmp_keys_.clear();\n    keys_.clear();\n    start_.clear();\n  }\n}"
  },
  {
    "function_name": "Finish",
    "container": "FilterBlockBuilder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
    "lines": "36-50",
    "snippet": "Slice FilterBlockBuilder::Finish() {\n  if (!start_.empty()) {\n    GenerateFilter();\n  }\n\n  // Append array of per-filter offsets\n  const uint32_t array_offset = result_.size();\n  for (size_t i = 0; i < filter_offsets_.size(); i++) {\n    PutFixed32(&result_, filter_offsets_[i]);\n  }\n\n  PutFixed32(&result_, array_offset);\n  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n  return Slice(result_);\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"table/filter_block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "result_"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "HashSlice",
          "container": "ShardedLRUCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "276-278",
          "snippet": "static inline uint32_t HashSlice(const Slice& s) {\n    return Hash(s.data(), s.size(), 0);\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nShardedLRUCache {\n  static inline uint32_t HashSlice(const Slice& s) {\n      return Hash(s.data(), s.size(), 0);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result_.push_back",
          "args": [
            "kFilterBaseLg"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PutFixed32",
          "args": [
            "&result_",
            "array_offset"
          ],
          "line": 47
        },
        "resolved": true,
        "details": {
          "function_name": "PutFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "35-39",
          "snippet": "void PutFixed32(std::string* dst, uint32_t value) {\n  char buf[sizeof(value)];\n  EncodeFixed32(buf, value);\n  dst->append(buf, sizeof(buf));\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid PutFixed32(std::string* dst, uint32_t value) {\n  char buf[sizeof(value)];\n  EncodeFixed32(buf, value);\n  dst->append(buf, sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_offsets_.size",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GenerateFilter",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateFilter",
          "container": "FilterBlockBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
          "lines": "52-76",
          "snippet": "void FilterBlockBuilder::GenerateFilter() {\n  const size_t num_keys = start_.size();\n  if (num_keys == 0) {\n    // Fast path if there are no keys for this filter\n    filter_offsets_.push_back(result_.size());\n    return;\n  }\n\n  // Make list of keys from flattened key structure\n  start_.push_back(keys_.size());  // Simplify length computation\n  tmp_keys_.resize(num_keys);\n  for (size_t i = 0; i < num_keys; i++) {\n    const char* base = keys_.data() + start_[i];\n    size_t length = start_[i+1] - start_[i];\n    tmp_keys_[i] = Slice(base, length);\n  }\n\n  // Generate filter for current set of keys and append to result_.\n  filter_offsets_.push_back(result_.size());\n  policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);\n\n  tmp_keys_.clear();\n  keys_.clear();\n  start_.clear();\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"table/filter_block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  void FilterBlockBuilder::GenerateFilter() {\n    const size_t num_keys = start_.size();\n    if (num_keys == 0) {\n      // Fast path if there are no keys for this filter\n      filter_offsets_.push_back(result_.size());\n      return;\n    }\n  \n    // Make list of keys from flattened key structure\n    start_.push_back(keys_.size());  // Simplify length computation\n    tmp_keys_.resize(num_keys);\n    for (size_t i = 0; i < num_keys; i++) {\n      const char* base = keys_.data() + start_[i];\n      size_t length = start_[i+1] - start_[i];\n      tmp_keys_[i] = Slice(base, length);\n    }\n  \n    // Generate filter for current set of keys and append to result_.\n    filter_offsets_.push_back(result_.size());\n    policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);\n  \n    tmp_keys_.clear();\n    keys_.clear();\n    start_.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_.empty",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "BlockBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block_builder.h",
          "lines": "38-40",
          "snippet": "bool empty() const {\n    return buffer_.empty();\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <vector>\n\nBlockBuilder {\n  bool empty() const {\n      return buffer_.empty();\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  Slice FilterBlockBuilder::Finish() {\n    if (!start_.empty()) {\n      GenerateFilter();\n    }\n  \n    // Append array of per-filter offsets\n    const uint32_t array_offset = result_.size();\n    for (size_t i = 0; i < filter_offsets_.size(); i++) {\n      PutFixed32(&result_, filter_offsets_[i]);\n    }\n  \n    PutFixed32(&result_, array_offset);\n    result_.push_back(kFilterBaseLg);  // Save encoding parameter in result\n    return Slice(result_);\n  }\n}"
  },
  {
    "function_name": "AddKey",
    "container": "FilterBlockBuilder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
    "lines": "30-34",
    "snippet": "void FilterBlockBuilder::AddKey(const Slice& key) {\n  Slice k = key;\n  start_.push_back(keys_.size());\n  keys_.append(k.data(), k.size());\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"table/filter_block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keys_.append",
          "args": [
            "k.data()",
            "k.size()"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k.size",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "k.data",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_.push_back",
          "args": [
            "keys_.size()"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  void FilterBlockBuilder::AddKey(const Slice& key) {\n    Slice k = key;\n    start_.push_back(keys_.size());\n    keys_.append(k.data(), k.size());\n  }\n}"
  },
  {
    "function_name": "StartBlock",
    "container": "FilterBlockBuilder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
    "lines": "22-28",
    "snippet": "void FilterBlockBuilder::StartBlock(uint64_t block_offset) {\n  uint64_t filter_index = (block_offset / kFilterBase);\n  assert(filter_index >= filter_offsets_.size());\n  while (filter_index > filter_offsets_.size()) {\n    GenerateFilter();\n  }\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"table/filter_block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GenerateFilter",
          "args": [],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "GenerateFilter",
          "container": "FilterBlockBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
          "lines": "52-76",
          "snippet": "void FilterBlockBuilder::GenerateFilter() {\n  const size_t num_keys = start_.size();\n  if (num_keys == 0) {\n    // Fast path if there are no keys for this filter\n    filter_offsets_.push_back(result_.size());\n    return;\n  }\n\n  // Make list of keys from flattened key structure\n  start_.push_back(keys_.size());  // Simplify length computation\n  tmp_keys_.resize(num_keys);\n  for (size_t i = 0; i < num_keys; i++) {\n    const char* base = keys_.data() + start_[i];\n    size_t length = start_[i+1] - start_[i];\n    tmp_keys_[i] = Slice(base, length);\n  }\n\n  // Generate filter for current set of keys and append to result_.\n  filter_offsets_.push_back(result_.size());\n  policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);\n\n  tmp_keys_.clear();\n  keys_.clear();\n  start_.clear();\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"table/filter_block.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  void FilterBlockBuilder::GenerateFilter() {\n    const size_t num_keys = start_.size();\n    if (num_keys == 0) {\n      // Fast path if there are no keys for this filter\n      filter_offsets_.push_back(result_.size());\n      return;\n    }\n  \n    // Make list of keys from flattened key structure\n    start_.push_back(keys_.size());  // Simplify length computation\n    tmp_keys_.resize(num_keys);\n    for (size_t i = 0; i < num_keys; i++) {\n      const char* base = keys_.data() + start_[i];\n      size_t length = start_[i+1] - start_[i];\n      tmp_keys_[i] = Slice(base, length);\n    }\n  \n    // Generate filter for current set of keys and append to result_.\n    filter_offsets_.push_back(result_.size());\n    policy_->CreateFilter(&tmp_keys_[0], num_keys, &result_);\n  \n    tmp_keys_.clear();\n    keys_.clear();\n    start_.clear();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "filter_offsets_.size",
          "args": [],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "filter_index >= filter_offsets_.size()"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  void FilterBlockBuilder::StartBlock(uint64_t block_offset) {\n    uint64_t filter_index = (block_offset / kFilterBase);\n    assert(filter_index >= filter_offsets_.size());\n    while (filter_index > filter_offsets_.size()) {\n      GenerateFilter();\n    }\n  }\n}"
  },
  {
    "function_name": "FilterBlockBuilder",
    "container": "FilterBlockBuilder",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/filter_block.cc",
    "lines": "18-20",
    "snippet": "FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)\n    : policy_(policy) {\n}",
    "includes": [
      "#include \"util/coding.h\"",
      "#include \"leveldb/filter_policy.h\"",
      "#include \"table/filter_block.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"table/filter_block.h\"\n\nFilterBlockBuilder {\n  FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)\n      : policy_(policy) {\n  }\n}"
  }
]