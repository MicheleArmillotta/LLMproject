[
  {
    "function_name": "ReadPhysicalRecord",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "179-256",
    "snippet": "unsigned int Reader::ReadPhysicalRecord(Slice* result) {\n  while (true) {\n    if (buffer_.size() < kHeaderSize) {\n      if (!eof_) {\n        // Last read was a full read, so this is a trailer to skip\n        buffer_.clear();\n        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);\n        end_of_buffer_offset_ += buffer_.size();\n        if (!status.ok()) {\n          buffer_.clear();\n          ReportDrop(kBlockSize, status);\n          eof_ = true;\n          return kEof;\n        } else if (buffer_.size() < kBlockSize) {\n          eof_ = true;\n        }\n        continue;\n      } else if (buffer_.size() == 0) {\n        // End of file\n        return kEof;\n      } else {\n        size_t drop_size = buffer_.size();\n        buffer_.clear();\n        ReportCorruption(drop_size, \"truncated record at end of file\");\n        return kEof;\n      }\n    }\n\n    // Parse the header\n    const char* header = buffer_.data();\n    const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;\n    const uint32_t b = static_cast<uint32_t>(header[5]) & 0xff;\n    const unsigned int type = header[6];\n    const uint32_t length = a | (b << 8);\n    if (kHeaderSize + length > buffer_.size()) {\n      size_t drop_size = buffer_.size();\n      buffer_.clear();\n      ReportCorruption(drop_size, \"bad record length\");\n      return kBadRecord;\n    }\n\n    if (type == kZeroType && length == 0) {\n      // Skip zero length record without reporting any drops since\n      // such records are produced by the mmap based writing code in\n      // env_posix.cc that preallocates file regions.\n      buffer_.clear();\n      return kBadRecord;\n    }\n\n    // Check crc\n    if (checksum_) {\n      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));\n      uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);\n      if (actual_crc != expected_crc) {\n        // Drop the rest of the buffer since \"length\" itself may have\n        // been corrupted and if we trust it, we could find some\n        // fragment of a real log record that just happens to look\n        // like a valid log record.\n        size_t drop_size = buffer_.size();\n        buffer_.clear();\n        ReportCorruption(drop_size, \"checksum mismatch\");\n        return kBadRecord;\n      }\n    }\n\n    buffer_.remove_prefix(kHeaderSize + length);\n\n    // Skip physical record that started before initial_offset_\n    if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length <\n        initial_offset_) {\n      result->clear();\n      return kBadRecord;\n    }\n\n    *result = Slice(header + kHeaderSize, length);\n    return type;\n  }\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "header + kHeaderSize",
            "length"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "result->clear",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_.size",
          "args": [],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_.remove_prefix",
          "args": [
            "kHeaderSize + length"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "remove_prefix",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "59-63",
          "snippet": "void remove_prefix(size_t n) {\n    assert(n <= size());\n    data_ += n;\n    size_ -= n;\n  }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  void remove_prefix(size_t n) {\n      assert(n <= size());\n      data_ += n;\n      size_ -= n;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReportCorruption",
          "args": [
            "drop_size",
            "\"checksum mismatch\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ReportCorruption",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "168-170",
          "snippet": "void Reader::ReportCorruption(size_t bytes, const char* reason) {\n  ReportDrop(bytes, Status::Corruption(reason));\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  void Reader::ReportCorruption(size_t bytes, const char* reason) {\n    ReportDrop(bytes, Status::Corruption(reason));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c::Value",
          "args": [
            "header + 6",
            "1 + length"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "Value",
          "container": "CorruptionTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/corruption_test.cc",
          "lines": "196-199",
          "snippet": "Slice Value(int k, std::string* storage) {\n    Random r(k);\n    return test::RandomString(&r, kValueSize, storage);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/log_format.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"db/version_set.h\"\n#include \"db/log_format.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n#include \"leveldb/db.h\"\n\nCorruptionTest {\n  Slice Value(int k, std::string* storage) {\n      Random r(k);\n      return test::RandomString(&r, kValueSize, storage);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32c::Unmask",
          "args": [
            "DecodeFixed32(header)"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "Unmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/crc32c.h",
          "lines": "37-40",
          "snippet": "inline uint32_t Unmask(uint32_t masked_crc) {\n  uint32_t rot = masked_crc - kMaskDelta;\n  return ((rot >> 17) | (rot << 15));\n}",
          "includes": [
            "#include <stdint.h>",
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <stddef.h>\n\ninline uint32_t Unmask(uint32_t masked_crc) {\n  uint32_t rot = masked_crc - kMaskDelta;\n  return ((rot >> 17) | (rot << 15));\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeFixed32",
          "args": [
            "header"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFixed32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.h",
          "lines": "58-70",
          "snippet": "inline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}",
          "includes": [
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <string>",
            "#include <string.h>",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include <string>\n#include <string.h>\n#include <stdint.h>\n\ninline uint32_t DecodeFixed32(const char* ptr) {\n  if (port::kLittleEndian) {\n    // Load the raw bytes\n    uint32_t result;\n    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load\n    return result;\n  } else {\n    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)\n        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<uint32_t>",
          "args": [
            "header[5]"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<uint32_t>",
          "args": [
            "header[4]"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_.data",
          "args": [],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReportDrop",
          "args": [
            "kBlockSize",
            "status"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ReportDrop",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "172-177",
          "snippet": "void Reader::ReportDrop(size_t bytes, const Status& reason) {\n  if (reporter_ != NULL &&\n      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n    reporter_->Corruption(bytes, reason);\n  }\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  void Reader::ReportDrop(size_t bytes, const Status& reason) {\n    if (reporter_ != NULL &&\n        end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n      reporter_->Corruption(bytes, reason);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_->Read",
          "args": [
            "kBlockSize",
            "&buffer_",
            "backing_store_"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "Read",
          "container": "LogTest::StringSource",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "61-77",
          "snippet": "virtual Status Read(size_t n, Slice* result, char* scratch) {\n      ASSERT_TRUE(!returned_partial_) << \"must not Read() after eof/error\";\n\n      if (force_error_) {\n        force_error_ = false;\n        returned_partial_ = true;\n        return Status::Corruption(\"read error\");\n      }\n\n      if (contents_.size() < n) {\n        n = contents_.size();\n        returned_partial_ = true;\n      }\n      *result = Slice(contents_.data(), n);\n      contents_.remove_prefix(n);\n      return Status::OK();\n    }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringSource {\n    virtual Status Read(size_t n, Slice* result, char* scratch) {\n          ASSERT_TRUE(!returned_partial_) << \"must not Read() after eof/error\";\n    \n          if (force_error_) {\n            force_error_ = false;\n            returned_partial_ = true;\n            return Status::Corruption(\"read error\");\n          }\n    \n          if (contents_.size() < n) {\n            n = contents_.size();\n            returned_partial_ = true;\n          }\n          *result = Slice(contents_.data(), n);\n          contents_.remove_prefix(n);\n          return Status::OK();\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  unsigned int Reader::ReadPhysicalRecord(Slice* result) {\n    while (true) {\n      if (buffer_.size() < kHeaderSize) {\n        if (!eof_) {\n          // Last read was a full read, so this is a trailer to skip\n          buffer_.clear();\n          Status status = file_->Read(kBlockSize, &buffer_, backing_store_);\n          end_of_buffer_offset_ += buffer_.size();\n          if (!status.ok()) {\n            buffer_.clear();\n            ReportDrop(kBlockSize, status);\n            eof_ = true;\n            return kEof;\n          } else if (buffer_.size() < kBlockSize) {\n            eof_ = true;\n          }\n          continue;\n        } else if (buffer_.size() == 0) {\n          // End of file\n          return kEof;\n        } else {\n          size_t drop_size = buffer_.size();\n          buffer_.clear();\n          ReportCorruption(drop_size, \"truncated record at end of file\");\n          return kEof;\n        }\n      }\n  \n      // Parse the header\n      const char* header = buffer_.data();\n      const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;\n      const uint32_t b = static_cast<uint32_t>(header[5]) & 0xff;\n      const unsigned int type = header[6];\n      const uint32_t length = a | (b << 8);\n      if (kHeaderSize + length > buffer_.size()) {\n        size_t drop_size = buffer_.size();\n        buffer_.clear();\n        ReportCorruption(drop_size, \"bad record length\");\n        return kBadRecord;\n      }\n  \n      if (type == kZeroType && length == 0) {\n        // Skip zero length record without reporting any drops since\n        // such records are produced by the mmap based writing code in\n        // env_posix.cc that preallocates file regions.\n        buffer_.clear();\n        return kBadRecord;\n      }\n  \n      // Check crc\n      if (checksum_) {\n        uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));\n        uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);\n        if (actual_crc != expected_crc) {\n          // Drop the rest of the buffer since \"length\" itself may have\n          // been corrupted and if we trust it, we could find some\n          // fragment of a real log record that just happens to look\n          // like a valid log record.\n          size_t drop_size = buffer_.size();\n          buffer_.clear();\n          ReportCorruption(drop_size, \"checksum mismatch\");\n          return kBadRecord;\n        }\n      }\n  \n      buffer_.remove_prefix(kHeaderSize + length);\n  \n      // Skip physical record that started before initial_offset_\n      if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length <\n          initial_offset_) {\n        result->clear();\n        return kBadRecord;\n      }\n  \n      *result = Slice(header + kHeaderSize, length);\n      return type;\n    }\n  }\n}"
  },
  {
    "function_name": "ReportDrop",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "172-177",
    "snippet": "void Reader::ReportDrop(size_t bytes, const Status& reason) {\n  if (reporter_ != NULL &&\n      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n    reporter_->Corruption(bytes, reason);\n  }\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reporter_->Corruption",
          "args": [
            "bytes",
            "reason"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "CorruptionReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "38-42",
          "snippet": "virtual void Corruption(size_t bytes, const Status& status) {\n    printf(\"corruption: %d bytes; %s\\n\",\n            static_cast<int>(bytes),\n            status.ToString().c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nCorruptionReporter {\n  virtual void Corruption(size_t bytes, const Status& status) {\n      printf(\"corruption: %d bytes; %s\\n\",\n              static_cast<int>(bytes),\n              status.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_.size",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  void Reader::ReportDrop(size_t bytes, const Status& reason) {\n    if (reporter_ != NULL &&\n        end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n      reporter_->Corruption(bytes, reason);\n    }\n  }\n}"
  },
  {
    "function_name": "ReportCorruption",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "168-170",
    "snippet": "void Reader::ReportCorruption(size_t bytes, const char* reason) {\n  ReportDrop(bytes, Status::Corruption(reason));\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReportDrop",
          "args": [
            "bytes",
            "Status::Corruption(reason)"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "ReportDrop",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "172-177",
          "snippet": "void Reader::ReportDrop(size_t bytes, const Status& reason) {\n  if (reporter_ != NULL &&\n      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n    reporter_->Corruption(bytes, reason);\n  }\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  void Reader::ReportDrop(size_t bytes, const Status& reason) {\n    if (reporter_ != NULL &&\n        end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n      reporter_->Corruption(bytes, reason);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "reason"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  void Reader::ReportCorruption(size_t bytes, const char* reason) {\n    ReportDrop(bytes, Status::Corruption(reason));\n  }\n}"
  },
  {
    "function_name": "LastRecordOffset",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "164-166",
    "snippet": "uint64_t Reader::LastRecordOffset() {\n  return last_record_offset_;\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  uint64_t Reader::LastRecordOffset() {\n    return last_record_offset_;\n  }\n}"
  },
  {
    "function_name": "ReadRecord",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "59-162",
    "snippet": "bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n  if (last_record_offset_ < initial_offset_) {\n    if (!SkipToInitialBlock()) {\n      return false;\n    }\n  }\n\n  scratch->clear();\n  record->clear();\n  bool in_fragmented_record = false;\n  // Record offset of the logical record that we're reading\n  // 0 is a dummy value to make compilers happy\n  uint64_t prospective_record_offset = 0;\n\n  Slice fragment;\n  while (true) {\n    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n    const unsigned int record_type = ReadPhysicalRecord(&fragment);\n    switch (record_type) {\n      case kFullType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(1)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->clear();\n        *record = fragment;\n        last_record_offset_ = prospective_record_offset;\n        return true;\n\n      case kFirstType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(2)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->assign(fragment.data(), fragment.size());\n        in_fragmented_record = true;\n        break;\n\n      case kMiddleType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(1)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n        }\n        break;\n\n      case kLastType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(2)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n          *record = Slice(*scratch);\n          last_record_offset_ = prospective_record_offset;\n          return true;\n        }\n        break;\n\n      case kEof:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"partial record without end(3)\");\n          scratch->clear();\n        }\n        return false;\n\n      case kBadRecord:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"error in middle of record\");\n          in_fragmented_record = false;\n          scratch->clear();\n        }\n        break;\n\n      default: {\n        char buf[40];\n        snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n        ReportCorruption(\n            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n            buf);\n        in_fragmented_record = false;\n        scratch->clear();\n        break;\n      }\n    }\n  }\n  return false;\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "scratch->clear",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReportCorruption",
          "args": [
            "(fragment.size() + (in_fragmented_record ? scratch->size() : 0))",
            "buf"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ReportCorruption",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "168-170",
          "snippet": "void Reader::ReportCorruption(size_t bytes, const char* reason) {\n  ReportDrop(bytes, Status::Corruption(reason));\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  void Reader::ReportCorruption(size_t bytes, const char* reason) {\n    ReportDrop(bytes, Status::Corruption(reason));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scratch->size",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"unknown record type %u\"",
            "record_type"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "*scratch"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "scratch->append",
          "args": [
            "fragment.data()",
            "fragment.size()"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fragment.data",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scratch->append",
          "args": [
            "fragment.data()",
            "fragment.size()"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fragment.data",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scratch->assign",
          "args": [
            "fragment.data()",
            "fragment.size()"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fragment.data",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scratch->empty",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadPhysicalRecord",
          "args": [
            "&fragment"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ReadPhysicalRecord",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "179-256",
          "snippet": "unsigned int Reader::ReadPhysicalRecord(Slice* result) {\n  while (true) {\n    if (buffer_.size() < kHeaderSize) {\n      if (!eof_) {\n        // Last read was a full read, so this is a trailer to skip\n        buffer_.clear();\n        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);\n        end_of_buffer_offset_ += buffer_.size();\n        if (!status.ok()) {\n          buffer_.clear();\n          ReportDrop(kBlockSize, status);\n          eof_ = true;\n          return kEof;\n        } else if (buffer_.size() < kBlockSize) {\n          eof_ = true;\n        }\n        continue;\n      } else if (buffer_.size() == 0) {\n        // End of file\n        return kEof;\n      } else {\n        size_t drop_size = buffer_.size();\n        buffer_.clear();\n        ReportCorruption(drop_size, \"truncated record at end of file\");\n        return kEof;\n      }\n    }\n\n    // Parse the header\n    const char* header = buffer_.data();\n    const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;\n    const uint32_t b = static_cast<uint32_t>(header[5]) & 0xff;\n    const unsigned int type = header[6];\n    const uint32_t length = a | (b << 8);\n    if (kHeaderSize + length > buffer_.size()) {\n      size_t drop_size = buffer_.size();\n      buffer_.clear();\n      ReportCorruption(drop_size, \"bad record length\");\n      return kBadRecord;\n    }\n\n    if (type == kZeroType && length == 0) {\n      // Skip zero length record without reporting any drops since\n      // such records are produced by the mmap based writing code in\n      // env_posix.cc that preallocates file regions.\n      buffer_.clear();\n      return kBadRecord;\n    }\n\n    // Check crc\n    if (checksum_) {\n      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));\n      uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);\n      if (actual_crc != expected_crc) {\n        // Drop the rest of the buffer since \"length\" itself may have\n        // been corrupted and if we trust it, we could find some\n        // fragment of a real log record that just happens to look\n        // like a valid log record.\n        size_t drop_size = buffer_.size();\n        buffer_.clear();\n        ReportCorruption(drop_size, \"checksum mismatch\");\n        return kBadRecord;\n      }\n    }\n\n    buffer_.remove_prefix(kHeaderSize + length);\n\n    // Skip physical record that started before initial_offset_\n    if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length <\n        initial_offset_) {\n      result->clear();\n      return kBadRecord;\n    }\n\n    *result = Slice(header + kHeaderSize, length);\n    return type;\n  }\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  unsigned int Reader::ReadPhysicalRecord(Slice* result) {\n    while (true) {\n      if (buffer_.size() < kHeaderSize) {\n        if (!eof_) {\n          // Last read was a full read, so this is a trailer to skip\n          buffer_.clear();\n          Status status = file_->Read(kBlockSize, &buffer_, backing_store_);\n          end_of_buffer_offset_ += buffer_.size();\n          if (!status.ok()) {\n            buffer_.clear();\n            ReportDrop(kBlockSize, status);\n            eof_ = true;\n            return kEof;\n          } else if (buffer_.size() < kBlockSize) {\n            eof_ = true;\n          }\n          continue;\n        } else if (buffer_.size() == 0) {\n          // End of file\n          return kEof;\n        } else {\n          size_t drop_size = buffer_.size();\n          buffer_.clear();\n          ReportCorruption(drop_size, \"truncated record at end of file\");\n          return kEof;\n        }\n      }\n  \n      // Parse the header\n      const char* header = buffer_.data();\n      const uint32_t a = static_cast<uint32_t>(header[4]) & 0xff;\n      const uint32_t b = static_cast<uint32_t>(header[5]) & 0xff;\n      const unsigned int type = header[6];\n      const uint32_t length = a | (b << 8);\n      if (kHeaderSize + length > buffer_.size()) {\n        size_t drop_size = buffer_.size();\n        buffer_.clear();\n        ReportCorruption(drop_size, \"bad record length\");\n        return kBadRecord;\n      }\n  \n      if (type == kZeroType && length == 0) {\n        // Skip zero length record without reporting any drops since\n        // such records are produced by the mmap based writing code in\n        // env_posix.cc that preallocates file regions.\n        buffer_.clear();\n        return kBadRecord;\n      }\n  \n      // Check crc\n      if (checksum_) {\n        uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));\n        uint32_t actual_crc = crc32c::Value(header + 6, 1 + length);\n        if (actual_crc != expected_crc) {\n          // Drop the rest of the buffer since \"length\" itself may have\n          // been corrupted and if we trust it, we could find some\n          // fragment of a real log record that just happens to look\n          // like a valid log record.\n          size_t drop_size = buffer_.size();\n          buffer_.clear();\n          ReportCorruption(drop_size, \"checksum mismatch\");\n          return kBadRecord;\n        }\n      }\n  \n      buffer_.remove_prefix(kHeaderSize + length);\n  \n      // Skip physical record that started before initial_offset_\n      if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length <\n          initial_offset_) {\n        result->clear();\n        return kBadRecord;\n      }\n  \n      *result = Slice(header + kHeaderSize, length);\n      return type;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SkipToInitialBlock",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "SkipToInitialBlock",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "35-57",
          "snippet": "bool Reader::SkipToInitialBlock() {\n  size_t offset_in_block = initial_offset_ % kBlockSize;\n  uint64_t block_start_location = initial_offset_ - offset_in_block;\n\n  // Don't search a block if we'd be in the trailer\n  if (offset_in_block > kBlockSize - 6) {\n    offset_in_block = 0;\n    block_start_location += kBlockSize;\n  }\n\n  end_of_buffer_offset_ = block_start_location;\n\n  // Skip to start of first block that can contain the initial record\n  if (block_start_location > 0) {\n    Status skip_status = file_->Skip(block_start_location);\n    if (!skip_status.ok()) {\n      ReportDrop(block_start_location, skip_status);\n      return false;\n    }\n  }\n\n  return true;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  bool Reader::SkipToInitialBlock() {\n    size_t offset_in_block = initial_offset_ % kBlockSize;\n    uint64_t block_start_location = initial_offset_ - offset_in_block;\n  \n    // Don't search a block if we'd be in the trailer\n    if (offset_in_block > kBlockSize - 6) {\n      offset_in_block = 0;\n      block_start_location += kBlockSize;\n    }\n  \n    end_of_buffer_offset_ = block_start_location;\n  \n    // Skip to start of first block that can contain the initial record\n    if (block_start_location > 0) {\n      Status skip_status = file_->Skip(block_start_location);\n      if (!skip_status.ok()) {\n        ReportDrop(block_start_location, skip_status);\n        return false;\n      }\n    }\n  \n    return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n    if (last_record_offset_ < initial_offset_) {\n      if (!SkipToInitialBlock()) {\n        return false;\n      }\n    }\n  \n    scratch->clear();\n    record->clear();\n    bool in_fragmented_record = false;\n    // Record offset of the logical record that we're reading\n    // 0 is a dummy value to make compilers happy\n    uint64_t prospective_record_offset = 0;\n  \n    Slice fragment;\n    while (true) {\n      uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n      const unsigned int record_type = ReadPhysicalRecord(&fragment);\n      switch (record_type) {\n        case kFullType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(1)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->clear();\n          *record = fragment;\n          last_record_offset_ = prospective_record_offset;\n          return true;\n  \n        case kFirstType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(2)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->assign(fragment.data(), fragment.size());\n          in_fragmented_record = true;\n          break;\n  \n        case kMiddleType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(1)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n          }\n          break;\n  \n        case kLastType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(2)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n            *record = Slice(*scratch);\n            last_record_offset_ = prospective_record_offset;\n            return true;\n          }\n          break;\n  \n        case kEof:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"partial record without end(3)\");\n            scratch->clear();\n          }\n          return false;\n  \n        case kBadRecord:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"error in middle of record\");\n            in_fragmented_record = false;\n            scratch->clear();\n          }\n          break;\n  \n        default: {\n          char buf[40];\n          snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n          ReportCorruption(\n              (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n              buf);\n          in_fragmented_record = false;\n          scratch->clear();\n          break;\n        }\n      }\n    }\n    return false;\n  }\n}"
  },
  {
    "function_name": "SkipToInitialBlock",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "35-57",
    "snippet": "bool Reader::SkipToInitialBlock() {\n  size_t offset_in_block = initial_offset_ % kBlockSize;\n  uint64_t block_start_location = initial_offset_ - offset_in_block;\n\n  // Don't search a block if we'd be in the trailer\n  if (offset_in_block > kBlockSize - 6) {\n    offset_in_block = 0;\n    block_start_location += kBlockSize;\n  }\n\n  end_of_buffer_offset_ = block_start_location;\n\n  // Skip to start of first block that can contain the initial record\n  if (block_start_location > 0) {\n    Status skip_status = file_->Skip(block_start_location);\n    if (!skip_status.ok()) {\n      ReportDrop(block_start_location, skip_status);\n      return false;\n    }\n  }\n\n  return true;\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReportDrop",
          "args": [
            "block_start_location",
            "skip_status"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ReportDrop",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "172-177",
          "snippet": "void Reader::ReportDrop(size_t bytes, const Status& reason) {\n  if (reporter_ != NULL &&\n      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n    reporter_->Corruption(bytes, reason);\n  }\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  void Reader::ReportDrop(size_t bytes, const Status& reason) {\n    if (reporter_ != NULL &&\n        end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {\n      reporter_->Corruption(bytes, reason);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_status.ok",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_->Skip",
          "args": [
            "block_start_location"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "Skip",
          "container": "LogTest::StringSource",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "79-88",
          "snippet": "virtual Status Skip(uint64_t n) {\n      if (n > contents_.size()) {\n        contents_.clear();\n        return Status::NotFound(\"in-memory file skipepd past end\");\n      }\n\n      contents_.remove_prefix(n);\n\n      return Status::OK();\n    }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringSource {\n    virtual Status Skip(uint64_t n) {\n          if (n > contents_.size()) {\n            contents_.clear();\n            return Status::NotFound(\"in-memory file skipepd past end\");\n          }\n    \n          contents_.remove_prefix(n);\n    \n          return Status::OK();\n        }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  bool Reader::SkipToInitialBlock() {\n    size_t offset_in_block = initial_offset_ % kBlockSize;\n    uint64_t block_start_location = initial_offset_ - offset_in_block;\n  \n    // Don't search a block if we'd be in the trailer\n    if (offset_in_block > kBlockSize - 6) {\n      offset_in_block = 0;\n      block_start_location += kBlockSize;\n    }\n  \n    end_of_buffer_offset_ = block_start_location;\n  \n    // Skip to start of first block that can contain the initial record\n    if (block_start_location > 0) {\n      Status skip_status = file_->Skip(block_start_location);\n      if (!skip_status.ok()) {\n        ReportDrop(block_start_location, skip_status);\n        return false;\n      }\n    }\n  \n    return true;\n  }\n}"
  },
  {
    "function_name": "~Reader",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "31-33",
    "snippet": "Reader::~Reader() {\n  delete[] backing_store_;\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  Reader::~Reader() {\n    delete[] backing_store_;\n  }\n}"
  },
  {
    "function_name": "Reader",
    "container": "Reader",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "18-29",
    "snippet": "Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,\n               uint64_t initial_offset)\n    : file_(file),\n      reporter_(reporter),\n      checksum_(checksum),\n      backing_store_(new char[kBlockSize]),\n      buffer_(),\n      eof_(false),\n      last_record_offset_(0),\n      end_of_buffer_offset_(0),\n      initial_offset_(initial_offset) {\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,\n                 uint64_t initial_offset)\n      : file_(file),\n        reporter_(reporter),\n        checksum_(checksum),\n        backing_store_(new char[kBlockSize]),\n        buffer_(),\n        eof_(false),\n        last_record_offset_(0),\n        end_of_buffer_offset_(0),\n        initial_offset_(initial_offset) {\n  }\n}"
  },
  {
    "function_name": "~Reporter",
    "container": "Reader::Reporter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
    "lines": "15-16",
    "snippet": "Reader::Reporter::~Reporter() {\n}",
    "includes": [
      "#include \"util/crc32c.h\"",
      "#include \"util/coding.h\"",
      "#include \"leveldb/env.h\"",
      "#include <stdio.h>",
      "#include \"db/log_reader.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  Reporter {\n    Reader::Reporter::~Reporter() {\n    }\n  }\n}"
  }
]