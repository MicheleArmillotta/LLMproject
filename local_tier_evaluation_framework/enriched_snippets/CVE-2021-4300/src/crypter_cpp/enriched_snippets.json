[
  {
    "function_name": "DecryptSecret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
    "lines": "127-135",
    "snippet": "bool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CSecret& vchPlaintext)\n{\n    CCrypter cKeyCrypter;\n    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n        return false;\n    return cKeyCrypter.Decrypt(vchCiphertext, *((CKeyingMaterial*)&vchPlaintext));\n}",
    "includes": [
      "#include \"scrypt.h\"",
      "#include \"crypter.h\"",
      "#include <windows.h>",
      "#include <string>",
      "#include <vector>",
      "#include <openssl/evp.h>",
      "#include <openssl/aes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cKeyCrypter.Decrypt",
          "args": [
            "vchCiphertext",
            "*((CKeyingMaterial*)&vchPlaintext)"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "Decrypt",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "89-114",
          "snippet": "bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n{\n    if (!fKeySet)\n        return false;\n\n    // plaintext will always be equal to or lesser than length of ciphertext\n    int nLen = vchCiphertext.size();\n    int nPLen = nLen, nFLen = 0;\n\n    vchPlaintext = CKeyingMaterial(nPLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchPlaintext.resize(nPLen + nFLen);\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // plaintext will always be equal to or lesser than length of ciphertext\n      int nLen = vchCiphertext.size();\n      int nPLen = nLen, nFLen = 0;\n  \n      vchPlaintext = CKeyingMaterial(nPLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n      if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchPlaintext.resize(nPLen + nFLen);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cKeyCrypter.SetKey",
          "args": [
            "vMasterKey",
            "chIV"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "SetKey",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "50-60",
          "snippet": "bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n{\n    if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n        return false;\n\n    memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n    memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n\n    fKeySet = true;\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n  {\n      if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n          return false;\n  \n      memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n      memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n  \n      fKeySet = true;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&chIV[0]",
            "&nIV",
            "WALLET_CRYPTO_KEY_SIZE"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nbool DecryptSecret(const CKeyingMaterial& vMasterKey, const std::vector<unsigned char>& vchCiphertext, const uint256& nIV, CSecret& vchPlaintext)\n{\n    CCrypter cKeyCrypter;\n    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n        return false;\n    return cKeyCrypter.Decrypt(vchCiphertext, *((CKeyingMaterial*)&vchPlaintext));\n}"
  },
  {
    "function_name": "EncryptSecret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
    "lines": "117-125",
    "snippet": "bool EncryptSecret(CKeyingMaterial& vMasterKey, const CSecret &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n{\n    CCrypter cKeyCrypter;\n    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n        return false;\n    return cKeyCrypter.Encrypt((CKeyingMaterial)vchPlaintext, vchCiphertext);\n}",
    "includes": [
      "#include \"scrypt.h\"",
      "#include \"crypter.h\"",
      "#include <windows.h>",
      "#include <string>",
      "#include <vector>",
      "#include <openssl/evp.h>",
      "#include <openssl/aes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cKeyCrypter.Encrypt",
          "args": [
            "(CKeyingMaterial)vchPlaintext",
            "vchCiphertext"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "Encrypt",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "62-87",
          "snippet": "bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n{\n    if (!fKeySet)\n        return false;\n\n    // max ciphertext len for a n bytes of plaintext is\n    // n + AES_BLOCK_SIZE - 1 bytes\n    int nLen = vchPlaintext.size();\n    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n    vchCiphertext = std::vector<unsigned char> (nCLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchCiphertext.resize(nCLen + nFLen);\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // max ciphertext len for a n bytes of plaintext is\n      // n + AES_BLOCK_SIZE - 1 bytes\n      int nLen = vchPlaintext.size();\n      int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n      vchCiphertext = std::vector<unsigned char> (nCLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n      if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchCiphertext.resize(nCLen + nFLen);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "cKeyCrypter.SetKey",
          "args": [
            "vMasterKey",
            "chIV"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "SetKey",
          "container": "CCrypter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
          "lines": "50-60",
          "snippet": "bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n{\n    if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n        return false;\n\n    memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n    memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n\n    fKeySet = true;\n    return true;\n}",
          "includes": [
            "#include \"scrypt.h\"",
            "#include \"crypter.h\"",
            "#include <windows.h>",
            "#include <string>",
            "#include <vector>",
            "#include <openssl/evp.h>",
            "#include <openssl/aes.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n  {\n      if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n          return false;\n  \n      memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n      memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n  \n      fKeySet = true;\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&chIV[0]",
            "&nIV",
            "WALLET_CRYPTO_KEY_SIZE"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nbool EncryptSecret(CKeyingMaterial& vMasterKey, const CSecret &vchPlaintext, const uint256& nIV, std::vector<unsigned char> &vchCiphertext)\n{\n    CCrypter cKeyCrypter;\n    std::vector<unsigned char> chIV(WALLET_CRYPTO_KEY_SIZE);\n    memcpy(&chIV[0], &nIV, WALLET_CRYPTO_KEY_SIZE);\n    if(!cKeyCrypter.SetKey(vMasterKey, chIV))\n        return false;\n    return cKeyCrypter.Encrypt((CKeyingMaterial)vchPlaintext, vchCiphertext);\n}"
  },
  {
    "function_name": "Decrypt",
    "container": "CCrypter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
    "lines": "89-114",
    "snippet": "bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n{\n    if (!fKeySet)\n        return false;\n\n    // plaintext will always be equal to or lesser than length of ciphertext\n    int nLen = vchCiphertext.size();\n    int nPLen = nLen, nFLen = 0;\n\n    vchPlaintext = CKeyingMaterial(nPLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchPlaintext.resize(nPLen + nFLen);\n    return true;\n}",
    "includes": [
      "#include \"scrypt.h\"",
      "#include \"crypter.h\"",
      "#include <windows.h>",
      "#include <string>",
      "#include <vector>",
      "#include <openssl/evp.h>",
      "#include <openssl/aes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vchPlaintext.resize",
          "args": [
            "nPLen + nFLen"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_cleanup",
          "args": [
            "&ctx"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DecryptFinal_ex",
          "args": [
            "&ctx",
            "(&vchPlaintext[0])+nPLen",
            "&nFLen"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DecryptUpdate",
          "args": [
            "&ctx",
            "&vchPlaintext[0]",
            "&nPLen",
            "&vchCiphertext[0]",
            "nLen"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_DecryptInit_ex",
          "args": [
            "&ctx",
            "EVP_aes_256_cbc()",
            "NULL",
            "chKey",
            "chIV"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_256_cbc",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_init",
          "args": [
            "&ctx"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CKeyingMaterial",
          "args": [
            "nPLen"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchCiphertext.size",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Decrypt(const std::vector<unsigned char>& vchCiphertext, CKeyingMaterial& vchPlaintext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // plaintext will always be equal to or lesser than length of ciphertext\n      int nLen = vchCiphertext.size();\n      int nPLen = nLen, nFLen = 0;\n  \n      vchPlaintext = CKeyingMaterial(nPLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &vchCiphertext[0], nLen);\n      if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchPlaintext.resize(nPLen + nFLen);\n      return true;\n  }\n}"
  },
  {
    "function_name": "Encrypt",
    "container": "CCrypter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
    "lines": "62-87",
    "snippet": "bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n{\n    if (!fKeySet)\n        return false;\n\n    // max ciphertext len for a n bytes of plaintext is\n    // n + AES_BLOCK_SIZE - 1 bytes\n    int nLen = vchPlaintext.size();\n    int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n    vchCiphertext = std::vector<unsigned char> (nCLen);\n\n    EVP_CIPHER_CTX ctx;\n\n    bool fOk = true;\n\n    EVP_CIPHER_CTX_init(&ctx);\n    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n    EVP_CIPHER_CTX_cleanup(&ctx);\n\n    if (!fOk) return false;\n\n    vchCiphertext.resize(nCLen + nFLen);\n    return true;\n}",
    "includes": [
      "#include \"scrypt.h\"",
      "#include \"crypter.h\"",
      "#include <windows.h>",
      "#include <string>",
      "#include <vector>",
      "#include <openssl/evp.h>",
      "#include <openssl/aes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vchCiphertext.resize",
          "args": [
            "nCLen + nFLen"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_cleanup",
          "args": [
            "&ctx"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_EncryptFinal_ex",
          "args": [
            "&ctx",
            "(&vchCiphertext[0])+nCLen",
            "&nFLen"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_EncryptUpdate",
          "args": [
            "&ctx",
            "&vchCiphertext[0]",
            "&nCLen",
            "&vchPlaintext[0]",
            "nLen"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_EncryptInit_ex",
          "args": [
            "&ctx",
            "EVP_aes_256_cbc()",
            "NULL",
            "chKey",
            "chIV"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_256_cbc",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_CIPHER_CTX_init",
          "args": [
            "&ctx"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::vector<unsigned char>",
          "args": [
            "nCLen"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchPlaintext.size",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::Encrypt(const CKeyingMaterial& vchPlaintext, std::vector<unsigned char> &vchCiphertext)\n  {\n      if (!fKeySet)\n          return false;\n  \n      // max ciphertext len for a n bytes of plaintext is\n      // n + AES_BLOCK_SIZE - 1 bytes\n      int nLen = vchPlaintext.size();\n      int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;\n      vchCiphertext = std::vector<unsigned char> (nCLen);\n  \n      EVP_CIPHER_CTX ctx;\n  \n      bool fOk = true;\n  \n      EVP_CIPHER_CTX_init(&ctx);\n      if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, chKey, chIV);\n      if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, &vchPlaintext[0], nLen);\n      if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);\n      EVP_CIPHER_CTX_cleanup(&ctx);\n  \n      if (!fOk) return false;\n  \n      vchCiphertext.resize(nCLen + nFLen);\n      return true;\n  }\n}"
  },
  {
    "function_name": "SetKey",
    "container": "CCrypter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
    "lines": "50-60",
    "snippet": "bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n{\n    if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n        return false;\n\n    memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n    memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n\n    fKeySet = true;\n    return true;\n}",
    "includes": [
      "#include \"scrypt.h\"",
      "#include \"crypter.h\"",
      "#include <windows.h>",
      "#include <string>",
      "#include <vector>",
      "#include <openssl/evp.h>",
      "#include <openssl/aes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&chIV[0]",
            "&chNewIV[0]",
            "sizeof chIV"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&chKey[0]",
            "&chNewKey[0]",
            "sizeof chKey"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chNewIV.size",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::SetKey(const CKeyingMaterial& chNewKey, const std::vector<unsigned char>& chNewIV)\n  {\n      if (chNewKey.size() != WALLET_CRYPTO_KEY_SIZE || chNewIV.size() != WALLET_CRYPTO_KEY_SIZE)\n          return false;\n  \n      memcpy(&chKey[0], &chNewKey[0], sizeof chKey);\n      memcpy(&chIV[0], &chNewIV[0], sizeof chIV);\n  \n      fKeySet = true;\n      return true;\n  }\n}"
  },
  {
    "function_name": "SetKeyFromPassphrase",
    "container": "CCrypter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.cpp",
    "lines": "16-48",
    "snippet": "bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n{\n    if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n        return false;\n\n    int i = 0;\n    if (nDerivationMethod == 0)\n    {\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n    }\n\n    if (nDerivationMethod == 1)\n    {\n        // Passphrase conversion\n        uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n\n        i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                          (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n        OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n    }\n\n\n    if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n    {\n        OPENSSL_cleanse(&chKey, sizeof chKey);\n        OPENSSL_cleanse(&chIV, sizeof chIV);\n        return false;\n    }\n\n    fKeySet = true;\n    return true;\n}",
    "includes": [
      "#include \"scrypt.h\"",
      "#include \"crypter.h\"",
      "#include <windows.h>",
      "#include <string>",
      "#include <vector>",
      "#include <openssl/evp.h>",
      "#include <openssl/aes.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OPENSSL_cleanse",
          "args": [
            "&chIV",
            "sizeof chIV"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPENSSL_cleanse",
          "args": [
            "&chKey",
            "sizeof chKey"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPENSSL_cleanse",
          "args": [
            "&scryptHash",
            "sizeof scryptHash"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "EVP_aes_256_cbc()",
            "EVP_sha512()",
            "&chSalt[0]",
            "(unsigned char *)&scryptHash",
            "sizeof scryptHash",
            "nRounds",
            "chKey",
            "chIV"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha512",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_256_cbc",
          "args": [],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scrypt_salted_multiround_hash",
          "args": [
            "(const void*)strKeyData.c_str()",
            "strKeyData.size()",
            "&chSalt[0]",
            "8",
            "nRounds"
          ],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "scrypt_salted_multiround_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/scrypt.cpp",
          "lines": "179-191",
          "snippet": "uint256 scrypt_salted_multiround_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen, const unsigned int nRounds)\n{\n    uint256 resultHash = scrypt_salted_hash(input, inputlen, salt, saltlen);\n    uint256 transitionalHash = resultHash;\n\n    for(unsigned int i = 1; i < nRounds; i++)\n    {\n        resultHash = scrypt_salted_hash(input, inputlen, (const void*)&transitionalHash, 32);\n        transitionalHash = resultHash;\n    }\n\n    return resultHash;\n}",
          "includes": [
            "#include \"net.h\"",
            "#include \"util.h\"",
            "#include \"pbkdf2.h\"",
            "#include \"scrypt.h\"",
            "#include <stdint.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"net.h\"\n#include \"util.h\"\n#include \"pbkdf2.h\"\n#include \"scrypt.h\"\n#include <stdint.h>\n#include <stdlib.h>\n\nuint256 scrypt_salted_multiround_hash(const void* input, size_t inputlen, const void* salt, size_t saltlen, const unsigned int nRounds)\n{\n    uint256 resultHash = scrypt_salted_hash(input, inputlen, salt, saltlen);\n    uint256 transitionalHash = resultHash;\n\n    for(unsigned int i = 1; i < nRounds; i++)\n    {\n        resultHash = scrypt_salted_hash(input, inputlen, (const void*)&transitionalHash, 32);\n        transitionalHash = resultHash;\n    }\n\n    return resultHash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strKeyData.size",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strKeyData.c_str",
          "args": [],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_BytesToKey",
          "args": [
            "EVP_aes_256_cbc()",
            "EVP_sha512()",
            "&chSalt[0]",
            "(unsigned char *)&strKeyData[0]",
            "strKeyData.size()",
            "nRounds",
            "chKey",
            "chIV"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_sha512",
          "args": [],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EVP_aes_256_cbc",
          "args": [],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"scrypt.h\"\n#include \"crypter.h\"\n#include <windows.h>\n#include <string>\n#include <vector>\n#include <openssl/evp.h>\n#include <openssl/aes.h>\n\nCCrypter {\n  bool CCrypter::SetKeyFromPassphrase(const SecureString& strKeyData, const std::vector<unsigned char>& chSalt, const unsigned int nRounds, const unsigned int nDerivationMethod)\n  {\n      if (nRounds < 1 || chSalt.size() != WALLET_CRYPTO_SALT_SIZE)\n          return false;\n  \n      int i = 0;\n      if (nDerivationMethod == 0)\n      {\n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&strKeyData[0], strKeyData.size(), nRounds, chKey, chIV);\n      }\n  \n      if (nDerivationMethod == 1)\n      {\n          // Passphrase conversion\n          uint256 scryptHash = scrypt_salted_multiround_hash((const void*)strKeyData.c_str(), strKeyData.size(), &chSalt[0], 8, nRounds);\n  \n          i = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha512(), &chSalt[0],\n                            (unsigned char *)&scryptHash, sizeof scryptHash, nRounds, chKey, chIV);\n          OPENSSL_cleanse(&scryptHash, sizeof scryptHash);\n      }\n  \n  \n      if (i != (int)WALLET_CRYPTO_KEY_SIZE)\n      {\n          OPENSSL_cleanse(&chKey, sizeof chKey);\n          OPENSSL_cleanse(&chIV, sizeof chIV);\n          return false;\n      }\n  \n      fKeySet = true;\n      return true;\n  }\n}"
  }
]