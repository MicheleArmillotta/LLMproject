[
  {
    "function_name": "ReleaseInputs",
    "container": "Compaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1491-1496",
    "snippet": "void Compaction::ReleaseInputs() {\n  if (input_version_ != NULL) {\n    input_version_->Unref();\n    input_version_ = NULL;\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "input_version_->Unref",
          "args": [],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "491-498",
          "snippet": "void Version::Unref() {\n  assert(this != &vset_->dummy_versions_);\n  assert(refs_ >= 1);\n  --refs_;\n  if (refs_ == 0) {\n    delete this;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Unref() {\n    assert(this != &vset_->dummy_versions_);\n    assert(refs_ >= 1);\n    --refs_;\n    if (refs_ == 0) {\n      delete this;\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  void Compaction::ReleaseInputs() {\n    if (input_version_ != NULL) {\n      input_version_->Unref();\n      input_version_ = NULL;\n    }\n  }\n}"
  },
  {
    "function_name": "ShouldStopBefore",
    "container": "Compaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1469-1489",
    "snippet": "bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n  // Scan to find earliest grandparent file that contains key.\n  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n  while (grandparent_index_ < grandparents_.size() &&\n      icmp->Compare(internal_key,\n                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n    if (seen_key_) {\n      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;\n    }\n    grandparent_index_++;\n  }\n  seen_key_ = true;\n\n  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n    // Too much overlap for current output; start new output\n    overlapped_bytes_ = 0;\n    return true;\n  } else {\n    return false;\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "icmp->Compare",
          "args": [
            "internal_key",
            "grandparents_[grandparent_index_]->largest.Encode()"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "grandparents_[grandparent_index_]->largest.Encode",
          "args": [],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "154-157",
          "snippet": "Slice Encode() const {\n    assert(!rep_.empty());\n    return rep_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  Slice Encode() const {\n      assert(!rep_.empty());\n      return rep_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "grandparents_.size",
          "args": [],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n    // Scan to find earliest grandparent file that contains key.\n    const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n    while (grandparent_index_ < grandparents_.size() &&\n        icmp->Compare(internal_key,\n                      grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n      if (seen_key_) {\n        overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;\n      }\n      grandparent_index_++;\n    }\n    seen_key_ = true;\n  \n    if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n      // Too much overlap for current output; start new output\n      overlapped_bytes_ = 0;\n      return true;\n    } else {\n      return false;\n    }\n  }\n}"
  },
  {
    "function_name": "IsBaseLevelForKey",
    "container": "Compaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1448-1467",
    "snippet": "bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n  // Maybe use binary search to find right entry instead of linear search?\n  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();\n  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {\n    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];\n    for (; level_ptrs_[lvl] < files.size(); ) {\n      FileMetaData* f = files[level_ptrs_[lvl]];\n      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {\n        // We've advanced far enough\n        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {\n          // Key falls in this file's range, so definitely not base level\n          return false;\n        }\n        break;\n      }\n      level_ptrs_[lvl]++;\n    }\n  }\n  return true;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_cmp->Compare",
          "args": [
            "user_key",
            "f->smallest.user_key()"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->smallest.user_key",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "input_version_->vset_->icmp_.user_comparator",
          "args": [],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n    // Maybe use binary search to find right entry instead of linear search?\n    const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();\n    for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {\n      const std::vector<FileMetaData*>& files = input_version_->files_[lvl];\n      for (; level_ptrs_[lvl] < files.size(); ) {\n        FileMetaData* f = files[level_ptrs_[lvl]];\n        if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {\n          // We've advanced far enough\n          if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {\n            // Key falls in this file's range, so definitely not base level\n            return false;\n          }\n          break;\n        }\n        level_ptrs_[lvl]++;\n      }\n    }\n    return true;\n  }\n}"
  },
  {
    "function_name": "AddInputDeletions",
    "container": "Compaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1440-1446",
    "snippet": "void Compaction::AddInputDeletions(VersionEdit* edit) {\n  for (int which = 0; which < 2; which++) {\n    for (size_t i = 0; i < inputs_[which].size(); i++) {\n      edit->DeleteFile(level_ + which, inputs_[which][i]->number);\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "edit->DeleteFile",
          "args": [
            "level_ + which",
            "inputs_[which][i]->number"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "75-77",
          "snippet": "void DeleteFile(int level, uint64_t file) {\n    deleted_files_.insert(std::make_pair(level, file));\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void DeleteFile(int level, uint64_t file) {\n      deleted_files_.insert(std::make_pair(level, file));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputs_[which].size",
          "args": [],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  void Compaction::AddInputDeletions(VersionEdit* edit) {\n    for (int which = 0; which < 2; which++) {\n      for (size_t i = 0; i < inputs_[which].size(); i++) {\n        edit->DeleteFile(level_ + which, inputs_[which][i]->number);\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "IsTrivialMove",
    "container": "Compaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1431-1438",
    "snippet": "bool Compaction::IsTrivialMove() const {\n  // Avoid a move if there is lots of overlapping grandparent data.\n  // Otherwise, the move could create a parent file that will require\n  // a very expensive merge later on.\n  return (num_input_files(0) == 1 &&\n          num_input_files(1) == 0 &&\n          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TotalFileSize",
          "args": [
            "grandparents_"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "TotalFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "49-55",
          "snippet": "static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_input_files",
          "args": [
            "1"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "num_input_files",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "335-335",
          "snippet": "int num_input_files(int which) const { return inputs_[which].size(); }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int num_input_files(int which) const { return inputs_[which].size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  bool Compaction::IsTrivialMove() const {\n    // Avoid a move if there is lots of overlapping grandparent data.\n    // Otherwise, the move could create a parent file that will require\n    // a very expensive merge later on.\n    return (num_input_files(0) == 1 &&\n            num_input_files(1) == 0 &&\n            TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n  }\n}"
  },
  {
    "function_name": "~Compaction",
    "container": "Compaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1425-1429",
    "snippet": "Compaction::~Compaction() {\n  if (input_version_ != NULL) {\n    input_version_->Unref();\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "input_version_->Unref",
          "args": [],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "491-498",
          "snippet": "void Version::Unref() {\n  assert(this != &vset_->dummy_versions_);\n  assert(refs_ >= 1);\n  --refs_;\n  if (refs_ == 0) {\n    delete this;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Unref() {\n    assert(this != &vset_->dummy_versions_);\n    assert(refs_ >= 1);\n    --refs_;\n    if (refs_ == 0) {\n      delete this;\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  Compaction::~Compaction() {\n    if (input_version_ != NULL) {\n      input_version_->Unref();\n    }\n  }\n}"
  },
  {
    "function_name": "Compaction",
    "container": "Compaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1413-1423",
    "snippet": "Compaction::Compaction(int level)\n    : level_(level),\n      max_output_file_size_(MaxFileSizeForLevel(level)),\n      input_version_(NULL),\n      grandparent_index_(0),\n      seen_key_(false),\n      overlapped_bytes_(0) {\n  for (int i = 0; i < config::kNumLevels; i++) {\n    level_ptrs_[i] = 0;\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MaxFileSizeForLevel",
          "args": [
            "level"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "MaxFileSizeForLevel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "45-47",
          "snippet": "static uint64_t MaxFileSizeForLevel(int level) {\n  return kTargetFileSize;  // We could vary per level to reduce number of files?\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic uint64_t MaxFileSizeForLevel(int level) {\n  return kTargetFileSize;  // We could vary per level to reduce number of files?\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nCompaction {\n  Compaction::Compaction(int level)\n      : level_(level),\n        max_output_file_size_(MaxFileSizeForLevel(level)),\n        input_version_(NULL),\n        grandparent_index_(0),\n        seen_key_(false),\n        overlapped_bytes_(0) {\n    for (int i = 0; i < config::kNumLevels; i++) {\n      level_ptrs_[i] = 0;\n    }\n  }\n}"
  },
  {
    "function_name": "SetupOtherInputs",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1311-1376",
    "snippet": "void VersionSet::SetupOtherInputs(Compaction* c) {\n  const int level = c->level();\n  InternalKey smallest, largest;\n  GetRange(c->inputs_[0], &smallest, &largest);\n\n  current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);\n\n  // Get entire range covered by compaction\n  InternalKey all_start, all_limit;\n  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);\n\n  // See if we can grow the number of inputs in \"level\" without\n  // changing the number of \"level+1\" files we pick up.\n  if (!c->inputs_[1].empty()) {\n    std::vector<FileMetaData*> expanded0;\n    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);\n    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);\n    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);\n    const int64_t expanded0_size = TotalFileSize(expanded0);\n    if (expanded0.size() > c->inputs_[0].size() &&\n        inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {\n      InternalKey new_start, new_limit;\n      GetRange(expanded0, &new_start, &new_limit);\n      std::vector<FileMetaData*> expanded1;\n      current_->GetOverlappingInputs(level+1, &new_start, &new_limit,\n                                     &expanded1);\n      if (expanded1.size() == c->inputs_[1].size()) {\n        Log(options_->info_log,\n            \"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\\n\",\n            level,\n            int(c->inputs_[0].size()),\n            int(c->inputs_[1].size()),\n            long(inputs0_size), long(inputs1_size),\n            int(expanded0.size()),\n            int(expanded1.size()),\n            long(expanded0_size), long(inputs1_size));\n        smallest = new_start;\n        largest = new_limit;\n        c->inputs_[0] = expanded0;\n        c->inputs_[1] = expanded1;\n        GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);\n      }\n    }\n  }\n\n  // Compute the set of grandparent files that overlap this compaction\n  // (parent == level+1; grandparent == level+2)\n  if (level + 2 < config::kNumLevels) {\n    current_->GetOverlappingInputs(level + 2, &all_start, &all_limit,\n                                   &c->grandparents_);\n  }\n\n  if (false) {\n    Log(options_->info_log, \"Compacting %d '%s' .. '%s'\",\n        level,\n        smallest.DebugString().c_str(),\n        largest.DebugString().c_str());\n  }\n\n  // Update the place where we will do the next compaction for this level.\n  // We update this immediately instead of waiting for the VersionEdit\n  // to be applied so that if the compaction fails, we will try a different\n  // key range next time.\n  compact_pointer_[level] = largest.Encode().ToString();\n  c->edit_.SetCompactPointer(level, largest);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->edit_.SetCompactPointer",
          "args": [
            "level",
            "largest"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompactPointer",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "55-57",
          "snippet": "void SetCompactPointer(int level, const InternalKey& key) {\n    compact_pointers_.push_back(std::make_pair(level, key));\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetCompactPointer(int level, const InternalKey& key) {\n      compact_pointers_.push_back(std::make_pair(level, key));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "largest.Encode",
          "args": [],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "154-157",
          "snippet": "Slice Encode() const {\n    assert(!rep_.empty());\n    return rep_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  Slice Encode() const {\n      assert(!rep_.empty());\n      return rep_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_->info_log",
            "\"Compacting %d '%s' .. '%s'\"",
            "level",
            "smallest.DebugString().c_str()",
            "largest.DebugString().c_str()"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "largest.DebugString",
          "args": [],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "DebugString",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "579-603",
          "snippet": "std::string Version::DebugString() const {\n  std::string r;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    // E.g.,\n    //   --- level 1 ---\n    //   17:123['a' .. 'd']\n    //   20:43['e' .. 'g']\n    r.append(\"--- level \");\n    AppendNumberTo(&r, level);\n    r.append(\" ---\\n\");\n    const std::vector<FileMetaData*>& files = files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      r.push_back(' ');\n      AppendNumberTo(&r, files[i]->number);\n      r.push_back(':');\n      AppendNumberTo(&r, files[i]->file_size);\n      r.append(\"[\");\n      r.append(files[i]->smallest.DebugString());\n      r.append(\" .. \");\n      r.append(files[i]->largest.DebugString());\n      r.append(\"]\\n\");\n    }\n  }\n  return r;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  std::string Version::DebugString() const {\n    std::string r;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // E.g.,\n      //   --- level 1 ---\n      //   17:123['a' .. 'd']\n      //   20:43['e' .. 'g']\n      r.append(\"--- level \");\n      AppendNumberTo(&r, level);\n      r.append(\" ---\\n\");\n      const std::vector<FileMetaData*>& files = files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        r.push_back(' ');\n        AppendNumberTo(&r, files[i]->number);\n        r.push_back(':');\n        AppendNumberTo(&r, files[i]->file_size);\n        r.append(\"[\");\n        r.append(files[i]->smallest.DebugString());\n        r.append(\" .. \");\n        r.append(files[i]->largest.DebugString());\n        r.append(\"]\\n\");\n      }\n    }\n    return r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_->GetOverlappingInputs",
          "args": [
            "level + 2",
            "&all_start",
            "&all_limit",
            "&c->grandparents_"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "GetOverlappingInputs",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "536-577",
          "snippet": "void Version::GetOverlappingInputs(\n    int level,\n    const InternalKey* begin,\n    const InternalKey* end,\n    std::vector<FileMetaData*>* inputs) {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  inputs->clear();\n  Slice user_begin, user_end;\n  if (begin != NULL) {\n    user_begin = begin->user_key();\n  }\n  if (end != NULL) {\n    user_end = end->user_key();\n  }\n  const Comparator* user_cmp = vset_->icmp_.user_comparator();\n  for (size_t i = 0; i < files_[level].size(); ) {\n    FileMetaData* f = files_[level][i++];\n    const Slice file_start = f->smallest.user_key();\n    const Slice file_limit = f->largest.user_key();\n    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n      // \"f\" is completely before specified range; skip it\n    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n      // \"f\" is completely after specified range; skip it\n    } else {\n      inputs->push_back(f);\n      if (level == 0) {\n        // Level-0 files may overlap each other.  So check if the newly\n        // added file has expanded the range.  If so, restart search.\n        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n          user_begin = file_start;\n          inputs->clear();\n          i = 0;\n        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n          user_end = file_limit;\n          inputs->clear();\n          i = 0;\n        }\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::GetOverlappingInputs(\n      int level,\n      const InternalKey* begin,\n      const InternalKey* end,\n      std::vector<FileMetaData*>* inputs) {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    inputs->clear();\n    Slice user_begin, user_end;\n    if (begin != NULL) {\n      user_begin = begin->user_key();\n    }\n    if (end != NULL) {\n      user_end = end->user_key();\n    }\n    const Comparator* user_cmp = vset_->icmp_.user_comparator();\n    for (size_t i = 0; i < files_[level].size(); ) {\n      FileMetaData* f = files_[level][i++];\n      const Slice file_start = f->smallest.user_key();\n      const Slice file_limit = f->largest.user_key();\n      if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n        // \"f\" is completely before specified range; skip it\n      } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n        // \"f\" is completely after specified range; skip it\n      } else {\n        inputs->push_back(f);\n        if (level == 0) {\n          // Level-0 files may overlap each other.  So check if the newly\n          // added file has expanded the range.  If so, restart search.\n          if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n            user_begin = file_start;\n            inputs->clear();\n            i = 0;\n          } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n            user_end = file_limit;\n            inputs->clear();\n            i = 0;\n          }\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRange2",
          "args": [
            "c->inputs_[0]",
            "c->inputs_[1]",
            "&all_start",
            "&all_limit"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "GetRange2",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1215-1222",
          "snippet": "void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,\n                           const std::vector<FileMetaData*>& inputs2,\n                           InternalKey* smallest,\n                           InternalKey* largest) {\n  std::vector<FileMetaData*> all = inputs1;\n  all.insert(all.end(), inputs2.begin(), inputs2.end());\n  GetRange(all, smallest, largest);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,\n                             const std::vector<FileMetaData*>& inputs2,\n                             InternalKey* smallest,\n                             InternalKey* largest) {\n    std::vector<FileMetaData*> all = inputs1;\n    all.insert(all.end(), inputs2.begin(), inputs2.end());\n    GetRange(all, smallest, largest);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_->info_log",
            "\"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\\n\"",
            "level",
            "int(c->inputs_[0].size())",
            "int(c->inputs_[1].size())",
            "long(inputs0_size)",
            "long(inputs1_size)",
            "int(expanded0.size())",
            "int(expanded1.size())",
            "long(expanded0_size)",
            "long(inputs1_size)"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "long",
          "args": [
            "inputs1_size"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "setulong",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "140-144",
          "snippet": "void setulong(unsigned long n)\n    {\n        if (!BN_set_word(this, n))\n            throw bignum_error(\"CBigNum conversion from unsigned long : BN_set_word failed\");\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void setulong(unsigned long n)\n      {\n          if (!BN_set_word(this, n))\n              throw bignum_error(\"CBigNum conversion from unsigned long : BN_set_word failed\");\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "int",
          "args": [
            "expanded1.size()"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "VersionEditPrinter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "110-118",
          "snippet": "static void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nstatic void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "expanded1.size",
          "args": [],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->inputs_[1].size",
          "args": [],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "TransactionTablePriv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "170-173",
          "snippet": "int size()\n    {\n        return cachedWallet.size();\n    }",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTablePriv {\n  int size()\n      {\n          return cachedWallet.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRange",
          "args": [
            "expanded0",
            "&new_start",
            "&new_limit"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "GetRange",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1190-1210",
          "snippet": "void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,\n                          InternalKey* smallest,\n                          InternalKey* largest) {\n  assert(!inputs.empty());\n  smallest->Clear();\n  largest->Clear();\n  for (size_t i = 0; i < inputs.size(); i++) {\n    FileMetaData* f = inputs[i];\n    if (i == 0) {\n      *smallest = f->smallest;\n      *largest = f->largest;\n    } else {\n      if (icmp_.Compare(f->smallest, *smallest) < 0) {\n        *smallest = f->smallest;\n      }\n      if (icmp_.Compare(f->largest, *largest) > 0) {\n        *largest = f->largest;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,\n                            InternalKey* smallest,\n                            InternalKey* largest) {\n    assert(!inputs.empty());\n    smallest->Clear();\n    largest->Clear();\n    for (size_t i = 0; i < inputs.size(); i++) {\n      FileMetaData* f = inputs[i];\n      if (i == 0) {\n        *smallest = f->smallest;\n        *largest = f->largest;\n      } else {\n        if (icmp_.Compare(f->smallest, *smallest) < 0) {\n          *smallest = f->smallest;\n        }\n        if (icmp_.Compare(f->largest, *largest) > 0) {\n          *largest = f->largest;\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TotalFileSize",
          "args": [
            "expanded0"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "TotalFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "49-55",
          "snippet": "static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->inputs_[1].empty",
          "args": [],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "BlockBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/block_builder.h",
          "lines": "38-40",
          "snippet": "bool empty() const {\n    return buffer_.empty();\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <vector>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <vector>\n\nBlockBuilder {\n  bool empty() const {\n      return buffer_.empty();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "c->level",
          "args": [],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "level",
          "container": "Compaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "328-328",
          "snippet": "int level() const { return level_; }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nCompaction {\n  int level() const { return level_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::SetupOtherInputs(Compaction* c) {\n    const int level = c->level();\n    InternalKey smallest, largest;\n    GetRange(c->inputs_[0], &smallest, &largest);\n  \n    current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);\n  \n    // Get entire range covered by compaction\n    InternalKey all_start, all_limit;\n    GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);\n  \n    // See if we can grow the number of inputs in \"level\" without\n    // changing the number of \"level+1\" files we pick up.\n    if (!c->inputs_[1].empty()) {\n      std::vector<FileMetaData*> expanded0;\n      current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);\n      const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);\n      const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);\n      const int64_t expanded0_size = TotalFileSize(expanded0);\n      if (expanded0.size() > c->inputs_[0].size() &&\n          inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {\n        InternalKey new_start, new_limit;\n        GetRange(expanded0, &new_start, &new_limit);\n        std::vector<FileMetaData*> expanded1;\n        current_->GetOverlappingInputs(level+1, &new_start, &new_limit,\n                                       &expanded1);\n        if (expanded1.size() == c->inputs_[1].size()) {\n          Log(options_->info_log,\n              \"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\\n\",\n              level,\n              int(c->inputs_[0].size()),\n              int(c->inputs_[1].size()),\n              long(inputs0_size), long(inputs1_size),\n              int(expanded0.size()),\n              int(expanded1.size()),\n              long(expanded0_size), long(inputs1_size));\n          smallest = new_start;\n          largest = new_limit;\n          c->inputs_[0] = expanded0;\n          c->inputs_[1] = expanded1;\n          GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);\n        }\n      }\n    }\n  \n    // Compute the set of grandparent files that overlap this compaction\n    // (parent == level+1; grandparent == level+2)\n    if (level + 2 < config::kNumLevels) {\n      current_->GetOverlappingInputs(level + 2, &all_start, &all_limit,\n                                     &c->grandparents_);\n    }\n  \n    if (false) {\n      Log(options_->info_log, \"Compacting %d '%s' .. '%s'\",\n          level,\n          smallest.DebugString().c_str(),\n          largest.DebugString().c_str());\n    }\n  \n    // Update the place where we will do the next compaction for this level.\n    // We update this immediately instead of waiting for the VersionEdit\n    // to be applied so that if the compaction fails, we will try a different\n    // key range next time.\n    compact_pointer_[level] = largest.Encode().ToString();\n    c->edit_.SetCompactPointer(level, largest);\n  }\n}"
  },
  {
    "function_name": "GetRange2",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1215-1222",
    "snippet": "void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,\n                           const std::vector<FileMetaData*>& inputs2,\n                           InternalKey* smallest,\n                           InternalKey* largest) {\n  std::vector<FileMetaData*> all = inputs1;\n  all.insert(all.end(), inputs2.begin(), inputs2.end());\n  GetRange(all, smallest, largest);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetRange",
          "args": [
            "all",
            "smallest",
            "largest"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "GetRange",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1190-1210",
          "snippet": "void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,\n                          InternalKey* smallest,\n                          InternalKey* largest) {\n  assert(!inputs.empty());\n  smallest->Clear();\n  largest->Clear();\n  for (size_t i = 0; i < inputs.size(); i++) {\n    FileMetaData* f = inputs[i];\n    if (i == 0) {\n      *smallest = f->smallest;\n      *largest = f->largest;\n    } else {\n      if (icmp_.Compare(f->smallest, *smallest) < 0) {\n        *smallest = f->smallest;\n      }\n      if (icmp_.Compare(f->largest, *largest) > 0) {\n        *largest = f->largest;\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,\n                            InternalKey* smallest,\n                            InternalKey* largest) {\n    assert(!inputs.empty());\n    smallest->Clear();\n    largest->Clear();\n    for (size_t i = 0; i < inputs.size(); i++) {\n      FileMetaData* f = inputs[i];\n      if (i == 0) {\n        *smallest = f->smallest;\n        *largest = f->largest;\n      } else {\n        if (icmp_.Compare(f->smallest, *smallest) < 0) {\n          *smallest = f->smallest;\n        }\n        if (icmp_.Compare(f->largest, *largest) > 0) {\n          *largest = f->largest;\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "all.insert",
          "args": [
            "all.end()",
            "inputs2.begin()",
            "inputs2.end()"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "839-850",
          "snippet": "void insert(iterator it, const char* first, const char* last)\n    {\n        assert(last - first >= 0);\n        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n        {\n            // special case for inserting at the front when there's room\n            nReadPos -= (last - first);\n            memcpy(&vch[nReadPos], &first[0], last - first);\n        }\n        else\n            vch.insert(it, first, last);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void insert(iterator it, const char* first, const char* last)\n      {\n          assert(last - first >= 0);\n          if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n          {\n              // special case for inserting at the front when there's room\n              nReadPos -= (last - first);\n              memcpy(&vch[nReadPos], &first[0], last - first);\n          }\n          else\n              vch.insert(it, first, last);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputs2.end",
          "args": [],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputs2.begin",
          "args": [],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,\n                             const std::vector<FileMetaData*>& inputs2,\n                             InternalKey* smallest,\n                             InternalKey* largest) {\n    std::vector<FileMetaData*> all = inputs1;\n    all.insert(all.end(), inputs2.begin(), inputs2.end());\n    GetRange(all, smallest, largest);\n  }\n}"
  },
  {
    "function_name": "GetRange",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1190-1210",
    "snippet": "void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,\n                          InternalKey* smallest,\n                          InternalKey* largest) {\n  assert(!inputs.empty());\n  smallest->Clear();\n  largest->Clear();\n  for (size_t i = 0; i < inputs.size(); i++) {\n    FileMetaData* f = inputs[i];\n    if (i == 0) {\n      *smallest = f->smallest;\n      *largest = f->largest;\n    } else {\n      if (icmp_.Compare(f->smallest, *smallest) < 0) {\n        *smallest = f->smallest;\n      }\n      if (icmp_.Compare(f->largest, *largest) > 0) {\n        *largest = f->largest;\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "icmp_.Compare",
          "args": [
            "f->largest",
            "*largest"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputs.size",
          "args": [],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "largest->Clear",
          "args": [],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!inputs.empty()"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputs.empty",
          "args": [],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,\n                            InternalKey* smallest,\n                            InternalKey* largest) {\n    assert(!inputs.empty());\n    smallest->Clear();\n    largest->Clear();\n    for (size_t i = 0; i < inputs.size(); i++) {\n      FileMetaData* f = inputs[i];\n      if (i == 0) {\n        *smallest = f->smallest;\n        *largest = f->largest;\n      } else {\n        if (icmp_.Compare(f->smallest, *smallest) < 0) {\n          *smallest = f->smallest;\n        }\n        if (icmp_.Compare(f->largest, *largest) > 0) {\n          *largest = f->largest;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "MaxNextLevelOverlappingBytes",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1170-1185",
    "snippet": "int64_t VersionSet::MaxNextLevelOverlappingBytes() {\n  int64_t result = 0;\n  std::vector<FileMetaData*> overlaps;\n  for (int level = 1; level < config::kNumLevels - 1; level++) {\n    for (size_t i = 0; i < current_->files_[level].size(); i++) {\n      const FileMetaData* f = current_->files_[level][i];\n      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,\n                                     &overlaps);\n      const int64_t sum = TotalFileSize(overlaps);\n      if (sum > result) {\n        result = sum;\n      }\n    }\n  }\n  return result;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TotalFileSize",
          "args": [
            "overlaps"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "TotalFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "49-55",
          "snippet": "static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_->GetOverlappingInputs",
          "args": [
            "level+1",
            "&f->smallest",
            "&f->largest",
            "&overlaps"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "GetOverlappingInputs",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "536-577",
          "snippet": "void Version::GetOverlappingInputs(\n    int level,\n    const InternalKey* begin,\n    const InternalKey* end,\n    std::vector<FileMetaData*>* inputs) {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  inputs->clear();\n  Slice user_begin, user_end;\n  if (begin != NULL) {\n    user_begin = begin->user_key();\n  }\n  if (end != NULL) {\n    user_end = end->user_key();\n  }\n  const Comparator* user_cmp = vset_->icmp_.user_comparator();\n  for (size_t i = 0; i < files_[level].size(); ) {\n    FileMetaData* f = files_[level][i++];\n    const Slice file_start = f->smallest.user_key();\n    const Slice file_limit = f->largest.user_key();\n    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n      // \"f\" is completely before specified range; skip it\n    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n      // \"f\" is completely after specified range; skip it\n    } else {\n      inputs->push_back(f);\n      if (level == 0) {\n        // Level-0 files may overlap each other.  So check if the newly\n        // added file has expanded the range.  If so, restart search.\n        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n          user_begin = file_start;\n          inputs->clear();\n          i = 0;\n        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n          user_end = file_limit;\n          inputs->clear();\n          i = 0;\n        }\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::GetOverlappingInputs(\n      int level,\n      const InternalKey* begin,\n      const InternalKey* end,\n      std::vector<FileMetaData*>* inputs) {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    inputs->clear();\n    Slice user_begin, user_end;\n    if (begin != NULL) {\n      user_begin = begin->user_key();\n    }\n    if (end != NULL) {\n      user_end = end->user_key();\n    }\n    const Comparator* user_cmp = vset_->icmp_.user_comparator();\n    for (size_t i = 0; i < files_[level].size(); ) {\n      FileMetaData* f = files_[level][i++];\n      const Slice file_start = f->smallest.user_key();\n      const Slice file_limit = f->largest.user_key();\n      if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n        // \"f\" is completely before specified range; skip it\n      } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n        // \"f\" is completely after specified range; skip it\n      } else {\n        inputs->push_back(f);\n        if (level == 0) {\n          // Level-0 files may overlap each other.  So check if the newly\n          // added file has expanded the range.  If so, restart search.\n          if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n            user_begin = file_start;\n            inputs->clear();\n            i = 0;\n          } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n            user_end = file_limit;\n            inputs->clear();\n            i = 0;\n          }\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_->files_[level].size",
          "args": [],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int64_t VersionSet::MaxNextLevelOverlappingBytes() {\n    int64_t result = 0;\n    std::vector<FileMetaData*> overlaps;\n    for (int level = 1; level < config::kNumLevels - 1; level++) {\n      for (size_t i = 0; i < current_->files_[level].size(); i++) {\n        const FileMetaData* f = current_->files_[level][i];\n        current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,\n                                       &overlaps);\n        const int64_t sum = TotalFileSize(overlaps);\n        if (sum > result) {\n          result = sum;\n        }\n      }\n    }\n    return result;\n  }\n}"
  },
  {
    "function_name": "NumLevelBytes",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1164-1168",
    "snippet": "int64_t VersionSet::NumLevelBytes(int level) const {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  return TotalFileSize(current_->files_[level]);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TotalFileSize",
          "args": [
            "current_->files_[level]"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "TotalFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "49-55",
          "snippet": "static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level < config::kNumLevels"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level >= 0"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int64_t VersionSet::NumLevelBytes(int level) const {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    return TotalFileSize(current_->files_[level]);\n  }\n}"
  },
  {
    "function_name": "AddLiveFiles",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1151-1162",
    "snippet": "void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {\n  for (Version* v = dummy_versions_.next_;\n       v != &dummy_versions_;\n       v = v->next_) {\n    for (int level = 0; level < config::kNumLevels; level++) {\n      const std::vector<FileMetaData*>& files = v->files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        live->insert(files[i]->number);\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "live->insert",
          "args": [
            "files[i]->number"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {\n    for (Version* v = dummy_versions_.next_;\n         v != &dummy_versions_;\n         v = v->next_) {\n      for (int level = 0; level < config::kNumLevels; level++) {\n        const std::vector<FileMetaData*>& files = v->files_[level];\n        for (size_t i = 0; i < files.size(); i++) {\n          live->insert(files[i]->number);\n        }\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "ApproximateOffsetOf",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1119-1149",
    "snippet": "uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {\n  uint64_t result = 0;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    const std::vector<FileMetaData*>& files = v->files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {\n        // Entire file is before \"ikey\", so just add the file size\n        result += files[i]->file_size;\n      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {\n        // Entire file is after \"ikey\", so ignore\n        if (level > 0) {\n          // Files other than level 0 are sorted by meta->smallest, so\n          // no further files in this level will contain data for\n          // \"ikey\".\n          break;\n        }\n      } else {\n        // \"ikey\" falls in the range for this table.  Add the\n        // approximate offset of \"ikey\" within the table.\n        Table* tableptr;\n        Iterator* iter = table_cache_->NewIterator(\n            ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);\n        if (tableptr != NULL) {\n          result += tableptr->ApproximateOffsetOf(ikey.Encode());\n        }\n        delete iter;\n      }\n    }\n  }\n  return result;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tableptr->ApproximateOffsetOf",
          "args": [
            "ikey.Encode()"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "ApproximateOffsetOf",
          "container": "TableConstructor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "257-259",
          "snippet": "uint64_t ApproximateOffsetOf(const Slice& key) const {\n    return table_->ApproximateOffsetOf(key);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nTableConstructor {\n  uint64_t ApproximateOffsetOf(const Slice& key) const {\n      return table_->ApproximateOffsetOf(key);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ikey.Encode",
          "args": [],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "154-157",
          "snippet": "Slice Encode() const {\n    assert(!rep_.empty());\n    return rep_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  Slice Encode() const {\n      assert(!rep_.empty());\n      return rep_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table_cache_->NewIterator",
          "args": [
            "ReadOptions()",
            "files[i]->number",
            "files[i]->file_size",
            "&tableptr"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "icmp_.Compare",
          "args": [
            "files[i]->smallest",
            "ikey"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {\n    uint64_t result = 0;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      const std::vector<FileMetaData*>& files = v->files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        if (icmp_.Compare(files[i]->largest, ikey) <= 0) {\n          // Entire file is before \"ikey\", so just add the file size\n          result += files[i]->file_size;\n        } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {\n          // Entire file is after \"ikey\", so ignore\n          if (level > 0) {\n            // Files other than level 0 are sorted by meta->smallest, so\n            // no further files in this level will contain data for\n            // \"ikey\".\n            break;\n          }\n        } else {\n          // \"ikey\" falls in the range for this table.  Add the\n          // approximate offset of \"ikey\" within the table.\n          Table* tableptr;\n          Iterator* iter = table_cache_->NewIterator(\n              ReadOptions(), files[i]->number, files[i]->file_size, &tableptr);\n          if (tableptr != NULL) {\n            result += tableptr->ApproximateOffsetOf(ikey.Encode());\n          }\n          delete iter;\n        }\n      }\n    }\n    return result;\n  }\n}"
  },
  {
    "function_name": "NumLevelFiles",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1098-1102",
    "snippet": "int VersionSet::NumLevelFiles(int level) const {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  return current_->files_[level].size();\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_->files_[level].size",
          "args": [],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level < config::kNumLevels"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level >= 0"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  int VersionSet::NumLevelFiles(int level) const {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    return current_->files_[level].size();\n  }\n}"
  },
  {
    "function_name": "WriteSnapshot",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1068-1096",
    "snippet": "Status VersionSet::WriteSnapshot(log::Writer* log) {\n  // TODO: Break up into multiple records to reduce memory usage on recovery?\n\n  // Save metadata\n  VersionEdit edit;\n  edit.SetComparatorName(icmp_.user_comparator()->Name());\n\n  // Save compaction pointers\n  for (int level = 0; level < config::kNumLevels; level++) {\n    if (!compact_pointer_[level].empty()) {\n      InternalKey key;\n      key.DecodeFrom(compact_pointer_[level]);\n      edit.SetCompactPointer(level, key);\n    }\n  }\n\n  // Save files\n  for (int level = 0; level < config::kNumLevels; level++) {\n    const std::vector<FileMetaData*>& files = current_->files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      const FileMetaData* f = files[i];\n      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);\n    }\n  }\n\n  std::string record;\n  edit.EncodeTo(&record);\n  return log->AddRecord(record);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "log->AddRecord",
          "args": [
            "record"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "AddRecord",
          "container": "Writer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
          "lines": "27-73",
          "snippet": "Status Writer::AddRecord(const Slice& slice) {\n  const char* ptr = slice.data();\n  size_t left = slice.size();\n\n  // Fragment the record if necessary and emit it.  Note that if slice\n  // is empty, we still want to iterate once to emit a single\n  // zero-length record\n  Status s;\n  bool begin = true;\n  do {\n    const int leftover = kBlockSize - block_offset_;\n    assert(leftover >= 0);\n    if (leftover < kHeaderSize) {\n      // Switch to a new block\n      if (leftover > 0) {\n        // Fill the trailer (literal below relies on kHeaderSize being 7)\n        assert(kHeaderSize == 7);\n        dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n      }\n      block_offset_ = 0;\n    }\n\n    // Invariant: we never leave < kHeaderSize bytes in a block.\n    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n\n    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n    const size_t fragment_length = (left < avail) ? left : avail;\n\n    RecordType type;\n    const bool end = (left == fragment_length);\n    if (begin && end) {\n      type = kFullType;\n    } else if (begin) {\n      type = kFirstType;\n    } else if (end) {\n      type = kLastType;\n    } else {\n      type = kMiddleType;\n    }\n\n    s = EmitPhysicalRecord(type, ptr, fragment_length);\n    ptr += fragment_length;\n    left -= fragment_length;\n    begin = false;\n  } while (s.ok() && left > 0);\n  return s;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdint.h>",
            "#include \"db/log_writer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::AddRecord(const Slice& slice) {\n    const char* ptr = slice.data();\n    size_t left = slice.size();\n  \n    // Fragment the record if necessary and emit it.  Note that if slice\n    // is empty, we still want to iterate once to emit a single\n    // zero-length record\n    Status s;\n    bool begin = true;\n    do {\n      const int leftover = kBlockSize - block_offset_;\n      assert(leftover >= 0);\n      if (leftover < kHeaderSize) {\n        // Switch to a new block\n        if (leftover > 0) {\n          // Fill the trailer (literal below relies on kHeaderSize being 7)\n          assert(kHeaderSize == 7);\n          dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n        }\n        block_offset_ = 0;\n      }\n  \n      // Invariant: we never leave < kHeaderSize bytes in a block.\n      assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n  \n      const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n      const size_t fragment_length = (left < avail) ? left : avail;\n  \n      RecordType type;\n      const bool end = (left == fragment_length);\n      if (begin && end) {\n        type = kFullType;\n      } else if (begin) {\n        type = kFirstType;\n      } else if (end) {\n        type = kLastType;\n      } else {\n        type = kMiddleType;\n      }\n  \n      s = EmitPhysicalRecord(type, ptr, fragment_length);\n      ptr += fragment_length;\n      left -= fragment_length;\n      begin = false;\n    } while (s.ok() && left > 0);\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.EncodeTo",
          "args": [
            "&record"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTo",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.cc",
          "lines": "41-86",
          "snippet": "void VersionEdit::EncodeTo(std::string* dst) const {\n  if (has_comparator_) {\n    PutVarint32(dst, kComparator);\n    PutLengthPrefixedSlice(dst, comparator_);\n  }\n  if (has_log_number_) {\n    PutVarint32(dst, kLogNumber);\n    PutVarint64(dst, log_number_);\n  }\n  if (has_prev_log_number_) {\n    PutVarint32(dst, kPrevLogNumber);\n    PutVarint64(dst, prev_log_number_);\n  }\n  if (has_next_file_number_) {\n    PutVarint32(dst, kNextFileNumber);\n    PutVarint64(dst, next_file_number_);\n  }\n  if (has_last_sequence_) {\n    PutVarint32(dst, kLastSequence);\n    PutVarint64(dst, last_sequence_);\n  }\n\n  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n    PutVarint32(dst, kCompactPointer);\n    PutVarint32(dst, compact_pointers_[i].first);  // level\n    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n  }\n\n  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n       iter != deleted_files_.end();\n       ++iter) {\n    PutVarint32(dst, kDeletedFile);\n    PutVarint32(dst, iter->first);   // level\n    PutVarint64(dst, iter->second);  // file number\n  }\n\n  for (size_t i = 0; i < new_files_.size(); i++) {\n    const FileMetaData& f = new_files_[i].second;\n    PutVarint32(dst, kNewFile);\n    PutVarint32(dst, new_files_[i].first);  // level\n    PutVarint64(dst, f.number);\n    PutVarint64(dst, f.file_size);\n    PutLengthPrefixedSlice(dst, f.smallest.Encode());\n    PutLengthPrefixedSlice(dst, f.largest.Encode());\n  }\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/version_edit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/version_set.h\"\n#include \"db/version_edit.h\"\n\nVersionEdit {\n  void VersionEdit::EncodeTo(std::string* dst) const {\n    if (has_comparator_) {\n      PutVarint32(dst, kComparator);\n      PutLengthPrefixedSlice(dst, comparator_);\n    }\n    if (has_log_number_) {\n      PutVarint32(dst, kLogNumber);\n      PutVarint64(dst, log_number_);\n    }\n    if (has_prev_log_number_) {\n      PutVarint32(dst, kPrevLogNumber);\n      PutVarint64(dst, prev_log_number_);\n    }\n    if (has_next_file_number_) {\n      PutVarint32(dst, kNextFileNumber);\n      PutVarint64(dst, next_file_number_);\n    }\n    if (has_last_sequence_) {\n      PutVarint32(dst, kLastSequence);\n      PutVarint64(dst, last_sequence_);\n    }\n  \n    for (size_t i = 0; i < compact_pointers_.size(); i++) {\n      PutVarint32(dst, kCompactPointer);\n      PutVarint32(dst, compact_pointers_[i].first);  // level\n      PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n    }\n  \n    for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n         iter != deleted_files_.end();\n         ++iter) {\n      PutVarint32(dst, kDeletedFile);\n      PutVarint32(dst, iter->first);   // level\n      PutVarint64(dst, iter->second);  // file number\n    }\n  \n    for (size_t i = 0; i < new_files_.size(); i++) {\n      const FileMetaData& f = new_files_[i].second;\n      PutVarint32(dst, kNewFile);\n      PutVarint32(dst, new_files_[i].first);  // level\n      PutVarint64(dst, f.number);\n      PutVarint64(dst, f.file_size);\n      PutLengthPrefixedSlice(dst, f.smallest.Encode());\n      PutLengthPrefixedSlice(dst, f.largest.Encode());\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.AddFile",
          "args": [
            "level",
            "f->number",
            "f->file_size",
            "f->smallest",
            "f->largest"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "AddFile",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "62-72",
          "snippet": "void AddFile(int level, uint64_t file,\n               uint64_t file_size,\n               const InternalKey& smallest,\n               const InternalKey& largest) {\n    FileMetaData f;\n    f.number = file;\n    f.file_size = file_size;\n    f.smallest = smallest;\n    f.largest = largest;\n    new_files_.push_back(std::make_pair(level, f));\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void AddFile(int level, uint64_t file,\n                 uint64_t file_size,\n                 const InternalKey& smallest,\n                 const InternalKey& largest) {\n      FileMetaData f;\n      f.number = file;\n      f.file_size = file_size;\n      f.smallest = smallest;\n      f.largest = largest;\n      new_files_.push_back(std::make_pair(level, f));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.SetCompactPointer",
          "args": [
            "level",
            "key"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "SetCompactPointer",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "55-57",
          "snippet": "void SetCompactPointer(int level, const InternalKey& key) {\n    compact_pointers_.push_back(std::make_pair(level, key));\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetCompactPointer(int level, const InternalKey& key) {\n      compact_pointers_.push_back(std::make_pair(level, key));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.DecodeFrom",
          "args": [
            "compact_pointer_[level]"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "153-153",
          "snippet": "void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "compact_pointer_[level].empty",
          "args": [],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.SetComparatorName",
          "args": [
            "icmp_.user_comparator()->Name()"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "SetComparatorName",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "35-38",
          "snippet": "void SetComparatorName(const Slice& name) {\n    has_comparator_ = true;\n    comparator_ = name.ToString();\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetComparatorName(const Slice& name) {\n      has_comparator_ = true;\n      comparator_ = name.ToString();\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::WriteSnapshot(log::Writer* log) {\n    // TODO: Break up into multiple records to reduce memory usage on recovery?\n  \n    // Save metadata\n    VersionEdit edit;\n    edit.SetComparatorName(icmp_.user_comparator()->Name());\n  \n    // Save compaction pointers\n    for (int level = 0; level < config::kNumLevels; level++) {\n      if (!compact_pointer_[level].empty()) {\n        InternalKey key;\n        key.DecodeFrom(compact_pointer_[level]);\n        edit.SetCompactPointer(level, key);\n      }\n    }\n  \n    // Save files\n    for (int level = 0; level < config::kNumLevels; level++) {\n      const std::vector<FileMetaData*>& files = current_->files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        const FileMetaData* f = files[i];\n        edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);\n      }\n    }\n  \n    std::string record;\n    edit.EncodeTo(&record);\n    return log->AddRecord(record);\n  }\n}"
  },
  {
    "function_name": "Finalize",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1031-1066",
    "snippet": "void VersionSet::Finalize(Version* v) {\n  // Precomputed best level for next compaction\n  int best_level = -1;\n  double best_score = -1;\n\n  for (int level = 0; level < config::kNumLevels-1; level++) {\n    double score;\n    if (level == 0) {\n      // We treat level-0 specially by bounding the number of files\n      // instead of number of bytes for two reasons:\n      //\n      // (1) With larger write-buffer sizes, it is nice not to do too\n      // many level-0 compactions.\n      //\n      // (2) The files in level-0 are merged on every read and\n      // therefore we wish to avoid too many files when the individual\n      // file size is small (perhaps because of a small write-buffer\n      // setting, or very high compression ratios, or lots of\n      // overwrites/deletions).\n      score = v->files_[level].size() /\n          static_cast<double>(config::kL0_CompactionTrigger);\n    } else {\n      // Compute the ratio of current size to size limit.\n      const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n    }\n\n    if (score > best_score) {\n      best_level = level;\n      best_score = score;\n    }\n  }\n\n  v->compaction_level_ = best_level;\n  v->compaction_score_ = best_score;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MaxBytesForLevel",
          "args": [
            "level"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "MaxBytesForLevel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "34-43",
          "snippet": "static double MaxBytesForLevel(int level) {\n  // Note: the result for level zero is not really used since we set\n  // the level-0 compaction threshold based on number of files.\n  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n  while (level > 1) {\n    result *= 10;\n    level--;\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic double MaxBytesForLevel(int level) {\n  // Note: the result for level zero is not really used since we set\n  // the level-0 compaction threshold based on number of files.\n  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n  while (level > 1) {\n    result *= 10;\n    level--;\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<double>",
          "args": [
            "level_bytes"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TotalFileSize",
          "args": [
            "v->files_[level]"
          ],
          "line": 1054
        },
        "resolved": true,
        "details": {
          "function_name": "TotalFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "49-55",
          "snippet": "static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<double>",
          "args": [
            "config::kL0_CompactionTrigger"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v->files_[level].size",
          "args": [],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "TransactionTablePriv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "170-173",
          "snippet": "int size()\n    {\n        return cachedWallet.size();\n    }",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTablePriv {\n  int size()\n      {\n          return cachedWallet.size();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::Finalize(Version* v) {\n    // Precomputed best level for next compaction\n    int best_level = -1;\n    double best_score = -1;\n  \n    for (int level = 0; level < config::kNumLevels-1; level++) {\n      double score;\n      if (level == 0) {\n        // We treat level-0 specially by bounding the number of files\n        // instead of number of bytes for two reasons:\n        //\n        // (1) With larger write-buffer sizes, it is nice not to do too\n        // many level-0 compactions.\n        //\n        // (2) The files in level-0 are merged on every read and\n        // therefore we wish to avoid too many files when the individual\n        // file size is small (perhaps because of a small write-buffer\n        // setting, or very high compression ratios, or lots of\n        // overwrites/deletions).\n        score = v->files_[level].size() /\n            static_cast<double>(config::kL0_CompactionTrigger);\n      } else {\n        // Compute the ratio of current size to size limit.\n        const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n        score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n      }\n  \n      if (score > best_score) {\n        best_level = level;\n        best_score = score;\n      }\n    }\n  \n    v->compaction_level_ = best_level;\n    v->compaction_score_ = best_score;\n  }\n}"
  },
  {
    "function_name": "MarkFileNumberUsed",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "1025-1029",
    "snippet": "void VersionSet::MarkFileNumberUsed(uint64_t number) {\n  if (next_file_number_ <= number) {\n    next_file_number_ = number + 1;\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::MarkFileNumberUsed(uint64_t number) {\n    if (next_file_number_ <= number) {\n      next_file_number_ = number + 1;\n    }\n  }\n}"
  },
  {
    "function_name": "Recover",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "910-1023",
    "snippet": "Status VersionSet::Recover() {\n  struct LogReporter : public log::Reader::Reporter {\n    Status* status;\n    virtual void Corruption(size_t bytes, const Status& s) {\n      if (this->status->ok()) *this->status = s;\n    }\n  };\n\n  // Read \"CURRENT\" file, which contains a pointer to the current manifest file\n  std::string current;\n  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);\n  if (!s.ok()) {\n    return s;\n  }\n  if (current.empty() || current[current.size()-1] != '\\n') {\n    return Status::Corruption(\"CURRENT file does not end with newline\");\n  }\n  current.resize(current.size() - 1);\n\n  std::string dscname = dbname_ + \"/\" + current;\n  SequentialFile* file;\n  s = env_->NewSequentialFile(dscname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n\n  bool have_log_number = false;\n  bool have_prev_log_number = false;\n  bool have_next_file = false;\n  bool have_last_sequence = false;\n  uint64_t next_file = 0;\n  uint64_t last_sequence = 0;\n  uint64_t log_number = 0;\n  uint64_t prev_log_number = 0;\n  Builder builder(this, current_);\n\n  {\n    LogReporter reporter;\n    reporter.status = &s;\n    log::Reader reader(file, &reporter, true/*checksum*/, 0/*initial_offset*/);\n    Slice record;\n    std::string scratch;\n    while (reader.ReadRecord(&record, &scratch) && s.ok()) {\n      VersionEdit edit;\n      s = edit.DecodeFrom(record);\n      if (s.ok()) {\n        if (edit.has_comparator_ &&\n            edit.comparator_ != icmp_.user_comparator()->Name()) {\n          s = Status::InvalidArgument(\n              edit.comparator_ + \" does not match existing comparator \",\n              icmp_.user_comparator()->Name());\n        }\n      }\n\n      if (s.ok()) {\n        builder.Apply(&edit);\n      }\n\n      if (edit.has_log_number_) {\n        log_number = edit.log_number_;\n        have_log_number = true;\n      }\n\n      if (edit.has_prev_log_number_) {\n        prev_log_number = edit.prev_log_number_;\n        have_prev_log_number = true;\n      }\n\n      if (edit.has_next_file_number_) {\n        next_file = edit.next_file_number_;\n        have_next_file = true;\n      }\n\n      if (edit.has_last_sequence_) {\n        last_sequence = edit.last_sequence_;\n        have_last_sequence = true;\n      }\n    }\n  }\n  delete file;\n  file = NULL;\n\n  if (s.ok()) {\n    if (!have_next_file) {\n      s = Status::Corruption(\"no meta-nextfile entry in descriptor\");\n    } else if (!have_log_number) {\n      s = Status::Corruption(\"no meta-lognumber entry in descriptor\");\n    } else if (!have_last_sequence) {\n      s = Status::Corruption(\"no last-sequence-number entry in descriptor\");\n    }\n\n    if (!have_prev_log_number) {\n      prev_log_number = 0;\n    }\n\n    MarkFileNumberUsed(prev_log_number);\n    MarkFileNumberUsed(log_number);\n  }\n\n  if (s.ok()) {\n    Version* v = new Version(this);\n    builder.SaveTo(v);\n    // Install recovered version\n    Finalize(v);\n    AppendVersion(v);\n    manifest_file_number_ = next_file;\n    next_file_number_ = next_file + 1;\n    last_sequence_ = last_sequence;\n    log_number_ = log_number;\n    prev_log_number_ = prev_log_number;\n  }\n\n  return s;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AppendVersion",
          "args": [
            "v"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "AppendVersion",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "808-823",
          "snippet": "void VersionSet::AppendVersion(Version* v) {\n  // Make \"v\" current\n  assert(v->refs_ == 0);\n  assert(v != current_);\n  if (current_ != NULL) {\n    current_->Unref();\n  }\n  current_ = v;\n  v->Ref();\n\n  // Append to linked list\n  v->prev_ = dummy_versions_.prev_;\n  v->next_ = &dummy_versions_;\n  v->prev_->next_ = v;\n  v->next_->prev_ = v;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::AppendVersion(Version* v) {\n    // Make \"v\" current\n    assert(v->refs_ == 0);\n    assert(v != current_);\n    if (current_ != NULL) {\n      current_->Unref();\n    }\n    current_ = v;\n    v->Ref();\n  \n    // Append to linked list\n    v->prev_ = dummy_versions_.prev_;\n    v->next_ = &dummy_versions_;\n    v->prev_->next_ = v;\n    v->next_->prev_ = v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Finalize",
          "args": [
            "v"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "Finalize",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1031-1066",
          "snippet": "void VersionSet::Finalize(Version* v) {\n  // Precomputed best level for next compaction\n  int best_level = -1;\n  double best_score = -1;\n\n  for (int level = 0; level < config::kNumLevels-1; level++) {\n    double score;\n    if (level == 0) {\n      // We treat level-0 specially by bounding the number of files\n      // instead of number of bytes for two reasons:\n      //\n      // (1) With larger write-buffer sizes, it is nice not to do too\n      // many level-0 compactions.\n      //\n      // (2) The files in level-0 are merged on every read and\n      // therefore we wish to avoid too many files when the individual\n      // file size is small (perhaps because of a small write-buffer\n      // setting, or very high compression ratios, or lots of\n      // overwrites/deletions).\n      score = v->files_[level].size() /\n          static_cast<double>(config::kL0_CompactionTrigger);\n    } else {\n      // Compute the ratio of current size to size limit.\n      const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n    }\n\n    if (score > best_score) {\n      best_level = level;\n      best_score = score;\n    }\n  }\n\n  v->compaction_level_ = best_level;\n  v->compaction_score_ = best_score;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::Finalize(Version* v) {\n    // Precomputed best level for next compaction\n    int best_level = -1;\n    double best_score = -1;\n  \n    for (int level = 0; level < config::kNumLevels-1; level++) {\n      double score;\n      if (level == 0) {\n        // We treat level-0 specially by bounding the number of files\n        // instead of number of bytes for two reasons:\n        //\n        // (1) With larger write-buffer sizes, it is nice not to do too\n        // many level-0 compactions.\n        //\n        // (2) The files in level-0 are merged on every read and\n        // therefore we wish to avoid too many files when the individual\n        // file size is small (perhaps because of a small write-buffer\n        // setting, or very high compression ratios, or lots of\n        // overwrites/deletions).\n        score = v->files_[level].size() /\n            static_cast<double>(config::kL0_CompactionTrigger);\n      } else {\n        // Compute the ratio of current size to size limit.\n        const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n        score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n      }\n  \n      if (score > best_score) {\n        best_level = level;\n        best_score = score;\n      }\n    }\n  \n    v->compaction_level_ = best_level;\n    v->compaction_score_ = best_score;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.SaveTo",
          "args": [
            "v"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "SaveTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "716-762",
          "snippet": "void SaveTo(Version* v) {\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // Merge the set of added files with the set of pre-existing files.\n      // Drop any deleted files.  Store the result in *v.\n      const std::vector<FileMetaData*>& base_files = base_->files_[level];\n      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();\n      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();\n      const FileSet* added = levels_[level].added_files;\n      v->files_[level].reserve(base_files.size() + added->size());\n      for (FileSet::const_iterator added_iter = added->begin();\n           added_iter != added->end();\n           ++added_iter) {\n        // Add all smaller files listed in base_\n        for (std::vector<FileMetaData*>::const_iterator bpos\n                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);\n             base_iter != bpos;\n             ++base_iter) {\n          MaybeAddFile(v, level, *base_iter);\n        }\n\n        MaybeAddFile(v, level, *added_iter);\n      }\n\n      // Add remaining base files\n      for (; base_iter != base_end; ++base_iter) {\n        MaybeAddFile(v, level, *base_iter);\n      }\n\n#ifndef NDEBUG\n      // Make sure there is no overlap in levels > 0\n      if (level > 0) {\n        for (uint32_t i = 1; i < v->files_[level].size(); i++) {\n          const InternalKey& prev_end = v->files_[level][i-1]->largest;\n          const InternalKey& this_begin = v->files_[level][i]->smallest;\n          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {\n            fprintf(stderr, \"overlapping ranges in same level %s vs. %s\\n\",\n                    prev_end.DebugString().c_str(),\n                    this_begin.DebugString().c_str());\n            abort();\n          }\n        }\n      }\n#endif\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid SaveTo(Version* v) {\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // Merge the set of added files with the set of pre-existing files.\n      // Drop any deleted files.  Store the result in *v.\n      const std::vector<FileMetaData*>& base_files = base_->files_[level];\n      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();\n      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();\n      const FileSet* added = levels_[level].added_files;\n      v->files_[level].reserve(base_files.size() + added->size());\n      for (FileSet::const_iterator added_iter = added->begin();\n           added_iter != added->end();\n           ++added_iter) {\n        // Add all smaller files listed in base_\n        for (std::vector<FileMetaData*>::const_iterator bpos\n                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);\n             base_iter != bpos;\n             ++base_iter) {\n          MaybeAddFile(v, level, *base_iter);\n        }\n\n        MaybeAddFile(v, level, *added_iter);\n      }\n\n      // Add remaining base files\n      for (; base_iter != base_end; ++base_iter) {\n        MaybeAddFile(v, level, *base_iter);\n      }\n\n#ifndef NDEBUG\n      // Make sure there is no overlap in levels > 0\n      if (level > 0) {\n        for (uint32_t i = 1; i < v->files_[level].size(); i++) {\n          const InternalKey& prev_end = v->files_[level][i-1]->largest;\n          const InternalKey& this_begin = v->files_[level][i]->smallest;\n          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {\n            fprintf(stderr, \"overlapping ranges in same level %s vs. %s\\n\",\n                    prev_end.DebugString().c_str(),\n                    this_begin.DebugString().c_str());\n            abort();\n          }\n        }\n      }\n#endif\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MarkFileNumberUsed",
          "args": [
            "log_number"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "MarkFileNumberUsed",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1025-1029",
          "snippet": "void VersionSet::MarkFileNumberUsed(uint64_t number) {\n  if (next_file_number_ <= number) {\n    next_file_number_ = number + 1;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::MarkFileNumberUsed(uint64_t number) {\n    if (next_file_number_ <= number) {\n      next_file_number_ = number + 1;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"no last-sequence-number entry in descriptor\""
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.Apply",
          "args": [
            "&edit"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "Apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "670-713",
          "snippet": "void Apply(VersionEdit* edit) {\n    // Update compaction pointers\n    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {\n      const int level = edit->compact_pointers_[i].first;\n      vset_->compact_pointer_[level] =\n          edit->compact_pointers_[i].second.Encode().ToString();\n    }\n\n    // Delete files\n    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;\n    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();\n         iter != del.end();\n         ++iter) {\n      const int level = iter->first;\n      const uint64_t number = iter->second;\n      levels_[level].deleted_files.insert(number);\n    }\n\n    // Add new files\n    for (size_t i = 0; i < edit->new_files_.size(); i++) {\n      const int level = edit->new_files_[i].first;\n      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);\n      f->refs = 1;\n\n      // We arrange to automatically compact this file after\n      // a certain number of seeks.  Let's assume:\n      //   (1) One seek costs 10ms\n      //   (2) Writing or reading 1MB costs 10ms (100MB/s)\n      //   (3) A compaction of 1MB does 25MB of IO:\n      //         1MB read from this level\n      //         10-12MB read from next level (boundaries may be misaligned)\n      //         10-12MB written to next level\n      // This implies that 25 seeks cost the same as the compaction\n      // of 1MB of data.  I.e., one seek costs approximately the\n      // same as the compaction of 40KB of data.  We are a little\n      // conservative and allow approximately one seek for every 16KB\n      // of data before triggering a compaction.\n      f->allowed_seeks = (f->file_size / 16384);\n      if (f->allowed_seeks < 100) f->allowed_seeks = 100;\n\n      levels_[level].deleted_files.erase(f->number);\n      levels_[level].added_files->insert(f);\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid Apply(VersionEdit* edit) {\n    // Update compaction pointers\n    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {\n      const int level = edit->compact_pointers_[i].first;\n      vset_->compact_pointer_[level] =\n          edit->compact_pointers_[i].second.Encode().ToString();\n    }\n\n    // Delete files\n    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;\n    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();\n         iter != del.end();\n         ++iter) {\n      const int level = iter->first;\n      const uint64_t number = iter->second;\n      levels_[level].deleted_files.insert(number);\n    }\n\n    // Add new files\n    for (size_t i = 0; i < edit->new_files_.size(); i++) {\n      const int level = edit->new_files_[i].first;\n      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);\n      f->refs = 1;\n\n      // We arrange to automatically compact this file after\n      // a certain number of seeks.  Let's assume:\n      //   (1) One seek costs 10ms\n      //   (2) Writing or reading 1MB costs 10ms (100MB/s)\n      //   (3) A compaction of 1MB does 25MB of IO:\n      //         1MB read from this level\n      //         10-12MB read from next level (boundaries may be misaligned)\n      //         10-12MB written to next level\n      // This implies that 25 seeks cost the same as the compaction\n      // of 1MB of data.  I.e., one seek costs approximately the\n      // same as the compaction of 40KB of data.  We are a little\n      // conservative and allow approximately one seek for every 16KB\n      // of data before triggering a compaction.\n      f->allowed_seeks = (f->file_size / 16384);\n      if (f->allowed_seeks < 100) f->allowed_seeks = 100;\n\n      levels_[level].deleted_files.erase(f->number);\n      levels_[level].added_files->insert(f);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "Status::InvalidArgument",
          "args": [
            "edit.comparator_ + \" does not match existing comparator \"",
            "icmp_.user_comparator()->Name()"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "icmp_.user_comparator",
          "args": [],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "edit.DecodeFrom",
          "args": [
            "record"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "153-153",
          "snippet": "void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.ReadRecord",
          "args": [
            "&record",
            "&scratch"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ReadRecord",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "59-162",
          "snippet": "bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n  if (last_record_offset_ < initial_offset_) {\n    if (!SkipToInitialBlock()) {\n      return false;\n    }\n  }\n\n  scratch->clear();\n  record->clear();\n  bool in_fragmented_record = false;\n  // Record offset of the logical record that we're reading\n  // 0 is a dummy value to make compilers happy\n  uint64_t prospective_record_offset = 0;\n\n  Slice fragment;\n  while (true) {\n    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n    const unsigned int record_type = ReadPhysicalRecord(&fragment);\n    switch (record_type) {\n      case kFullType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(1)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->clear();\n        *record = fragment;\n        last_record_offset_ = prospective_record_offset;\n        return true;\n\n      case kFirstType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(2)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->assign(fragment.data(), fragment.size());\n        in_fragmented_record = true;\n        break;\n\n      case kMiddleType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(1)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n        }\n        break;\n\n      case kLastType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(2)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n          *record = Slice(*scratch);\n          last_record_offset_ = prospective_record_offset;\n          return true;\n        }\n        break;\n\n      case kEof:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"partial record without end(3)\");\n          scratch->clear();\n        }\n        return false;\n\n      case kBadRecord:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"error in middle of record\");\n          in_fragmented_record = false;\n          scratch->clear();\n        }\n        break;\n\n      default: {\n        char buf[40];\n        snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n        ReportCorruption(\n            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n            buf);\n        in_fragmented_record = false;\n        scratch->clear();\n        break;\n      }\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n    if (last_record_offset_ < initial_offset_) {\n      if (!SkipToInitialBlock()) {\n        return false;\n      }\n    }\n  \n    scratch->clear();\n    record->clear();\n    bool in_fragmented_record = false;\n    // Record offset of the logical record that we're reading\n    // 0 is a dummy value to make compilers happy\n    uint64_t prospective_record_offset = 0;\n  \n    Slice fragment;\n    while (true) {\n      uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n      const unsigned int record_type = ReadPhysicalRecord(&fragment);\n      switch (record_type) {\n        case kFullType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(1)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->clear();\n          *record = fragment;\n          last_record_offset_ = prospective_record_offset;\n          return true;\n  \n        case kFirstType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(2)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->assign(fragment.data(), fragment.size());\n          in_fragmented_record = true;\n          break;\n  \n        case kMiddleType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(1)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n          }\n          break;\n  \n        case kLastType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(2)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n            *record = Slice(*scratch);\n            last_record_offset_ = prospective_record_offset;\n            return true;\n          }\n          break;\n  \n        case kEof:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"partial record without end(3)\");\n            scratch->clear();\n          }\n          return false;\n  \n        case kBadRecord:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"error in middle of record\");\n            in_fragmented_record = false;\n            scratch->clear();\n          }\n          break;\n  \n        default: {\n          char buf[40];\n          snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n          ReportCorruption(\n              (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n              buf);\n          in_fragmented_record = false;\n          scratch->clear();\n          break;\n        }\n      }\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NewSequentialFile",
          "args": [
            "dscname",
            "&file"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "951-964",
          "snippet": "Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n{\n    Status sRet;\n    std::string path = fname;\n    ModifyPath(path);\n    Win32SequentialFile* pFile = new Win32SequentialFile(path);\n    if(pFile->isEnable()){\n        *result = pFile;\n    }else {\n        delete pFile;\n        sRet = Status::IOError(path, Win32::GetLastErrSz());\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n  {\n      Status sRet;\n      std::string path = fname;\n      ModifyPath(path);\n      Win32SequentialFile* pFile = new Win32SequentialFile(path);\n      if(pFile->isEnable()){\n          *result = pFile;\n      }else {\n          delete pFile;\n          sRet = Status::IOError(path, Win32::GetLastErrSz());\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current.resize",
          "args": [
            "current.size() - 1"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current.size",
          "args": [],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current.empty",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadFileToString",
          "args": [
            "env_",
            "CurrentFileName(dbname_)",
            "&current"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFileToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env.cc",
          "lines": "68-91",
          "snippet": "Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {\n  data->clear();\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  static const int kBufferSize = 8192;\n  char* space = new char[kBufferSize];\n  while (true) {\n    Slice fragment;\n    s = file->Read(kBufferSize, &fragment, space);\n    if (!s.ok()) {\n      break;\n    }\n    data->append(fragment.data(), fragment.size());\n    if (fragment.empty()) {\n      break;\n    }\n  }\n  delete[] space;\n  delete file;\n  return s;\n}",
          "includes": [
            "#include \"leveldb/env.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n\nStatus ReadFileToString(Env* env, const std::string& fname, std::string* data) {\n  data->clear();\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    return s;\n  }\n  static const int kBufferSize = 8192;\n  char* space = new char[kBufferSize];\n  while (true) {\n    Slice fragment;\n    s = file->Read(kBufferSize, &fragment, space);\n    if (!s.ok()) {\n      break;\n    }\n    data->append(fragment.data(), fragment.size());\n    if (fragment.empty()) {\n      break;\n    }\n  }\n  delete[] space;\n  delete file;\n  return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CurrentFileName",
          "args": [
            "dbname_"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "55-57",
          "snippet": "std::string CurrentFileName(const std::string& dbname) {\n  return dbname + \"/CURRENT\";\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string CurrentFileName(const std::string& dbname) {\n  return dbname + \"/CURRENT\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->status->ok",
          "args": [],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::Recover() {\n    struct LogReporter : public log::Reader::Reporter {\n      Status* status;\n      virtual void Corruption(size_t bytes, const Status& s) {\n        if (this->status->ok()) *this->status = s;\n      }\n    };\n  \n    // Read \"CURRENT\" file, which contains a pointer to the current manifest file\n    std::string current;\n    Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);\n    if (!s.ok()) {\n      return s;\n    }\n    if (current.empty() || current[current.size()-1] != '\\n') {\n      return Status::Corruption(\"CURRENT file does not end with newline\");\n    }\n    current.resize(current.size() - 1);\n  \n    std::string dscname = dbname_ + \"/\" + current;\n    SequentialFile* file;\n    s = env_->NewSequentialFile(dscname, &file);\n    if (!s.ok()) {\n      return s;\n    }\n  \n    bool have_log_number = false;\n    bool have_prev_log_number = false;\n    bool have_next_file = false;\n    bool have_last_sequence = false;\n    uint64_t next_file = 0;\n    uint64_t last_sequence = 0;\n    uint64_t log_number = 0;\n    uint64_t prev_log_number = 0;\n    Builder builder(this, current_);\n  \n    {\n      LogReporter reporter;\n      reporter.status = &s;\n      log::Reader reader(file, &reporter, true/*checksum*/, 0/*initial_offset*/);\n      Slice record;\n      std::string scratch;\n      while (reader.ReadRecord(&record, &scratch) && s.ok()) {\n        VersionEdit edit;\n        s = edit.DecodeFrom(record);\n        if (s.ok()) {\n          if (edit.has_comparator_ &&\n              edit.comparator_ != icmp_.user_comparator()->Name()) {\n            s = Status::InvalidArgument(\n                edit.comparator_ + \" does not match existing comparator \",\n                icmp_.user_comparator()->Name());\n          }\n        }\n  \n        if (s.ok()) {\n          builder.Apply(&edit);\n        }\n  \n        if (edit.has_log_number_) {\n          log_number = edit.log_number_;\n          have_log_number = true;\n        }\n  \n        if (edit.has_prev_log_number_) {\n          prev_log_number = edit.prev_log_number_;\n          have_prev_log_number = true;\n        }\n  \n        if (edit.has_next_file_number_) {\n          next_file = edit.next_file_number_;\n          have_next_file = true;\n        }\n  \n        if (edit.has_last_sequence_) {\n          last_sequence = edit.last_sequence_;\n          have_last_sequence = true;\n        }\n      }\n    }\n    delete file;\n    file = NULL;\n  \n    if (s.ok()) {\n      if (!have_next_file) {\n        s = Status::Corruption(\"no meta-nextfile entry in descriptor\");\n      } else if (!have_log_number) {\n        s = Status::Corruption(\"no meta-lognumber entry in descriptor\");\n      } else if (!have_last_sequence) {\n        s = Status::Corruption(\"no last-sequence-number entry in descriptor\");\n      }\n  \n      if (!have_prev_log_number) {\n        prev_log_number = 0;\n      }\n  \n      MarkFileNumberUsed(prev_log_number);\n      MarkFileNumberUsed(log_number);\n    }\n  \n    if (s.ok()) {\n      Version* v = new Version(this);\n      builder.SaveTo(v);\n      // Install recovered version\n      Finalize(v);\n      AppendVersion(v);\n      manifest_file_number_ = next_file;\n      next_file_number_ = next_file + 1;\n      last_sequence_ = last_sequence;\n      log_number_ = log_number;\n      prev_log_number_ = prev_log_number;\n    }\n  \n    return s;\n  }\n}"
  },
  {
    "function_name": "LogAndApply",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "825-908",
    "snippet": "Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n  if (edit->has_log_number_) {\n    assert(edit->log_number_ >= log_number_);\n    assert(edit->log_number_ < next_file_number_);\n  } else {\n    edit->SetLogNumber(log_number_);\n  }\n\n  if (!edit->has_prev_log_number_) {\n    edit->SetPrevLogNumber(prev_log_number_);\n  }\n\n  edit->SetNextFile(next_file_number_);\n  edit->SetLastSequence(last_sequence_);\n\n  Version* v = new Version(this);\n  {\n    Builder builder(this, current_);\n    builder.Apply(edit);\n    builder.SaveTo(v);\n  }\n  Finalize(v);\n\n  // Initialize new descriptor log file if necessary by creating\n  // a temporary file that contains a snapshot of the current version.\n  std::string new_manifest_file;\n  Status s;\n  if (descriptor_log_ == NULL) {\n    // No reason to unlock *mu here since we only hit this path in the\n    // first call to LogAndApply (when opening the database).\n    assert(descriptor_file_ == NULL);\n    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n    edit->SetNextFile(next_file_number_);\n    s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n    if (s.ok()) {\n      descriptor_log_ = new log::Writer(descriptor_file_);\n      s = WriteSnapshot(descriptor_log_);\n    }\n  }\n\n  // Unlock during expensive MANIFEST log write\n  {\n    mu->Unlock();\n\n    // Write new record to MANIFEST log\n    if (s.ok()) {\n      std::string record;\n      edit->EncodeTo(&record);\n      s = descriptor_log_->AddRecord(record);\n      if (s.ok()) {\n        s = descriptor_file_->Sync();\n      }\n      if (!s.ok()) {\n        Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n      }\n    }\n\n    // If we just created a new descriptor file, install it by writing a\n    // new CURRENT file that points to it.\n    if (s.ok() && !new_manifest_file.empty()) {\n      s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n    }\n\n    mu->Lock();\n  }\n\n  // Install the new version\n  if (s.ok()) {\n    AppendVersion(v);\n    log_number_ = edit->log_number_;\n    prev_log_number_ = edit->prev_log_number_;\n  } else {\n    delete v;\n    if (!new_manifest_file.empty()) {\n      delete descriptor_log_;\n      delete descriptor_file_;\n      descriptor_log_ = NULL;\n      descriptor_file_ = NULL;\n      env_->DeleteFile(new_manifest_file);\n    }\n  }\n\n  return s;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_->DeleteFile",
          "args": [
            "new_manifest_file"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "DeleteFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "801-812",
          "snippet": "Status Win32Env::DeleteFile( const std::string& fname )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    if(!::DeleteFileW(wpath.c_str())) {\n        sRet = Status::IOError(path, \"Could not delete file.\");\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::DeleteFile( const std::string& fname )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      if(!::DeleteFileW(wpath.c_str())) {\n          sRet = Status::IOError(path, \"Could not delete file.\");\n      }\n      return sRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_manifest_file.empty",
          "args": [],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AppendVersion",
          "args": [
            "v"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "AppendVersion",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "808-823",
          "snippet": "void VersionSet::AppendVersion(Version* v) {\n  // Make \"v\" current\n  assert(v->refs_ == 0);\n  assert(v != current_);\n  if (current_ != NULL) {\n    current_->Unref();\n  }\n  current_ = v;\n  v->Ref();\n\n  // Append to linked list\n  v->prev_ = dummy_versions_.prev_;\n  v->next_ = &dummy_versions_;\n  v->prev_->next_ = v;\n  v->next_->prev_ = v;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::AppendVersion(Version* v) {\n    // Make \"v\" current\n    assert(v->refs_ == 0);\n    assert(v != current_);\n    if (current_ != NULL) {\n      current_->Unref();\n    }\n    current_ = v;\n    v->Ref();\n  \n    // Append to linked list\n    v->prev_ = dummy_versions_.prev_;\n    v->next_ = &dummy_versions_;\n    v->prev_->next_ = v;\n    v->next_->prev_ = v;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mu->Lock",
          "args": [],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "Lock",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "76-88",
          "snippet": "bool CCryptoKeyStore::Lock()\n{\n    if (!SetCrypted())\n        return false;\n\n    {\n        LOCK(cs_KeyStore);\n        vMasterKey.clear();\n    }\n\n    NotifyStatusChanged(this);\n    return true;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::Lock()\n  {\n      if (!SetCrypted())\n          return false;\n  \n      {\n          LOCK(cs_KeyStore);\n          vMasterKey.clear();\n      }\n  \n      NotifyStatusChanged(this);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetCurrentFile",
          "args": [
            "env_",
            "dbname_",
            "manifest_file_number_"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "SetCurrentFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "131-147",
          "snippet": "Status SetCurrentFile(Env* env, const std::string& dbname,\n                      uint64_t descriptor_number) {\n  // Remove leading \"dbname/\" and add newline to manifest file name\n  std::string manifest = DescriptorFileName(dbname, descriptor_number);\n  Slice contents = manifest;\n  assert(contents.starts_with(dbname + \"/\"));\n  contents.remove_prefix(dbname.size() + 1);\n  std::string tmp = TempFileName(dbname, descriptor_number);\n  Status s = WriteStringToFileSync(env, contents.ToString() + \"\\n\", tmp);\n  if (s.ok()) {\n    s = env->RenameFile(tmp, CurrentFileName(dbname));\n  }\n  if (!s.ok()) {\n    env->DeleteFile(tmp);\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nStatus SetCurrentFile(Env* env, const std::string& dbname,\n                      uint64_t descriptor_number) {\n  // Remove leading \"dbname/\" and add newline to manifest file name\n  std::string manifest = DescriptorFileName(dbname, descriptor_number);\n  Slice contents = manifest;\n  assert(contents.starts_with(dbname + \"/\"));\n  contents.remove_prefix(dbname.size() + 1);\n  std::string tmp = TempFileName(dbname, descriptor_number);\n  Status s = WriteStringToFileSync(env, contents.ToString() + \"\\n\", tmp);\n  if (s.ok()) {\n    s = env->RenameFile(tmp, CurrentFileName(dbname));\n  }\n  if (!s.ok()) {\n    env->DeleteFile(tmp);\n  }\n  return s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Log",
          "args": [
            "options_->info_log",
            "\"MANIFEST write: %s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "PrintLogContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "46-65",
          "snippet": "bool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "descriptor_file_->Sync",
          "args": [],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "Sync",
          "container": "LogTest::StringDest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_test.cc",
          "lines": "47-47",
          "snippet": "virtual Status Sync() { return Status::OK(); }",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n\nLogTest {\n  StringDest {\n    virtual Status Sync() { return Status::OK(); }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "descriptor_log_->AddRecord",
          "args": [
            "record"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "AddRecord",
          "container": "Writer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_writer.cc",
          "lines": "27-73",
          "snippet": "Status Writer::AddRecord(const Slice& slice) {\n  const char* ptr = slice.data();\n  size_t left = slice.size();\n\n  // Fragment the record if necessary and emit it.  Note that if slice\n  // is empty, we still want to iterate once to emit a single\n  // zero-length record\n  Status s;\n  bool begin = true;\n  do {\n    const int leftover = kBlockSize - block_offset_;\n    assert(leftover >= 0);\n    if (leftover < kHeaderSize) {\n      // Switch to a new block\n      if (leftover > 0) {\n        // Fill the trailer (literal below relies on kHeaderSize being 7)\n        assert(kHeaderSize == 7);\n        dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n      }\n      block_offset_ = 0;\n    }\n\n    // Invariant: we never leave < kHeaderSize bytes in a block.\n    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n\n    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n    const size_t fragment_length = (left < avail) ? left : avail;\n\n    RecordType type;\n    const bool end = (left == fragment_length);\n    if (begin && end) {\n      type = kFullType;\n    } else if (begin) {\n      type = kFirstType;\n    } else if (end) {\n      type = kLastType;\n    } else {\n      type = kMiddleType;\n    }\n\n    s = EmitPhysicalRecord(type, ptr, fragment_length);\n    ptr += fragment_length;\n    left -= fragment_length;\n    begin = false;\n  } while (s.ok() && left > 0);\n  return s;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdint.h>",
            "#include \"db/log_writer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdint.h>\n#include \"db/log_writer.h\"\n\nWriter {\n  Status Writer::AddRecord(const Slice& slice) {\n    const char* ptr = slice.data();\n    size_t left = slice.size();\n  \n    // Fragment the record if necessary and emit it.  Note that if slice\n    // is empty, we still want to iterate once to emit a single\n    // zero-length record\n    Status s;\n    bool begin = true;\n    do {\n      const int leftover = kBlockSize - block_offset_;\n      assert(leftover >= 0);\n      if (leftover < kHeaderSize) {\n        // Switch to a new block\n        if (leftover > 0) {\n          // Fill the trailer (literal below relies on kHeaderSize being 7)\n          assert(kHeaderSize == 7);\n          dest_->Append(Slice(\"\\x00\\x00\\x00\\x00\\x00\\x00\", leftover));\n        }\n        block_offset_ = 0;\n      }\n  \n      // Invariant: we never leave < kHeaderSize bytes in a block.\n      assert(kBlockSize - block_offset_ - kHeaderSize >= 0);\n  \n      const size_t avail = kBlockSize - block_offset_ - kHeaderSize;\n      const size_t fragment_length = (left < avail) ? left : avail;\n  \n      RecordType type;\n      const bool end = (left == fragment_length);\n      if (begin && end) {\n        type = kFullType;\n      } else if (begin) {\n        type = kFirstType;\n      } else if (end) {\n        type = kLastType;\n      } else {\n        type = kMiddleType;\n      }\n  \n      s = EmitPhysicalRecord(type, ptr, fragment_length);\n      ptr += fragment_length;\n      left -= fragment_length;\n      begin = false;\n    } while (s.ok() && left > 0);\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit->EncodeTo",
          "args": [
            "&record"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeTo",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.cc",
          "lines": "41-86",
          "snippet": "void VersionEdit::EncodeTo(std::string* dst) const {\n  if (has_comparator_) {\n    PutVarint32(dst, kComparator);\n    PutLengthPrefixedSlice(dst, comparator_);\n  }\n  if (has_log_number_) {\n    PutVarint32(dst, kLogNumber);\n    PutVarint64(dst, log_number_);\n  }\n  if (has_prev_log_number_) {\n    PutVarint32(dst, kPrevLogNumber);\n    PutVarint64(dst, prev_log_number_);\n  }\n  if (has_next_file_number_) {\n    PutVarint32(dst, kNextFileNumber);\n    PutVarint64(dst, next_file_number_);\n  }\n  if (has_last_sequence_) {\n    PutVarint32(dst, kLastSequence);\n    PutVarint64(dst, last_sequence_);\n  }\n\n  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n    PutVarint32(dst, kCompactPointer);\n    PutVarint32(dst, compact_pointers_[i].first);  // level\n    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n  }\n\n  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n       iter != deleted_files_.end();\n       ++iter) {\n    PutVarint32(dst, kDeletedFile);\n    PutVarint32(dst, iter->first);   // level\n    PutVarint64(dst, iter->second);  // file number\n  }\n\n  for (size_t i = 0; i < new_files_.size(); i++) {\n    const FileMetaData& f = new_files_[i].second;\n    PutVarint32(dst, kNewFile);\n    PutVarint32(dst, new_files_[i].first);  // level\n    PutVarint64(dst, f.number);\n    PutVarint64(dst, f.file_size);\n    PutLengthPrefixedSlice(dst, f.smallest.Encode());\n    PutLengthPrefixedSlice(dst, f.largest.Encode());\n  }\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/version_edit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/version_set.h\"\n#include \"db/version_edit.h\"\n\nVersionEdit {\n  void VersionEdit::EncodeTo(std::string* dst) const {\n    if (has_comparator_) {\n      PutVarint32(dst, kComparator);\n      PutLengthPrefixedSlice(dst, comparator_);\n    }\n    if (has_log_number_) {\n      PutVarint32(dst, kLogNumber);\n      PutVarint64(dst, log_number_);\n    }\n    if (has_prev_log_number_) {\n      PutVarint32(dst, kPrevLogNumber);\n      PutVarint64(dst, prev_log_number_);\n    }\n    if (has_next_file_number_) {\n      PutVarint32(dst, kNextFileNumber);\n      PutVarint64(dst, next_file_number_);\n    }\n    if (has_last_sequence_) {\n      PutVarint32(dst, kLastSequence);\n      PutVarint64(dst, last_sequence_);\n    }\n  \n    for (size_t i = 0; i < compact_pointers_.size(); i++) {\n      PutVarint32(dst, kCompactPointer);\n      PutVarint32(dst, compact_pointers_[i].first);  // level\n      PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());\n    }\n  \n    for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n         iter != deleted_files_.end();\n         ++iter) {\n      PutVarint32(dst, kDeletedFile);\n      PutVarint32(dst, iter->first);   // level\n      PutVarint64(dst, iter->second);  // file number\n    }\n  \n    for (size_t i = 0; i < new_files_.size(); i++) {\n      const FileMetaData& f = new_files_[i].second;\n      PutVarint32(dst, kNewFile);\n      PutVarint32(dst, new_files_[i].first);  // level\n      PutVarint64(dst, f.number);\n      PutVarint64(dst, f.file_size);\n      PutLengthPrefixedSlice(dst, f.smallest.Encode());\n      PutLengthPrefixedSlice(dst, f.largest.Encode());\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mu->Unlock",
          "args": [],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "Unlock",
          "container": "Mutex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/port/port_win.cc",
          "lines": "60-63",
          "snippet": "void Mutex::Unlock() {\n  assert(cs_);\n  ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n}",
          "includes": [
            "#include <cassert>",
            "#include <windows.h>",
            "#include \"port/port_win.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <cassert>\n#include <windows.h>\n#include \"port/port_win.h\"\n\nMutex {\n  void Mutex::Unlock() {\n    assert(cs_);\n    ::LeaveCriticalSection(static_cast<CRITICAL_SECTION *>(cs_));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteSnapshot",
          "args": [
            "descriptor_log_"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSnapshot",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1068-1096",
          "snippet": "Status VersionSet::WriteSnapshot(log::Writer* log) {\n  // TODO: Break up into multiple records to reduce memory usage on recovery?\n\n  // Save metadata\n  VersionEdit edit;\n  edit.SetComparatorName(icmp_.user_comparator()->Name());\n\n  // Save compaction pointers\n  for (int level = 0; level < config::kNumLevels; level++) {\n    if (!compact_pointer_[level].empty()) {\n      InternalKey key;\n      key.DecodeFrom(compact_pointer_[level]);\n      edit.SetCompactPointer(level, key);\n    }\n  }\n\n  // Save files\n  for (int level = 0; level < config::kNumLevels; level++) {\n    const std::vector<FileMetaData*>& files = current_->files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      const FileMetaData* f = files[i];\n      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);\n    }\n  }\n\n  std::string record;\n  edit.EncodeTo(&record);\n  return log->AddRecord(record);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::WriteSnapshot(log::Writer* log) {\n    // TODO: Break up into multiple records to reduce memory usage on recovery?\n  \n    // Save metadata\n    VersionEdit edit;\n    edit.SetComparatorName(icmp_.user_comparator()->Name());\n  \n    // Save compaction pointers\n    for (int level = 0; level < config::kNumLevels; level++) {\n      if (!compact_pointer_[level].empty()) {\n        InternalKey key;\n        key.DecodeFrom(compact_pointer_[level]);\n        edit.SetCompactPointer(level, key);\n      }\n    }\n  \n    // Save files\n    for (int level = 0; level < config::kNumLevels; level++) {\n      const std::vector<FileMetaData*>& files = current_->files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        const FileMetaData* f = files[i];\n        edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);\n      }\n    }\n  \n    std::string record;\n    edit.EncodeTo(&record);\n    return log->AddRecord(record);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env_->NewWritableFile",
          "args": [
            "new_manifest_file",
            "&descriptor_file_"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "NewWritableFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "91-162",
          "snippet": "Status NewWritableFile(const std::string& f, WritableFile** r) {\n    class DataFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n\n     public:\n      DataFile(SpecialEnv* env, WritableFile* base)\n          : env_(env),\n            base_(base) {\n      }\n      ~DataFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->no_space_.Acquire_Load() != NULL) {\n          // Drop writes on the floor\n          return Status::OK();\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->data_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated data sync error\");\n        }\n        while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n          DelayMilliseconds(100);\n        }\n        return base_->Sync();\n      }\n    };\n    class ManifestFile : public WritableFile {\n     private:\n      SpecialEnv* env_;\n      WritableFile* base_;\n     public:\n      ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n      ~ManifestFile() { delete base_; }\n      Status Append(const Slice& data) {\n        if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated writer error\");\n        } else {\n          return base_->Append(data);\n        }\n      }\n      Status Close() { return base_->Close(); }\n      Status Flush() { return base_->Flush(); }\n      Status Sync() {\n        if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n          return Status::IOError(\"simulated sync error\");\n        } else {\n          return base_->Sync();\n        }\n      }\n    };\n\n    if (non_writable_.Acquire_Load() != NULL) {\n      return Status::IOError(\"simulated write error\");\n    }\n\n    Status s = target()->NewWritableFile(f, r);\n    if (s.ok()) {\n      if (strstr(f.c_str(), \".ldb\") != NULL ||\n          strstr(f.c_str(), \".log\") != NULL) {\n        *r = new DataFile(this, *r);\n      } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n        *r = new ManifestFile(this, *r);\n      }\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewWritableFile(const std::string& f, WritableFile** r) {\n      class DataFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n  \n       public:\n        DataFile(SpecialEnv* env, WritableFile* base)\n            : env_(env),\n              base_(base) {\n        }\n        ~DataFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->no_space_.Acquire_Load() != NULL) {\n            // Drop writes on the floor\n            return Status::OK();\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->data_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated data sync error\");\n          }\n          while (env_->delay_data_sync_.Acquire_Load() != NULL) {\n            DelayMilliseconds(100);\n          }\n          return base_->Sync();\n        }\n      };\n      class ManifestFile : public WritableFile {\n       private:\n        SpecialEnv* env_;\n        WritableFile* base_;\n       public:\n        ManifestFile(SpecialEnv* env, WritableFile* b) : env_(env), base_(b) { }\n        ~ManifestFile() { delete base_; }\n        Status Append(const Slice& data) {\n          if (env_->manifest_write_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated writer error\");\n          } else {\n            return base_->Append(data);\n          }\n        }\n        Status Close() { return base_->Close(); }\n        Status Flush() { return base_->Flush(); }\n        Status Sync() {\n          if (env_->manifest_sync_error_.Acquire_Load() != NULL) {\n            return Status::IOError(\"simulated sync error\");\n          } else {\n            return base_->Sync();\n          }\n        }\n      };\n  \n      if (non_writable_.Acquire_Load() != NULL) {\n        return Status::IOError(\"simulated write error\");\n      }\n  \n      Status s = target()->NewWritableFile(f, r);\n      if (s.ok()) {\n        if (strstr(f.c_str(), \".ldb\") != NULL ||\n            strstr(f.c_str(), \".log\") != NULL) {\n          *r = new DataFile(this, *r);\n        } else if (strstr(f.c_str(), \"MANIFEST\") != NULL) {\n          *r = new ManifestFile(this, *r);\n        }\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit->SetNextFile",
          "args": [
            "next_file_number_"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "SetNextFile",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "47-50",
          "snippet": "void SetNextFile(uint64_t num) {\n    has_next_file_number_ = true;\n    next_file_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetNextFile(uint64_t num) {\n      has_next_file_number_ = true;\n      next_file_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DescriptorFileName",
          "args": [
            "dbname_",
            "manifest_file_number_"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "DescriptorFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "47-53",
          "snippet": "std::string DescriptorFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"/MANIFEST-%06llu\",\n           static_cast<unsigned long long>(number));\n  return dbname + buf;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nstd::string DescriptorFileName(const std::string& dbname, uint64_t number) {\n  assert(number > 0);\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"/MANIFEST-%06llu\",\n           static_cast<unsigned long long>(number));\n  return dbname + buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "descriptor_file_ == NULL"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Finalize",
          "args": [
            "v"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "Finalize",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "1031-1066",
          "snippet": "void VersionSet::Finalize(Version* v) {\n  // Precomputed best level for next compaction\n  int best_level = -1;\n  double best_score = -1;\n\n  for (int level = 0; level < config::kNumLevels-1; level++) {\n    double score;\n    if (level == 0) {\n      // We treat level-0 specially by bounding the number of files\n      // instead of number of bytes for two reasons:\n      //\n      // (1) With larger write-buffer sizes, it is nice not to do too\n      // many level-0 compactions.\n      //\n      // (2) The files in level-0 are merged on every read and\n      // therefore we wish to avoid too many files when the individual\n      // file size is small (perhaps because of a small write-buffer\n      // setting, or very high compression ratios, or lots of\n      // overwrites/deletions).\n      score = v->files_[level].size() /\n          static_cast<double>(config::kL0_CompactionTrigger);\n    } else {\n      // Compute the ratio of current size to size limit.\n      const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n    }\n\n    if (score > best_score) {\n      best_level = level;\n      best_score = score;\n    }\n  }\n\n  v->compaction_level_ = best_level;\n  v->compaction_score_ = best_score;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::Finalize(Version* v) {\n    // Precomputed best level for next compaction\n    int best_level = -1;\n    double best_score = -1;\n  \n    for (int level = 0; level < config::kNumLevels-1; level++) {\n      double score;\n      if (level == 0) {\n        // We treat level-0 specially by bounding the number of files\n        // instead of number of bytes for two reasons:\n        //\n        // (1) With larger write-buffer sizes, it is nice not to do too\n        // many level-0 compactions.\n        //\n        // (2) The files in level-0 are merged on every read and\n        // therefore we wish to avoid too many files when the individual\n        // file size is small (perhaps because of a small write-buffer\n        // setting, or very high compression ratios, or lots of\n        // overwrites/deletions).\n        score = v->files_[level].size() /\n            static_cast<double>(config::kL0_CompactionTrigger);\n      } else {\n        // Compute the ratio of current size to size limit.\n        const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n        score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n      }\n  \n      if (score > best_score) {\n        best_level = level;\n        best_score = score;\n      }\n    }\n  \n    v->compaction_level_ = best_level;\n    v->compaction_score_ = best_score;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "builder.SaveTo",
          "args": [
            "v"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "SaveTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "716-762",
          "snippet": "void SaveTo(Version* v) {\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // Merge the set of added files with the set of pre-existing files.\n      // Drop any deleted files.  Store the result in *v.\n      const std::vector<FileMetaData*>& base_files = base_->files_[level];\n      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();\n      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();\n      const FileSet* added = levels_[level].added_files;\n      v->files_[level].reserve(base_files.size() + added->size());\n      for (FileSet::const_iterator added_iter = added->begin();\n           added_iter != added->end();\n           ++added_iter) {\n        // Add all smaller files listed in base_\n        for (std::vector<FileMetaData*>::const_iterator bpos\n                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);\n             base_iter != bpos;\n             ++base_iter) {\n          MaybeAddFile(v, level, *base_iter);\n        }\n\n        MaybeAddFile(v, level, *added_iter);\n      }\n\n      // Add remaining base files\n      for (; base_iter != base_end; ++base_iter) {\n        MaybeAddFile(v, level, *base_iter);\n      }\n\n#ifndef NDEBUG\n      // Make sure there is no overlap in levels > 0\n      if (level > 0) {\n        for (uint32_t i = 1; i < v->files_[level].size(); i++) {\n          const InternalKey& prev_end = v->files_[level][i-1]->largest;\n          const InternalKey& this_begin = v->files_[level][i]->smallest;\n          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {\n            fprintf(stderr, \"overlapping ranges in same level %s vs. %s\\n\",\n                    prev_end.DebugString().c_str(),\n                    this_begin.DebugString().c_str());\n            abort();\n          }\n        }\n      }\n#endif\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid SaveTo(Version* v) {\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // Merge the set of added files with the set of pre-existing files.\n      // Drop any deleted files.  Store the result in *v.\n      const std::vector<FileMetaData*>& base_files = base_->files_[level];\n      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();\n      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();\n      const FileSet* added = levels_[level].added_files;\n      v->files_[level].reserve(base_files.size() + added->size());\n      for (FileSet::const_iterator added_iter = added->begin();\n           added_iter != added->end();\n           ++added_iter) {\n        // Add all smaller files listed in base_\n        for (std::vector<FileMetaData*>::const_iterator bpos\n                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);\n             base_iter != bpos;\n             ++base_iter) {\n          MaybeAddFile(v, level, *base_iter);\n        }\n\n        MaybeAddFile(v, level, *added_iter);\n      }\n\n      // Add remaining base files\n      for (; base_iter != base_end; ++base_iter) {\n        MaybeAddFile(v, level, *base_iter);\n      }\n\n#ifndef NDEBUG\n      // Make sure there is no overlap in levels > 0\n      if (level > 0) {\n        for (uint32_t i = 1; i < v->files_[level].size(); i++) {\n          const InternalKey& prev_end = v->files_[level][i-1]->largest;\n          const InternalKey& this_begin = v->files_[level][i]->smallest;\n          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {\n            fprintf(stderr, \"overlapping ranges in same level %s vs. %s\\n\",\n                    prev_end.DebugString().c_str(),\n                    this_begin.DebugString().c_str());\n            abort();\n          }\n        }\n      }\n#endif\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "builder.Apply",
          "args": [
            "edit"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "Apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "670-713",
          "snippet": "void Apply(VersionEdit* edit) {\n    // Update compaction pointers\n    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {\n      const int level = edit->compact_pointers_[i].first;\n      vset_->compact_pointer_[level] =\n          edit->compact_pointers_[i].second.Encode().ToString();\n    }\n\n    // Delete files\n    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;\n    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();\n         iter != del.end();\n         ++iter) {\n      const int level = iter->first;\n      const uint64_t number = iter->second;\n      levels_[level].deleted_files.insert(number);\n    }\n\n    // Add new files\n    for (size_t i = 0; i < edit->new_files_.size(); i++) {\n      const int level = edit->new_files_[i].first;\n      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);\n      f->refs = 1;\n\n      // We arrange to automatically compact this file after\n      // a certain number of seeks.  Let's assume:\n      //   (1) One seek costs 10ms\n      //   (2) Writing or reading 1MB costs 10ms (100MB/s)\n      //   (3) A compaction of 1MB does 25MB of IO:\n      //         1MB read from this level\n      //         10-12MB read from next level (boundaries may be misaligned)\n      //         10-12MB written to next level\n      // This implies that 25 seeks cost the same as the compaction\n      // of 1MB of data.  I.e., one seek costs approximately the\n      // same as the compaction of 40KB of data.  We are a little\n      // conservative and allow approximately one seek for every 16KB\n      // of data before triggering a compaction.\n      f->allowed_seeks = (f->file_size / 16384);\n      if (f->allowed_seeks < 100) f->allowed_seeks = 100;\n\n      levels_[level].deleted_files.erase(f->number);\n      levels_[level].added_files->insert(f);\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid Apply(VersionEdit* edit) {\n    // Update compaction pointers\n    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {\n      const int level = edit->compact_pointers_[i].first;\n      vset_->compact_pointer_[level] =\n          edit->compact_pointers_[i].second.Encode().ToString();\n    }\n\n    // Delete files\n    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;\n    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();\n         iter != del.end();\n         ++iter) {\n      const int level = iter->first;\n      const uint64_t number = iter->second;\n      levels_[level].deleted_files.insert(number);\n    }\n\n    // Add new files\n    for (size_t i = 0; i < edit->new_files_.size(); i++) {\n      const int level = edit->new_files_[i].first;\n      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);\n      f->refs = 1;\n\n      // We arrange to automatically compact this file after\n      // a certain number of seeks.  Let's assume:\n      //   (1) One seek costs 10ms\n      //   (2) Writing or reading 1MB costs 10ms (100MB/s)\n      //   (3) A compaction of 1MB does 25MB of IO:\n      //         1MB read from this level\n      //         10-12MB read from next level (boundaries may be misaligned)\n      //         10-12MB written to next level\n      // This implies that 25 seeks cost the same as the compaction\n      // of 1MB of data.  I.e., one seek costs approximately the\n      // same as the compaction of 40KB of data.  We are a little\n      // conservative and allow approximately one seek for every 16KB\n      // of data before triggering a compaction.\n      f->allowed_seeks = (f->file_size / 16384);\n      if (f->allowed_seeks < 100) f->allowed_seeks = 100;\n\n      levels_[level].deleted_files.erase(f->number);\n      levels_[level].added_files->insert(f);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "edit->SetLastSequence",
          "args": [
            "last_sequence_"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "SetLastSequence",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.h",
          "lines": "212-215",
          "snippet": "void SetLastSequence(uint64_t s) {\n    assert(s >= last_sequence_);\n    last_sequence_ = s;\n  }",
          "includes": [
            "#include \"port/thread_annotations.h\"",
            "#include \"port/port.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <set>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"port/thread_annotations.h\"\n#include \"port/port.h\"\n#include \"db/version_edit.h\"\n#include \"db/dbformat.h\"\n#include <vector>\n#include <set>\n#include <map>\n\nVersionSet {\n  void SetLastSequence(uint64_t s) {\n      assert(s >= last_sequence_);\n      last_sequence_ = s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit->SetPrevLogNumber",
          "args": [
            "prev_log_number_"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "SetPrevLogNumber",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "43-46",
          "snippet": "void SetPrevLogNumber(uint64_t num) {\n    has_prev_log_number_ = true;\n    prev_log_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetPrevLogNumber(uint64_t num) {\n      has_prev_log_number_ = true;\n      prev_log_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit->SetLogNumber",
          "args": [
            "log_number_"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "SetLogNumber",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.h",
          "lines": "39-42",
          "snippet": "void SetLogNumber(uint64_t num) {\n    has_log_number_ = true;\n    log_number_ = num;\n  }",
          "includes": [
            "#include \"db/dbformat.h\"",
            "#include <vector>",
            "#include <utility>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"db/dbformat.h\"\n#include <vector>\n#include <utility>\n#include <set>\n\nVersionEdit {\n  void SetLogNumber(uint64_t num) {\n      has_log_number_ = true;\n      log_number_ = num;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "edit->log_number_ < next_file_number_"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "edit->log_number_ >= log_number_"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {\n    if (edit->has_log_number_) {\n      assert(edit->log_number_ >= log_number_);\n      assert(edit->log_number_ < next_file_number_);\n    } else {\n      edit->SetLogNumber(log_number_);\n    }\n  \n    if (!edit->has_prev_log_number_) {\n      edit->SetPrevLogNumber(prev_log_number_);\n    }\n  \n    edit->SetNextFile(next_file_number_);\n    edit->SetLastSequence(last_sequence_);\n  \n    Version* v = new Version(this);\n    {\n      Builder builder(this, current_);\n      builder.Apply(edit);\n      builder.SaveTo(v);\n    }\n    Finalize(v);\n  \n    // Initialize new descriptor log file if necessary by creating\n    // a temporary file that contains a snapshot of the current version.\n    std::string new_manifest_file;\n    Status s;\n    if (descriptor_log_ == NULL) {\n      // No reason to unlock *mu here since we only hit this path in the\n      // first call to LogAndApply (when opening the database).\n      assert(descriptor_file_ == NULL);\n      new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);\n      edit->SetNextFile(next_file_number_);\n      s = env_->NewWritableFile(new_manifest_file, &descriptor_file_);\n      if (s.ok()) {\n        descriptor_log_ = new log::Writer(descriptor_file_);\n        s = WriteSnapshot(descriptor_log_);\n      }\n    }\n  \n    // Unlock during expensive MANIFEST log write\n    {\n      mu->Unlock();\n  \n      // Write new record to MANIFEST log\n      if (s.ok()) {\n        std::string record;\n        edit->EncodeTo(&record);\n        s = descriptor_log_->AddRecord(record);\n        if (s.ok()) {\n          s = descriptor_file_->Sync();\n        }\n        if (!s.ok()) {\n          Log(options_->info_log, \"MANIFEST write: %s\\n\", s.ToString().c_str());\n        }\n      }\n  \n      // If we just created a new descriptor file, install it by writing a\n      // new CURRENT file that points to it.\n      if (s.ok() && !new_manifest_file.empty()) {\n        s = SetCurrentFile(env_, dbname_, manifest_file_number_);\n      }\n  \n      mu->Lock();\n    }\n  \n    // Install the new version\n    if (s.ok()) {\n      AppendVersion(v);\n      log_number_ = edit->log_number_;\n      prev_log_number_ = edit->prev_log_number_;\n    } else {\n      delete v;\n      if (!new_manifest_file.empty()) {\n        delete descriptor_log_;\n        delete descriptor_file_;\n        descriptor_log_ = NULL;\n        descriptor_file_ = NULL;\n        env_->DeleteFile(new_manifest_file);\n      }\n    }\n  \n    return s;\n  }\n}"
  },
  {
    "function_name": "AppendVersion",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "808-823",
    "snippet": "void VersionSet::AppendVersion(Version* v) {\n  // Make \"v\" current\n  assert(v->refs_ == 0);\n  assert(v != current_);\n  if (current_ != NULL) {\n    current_->Unref();\n  }\n  current_ = v;\n  v->Ref();\n\n  // Append to linked list\n  v->prev_ = dummy_versions_.prev_;\n  v->next_ = &dummy_versions_;\n  v->prev_->next_ = v;\n  v->next_->prev_ = v;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v->Ref",
          "args": [],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "487-489",
          "snippet": "void Version::Ref() {\n  ++refs_;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Ref() {\n    ++refs_;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_->Unref",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "491-498",
          "snippet": "void Version::Unref() {\n  assert(this != &vset_->dummy_versions_);\n  assert(refs_ >= 1);\n  --refs_;\n  if (refs_ == 0) {\n    delete this;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Unref() {\n    assert(this != &vset_->dummy_versions_);\n    assert(refs_ >= 1);\n    --refs_;\n    if (refs_ == 0) {\n      delete this;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "v != current_"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "v->refs_ == 0"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::AppendVersion(Version* v) {\n    // Make \"v\" current\n    assert(v->refs_ == 0);\n    assert(v != current_);\n    if (current_ != NULL) {\n      current_->Unref();\n    }\n    current_ = v;\n    v->Ref();\n  \n    // Append to linked list\n    v->prev_ = dummy_versions_.prev_;\n    v->next_ = &dummy_versions_;\n    v->prev_->next_ = v;\n    v->next_->prev_ = v;\n  }\n}"
  },
  {
    "function_name": "~VersionSet",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "801-806",
    "snippet": "VersionSet::~VersionSet() {\n  current_->Unref();\n  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty\n  delete descriptor_log_;\n  delete descriptor_file_;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dummy_versions_.next_ == &dummy_versions_"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_->Unref",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "491-498",
          "snippet": "void Version::Unref() {\n  assert(this != &vset_->dummy_versions_);\n  assert(refs_ >= 1);\n  --refs_;\n  if (refs_ == 0) {\n    delete this;\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Unref() {\n    assert(this != &vset_->dummy_versions_);\n    assert(refs_ >= 1);\n    --refs_;\n    if (refs_ == 0) {\n      delete this;\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  VersionSet::~VersionSet() {\n    current_->Unref();\n    assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty\n    delete descriptor_log_;\n    delete descriptor_file_;\n  }\n}"
  },
  {
    "function_name": "VersionSet",
    "container": "VersionSet",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "780-799",
    "snippet": "VersionSet::VersionSet(const std::string& dbname,\n                       const Options* options,\n                       TableCache* table_cache,\n                       const InternalKeyComparator* cmp)\n    : env_(options->env),\n      dbname_(dbname),\n      options_(options),\n      table_cache_(table_cache),\n      icmp_(*cmp),\n      next_file_number_(2),\n      manifest_file_number_(0),  // Filled by Recover()\n      last_sequence_(0),\n      log_number_(0),\n      prev_log_number_(0),\n      descriptor_file_(NULL),\n      descriptor_log_(NULL),\n      dummy_versions_(this),\n      current_(NULL) {\n  AppendVersion(new Version(this));\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AppendVersion",
          "args": [
            "new Version(this)"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "AppendVersion",
          "container": "VersionSet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "808-823",
          "snippet": "void VersionSet::AppendVersion(Version* v) {\n  // Make \"v\" current\n  assert(v->refs_ == 0);\n  assert(v != current_);\n  if (current_ != NULL) {\n    current_->Unref();\n  }\n  current_ = v;\n  v->Ref();\n\n  // Append to linked list\n  v->prev_ = dummy_versions_.prev_;\n  v->next_ = &dummy_versions_;\n  v->prev_->next_ = v;\n  v->next_->prev_ = v;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  void VersionSet::AppendVersion(Version* v) {\n    // Make \"v\" current\n    assert(v->refs_ == 0);\n    assert(v != current_);\n    if (current_ != NULL) {\n      current_->Unref();\n    }\n    current_ = v;\n    v->Ref();\n  \n    // Append to linked list\n    v->prev_ = dummy_versions_.prev_;\n    v->next_ = &dummy_versions_;\n    v->prev_->next_ = v;\n    v->next_->prev_ = v;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersionSet {\n  VersionSet::VersionSet(const std::string& dbname,\n                         const Options* options,\n                         TableCache* table_cache,\n                         const InternalKeyComparator* cmp)\n      : env_(options->env),\n        dbname_(dbname),\n        options_(options),\n        table_cache_(table_cache),\n        icmp_(*cmp),\n        next_file_number_(2),\n        manifest_file_number_(0),  // Filled by Recover()\n        last_sequence_(0),\n        log_number_(0),\n        prev_log_number_(0),\n        descriptor_file_(NULL),\n        descriptor_log_(NULL),\n        dummy_versions_(this),\n        current_(NULL) {\n    AppendVersion(new Version(this));\n  }\n}"
  },
  {
    "function_name": "MaybeAddFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "764-777",
    "snippet": "void MaybeAddFile(Version* v, int level, FileMetaData* f) {\n    if (levels_[level].deleted_files.count(f->number) > 0) {\n      // File is deleted: do nothing\n    } else {\n      std::vector<FileMetaData*>* files = &v->files_[level];\n      if (level > 0 && !files->empty()) {\n        // Must not overlap\n        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,\n                                    f->smallest) < 0);\n      }\n      f->refs++;\n      files->push_back(f);\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "files->push_back",
          "args": [
            "f"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "vset_->icmp_.Compare((*files)[files->size()-1]->largest,\n                                    f->smallest) < 0"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vset_->icmp_.Compare",
          "args": [
            "(*files)[files->size()-1]->largest",
            "f->smallest"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files->size",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files->empty",
          "args": [],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "levels_[level].deleted_files.count",
          "args": [
            "f->number"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid MaybeAddFile(Version* v, int level, FileMetaData* f) {\n    if (levels_[level].deleted_files.count(f->number) > 0) {\n      // File is deleted: do nothing\n    } else {\n      std::vector<FileMetaData*>* files = &v->files_[level];\n      if (level > 0 && !files->empty()) {\n        // Must not overlap\n        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,\n                                    f->smallest) < 0);\n      }\n      f->refs++;\n      files->push_back(f);\n    }\n  }"
  },
  {
    "function_name": "SaveTo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "716-762",
    "snippet": "void SaveTo(Version* v) {\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // Merge the set of added files with the set of pre-existing files.\n      // Drop any deleted files.  Store the result in *v.\n      const std::vector<FileMetaData*>& base_files = base_->files_[level];\n      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();\n      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();\n      const FileSet* added = levels_[level].added_files;\n      v->files_[level].reserve(base_files.size() + added->size());\n      for (FileSet::const_iterator added_iter = added->begin();\n           added_iter != added->end();\n           ++added_iter) {\n        // Add all smaller files listed in base_\n        for (std::vector<FileMetaData*>::const_iterator bpos\n                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);\n             base_iter != bpos;\n             ++base_iter) {\n          MaybeAddFile(v, level, *base_iter);\n        }\n\n        MaybeAddFile(v, level, *added_iter);\n      }\n\n      // Add remaining base files\n      for (; base_iter != base_end; ++base_iter) {\n        MaybeAddFile(v, level, *base_iter);\n      }\n\n#ifndef NDEBUG\n      // Make sure there is no overlap in levels > 0\n      if (level > 0) {\n        for (uint32_t i = 1; i < v->files_[level].size(); i++) {\n          const InternalKey& prev_end = v->files_[level][i-1]->largest;\n          const InternalKey& this_begin = v->files_[level][i]->smallest;\n          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {\n            fprintf(stderr, \"overlapping ranges in same level %s vs. %s\\n\",\n                    prev_end.DebugString().c_str(),\n                    this_begin.DebugString().c_str());\n            abort();\n          }\n        }\n      }\n#endif\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"overlapping ranges in same level %s vs. %s\\n\"",
            "prev_end.DebugString().c_str()",
            "this_begin.DebugString().c_str()"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_begin.DebugString",
          "args": [],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "DebugString",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "579-603",
          "snippet": "std::string Version::DebugString() const {\n  std::string r;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    // E.g.,\n    //   --- level 1 ---\n    //   17:123['a' .. 'd']\n    //   20:43['e' .. 'g']\n    r.append(\"--- level \");\n    AppendNumberTo(&r, level);\n    r.append(\" ---\\n\");\n    const std::vector<FileMetaData*>& files = files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      r.push_back(' ');\n      AppendNumberTo(&r, files[i]->number);\n      r.push_back(':');\n      AppendNumberTo(&r, files[i]->file_size);\n      r.append(\"[\");\n      r.append(files[i]->smallest.DebugString());\n      r.append(\" .. \");\n      r.append(files[i]->largest.DebugString());\n      r.append(\"]\\n\");\n    }\n  }\n  return r;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  std::string Version::DebugString() const {\n    std::string r;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // E.g.,\n      //   --- level 1 ---\n      //   17:123['a' .. 'd']\n      //   20:43['e' .. 'g']\n      r.append(\"--- level \");\n      AppendNumberTo(&r, level);\n      r.append(\" ---\\n\");\n      const std::vector<FileMetaData*>& files = files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        r.push_back(' ');\n        AppendNumberTo(&r, files[i]->number);\n        r.push_back(':');\n        AppendNumberTo(&r, files[i]->file_size);\n        r.append(\"[\");\n        r.append(files[i]->smallest.DebugString());\n        r.append(\" .. \");\n        r.append(files[i]->largest.DebugString());\n        r.append(\"]\\n\");\n      }\n    }\n    return r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vset_->icmp_.Compare",
          "args": [
            "prev_end",
            "this_begin"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->files_[level].size",
          "args": [],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "TransactionTablePriv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "170-173",
          "snippet": "int size()\n    {\n        return cachedWallet.size();\n    }",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTablePriv {\n  int size()\n      {\n          return cachedWallet.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MaybeAddFile",
          "args": [
            "v",
            "level",
            "*base_iter"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "MaybeAddFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "764-777",
          "snippet": "void MaybeAddFile(Version* v, int level, FileMetaData* f) {\n    if (levels_[level].deleted_files.count(f->number) > 0) {\n      // File is deleted: do nothing\n    } else {\n      std::vector<FileMetaData*>* files = &v->files_[level];\n      if (level > 0 && !files->empty()) {\n        // Must not overlap\n        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,\n                                    f->smallest) < 0);\n      }\n      f->refs++;\n      files->push_back(f);\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid MaybeAddFile(Version* v, int level, FileMetaData* f) {\n    if (levels_[level].deleted_files.count(f->number) > 0) {\n      // File is deleted: do nothing\n    } else {\n      std::vector<FileMetaData*>* files = &v->files_[level];\n      if (level > 0 && !files->empty()) {\n        // Must not overlap\n        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,\n                                    f->smallest) < 0);\n      }\n      f->refs++;\n      files->push_back(f);\n    }\n  }"
        }
      },
      {
        "call_info": {
          "callee": "std::upper_bound",
          "args": [
            "base_iter",
            "base_end",
            "*added_iter",
            "cmp"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "added->end",
          "args": [],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "added->begin",
          "args": [],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v->files_[level].reserve",
          "args": [
            "base_files.size() + added->size()"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "added->size",
          "args": [],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid SaveTo(Version* v) {\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // Merge the set of added files with the set of pre-existing files.\n      // Drop any deleted files.  Store the result in *v.\n      const std::vector<FileMetaData*>& base_files = base_->files_[level];\n      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();\n      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();\n      const FileSet* added = levels_[level].added_files;\n      v->files_[level].reserve(base_files.size() + added->size());\n      for (FileSet::const_iterator added_iter = added->begin();\n           added_iter != added->end();\n           ++added_iter) {\n        // Add all smaller files listed in base_\n        for (std::vector<FileMetaData*>::const_iterator bpos\n                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);\n             base_iter != bpos;\n             ++base_iter) {\n          MaybeAddFile(v, level, *base_iter);\n        }\n\n        MaybeAddFile(v, level, *added_iter);\n      }\n\n      // Add remaining base files\n      for (; base_iter != base_end; ++base_iter) {\n        MaybeAddFile(v, level, *base_iter);\n      }\n\n#ifndef NDEBUG\n      // Make sure there is no overlap in levels > 0\n      if (level > 0) {\n        for (uint32_t i = 1; i < v->files_[level].size(); i++) {\n          const InternalKey& prev_end = v->files_[level][i-1]->largest;\n          const InternalKey& this_begin = v->files_[level][i]->smallest;\n          if (vset_->icmp_.Compare(prev_end, this_begin) >= 0) {\n            fprintf(stderr, \"overlapping ranges in same level %s vs. %s\\n\",\n                    prev_end.DebugString().c_str(),\n                    this_begin.DebugString().c_str());\n            abort();\n          }\n        }\n      }\n#endif\n    }\n  }"
  },
  {
    "function_name": "Apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "670-713",
    "snippet": "void Apply(VersionEdit* edit) {\n    // Update compaction pointers\n    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {\n      const int level = edit->compact_pointers_[i].first;\n      vset_->compact_pointer_[level] =\n          edit->compact_pointers_[i].second.Encode().ToString();\n    }\n\n    // Delete files\n    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;\n    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();\n         iter != del.end();\n         ++iter) {\n      const int level = iter->first;\n      const uint64_t number = iter->second;\n      levels_[level].deleted_files.insert(number);\n    }\n\n    // Add new files\n    for (size_t i = 0; i < edit->new_files_.size(); i++) {\n      const int level = edit->new_files_[i].first;\n      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);\n      f->refs = 1;\n\n      // We arrange to automatically compact this file after\n      // a certain number of seeks.  Let's assume:\n      //   (1) One seek costs 10ms\n      //   (2) Writing or reading 1MB costs 10ms (100MB/s)\n      //   (3) A compaction of 1MB does 25MB of IO:\n      //         1MB read from this level\n      //         10-12MB read from next level (boundaries may be misaligned)\n      //         10-12MB written to next level\n      // This implies that 25 seeks cost the same as the compaction\n      // of 1MB of data.  I.e., one seek costs approximately the\n      // same as the compaction of 40KB of data.  We are a little\n      // conservative and allow approximately one seek for every 16KB\n      // of data before triggering a compaction.\n      f->allowed_seeks = (f->file_size / 16384);\n      if (f->allowed_seeks < 100) f->allowed_seeks = 100;\n\n      levels_[level].deleted_files.erase(f->number);\n      levels_[level].added_files->insert(f);\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "levels_[level].added_files->insert",
          "args": [
            "f"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "levels_[level].deleted_files.erase",
          "args": [
            "f->number"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit->new_files_.size",
          "args": [],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "del.end",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "del.begin",
          "args": [],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit->compact_pointers_[i].second.Encode",
          "args": [],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "154-157",
          "snippet": "Slice Encode() const {\n    assert(!rep_.empty());\n    return rep_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  Slice Encode() const {\n      assert(!rep_.empty());\n      return rep_;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvoid Apply(VersionEdit* edit) {\n    // Update compaction pointers\n    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {\n      const int level = edit->compact_pointers_[i].first;\n      vset_->compact_pointer_[level] =\n          edit->compact_pointers_[i].second.Encode().ToString();\n    }\n\n    // Delete files\n    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;\n    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();\n         iter != del.end();\n         ++iter) {\n      const int level = iter->first;\n      const uint64_t number = iter->second;\n      levels_[level].deleted_files.insert(number);\n    }\n\n    // Add new files\n    for (size_t i = 0; i < edit->new_files_.size(); i++) {\n      const int level = edit->new_files_[i].first;\n      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);\n      f->refs = 1;\n\n      // We arrange to automatically compact this file after\n      // a certain number of seeks.  Let's assume:\n      //   (1) One seek costs 10ms\n      //   (2) Writing or reading 1MB costs 10ms (100MB/s)\n      //   (3) A compaction of 1MB does 25MB of IO:\n      //         1MB read from this level\n      //         10-12MB read from next level (boundaries may be misaligned)\n      //         10-12MB written to next level\n      // This implies that 25 seeks cost the same as the compaction\n      // of 1MB of data.  I.e., one seek costs approximately the\n      // same as the compaction of 40KB of data.  We are a little\n      // conservative and allow approximately one seek for every 16KB\n      // of data before triggering a compaction.\n      f->allowed_seeks = (f->file_size / 16384);\n      if (f->allowed_seeks < 100) f->allowed_seeks = 100;\n\n      levels_[level].deleted_files.erase(f->number);\n      levels_[level].added_files->insert(f);\n    }\n  }"
  },
  {
    "function_name": "Builder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "637-646",
    "snippet": "Builder(VersionSet* vset, Version* base)\n      : vset_(vset),\n        base_(base) {\n    base_->Ref();\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      levels_[level].added_files = new FileSet(cmp);\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "base_->Ref",
          "args": [],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "487-489",
          "snippet": "void Version::Ref() {\n  ++refs_;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Ref() {\n    ++refs_;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nBuilder(VersionSet* vset, Version* base)\n      : vset_(vset),\n        base_(base) {\n    base_->Ref();\n    BySmallestKey cmp;\n    cmp.internal_comparator = &vset_->icmp_;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      levels_[level].added_files = new FileSet(cmp);\n    }\n  }"
  },
  {
    "function_name": "DebugString",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "579-603",
    "snippet": "std::string Version::DebugString() const {\n  std::string r;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    // E.g.,\n    //   --- level 1 ---\n    //   17:123['a' .. 'd']\n    //   20:43['e' .. 'g']\n    r.append(\"--- level \");\n    AppendNumberTo(&r, level);\n    r.append(\" ---\\n\");\n    const std::vector<FileMetaData*>& files = files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      r.push_back(' ');\n      AppendNumberTo(&r, files[i]->number);\n      r.push_back(':');\n      AppendNumberTo(&r, files[i]->file_size);\n      r.append(\"[\");\n      r.append(files[i]->smallest.DebugString());\n      r.append(\" .. \");\n      r.append(files[i]->largest.DebugString());\n      r.append(\"]\\n\");\n    }\n  }\n  return r;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "r.append",
          "args": [
            "\"]\\n\""
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r.append",
          "args": [
            "files[i]->largest.DebugString()"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files[i]->largest.DebugString",
          "args": [],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "DebugString",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "579-603",
          "snippet": "std::string Version::DebugString() const {\n  std::string r;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    // E.g.,\n    //   --- level 1 ---\n    //   17:123['a' .. 'd']\n    //   20:43['e' .. 'g']\n    r.append(\"--- level \");\n    AppendNumberTo(&r, level);\n    r.append(\" ---\\n\");\n    const std::vector<FileMetaData*>& files = files_[level];\n    for (size_t i = 0; i < files.size(); i++) {\n      r.push_back(' ');\n      AppendNumberTo(&r, files[i]->number);\n      r.push_back(':');\n      AppendNumberTo(&r, files[i]->file_size);\n      r.append(\"[\");\n      r.append(files[i]->smallest.DebugString());\n      r.append(\" .. \");\n      r.append(files[i]->largest.DebugString());\n      r.append(\"]\\n\");\n    }\n  }\n  return r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "r.append",
          "args": [
            "\" .. \""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r.append",
          "args": [
            "files[i]->smallest.DebugString()"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r.append",
          "args": [
            "\"[\""
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AppendNumberTo",
          "args": [
            "&r",
            "files[i]->file_size"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "AppendNumberTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "16-20",
          "snippet": "void AppendNumberTo(std::string* str, uint64_t num) {\n  char buf[30];\n  snprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) num);\n  str->append(buf);\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nvoid AppendNumberTo(std::string* str, uint64_t num) {\n  char buf[30];\n  snprintf(buf, sizeof(buf), \"%llu\", (unsigned long long) num);\n  str->append(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.push_back",
          "args": [
            "':'"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r.push_back",
          "args": [
            "' '"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "r.append",
          "args": [
            "\" ---\\n\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "r.append",
          "args": [
            "\"--- level \""
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  std::string Version::DebugString() const {\n    std::string r;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      // E.g.,\n      //   --- level 1 ---\n      //   17:123['a' .. 'd']\n      //   20:43['e' .. 'g']\n      r.append(\"--- level \");\n      AppendNumberTo(&r, level);\n      r.append(\" ---\\n\");\n      const std::vector<FileMetaData*>& files = files_[level];\n      for (size_t i = 0; i < files.size(); i++) {\n        r.push_back(' ');\n        AppendNumberTo(&r, files[i]->number);\n        r.push_back(':');\n        AppendNumberTo(&r, files[i]->file_size);\n        r.append(\"[\");\n        r.append(files[i]->smallest.DebugString());\n        r.append(\" .. \");\n        r.append(files[i]->largest.DebugString());\n        r.append(\"]\\n\");\n      }\n    }\n    return r;\n  }\n}"
  },
  {
    "function_name": "GetOverlappingInputs",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "536-577",
    "snippet": "void Version::GetOverlappingInputs(\n    int level,\n    const InternalKey* begin,\n    const InternalKey* end,\n    std::vector<FileMetaData*>* inputs) {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  inputs->clear();\n  Slice user_begin, user_end;\n  if (begin != NULL) {\n    user_begin = begin->user_key();\n  }\n  if (end != NULL) {\n    user_end = end->user_key();\n  }\n  const Comparator* user_cmp = vset_->icmp_.user_comparator();\n  for (size_t i = 0; i < files_[level].size(); ) {\n    FileMetaData* f = files_[level][i++];\n    const Slice file_start = f->smallest.user_key();\n    const Slice file_limit = f->largest.user_key();\n    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n      // \"f\" is completely before specified range; skip it\n    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n      // \"f\" is completely after specified range; skip it\n    } else {\n      inputs->push_back(f);\n      if (level == 0) {\n        // Level-0 files may overlap each other.  So check if the newly\n        // added file has expanded the range.  If so, restart search.\n        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n          user_begin = file_start;\n          inputs->clear();\n          i = 0;\n        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n          user_end = file_limit;\n          inputs->clear();\n          i = 0;\n        }\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inputs->clear",
          "args": [],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_cmp->Compare",
          "args": [
            "file_limit",
            "user_end"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputs->push_back",
          "args": [
            "f"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f->largest.user_key",
          "args": [],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_[level].size",
          "args": [],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vset_->icmp_.user_comparator",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level < config::kNumLevels"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "level >= 0"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::GetOverlappingInputs(\n      int level,\n      const InternalKey* begin,\n      const InternalKey* end,\n      std::vector<FileMetaData*>* inputs) {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    inputs->clear();\n    Slice user_begin, user_end;\n    if (begin != NULL) {\n      user_begin = begin->user_key();\n    }\n    if (end != NULL) {\n      user_end = end->user_key();\n    }\n    const Comparator* user_cmp = vset_->icmp_.user_comparator();\n    for (size_t i = 0; i < files_[level].size(); ) {\n      FileMetaData* f = files_[level][i++];\n      const Slice file_start = f->smallest.user_key();\n      const Slice file_limit = f->largest.user_key();\n      if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n        // \"f\" is completely before specified range; skip it\n      } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n        // \"f\" is completely after specified range; skip it\n      } else {\n        inputs->push_back(f);\n        if (level == 0) {\n          // Level-0 files may overlap each other.  So check if the newly\n          // added file has expanded the range.  If so, restart search.\n          if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n            user_begin = file_start;\n            inputs->clear();\n            i = 0;\n          } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n            user_end = file_limit;\n            inputs->clear();\n            i = 0;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "PickLevelForMemTableOutput",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "507-533",
    "snippet": "int Version::PickLevelForMemTableOutput(\n    const Slice& smallest_user_key,\n    const Slice& largest_user_key) {\n  int level = 0;\n  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {\n    // Push to next level if there is no overlap in next level,\n    // and the #bytes overlapping in the level after that are limited.\n    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);\n    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));\n    std::vector<FileMetaData*> overlaps;\n    while (level < config::kMaxMemCompactLevel) {\n      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {\n        break;\n      }\n      if (level + 2 < config::kNumLevels) {\n        // Check that file does not overlap too many grandparent bytes.\n        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n        const int64_t sum = TotalFileSize(overlaps);\n        if (sum > kMaxGrandParentOverlapBytes) {\n          break;\n        }\n      }\n      level++;\n    }\n  }\n  return level;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TotalFileSize",
          "args": [
            "overlaps"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "TotalFileSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "49-55",
          "snippet": "static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOverlappingInputs",
          "args": [
            "level + 2",
            "&start",
            "&limit",
            "&overlaps"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "GetOverlappingInputs",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "536-577",
          "snippet": "void Version::GetOverlappingInputs(\n    int level,\n    const InternalKey* begin,\n    const InternalKey* end,\n    std::vector<FileMetaData*>* inputs) {\n  assert(level >= 0);\n  assert(level < config::kNumLevels);\n  inputs->clear();\n  Slice user_begin, user_end;\n  if (begin != NULL) {\n    user_begin = begin->user_key();\n  }\n  if (end != NULL) {\n    user_end = end->user_key();\n  }\n  const Comparator* user_cmp = vset_->icmp_.user_comparator();\n  for (size_t i = 0; i < files_[level].size(); ) {\n    FileMetaData* f = files_[level][i++];\n    const Slice file_start = f->smallest.user_key();\n    const Slice file_limit = f->largest.user_key();\n    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n      // \"f\" is completely before specified range; skip it\n    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n      // \"f\" is completely after specified range; skip it\n    } else {\n      inputs->push_back(f);\n      if (level == 0) {\n        // Level-0 files may overlap each other.  So check if the newly\n        // added file has expanded the range.  If so, restart search.\n        if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n          user_begin = file_start;\n          inputs->clear();\n          i = 0;\n        } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n          user_end = file_limit;\n          inputs->clear();\n          i = 0;\n        }\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::GetOverlappingInputs(\n      int level,\n      const InternalKey* begin,\n      const InternalKey* end,\n      std::vector<FileMetaData*>* inputs) {\n    assert(level >= 0);\n    assert(level < config::kNumLevels);\n    inputs->clear();\n    Slice user_begin, user_end;\n    if (begin != NULL) {\n      user_begin = begin->user_key();\n    }\n    if (end != NULL) {\n      user_end = end->user_key();\n    }\n    const Comparator* user_cmp = vset_->icmp_.user_comparator();\n    for (size_t i = 0; i < files_[level].size(); ) {\n      FileMetaData* f = files_[level][i++];\n      const Slice file_start = f->smallest.user_key();\n      const Slice file_limit = f->largest.user_key();\n      if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {\n        // \"f\" is completely before specified range; skip it\n      } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {\n        // \"f\" is completely after specified range; skip it\n      } else {\n        inputs->push_back(f);\n        if (level == 0) {\n          // Level-0 files may overlap each other.  So check if the newly\n          // added file has expanded the range.  If so, restart search.\n          if (begin != NULL && user_cmp->Compare(file_start, user_begin) < 0) {\n            user_begin = file_start;\n            inputs->clear();\n            i = 0;\n          } else if (end != NULL && user_cmp->Compare(file_limit, user_end) > 0) {\n            user_end = file_limit;\n            inputs->clear();\n            i = 0;\n          }\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "OverlapInLevel",
          "args": [
            "level + 1",
            "&smallest_user_key",
            "&largest_user_key"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "OverlapInLevel",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "500-505",
          "snippet": "bool Version::OverlapInLevel(int level,\n                             const Slice* smallest_user_key,\n                             const Slice* largest_user_key) {\n  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],\n                               smallest_user_key, largest_user_key);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  bool Version::OverlapInLevel(int level,\n                               const Slice* smallest_user_key,\n                               const Slice* largest_user_key) {\n    return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],\n                                 smallest_user_key, largest_user_key);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<ValueType>",
          "args": [
            "0"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  int Version::PickLevelForMemTableOutput(\n      const Slice& smallest_user_key,\n      const Slice& largest_user_key) {\n    int level = 0;\n    if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {\n      // Push to next level if there is no overlap in next level,\n      // and the #bytes overlapping in the level after that are limited.\n      InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);\n      InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));\n      std::vector<FileMetaData*> overlaps;\n      while (level < config::kMaxMemCompactLevel) {\n        if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {\n          break;\n        }\n        if (level + 2 < config::kNumLevels) {\n          // Check that file does not overlap too many grandparent bytes.\n          GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n          const int64_t sum = TotalFileSize(overlaps);\n          if (sum > kMaxGrandParentOverlapBytes) {\n            break;\n          }\n        }\n        level++;\n      }\n    }\n    return level;\n  }\n}"
  },
  {
    "function_name": "OverlapInLevel",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "500-505",
    "snippet": "bool Version::OverlapInLevel(int level,\n                             const Slice* smallest_user_key,\n                             const Slice* largest_user_key) {\n  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],\n                               smallest_user_key, largest_user_key);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SomeFileOverlapsRange",
          "args": [
            "vset_->icmp_",
            "(level > 0)",
            "files_[level]",
            "smallest_user_key",
            "largest_user_key"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "SomeFileOverlapsRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "126-161",
          "snippet": "bool SomeFileOverlapsRange(\n    const InternalKeyComparator& icmp,\n    bool disjoint_sorted_files,\n    const std::vector<FileMetaData*>& files,\n    const Slice* smallest_user_key,\n    const Slice* largest_user_key) {\n  const Comparator* ucmp = icmp.user_comparator();\n  if (!disjoint_sorted_files) {\n    // Need to check against all files\n    for (size_t i = 0; i < files.size(); i++) {\n      const FileMetaData* f = files[i];\n      if (AfterFile(ucmp, smallest_user_key, f) ||\n          BeforeFile(ucmp, largest_user_key, f)) {\n        // No overlap\n      } else {\n        return true;  // Overlap\n      }\n    }\n    return false;\n  }\n\n  // Binary search over file list\n  uint32_t index = 0;\n  if (smallest_user_key != NULL) {\n    // Find the earliest possible internal key for smallest_user_key\n    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);\n    index = FindFile(icmp, files, small.Encode());\n  }\n\n  if (index >= files.size()) {\n    // beginning of range is after all files, so no overlap.\n    return false;\n  }\n\n  return !BeforeFile(ucmp, largest_user_key, files[index]);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nbool SomeFileOverlapsRange(\n    const InternalKeyComparator& icmp,\n    bool disjoint_sorted_files,\n    const std::vector<FileMetaData*>& files,\n    const Slice* smallest_user_key,\n    const Slice* largest_user_key) {\n  const Comparator* ucmp = icmp.user_comparator();\n  if (!disjoint_sorted_files) {\n    // Need to check against all files\n    for (size_t i = 0; i < files.size(); i++) {\n      const FileMetaData* f = files[i];\n      if (AfterFile(ucmp, smallest_user_key, f) ||\n          BeforeFile(ucmp, largest_user_key, f)) {\n        // No overlap\n      } else {\n        return true;  // Overlap\n      }\n    }\n    return false;\n  }\n\n  // Binary search over file list\n  uint32_t index = 0;\n  if (smallest_user_key != NULL) {\n    // Find the earliest possible internal key for smallest_user_key\n    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);\n    index = FindFile(icmp, files, small.Encode());\n  }\n\n  if (index >= files.size()) {\n    // beginning of range is after all files, so no overlap.\n    return false;\n  }\n\n  return !BeforeFile(ucmp, largest_user_key, files[index]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  bool Version::OverlapInLevel(int level,\n                               const Slice* smallest_user_key,\n                               const Slice* largest_user_key) {\n    return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],\n                                 smallest_user_key, largest_user_key);\n  }\n}"
  },
  {
    "function_name": "Unref",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "491-498",
    "snippet": "void Version::Unref() {\n  assert(this != &vset_->dummy_versions_);\n  assert(refs_ >= 1);\n  --refs_;\n  if (refs_ == 0) {\n    delete this;\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "refs_ >= 1"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "this != &vset_->dummy_versions_"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Unref() {\n    assert(this != &vset_->dummy_versions_);\n    assert(refs_ >= 1);\n    --refs_;\n    if (refs_ == 0) {\n      delete this;\n    }\n  }\n}"
  },
  {
    "function_name": "Ref",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "487-489",
    "snippet": "void Version::Ref() {\n  ++refs_;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::Ref() {\n    ++refs_;\n  }\n}"
  },
  {
    "function_name": "RecordReadSample",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "449-485",
    "snippet": "bool Version::RecordReadSample(Slice internal_key) {\n  ParsedInternalKey ikey;\n  if (!ParseInternalKey(internal_key, &ikey)) {\n    return false;\n  }\n\n  struct State {\n    GetStats stats;  // Holds first matching file\n    int matches;\n\n    static bool Match(void* arg, int level, FileMetaData* f) {\n      State* state = reinterpret_cast<State*>(arg);\n      state->matches++;\n      if (state->matches == 1) {\n        // Remember first match.\n        state->stats.seek_file = f;\n        state->stats.seek_file_level = level;\n      }\n      // We can stop iterating once we have a second match.\n      return state->matches < 2;\n    }\n  };\n\n  State state;\n  state.matches = 0;\n  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);\n\n  // Must have at least two matches since we want to merge across\n  // files. But what if we have a single file that contains many\n  // overwrites and deletions?  Should we have another mechanism for\n  // finding such files?\n  if (state.matches >= 2) {\n    // 1MB cost is about 1 seek (see comment in Builder::Apply).\n    return UpdateStats(state.stats);\n  }\n  return false;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UpdateStats",
          "args": [
            "state.stats"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateStats",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "436-447",
          "snippet": "bool Version::UpdateStats(const GetStats& stats) {\n  FileMetaData* f = stats.seek_file;\n  if (f != NULL) {\n    f->allowed_seeks--;\n    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {\n      file_to_compact_ = f;\n      file_to_compact_level_ = stats.seek_file_level;\n      return true;\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  bool Version::UpdateStats(const GetStats& stats) {\n    FileMetaData* f = stats.seek_file;\n    if (f != NULL) {\n      f->allowed_seeks--;\n      if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {\n        file_to_compact_ = f;\n        file_to_compact_level_ = stats.seek_file_level;\n        return true;\n      }\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ForEachOverlapping",
          "args": [
            "ikey.user_key",
            "internal_key",
            "&state",
            "&State::Match"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "ForEachOverlapping",
          "container": "Version",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "292-335",
          "snippet": "void Version::ForEachOverlapping(Slice user_key, Slice internal_key,\n                                 void* arg,\n                                 bool (*func)(void*, int, FileMetaData*)) {\n  // TODO(sanjay): Change Version::Get() to use this function.\n  const Comparator* ucmp = vset_->icmp_.user_comparator();\n\n  // Search level-0 in order from newest to oldest.\n  std::vector<FileMetaData*> tmp;\n  tmp.reserve(files_[0].size());\n  for (uint32_t i = 0; i < files_[0].size(); i++) {\n    FileMetaData* f = files_[0][i];\n    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n      tmp.push_back(f);\n    }\n  }\n  if (!tmp.empty()) {\n    std::sort(tmp.begin(), tmp.end(), NewestFirst);\n    for (uint32_t i = 0; i < tmp.size(); i++) {\n      if (!(*func)(arg, 0, tmp[i])) {\n        return;\n      }\n    }\n  }\n\n  // Search other levels.\n  for (int level = 1; level < config::kNumLevels; level++) {\n    size_t num_files = files_[level].size();\n    if (num_files == 0) continue;\n\n    // Binary search to find earliest index whose largest key >= internal_key.\n    uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);\n    if (index < num_files) {\n      FileMetaData* f = files_[level][index];\n      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {\n        // All of \"f\" is past any data for user_key\n      } else {\n        if (!(*func)(arg, level, f)) {\n          return;\n        }\n      }\n    }\n  }\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::ForEachOverlapping(Slice user_key, Slice internal_key,\n                                   void* arg,\n                                   bool (*func)(void*, int, FileMetaData*)) {\n    // TODO(sanjay): Change Version::Get() to use this function.\n    const Comparator* ucmp = vset_->icmp_.user_comparator();\n  \n    // Search level-0 in order from newest to oldest.\n    std::vector<FileMetaData*> tmp;\n    tmp.reserve(files_[0].size());\n    for (uint32_t i = 0; i < files_[0].size(); i++) {\n      FileMetaData* f = files_[0][i];\n      if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n          ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n        tmp.push_back(f);\n      }\n    }\n    if (!tmp.empty()) {\n      std::sort(tmp.begin(), tmp.end(), NewestFirst);\n      for (uint32_t i = 0; i < tmp.size(); i++) {\n        if (!(*func)(arg, 0, tmp[i])) {\n          return;\n        }\n      }\n    }\n  \n    // Search other levels.\n    for (int level = 1; level < config::kNumLevels; level++) {\n      size_t num_files = files_[level].size();\n      if (num_files == 0) continue;\n  \n      // Binary search to find earliest index whose largest key >= internal_key.\n      uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);\n      if (index < num_files) {\n        FileMetaData* f = files_[level][index];\n        if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {\n          // All of \"f\" is past any data for user_key\n        } else {\n          if (!(*func)(arg, level, f)) {\n            return;\n          }\n        }\n      }\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<State*>",
          "args": [
            "arg"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "internal_key",
            "&ikey"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  bool Version::RecordReadSample(Slice internal_key) {\n    ParsedInternalKey ikey;\n    if (!ParseInternalKey(internal_key, &ikey)) {\n      return false;\n    }\n  \n    struct State {\n      GetStats stats;  // Holds first matching file\n      int matches;\n  \n      static bool Match(void* arg, int level, FileMetaData* f) {\n        State* state = reinterpret_cast<State*>(arg);\n        state->matches++;\n        if (state->matches == 1) {\n          // Remember first match.\n          state->stats.seek_file = f;\n          state->stats.seek_file_level = level;\n        }\n        // We can stop iterating once we have a second match.\n        return state->matches < 2;\n      }\n    };\n  \n    State state;\n    state.matches = 0;\n    ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);\n  \n    // Must have at least two matches since we want to merge across\n    // files. But what if we have a single file that contains many\n    // overwrites and deletions?  Should we have another mechanism for\n    // finding such files?\n    if (state.matches >= 2) {\n      // 1MB cost is about 1 seek (see comment in Builder::Apply).\n      return UpdateStats(state.stats);\n    }\n    return false;\n  }\n}"
  },
  {
    "function_name": "UpdateStats",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "436-447",
    "snippet": "bool Version::UpdateStats(const GetStats& stats) {\n  FileMetaData* f = stats.seek_file;\n  if (f != NULL) {\n    f->allowed_seeks--;\n    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {\n      file_to_compact_ = f;\n      file_to_compact_level_ = stats.seek_file_level;\n      return true;\n    }\n  }\n  return false;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  bool Version::UpdateStats(const GetStats& stats) {\n    FileMetaData* f = stats.seek_file;\n    if (f != NULL) {\n      f->allowed_seeks--;\n      if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {\n        file_to_compact_ = f;\n        file_to_compact_level_ = stats.seek_file_level;\n        return true;\n      }\n    }\n    return false;\n  }\n}"
  },
  {
    "function_name": "Get",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "337-434",
    "snippet": "Status Version::Get(const ReadOptions& options,\n                    const LookupKey& k,\n                    std::string* value,\n                    GetStats* stats) {\n  Slice ikey = k.internal_key();\n  Slice user_key = k.user_key();\n  const Comparator* ucmp = vset_->icmp_.user_comparator();\n  Status s;\n\n  stats->seek_file = NULL;\n  stats->seek_file_level = -1;\n  FileMetaData* last_file_read = NULL;\n  int last_file_read_level = -1;\n\n  // We can search level-by-level since entries never hop across\n  // levels.  Therefore we are guaranteed that if we find data\n  // in an smaller level, later levels are irrelevant.\n  std::vector<FileMetaData*> tmp;\n  FileMetaData* tmp2;\n  for (int level = 0; level < config::kNumLevels; level++) {\n    size_t num_files = files_[level].size();\n    if (num_files == 0) continue;\n\n    // Get the list of files to search in this level\n    FileMetaData* const* files = &files_[level][0];\n    if (level == 0) {\n      // Level-0 files may overlap each other.  Find all files that\n      // overlap user_key and process them in order from newest to oldest.\n      tmp.reserve(num_files);\n      for (uint32_t i = 0; i < num_files; i++) {\n        FileMetaData* f = files[i];\n        if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n            ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n          tmp.push_back(f);\n        }\n      }\n      if (tmp.empty()) continue;\n\n      std::sort(tmp.begin(), tmp.end(), NewestFirst);\n      files = &tmp[0];\n      num_files = tmp.size();\n    } else {\n      // Binary search to find earliest index whose largest key >= ikey.\n      uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);\n      if (index >= num_files) {\n        files = NULL;\n        num_files = 0;\n      } else {\n        tmp2 = files[index];\n        if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {\n          // All of \"tmp2\" is past any data for user_key\n          files = NULL;\n          num_files = 0;\n        } else {\n          files = &tmp2;\n          num_files = 1;\n        }\n      }\n    }\n\n    for (uint32_t i = 0; i < num_files; ++i) {\n      if (last_file_read != NULL && stats->seek_file == NULL) {\n        // We have had more than one seek for this read.  Charge the 1st file.\n        stats->seek_file = last_file_read;\n        stats->seek_file_level = last_file_read_level;\n      }\n\n      FileMetaData* f = files[i];\n      last_file_read = f;\n      last_file_read_level = level;\n\n      Saver saver;\n      saver.state = kNotFound;\n      saver.ucmp = ucmp;\n      saver.user_key = user_key;\n      saver.value = value;\n      s = vset_->table_cache_->Get(options, f->number, f->file_size,\n                                   ikey, &saver, SaveValue);\n      if (!s.ok()) {\n        return s;\n      }\n      switch (saver.state) {\n        case kNotFound:\n          break;      // Keep searching in other files\n        case kFound:\n          return s;\n        case kDeleted:\n          s = Status::NotFound(Slice());  // Use empty error message for speed\n          return s;\n        case kCorrupt:\n          s = Status::Corruption(\"corrupted key for \", user_key);\n          return s;\n      }\n    }\n  }\n\n  return Status::NotFound(Slice());  // Use an empty error message for speed\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::NotFound",
          "args": [
            "Slice()"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "NotFound",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "35-37",
          "snippet": "static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kNotFound, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kNotFound, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Slice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/slice.h",
          "lines": "66-66",
          "snippet": "std::string ToString() const { return std::string(data_, size_); }",
          "includes": [
            "#include <string>",
            "#include <string.h>",
            "#include <stddef.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string>\n#include <string.h>\n#include <stddef.h>\n#include <assert.h>\n\nSlice {\n  std::string ToString() const { return std::string(data_, size_); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"corrupted key for \"",
            "user_key"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "CorruptionReporter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "38-42",
          "snippet": "virtual void Corruption(size_t bytes, const Status& status) {\n    printf(\"corruption: %d bytes; %s\\n\",\n            static_cast<int>(bytes),\n            status.ToString().c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nCorruptionReporter {\n  virtual void Corruption(size_t bytes, const Status& status) {\n      printf(\"corruption: %d bytes; %s\\n\",\n              static_cast<int>(bytes),\n              status.ToString().c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vset_->table_cache_->Get",
          "args": [
            "options",
            "f->number",
            "f->file_size",
            "ikey",
            "&saver",
            "SaveValue"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "TableCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/table_cache.cc",
          "lines": "105-119",
          "snippet": "Status TableCache::Get(const ReadOptions& options,\n                       uint64_t file_number,\n                       uint64_t file_size,\n                       const Slice& k,\n                       void* arg,\n                       void (*saver)(void*, const Slice&, const Slice&)) {\n  Cache::Handle* handle = NULL;\n  Status s = FindTable(file_number, file_size, &handle);\n  if (s.ok()) {\n    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;\n    s = t->InternalGet(options, k, arg, saver);\n    cache_->Release(handle);\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/table_cache.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"db/filename.h\"\n#include \"db/table_cache.h\"\n\nTableCache {\n  Status TableCache::Get(const ReadOptions& options,\n                         uint64_t file_number,\n                         uint64_t file_size,\n                         const Slice& k,\n                         void* arg,\n                         void (*saver)(void*, const Slice&, const Slice&)) {\n    Cache::Handle* handle = NULL;\n    Status s = FindTable(file_number, file_size, &handle);\n    if (s.ok()) {\n      Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;\n      s = t->InternalGet(options, k, arg, saver);\n      cache_->Release(handle);\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ucmp->Compare",
          "args": [
            "user_key",
            "tmp2->smallest.user_key()"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp2->smallest.user_key",
          "args": [],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFile",
          "args": [
            "vset_->icmp_",
            "files_[level]",
            "ikey"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "FindFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "91-110",
          "snippet": "int FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nint FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.size",
          "args": [],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "tmp.begin()",
            "tmp.end()",
            "NewestFirst"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.end",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.begin",
          "args": [],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.empty",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.push_back",
          "args": [
            "f"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.reserve",
          "args": [
            "num_files"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vset_->icmp_.user_comparator",
          "args": [],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k.internal_key",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "internal_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "201-201",
          "snippet": "Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  Status Version::Get(const ReadOptions& options,\n                      const LookupKey& k,\n                      std::string* value,\n                      GetStats* stats) {\n    Slice ikey = k.internal_key();\n    Slice user_key = k.user_key();\n    const Comparator* ucmp = vset_->icmp_.user_comparator();\n    Status s;\n  \n    stats->seek_file = NULL;\n    stats->seek_file_level = -1;\n    FileMetaData* last_file_read = NULL;\n    int last_file_read_level = -1;\n  \n    // We can search level-by-level since entries never hop across\n    // levels.  Therefore we are guaranteed that if we find data\n    // in an smaller level, later levels are irrelevant.\n    std::vector<FileMetaData*> tmp;\n    FileMetaData* tmp2;\n    for (int level = 0; level < config::kNumLevels; level++) {\n      size_t num_files = files_[level].size();\n      if (num_files == 0) continue;\n  \n      // Get the list of files to search in this level\n      FileMetaData* const* files = &files_[level][0];\n      if (level == 0) {\n        // Level-0 files may overlap each other.  Find all files that\n        // overlap user_key and process them in order from newest to oldest.\n        tmp.reserve(num_files);\n        for (uint32_t i = 0; i < num_files; i++) {\n          FileMetaData* f = files[i];\n          if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n              ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n            tmp.push_back(f);\n          }\n        }\n        if (tmp.empty()) continue;\n  \n        std::sort(tmp.begin(), tmp.end(), NewestFirst);\n        files = &tmp[0];\n        num_files = tmp.size();\n      } else {\n        // Binary search to find earliest index whose largest key >= ikey.\n        uint32_t index = FindFile(vset_->icmp_, files_[level], ikey);\n        if (index >= num_files) {\n          files = NULL;\n          num_files = 0;\n        } else {\n          tmp2 = files[index];\n          if (ucmp->Compare(user_key, tmp2->smallest.user_key()) < 0) {\n            // All of \"tmp2\" is past any data for user_key\n            files = NULL;\n            num_files = 0;\n          } else {\n            files = &tmp2;\n            num_files = 1;\n          }\n        }\n      }\n  \n      for (uint32_t i = 0; i < num_files; ++i) {\n        if (last_file_read != NULL && stats->seek_file == NULL) {\n          // We have had more than one seek for this read.  Charge the 1st file.\n          stats->seek_file = last_file_read;\n          stats->seek_file_level = last_file_read_level;\n        }\n  \n        FileMetaData* f = files[i];\n        last_file_read = f;\n        last_file_read_level = level;\n  \n        Saver saver;\n        saver.state = kNotFound;\n        saver.ucmp = ucmp;\n        saver.user_key = user_key;\n        saver.value = value;\n        s = vset_->table_cache_->Get(options, f->number, f->file_size,\n                                     ikey, &saver, SaveValue);\n        if (!s.ok()) {\n          return s;\n        }\n        switch (saver.state) {\n          case kNotFound:\n            break;      // Keep searching in other files\n          case kFound:\n            return s;\n          case kDeleted:\n            s = Status::NotFound(Slice());  // Use empty error message for speed\n            return s;\n          case kCorrupt:\n            s = Status::Corruption(\"corrupted key for \", user_key);\n            return s;\n        }\n      }\n    }\n  \n    return Status::NotFound(Slice());  // Use an empty error message for speed\n  }\n}"
  },
  {
    "function_name": "ForEachOverlapping",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "292-335",
    "snippet": "void Version::ForEachOverlapping(Slice user_key, Slice internal_key,\n                                 void* arg,\n                                 bool (*func)(void*, int, FileMetaData*)) {\n  // TODO(sanjay): Change Version::Get() to use this function.\n  const Comparator* ucmp = vset_->icmp_.user_comparator();\n\n  // Search level-0 in order from newest to oldest.\n  std::vector<FileMetaData*> tmp;\n  tmp.reserve(files_[0].size());\n  for (uint32_t i = 0; i < files_[0].size(); i++) {\n    FileMetaData* f = files_[0][i];\n    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n      tmp.push_back(f);\n    }\n  }\n  if (!tmp.empty()) {\n    std::sort(tmp.begin(), tmp.end(), NewestFirst);\n    for (uint32_t i = 0; i < tmp.size(); i++) {\n      if (!(*func)(arg, 0, tmp[i])) {\n        return;\n      }\n    }\n  }\n\n  // Search other levels.\n  for (int level = 1; level < config::kNumLevels; level++) {\n    size_t num_files = files_[level].size();\n    if (num_files == 0) continue;\n\n    // Binary search to find earliest index whose largest key >= internal_key.\n    uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);\n    if (index < num_files) {\n      FileMetaData* f = files_[level][index];\n      if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {\n        // All of \"f\" is past any data for user_key\n      } else {\n        if (!(*func)(arg, level, f)) {\n          return;\n        }\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg",
            "level",
            "f"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ucmp->Compare",
          "args": [
            "user_key",
            "f->smallest.user_key()"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->smallest.user_key",
          "args": [],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFile",
          "args": [
            "vset_->icmp_",
            "files_[level]",
            "internal_key"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "FindFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "91-110",
          "snippet": "int FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nint FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}"
        }
      },
      {
        "call_info": {
          "callee": "files_[level].size",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "arg",
            "0",
            "tmp[i]"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::sort",
          "args": [
            "tmp.begin()",
            "tmp.end()",
            "NewestFirst"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.end",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.begin",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.empty",
          "args": [],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmp.push_back",
          "args": [
            "f"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp.reserve",
          "args": [
            "files_[0].size()"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vset_->icmp_.user_comparator",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::ForEachOverlapping(Slice user_key, Slice internal_key,\n                                   void* arg,\n                                   bool (*func)(void*, int, FileMetaData*)) {\n    // TODO(sanjay): Change Version::Get() to use this function.\n    const Comparator* ucmp = vset_->icmp_.user_comparator();\n  \n    // Search level-0 in order from newest to oldest.\n    std::vector<FileMetaData*> tmp;\n    tmp.reserve(files_[0].size());\n    for (uint32_t i = 0; i < files_[0].size(); i++) {\n      FileMetaData* f = files_[0][i];\n      if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n          ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n        tmp.push_back(f);\n      }\n    }\n    if (!tmp.empty()) {\n      std::sort(tmp.begin(), tmp.end(), NewestFirst);\n      for (uint32_t i = 0; i < tmp.size(); i++) {\n        if (!(*func)(arg, 0, tmp[i])) {\n          return;\n        }\n      }\n    }\n  \n    // Search other levels.\n    for (int level = 1; level < config::kNumLevels; level++) {\n      size_t num_files = files_[level].size();\n      if (num_files == 0) continue;\n  \n      // Binary search to find earliest index whose largest key >= internal_key.\n      uint32_t index = FindFile(vset_->icmp_, files_[level], internal_key);\n      if (index < num_files) {\n        FileMetaData* f = files_[level][index];\n        if (ucmp->Compare(user_key, f->smallest.user_key()) < 0) {\n          // All of \"f\" is past any data for user_key\n        } else {\n          if (!(*func)(arg, level, f)) {\n            return;\n          }\n        }\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "NewestFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "288-290",
    "snippet": "static bool NewestFirst(FileMetaData* a, FileMetaData* b) {\n  return a->number > b->number;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic bool NewestFirst(FileMetaData* a, FileMetaData* b) {\n  return a->number > b->number;\n}"
  },
  {
    "function_name": "SaveValue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "273-286",
    "snippet": "static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {\n  Saver* s = reinterpret_cast<Saver*>(arg);\n  ParsedInternalKey parsed_key;\n  if (!ParseInternalKey(ikey, &parsed_key)) {\n    s->state = kCorrupt;\n  } else {\n    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {\n      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;\n      if (s->state == kFound) {\n        s->value->assign(v.data(), v.size());\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "s->value->assign",
          "args": [
            "v.data()",
            "v.size()"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v.size",
          "args": [],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "TransactionTablePriv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "170-173",
          "snippet": "int size()\n    {\n        return cachedWallet.size();\n    }",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTablePriv {\n  int size()\n      {\n          return cachedWallet.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.data",
          "args": [],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s->ucmp->Compare",
          "args": [
            "parsed_key.user_key",
            "s->user_key"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "BytewiseComparatorImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/comparator.cc",
          "lines": "25-27",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return a.compare(b);\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdint.h>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/comparator.h\"\n#include <stdint.h>\n#include <algorithm>\n\nBytewiseComparatorImpl {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return a.compare(b);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "ikey",
            "&parsed_key"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<Saver*>",
          "args": [
            "arg"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic void SaveValue(void* arg, const Slice& ikey, const Slice& v) {\n  Saver* s = reinterpret_cast<Saver*>(arg);\n  ParsedInternalKey parsed_key;\n  if (!ParseInternalKey(ikey, &parsed_key)) {\n    s->state = kCorrupt;\n  } else {\n    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {\n      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;\n      if (s->state == kFound) {\n        s->value->assign(v.data(), v.size());\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "AddIterators",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "239-256",
    "snippet": "void Version::AddIterators(const ReadOptions& options,\n                           std::vector<Iterator*>* iters) {\n  // Merge all level zero files together since they may overlap\n  for (size_t i = 0; i < files_[0].size(); i++) {\n    iters->push_back(\n        vset_->table_cache_->NewIterator(\n            options, files_[0][i]->number, files_[0][i]->file_size));\n  }\n\n  // For levels > 0, we can use a concatenating iterator that sequentially\n  // walks through the non-overlapping files in the level, opening them\n  // lazily.\n  for (int level = 1; level < config::kNumLevels; level++) {\n    if (!files_[level].empty()) {\n      iters->push_back(NewConcatenatingIterator(options, level));\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iters->push_back",
          "args": [
            "NewConcatenatingIterator(options, level)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NewConcatenatingIterator",
          "args": [
            "options",
            "level"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_[level].empty",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iters->push_back",
          "args": [
            "vset_->table_cache_->NewIterator(\n            options, files_[0][i]->number, files_[0][i]->file_size)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vset_->table_cache_->NewIterator",
          "args": [
            "options",
            "files_[0][i]->number",
            "files_[0][i]->file_size"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_[0].size",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  void Version::AddIterators(const ReadOptions& options,\n                             std::vector<Iterator*>* iters) {\n    // Merge all level zero files together since they may overlap\n    for (size_t i = 0; i < files_[0].size(); i++) {\n      iters->push_back(\n          vset_->table_cache_->NewIterator(\n              options, files_[0][i]->number, files_[0][i]->file_size));\n    }\n  \n    // For levels > 0, we can use a concatenating iterator that sequentially\n    // walks through the non-overlapping files in the level, opening them\n    // lazily.\n    for (int level = 1; level < config::kNumLevels; level++) {\n      if (!files_[level].empty()) {\n        iters->push_back(NewConcatenatingIterator(options, level));\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "208-208",
    "snippet": "virtual Status status() const { return Status::OK(); }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::OK",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "OK",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "32-32",
          "snippet": "static Status OK() { return Status(); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status OK() { return Status(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual Status status() const { return Status::OK(); }"
  },
  {
    "function_name": "value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "202-207",
    "snippet": "Slice value() const {\n    assert(Valid());\n    EncodeFixed64(value_buf_, (*flist_)[index_]->number);\n    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);\n    return Slice(value_buf_, sizeof(value_buf_));\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "value_buf_",
            "sizeof(value_buf_)"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeFixed64",
          "args": [
            "value_buf_+8",
            "(*flist_)[index_]->file_size"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeFixed64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "20-33",
          "snippet": "void EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nvoid EncodeFixed64(char* buf, uint64_t value) {\n  if (port::kLittleEndian) {\n    memcpy(buf, &value, sizeof(value));\n  } else {\n    buf[0] = value & 0xff;\n    buf[1] = (value >> 8) & 0xff;\n    buf[2] = (value >> 16) & 0xff;\n    buf[3] = (value >> 24) & 0xff;\n    buf[4] = (value >> 32) & 0xff;\n    buf[5] = (value >> 40) & 0xff;\n    buf[6] = (value >> 48) & 0xff;\n    buf[7] = (value >> 56) & 0xff;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "176-178",
          "snippet": "virtual bool Valid() const {\n    return index_ < flist_->size();\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual bool Valid() const {\n    return index_ < flist_->size();\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nSlice value() const {\n    assert(Valid());\n    EncodeFixed64(value_buf_, (*flist_)[index_]->number);\n    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);\n    return Slice(value_buf_, sizeof(value_buf_));\n  }"
  },
  {
    "function_name": "key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "198-201",
    "snippet": "Slice key() const {\n    assert(Valid());\n    return (*flist_)[index_]->largest.Encode();\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "176-178",
          "snippet": "virtual bool Valid() const {\n    return index_ < flist_->size();\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual bool Valid() const {\n    return index_ < flist_->size();\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nSlice key() const {\n    assert(Valid());\n    return (*flist_)[index_]->largest.Encode();\n  }"
  },
  {
    "function_name": "Prev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "190-197",
    "snippet": "virtual void Prev() {\n    assert(Valid());\n    if (index_ == 0) {\n      index_ = flist_->size();  // Marks as invalid\n    } else {\n      index_--;\n    }\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flist_->size",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "176-178",
          "snippet": "virtual bool Valid() const {\n    return index_ < flist_->size();\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual bool Valid() const {\n    return index_ < flist_->size();\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual void Prev() {\n    assert(Valid());\n    if (index_ == 0) {\n      index_ = flist_->size();  // Marks as invalid\n    } else {\n      index_--;\n    }\n  }"
  },
  {
    "function_name": "Next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "186-189",
    "snippet": "virtual void Next() {\n    assert(Valid());\n    index_++;\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "Valid()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Valid",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "176-178",
          "snippet": "virtual bool Valid() const {\n    return index_ < flist_->size();\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual bool Valid() const {\n    return index_ < flist_->size();\n  }"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual void Next() {\n    assert(Valid());\n    index_++;\n  }"
  },
  {
    "function_name": "SeekToLast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "183-185",
    "snippet": "virtual void SeekToLast() {\n    index_ = flist_->empty() ? 0 : flist_->size() - 1;\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flist_->size",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "flist_->empty",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "SnapshotList",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/snapshot.h",
          "lines": "37-37",
          "snippet": "bool empty() const { return list_.next_ == &list_; }",
          "includes": [
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/db.h\"\n\nSnapshotList {\n  bool empty() const { return list_.next_ == &list_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual void SeekToLast() {\n    index_ = flist_->empty() ? 0 : flist_->size() - 1;\n  }"
  },
  {
    "function_name": "SeekToFirst",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "182-182",
    "snippet": "virtual void SeekToFirst() { index_ = 0; }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual void SeekToFirst() { index_ = 0; }"
  },
  {
    "function_name": "Seek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "179-181",
    "snippet": "virtual void Seek(const Slice& target) {\n    index_ = FindFile(icmp_, *flist_, target);\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindFile",
          "args": [
            "icmp_",
            "*flist_",
            "target"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "FindFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "91-110",
          "snippet": "int FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nint FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual void Seek(const Slice& target) {\n    index_ = FindFile(icmp_, *flist_, target);\n  }"
  },
  {
    "function_name": "Valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "176-178",
    "snippet": "virtual bool Valid() const {\n    return index_ < flist_->size();\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flist_->size",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nvirtual bool Valid() const {\n    return index_ < flist_->size();\n  }"
  },
  {
    "function_name": "LevelFileNumIterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "170-175",
    "snippet": "LevelFileNumIterator(const InternalKeyComparator& icmp,\n                       const std::vector<FileMetaData*>* flist)\n      : icmp_(icmp),\n        flist_(flist),\n        index_(flist->size()) {        // Marks as invalid\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flist->size",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nLevelFileNumIterator(const InternalKeyComparator& icmp,\n                       const std::vector<FileMetaData*>* flist)\n      : icmp_(icmp),\n        flist_(flist),\n        index_(flist->size()) {        // Marks as invalid\n  }"
  },
  {
    "function_name": "SomeFileOverlapsRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "126-161",
    "snippet": "bool SomeFileOverlapsRange(\n    const InternalKeyComparator& icmp,\n    bool disjoint_sorted_files,\n    const std::vector<FileMetaData*>& files,\n    const Slice* smallest_user_key,\n    const Slice* largest_user_key) {\n  const Comparator* ucmp = icmp.user_comparator();\n  if (!disjoint_sorted_files) {\n    // Need to check against all files\n    for (size_t i = 0; i < files.size(); i++) {\n      const FileMetaData* f = files[i];\n      if (AfterFile(ucmp, smallest_user_key, f) ||\n          BeforeFile(ucmp, largest_user_key, f)) {\n        // No overlap\n      } else {\n        return true;  // Overlap\n      }\n    }\n    return false;\n  }\n\n  // Binary search over file list\n  uint32_t index = 0;\n  if (smallest_user_key != NULL) {\n    // Find the earliest possible internal key for smallest_user_key\n    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);\n    index = FindFile(icmp, files, small.Encode());\n  }\n\n  if (index >= files.size()) {\n    // beginning of range is after all files, so no overlap.\n    return false;\n  }\n\n  return !BeforeFile(ucmp, largest_user_key, files[index]);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BeforeFile",
          "args": [
            "ucmp",
            "largest_user_key",
            "files[index]"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "BeforeFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "119-124",
          "snippet": "static bool BeforeFile(const Comparator* ucmp,\n                       const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs after all keys and is therefore never before *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic bool BeforeFile(const Comparator* ucmp,\n                       const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs after all keys and is therefore never before *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FindFile",
          "args": [
            "icmp",
            "files",
            "small.Encode()"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "FindFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "91-110",
          "snippet": "int FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nint FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}"
        }
      },
      {
        "call_info": {
          "callee": "small.Encode",
          "args": [],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "154-157",
          "snippet": "Slice Encode() const {\n    assert(!rep_.empty());\n    return rep_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  Slice Encode() const {\n      assert(!rep_.empty());\n      return rep_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AfterFile",
          "args": [
            "ucmp",
            "smallest_user_key",
            "f"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "AfterFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
          "lines": "112-117",
          "snippet": "static bool AfterFile(const Comparator* ucmp,\n                      const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs before all keys and is therefore never after *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->largest.user_key()) > 0);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <algorithm>",
            "#include \"db/version_set.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic bool AfterFile(const Comparator* ucmp,\n                      const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs before all keys and is therefore never after *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->largest.user_key()) > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "icmp.user_comparator",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nbool SomeFileOverlapsRange(\n    const InternalKeyComparator& icmp,\n    bool disjoint_sorted_files,\n    const std::vector<FileMetaData*>& files,\n    const Slice* smallest_user_key,\n    const Slice* largest_user_key) {\n  const Comparator* ucmp = icmp.user_comparator();\n  if (!disjoint_sorted_files) {\n    // Need to check against all files\n    for (size_t i = 0; i < files.size(); i++) {\n      const FileMetaData* f = files[i];\n      if (AfterFile(ucmp, smallest_user_key, f) ||\n          BeforeFile(ucmp, largest_user_key, f)) {\n        // No overlap\n      } else {\n        return true;  // Overlap\n      }\n    }\n    return false;\n  }\n\n  // Binary search over file list\n  uint32_t index = 0;\n  if (smallest_user_key != NULL) {\n    // Find the earliest possible internal key for smallest_user_key\n    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);\n    index = FindFile(icmp, files, small.Encode());\n  }\n\n  if (index >= files.size()) {\n    // beginning of range is after all files, so no overlap.\n    return false;\n  }\n\n  return !BeforeFile(ucmp, largest_user_key, files[index]);\n}"
  },
  {
    "function_name": "BeforeFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "119-124",
    "snippet": "static bool BeforeFile(const Comparator* ucmp,\n                       const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs after all keys and is therefore never before *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ucmp->Compare",
          "args": [
            "*user_key",
            "f->smallest.user_key()"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->smallest.user_key",
          "args": [],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic bool BeforeFile(const Comparator* ucmp,\n                       const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs after all keys and is therefore never before *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);\n}"
  },
  {
    "function_name": "AfterFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "112-117",
    "snippet": "static bool AfterFile(const Comparator* ucmp,\n                      const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs before all keys and is therefore never after *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->largest.user_key()) > 0);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ucmp->Compare",
          "args": [
            "*user_key",
            "f->largest.user_key()"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->largest.user_key",
          "args": [],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "user_key",
          "container": "LookupKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "204-204",
          "snippet": "Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nLookupKey {\n  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic bool AfterFile(const Comparator* ucmp,\n                      const Slice* user_key, const FileMetaData* f) {\n  // NULL user_key occurs before all keys and is therefore never after *f\n  return (user_key != NULL &&\n          ucmp->Compare(*user_key, f->largest.user_key()) > 0);\n}"
  },
  {
    "function_name": "FindFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "91-110",
    "snippet": "int FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "icmp.InternalKeyComparator::Compare",
          "args": [
            "f->largest.Encode()",
            "key"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "InternalKeyComparator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "171-174",
          "snippet": "inline int InternalKeyComparator::Compare(\n    const InternalKey& a, const InternalKey& b) const {\n  return Compare(a.Encode(), b.Encode());\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKeyComparator {\n  inline int InternalKeyComparator::Compare(\n      const InternalKey& a, const InternalKey& b) const {\n    return Compare(a.Encode(), b.Encode());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "f->largest.Encode",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "Encode",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "154-157",
          "snippet": "Slice Encode() const {\n    assert(!rep_.empty());\n    return rep_;\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  Slice Encode() const {\n      assert(!rep_.empty());\n      return rep_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nint FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files,\n             const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at \"mid.largest\" is < \"target\".  Therefore all\n      // files at or before \"mid\" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at \"mid.largest\" is >= \"target\".  Therefore all files\n      // after \"mid\" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}"
  },
  {
    "function_name": "~Version",
    "container": "Version",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "71-89",
    "snippet": "Version::~Version() {\n  assert(refs_ == 0);\n\n  // Remove from linked list\n  prev_->next_ = next_;\n  next_->prev_ = prev_;\n\n  // Drop references to files\n  for (int level = 0; level < config::kNumLevels; level++) {\n    for (size_t i = 0; i < files_[level].size(); i++) {\n      FileMetaData* f = files_[level][i];\n      assert(f->refs > 0);\n      f->refs--;\n      if (f->refs <= 0) {\n        delete f;\n      }\n    }\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "f->refs > 0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "files_[level].size",
          "args": [],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "refs_ == 0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nVersion {\n  Version::~Version() {\n    assert(refs_ == 0);\n  \n    // Remove from linked list\n    prev_->next_ = next_;\n    next_->prev_ = prev_;\n  \n    // Drop references to files\n    for (int level = 0; level < config::kNumLevels; level++) {\n      for (size_t i = 0; i < files_[level].size(); i++) {\n        FileMetaData* f = files_[level][i];\n        assert(f->refs > 0);\n        f->refs--;\n        if (f->refs <= 0) {\n          delete f;\n        }\n      }\n    }\n  }\n}"
  },
  {
    "function_name": "IntSetToString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "58-68",
    "snippet": "std::string IntSetToString(const std::set<uint64_t>& s) {\n  std::string result = \"{\";\n  for (std::set<uint64_t>::const_iterator it = s.begin();\n       it != s.end();\n       ++it) {\n    result += (result.size() > 1) ? \",\" : \"\";\n    result += NumberToString(*it);\n  }\n  result += \"}\";\n  return result;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "NumberToString",
          "args": [
            "*it"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "NumberToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "36-40",
          "snippet": "std::string NumberToString(uint64_t num) {\n  std::string r;\n  AppendNumberTo(&r, num);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string NumberToString(uint64_t num) {\n  std::string r;\n  AppendNumberTo(&r, num);\n  return r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "result.size",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.end",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "mruset",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/mruset.h",
          "lines": "28-28",
          "snippet": "iterator end() const { return set.end(); }",
          "includes": [
            "#include <deque>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <set>\n\nmruset {\n  iterator end() const { return set.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.begin",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "mruset",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/mruset.h",
          "lines": "27-27",
          "snippet": "iterator begin() const { return set.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <set>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <set>\n\nmruset {\n  iterator begin() const { return set.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstd::string IntSetToString(const std::set<uint64_t>& s) {\n  std::string result = \"{\";\n  for (std::set<uint64_t>::const_iterator it = s.begin();\n       it != s.end();\n       ++it) {\n    result += (result.size() > 1) ? \",\" : \"\";\n    result += NumberToString(*it);\n  }\n  result += \"}\";\n  return result;\n}"
  },
  {
    "function_name": "TotalFileSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "49-55",
    "snippet": "static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "files.size",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n  int64_t sum = 0;\n  for (size_t i = 0; i < files.size(); i++) {\n    sum += files[i]->file_size;\n  }\n  return sum;\n}"
  },
  {
    "function_name": "MaxFileSizeForLevel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "45-47",
    "snippet": "static uint64_t MaxFileSizeForLevel(int level) {\n  return kTargetFileSize;  // We could vary per level to reduce number of files?\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic uint64_t MaxFileSizeForLevel(int level) {\n  return kTargetFileSize;  // We could vary per level to reduce number of files?\n}"
  },
  {
    "function_name": "MaxBytesForLevel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_set.cc",
    "lines": "34-43",
    "snippet": "static double MaxBytesForLevel(int level) {\n  // Note: the result for level zero is not really used since we set\n  // the level-0 compaction threshold based on number of files.\n  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n  while (level > 1) {\n    result *= 10;\n    level--;\n  }\n  return result;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"util/coding.h\"",
      "#include \"table/two_level_iterator.h\"",
      "#include \"table/merger.h\"",
      "#include \"leveldb/table_builder.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/table_cache.h\"",
      "#include \"db/memtable.h\"",
      "#include \"db/log_writer.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include <stdio.h>",
      "#include <algorithm>",
      "#include \"db/version_set.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/env.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <algorithm>\n#include \"db/version_set.h\"\n\nstatic double MaxBytesForLevel(int level) {\n  // Note: the result for level zero is not really used since we set\n  // the level-0 compaction threshold based on number of files.\n  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n  while (level > 1) {\n    result *= 10;\n    level--;\n  }\n  return result;\n}"
  }
]