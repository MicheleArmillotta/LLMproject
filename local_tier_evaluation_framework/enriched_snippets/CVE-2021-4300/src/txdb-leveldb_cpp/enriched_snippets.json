[
  {
    "function_name": "LoadBlockIndex",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "327-571",
    "snippet": "bool CTxDB::LoadBlockIndex()\n{\n    if (mapBlockIndex.size() > 0) {\n        // Already loaded once in this session. It can happen during migration\n        // from BDB.\n        return true;\n    }\n    // The block index is an in-memory structure that maps hashes to on-disk\n    // locations where the contents of the block can be found. Here, we scan it\n    // out of the DB and into mapBlockIndex.\n    leveldb::Iterator *iterator = pdb->NewIterator(leveldb::ReadOptions());\n    // Seek to start key.\n    CDataStream ssStartKey(SER_DISK, CLIENT_VERSION);\n    ssStartKey << make_pair(string(\"blockindex\"), uint256(0));\n    iterator->Seek(ssStartKey.str());\n    // Now read each entry.\n    while (iterator->Valid())\n    {\n        // Unpack keys and values.\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.write(iterator->key().data(), iterator->key().size());\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.write(iterator->value().data(), iterator->value().size());\n        string strType;\n        ssKey >> strType;\n        // Did we reach the end of the data to read?\n        if (fRequestShutdown || strType != \"blockindex\")\n            break;\n        CDiskBlockIndex diskindex;\n        ssValue >> diskindex;\n\n        uint256 blockHash = diskindex.GetBlockHash();\n\n        // Construct block index object\n        CBlockIndex* pindexNew    = InsertBlockIndex(blockHash);\n        pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n        pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n        pindexNew->nFile          = diskindex.nFile;\n        pindexNew->nBlockPos      = diskindex.nBlockPos;\n        pindexNew->nHeight        = diskindex.nHeight;\n        pindexNew->nMint          = diskindex.nMint;\n        pindexNew->nMoneySupply   = diskindex.nMoneySupply;\n        pindexNew->nFlags         = diskindex.nFlags;\n        pindexNew->nStakeModifier = diskindex.nStakeModifier;\n        pindexNew->prevoutStake   = diskindex.prevoutStake;\n        pindexNew->nStakeTime     = diskindex.nStakeTime;\n        pindexNew->hashProofOfStake = diskindex.hashProofOfStake;\n        pindexNew->nVersion       = diskindex.nVersion;\n        pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n        pindexNew->nTime          = diskindex.nTime;\n        pindexNew->nBits          = diskindex.nBits;\n        pindexNew->nNonce         = diskindex.nNonce;\n\n        // Watch for genesis block\n        if (pindexGenesisBlock == NULL && blockHash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n            pindexGenesisBlock = pindexNew;\n\n        if (!pindexNew->CheckIndex()) {\n            delete iterator;\n            return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n        }\n\n        // NovaCoin: build setStakeSeen\n        if (pindexNew->IsProofOfStake())\n            setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n\n        iterator->Next();\n    }\n    delete iterator;\n\n    if (fRequestShutdown)\n        return true;\n\n    // Calculate nChainTrust\n    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n    vSortedByHeight.reserve(mapBlockIndex.size());\n    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n    {\n        CBlockIndex* pindex = item.second;\n        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n    }\n    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n    {\n        CBlockIndex* pindex = item.second;\n        pindex->nChainTrust = (pindex->pprev ? pindex->pprev->nChainTrust : 0) + pindex->GetBlockTrust();\n        // NovaCoin: calculate stake modifier checksum\n        pindex->nStakeModifierChecksum = GetStakeModifierChecksum(pindex);\n        if (!CheckStakeModifierCheckpoints(pindex->nHeight, pindex->nStakeModifierChecksum))\n            return error(\"CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindex->nHeight, pindex->nStakeModifier);\n    }\n\n    // Load hashBestChain pointer to end of best chain\n    if (!ReadHashBestChain(hashBestChain))\n    {\n        if (pindexGenesisBlock == NULL)\n            return true;\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n    }\n    if (!mapBlockIndex.count(hashBestChain))\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n    pindexBest = mapBlockIndex[hashBestChain];\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexBest->nChainTrust;\n\n    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, CBigNum(nBestChainTrust).ToString().c_str(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    // NovaCoin: load hashSyncCheckpoint\n    if (!ReadSyncCheckpoint(Checkpoints::hashSyncCheckpoint))\n        return error(\"CTxDB::LoadBlockIndex() : hashSyncCheckpoint not loaded\");\n    printf(\"LoadBlockIndex(): synchronized checkpoint %s\\n\", Checkpoints::hashSyncCheckpoint.ToString().c_str());\n\n    // Load bnBestInvalidTrust, OK if it doesn't exist\n    CBigNum bnBestInvalidTrust;\n    ReadBestInvalidTrust(bnBestInvalidTrust);\n    nBestInvalidTrust = bnBestInvalidTrust.getuint256();\n\n    // Verify blocks in the best chain\n    int nCheckLevel = GetArg(\"-checklevel\", 1);\n    int nCheckDepth = GetArg( \"-checkblocks\", 500);\n    if (nCheckDepth == 0)\n        nCheckDepth = 1000000000; // suffices until the year 19000\n    if (nCheckDepth > nBestHeight)\n        nCheckDepth = nBestHeight;\n    printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n    CBlockIndex* pindexFork = NULL;\n    map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n    {\n        if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n            break;\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        // check level 1: verify block validity\n        if((nCheckLevel > 0) && !block.CheckBlock()) {\n            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n            pindexFork = pindex->pprev;\n        }\n        // check level 2: verify transaction index validity\n        if (nCheckLevel>1)\n        {\n            pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n            mapBlockPos[pos] = pindex;\n            BOOST_FOREACH(const CTransaction &tx, block.vtx)\n            {\n                uint256 hashTx = tx.GetHash();\n                CTxIndex txindex;\n                if (ReadTxIndex(hashTx, txindex))\n                {\n                    // check level 3: checker transaction hashes\n                    if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                    {\n                        // either an error or a duplicate transaction\n                        CTransaction txFound;\n                        if (!txFound.ReadFromDisk(txindex.pos))\n                        {\n                            printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n                            pindexFork = pindex->pprev;\n                        }\n                        else\n                            if (txFound.GetHash() != hashTx) // not a duplicate tx\n                            {\n                                printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n                                pindexFork = pindex->pprev;\n                            }\n                    }\n                    // check level 4: check whether spent txouts were spent within the main chain\n                    unsigned int nOutput = 0;\n                    if (nCheckLevel>3)\n                    {\n                        BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n                        {\n                            if (!txpos.IsNull())\n                            {\n                                pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n                                if (!mapBlockPos.count(posFind))\n                                {\n                                    printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                    pindexFork = pindex->pprev;\n                                }\n                                // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                if (nCheckLevel>5)\n                                {\n                                    CTransaction txSpend;\n                                    if (!txSpend.ReadFromDisk(txpos))\n                                    {\n                                        printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else if (!txSpend.CheckTransaction())\n                                    {\n                                        printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else\n                                    {\n                                        bool fFound = false;\n                                        BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n                                            if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n                                                fFound = true;\n                                        if (!fFound)\n                                        {\n                                            printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n                                            pindexFork = pindex->pprev;\n                                        }\n                                    }\n                                }\n                            }\n                            nOutput++;\n                        }\n                    }\n                }\n                // check level 5: check whether all prevouts are marked spent\n                if (nCheckLevel>4)\n                {\n                     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n                     {\n                          CTxIndex txindex;\n                          if (ReadTxIndex(txin.prevout.hash, txindex))\n                              if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n                              {\n                                  printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n                                  pindexFork = pindex->pprev;\n                              }\n                     }\n                }\n            }\n        }\n    }\n    if (pindexFork && !fRequestShutdown)\n    {\n        // Reorg back to the fork\n        printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n        CBlock block;\n        if (!block.ReadFromDisk(pindexFork))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        CTxDB txdb;\n        block.SetBestChain(txdb, pindexFork);\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [
      "leveldb::DB *txdb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block.SetBestChain",
          "args": [
            "txdb",
            "pindexFork"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChain",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1854-1953",
          "snippet": "bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexGenesisBlock = NULL;",
            "int nBestHeight = -1;",
            "uint256 nBestChainTrust = 0;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;",
            "int64_t nTimeBestReceived = 0;",
            "static CBlockIndex* pblockindexFBBHLast;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nuint256 nBestChainTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\nstatic CBlockIndex* pblockindexFBBHLast;\n\nCBlock {\n  bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      if (!txdb.TxnBegin())\n          return error(\"SetBestChain() : TxnBegin failed\");\n  \n      if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n      {\n          txdb.WriteHashBestChain(hash);\n          if (!txdb.TxnCommit())\n              return error(\"SetBestChain() : TxnCommit failed\");\n          pindexGenesisBlock = pindexNew;\n      }\n      else if (hashPrevBlock == hashBestChain)\n      {\n          if (!SetBestChainInner(txdb, pindexNew))\n              return error(\"SetBestChain() : SetBestChainInner failed\");\n      }\n      else\n      {\n          // the first block in the new chain that will cause it to become the new best chain\n          CBlockIndex *pindexIntermediate = pindexNew;\n  \n          // list of blocks that need to be connected afterwards\n          std::vector<CBlockIndex*> vpindexSecondary;\n  \n          // Reorganize is costly in terms of db load, as it works in a single db transaction.\n          // Try to limit how much needs to be done inside\n          while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n          {\n              vpindexSecondary.push_back(pindexIntermediate);\n              pindexIntermediate = pindexIntermediate->pprev;\n          }\n  \n          if (!vpindexSecondary.empty())\n              printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n  \n          // Switch to new best branch\n          if (!Reorganize(txdb, pindexIntermediate))\n          {\n              txdb.TxnAbort();\n              InvalidChainFound(pindexNew);\n              return error(\"SetBestChain() : Reorganize failed\");\n          }\n  \n          // Connect further blocks\n          BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n          {\n              CBlock block;\n              if (!block.ReadFromDisk(pindex))\n              {\n                  printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                  break;\n              }\n              if (!txdb.TxnBegin()) {\n                  printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                  break;\n              }\n              // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n              if (!block.SetBestChainInner(txdb, pindex))\n                  break;\n          }\n      }\n  \n      // Update best block in wallet (so we can detect restored wallets)\n      bool fIsInitialDownload = IsInitialBlockDownload();\n      if (!fIsInitialDownload)\n      {\n          const CBlockLocator locator(pindexNew);\n          ::SetBestChain(locator);\n      }\n  \n      // New best block\n      hashBestChain = hash;\n      pindexBest = pindexNew;\n      pblockindexFBBHLast = NULL;\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexNew->nChainTrust;\n      nTimeBestReceived = GetTime();\n      nTransactionsUpdated++;\n  \n      uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n  \n      printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n        CBigNum(nBestChainTrust).ToString().c_str(),\n        nBestBlockTrust.Get64(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      std::string strCmd = GetArg(\"-blocknotify\", \"\");\n  \n      if (!fIsInitialDownload && !strCmd.empty())\n      {\n          boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n          boost::thread t(runCommand, strCmd); // thread runs free\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"LoadBlockIndex() : block.ReadFromDisk failed\""
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindexFork"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "601-626",
          "snippet": "bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n      {\n          CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n  \n          // Read transaction\n          if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n              return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n  \n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          // Return file pointer\n          if (pfileRet)\n          {\n              if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                  return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n              *pfileRet = filein.release();\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\"",
            "pindexFork->nHeight"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\"",
            "txin.prevout.hash.ToString().c_str()",
            "txin.prevout.n",
            "hashTx.ToString().c_str()"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashTx.ToString",
          "args": [],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txindex.vSpent[txin.prevout.n].IsNull",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "IsNull",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "133-136",
          "snippet": "bool IsNull() const\n    {\n        return (hashCheckpoint == 0);\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  bool IsNull() const\n      {\n          return (hashCheckpoint == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txindex.vSpent.size",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadTxIndex",
          "args": [
            "txin.prevout.hash",
            "txindex"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ReadTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "199-204",
          "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\"",
            "hashTx.ToString().c_str()",
            "nOutput"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\"",
            "hashTx.ToString().c_str()",
            "nOutput"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txSpend.CheckTransaction",
          "args": [],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "CheckTransaction",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "478-527",
          "snippet": "bool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::CheckTransaction() const\n  {\n      // Basic checks that don't depend on any context\n      if (vin.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n      if (vout.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n      // Size limits\n      if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n  \n      // Check for negative or overflow output values\n      int64_t nValueOut = 0;\n      for (unsigned int i = 0; i < vout.size(); i++)\n      {\n          const CTxOut& txout = vout[i];\n          if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n          if (txout.nValue < 0)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n          if (txout.nValue > MAX_MONEY)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n          nValueOut += txout.nValue;\n          if (!MoneyRange(nValueOut))\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n      }\n  \n      // Check for duplicate inputs\n      set<COutPoint> vInOutPoints;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          if (vInOutPoints.count(txin.prevout))\n              return false;\n          vInOutPoints.insert(txin.prevout);\n      }\n  \n      if (IsCoinBase())\n      {\n          if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n      }\n      else\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (txin.prevout.IsNull())\n                  return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\"",
            "hashTx.ToString().c_str()",
            "nOutput"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\"",
            "pindex->nHeight",
            "pindex->GetBlockHash().ToString().c_str()",
            "hashTx.ToString().c_str()"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockPos.count",
          "args": [
            "posFind"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "txpos.nFile",
            "txpos.nBlockPos"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txFound.GetHash",
          "args": [],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pindex->nFile",
            "pindex->nBlockPos"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\"",
            "pindex->nHeight",
            "pindex->GetBlockHash().ToString().c_str()"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.CheckBlock",
          "args": [],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "CheckBlock",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2101-2190",
          "snippet": "bool CBlock::CheckBlock() const {\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    if(IsProofOfWork()) {\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n    }\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n\n    if (IsProofOfStake())\n    {\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n        for (unsigned int i = 2; i < vtx.size(); i++)\n            if (vtx[i].IsCoinStake())\n                return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    return(true);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::CheckBlock() const {\n  \n      // These are checks that are independent of context\n      // that can be verified before saving an orphan block.\n  \n      // Size limits\n      if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CheckBlock() : size limits failed\"));\n  \n      if(IsProofOfWork()) {\n  \n          /* Proof-of-work verification against target */\n          if(!CheckProofOfWork(GetHashPoW(), nBits))\n            return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n  \n          /* Proof-of-work block signature verification */\n          if(!CheckBlockSignature())\n            return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n      }\n  \n      // Check timestamp\n      if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n          return error(\"CheckBlock() : block timestamp too far in the future\");\n  \n      // First transaction must be coinbase, the rest must not be\n      if (vtx.empty() || !vtx[0].IsCoinBase())\n          return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n      for (unsigned int i = 1; i < vtx.size(); i++)\n          if (vtx[i].IsCoinBase())\n              return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n  \n      // Check coinbase timestamp\n      if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n          return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n  \n      if (IsProofOfStake())\n      {\n          // Coinbase output should be empty if proof-of-stake block\n          if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n              return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n  \n          // Second transaction must be coinstake, the rest must not be\n          if (vtx.empty() || !vtx[1].IsCoinStake())\n              return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n          for (unsigned int i = 2; i < vtx.size(); i++)\n              if (vtx[i].IsCoinStake())\n                  return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n  \n          // Check coinstake timestamp\n          if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n              return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n  \n          // NovaCoin: check proof-of-stake block signature\n          if(!CheckBlockSignature())\n              return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n      }\n  \n      // Check transactions\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          if (!tx.CheckTransaction())\n              return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n  \n          // ppcoin: check transaction timestamp\n          if (GetBlockTime() < (int64_t)tx.nTime)\n              return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n      }\n  \n      /* Merkle root verification */\n      if(hashMerkleRoot != BuildMerkleTree())\n        return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n  \n      /* Check for duplicate transactions */\n      set<uint256> uniqueTx;\n      BOOST_FOREACH(const CTransaction& tx, vtx) {\n          uniqueTx.insert(tx.GetHash());\n      }\n      if(uniqueTx.size() != vtx.size())\n        return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n  \n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          nSigOps += tx.GetLegacySigOpCount();\n      }\n      if (nSigOps > MAX_BLOCK_SIGOPS)\n          return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n  \n      return(true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Verifying last %i blocks at level %i\\n\"",
            "nCheckDepth",
            "nCheckLevel"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-checkblocks\"",
            "500"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bnBestInvalidTrust.getuint256",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "getuint256",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "278-291",
          "snippet": "uint256 getuint256() const\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        if (nSize < 4)\n            return 0;\n        std::vector<unsigned char> vch(nSize);\n        BN_bn2mpi(this, &vch[0]);\n        if (vch.size() > 4)\n            vch[4] &= 0x7f;\n        uint256 n = 0;\n        for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n            ((unsigned char*)&n)[i] = vch[j];\n        return n;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  uint256 getuint256() const\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          if (nSize < 4)\n              return 0;\n          std::vector<unsigned char> vch(nSize);\n          BN_bn2mpi(this, &vch[0]);\n          if (vch.size() > 4)\n              vch[4] &= 0x7f;\n          uint256 n = 0;\n          for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n              ((unsigned char*)&n)[i] = vch[j];\n          return n;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadBestInvalidTrust",
          "args": [
            "bnBestInvalidTrust"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "ReadBestInvalidTrust",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "277-280",
          "snippet": "bool CTxDB::ReadBestInvalidTrust(CBigNum& bnBestInvalidTrust)\n{\n    return Read(string(\"bnBestInvalidTrust\"), bnBestInvalidTrust);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadBestInvalidTrust(CBigNum& bnBestInvalidTrust)\n  {\n      return Read(string(\"bnBestInvalidTrust\"), bnBestInvalidTrust);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadSyncCheckpoint",
          "args": [
            "Checkpoints::hashSyncCheckpoint"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ReadSyncCheckpoint",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "287-290",
          "snippet": "bool CTxDB::ReadSyncCheckpoint(uint256& hashCheckpoint)\n{\n    return Read(string(\"hashSyncCheckpoint\"), hashCheckpoint);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadSyncCheckpoint(uint256& hashCheckpoint)\n  {\n      return Read(string(\"hashSyncCheckpoint\"), hashCheckpoint);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\"",
            "hashBestChain.ToString().substr(0,20).c_str()",
            "nBestHeight",
            "CBigNum(nBestChainTrust).ToString().c_str()",
            "DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str()"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "\"%x %H:%M:%S\"",
            "pindexBest->GetBlockTime()"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "376-383",
          "snippet": "inline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetBlockTime",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "nBestChainTrust"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBestChain.ToString",
          "args": [
            "0",
            "20"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadHashBestChain",
          "args": [
            "hashBestChain"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ReadHashBestChain",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "267-270",
          "snippet": "bool CTxDB::ReadHashBestChain(uint256& hashBestChain)\n{\n    return Read(string(\"hashBestChain\"), hashBestChain);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadHashBestChain(uint256& hashBestChain)\n  {\n      return Read(string(\"hashBestChain\"), hashBestChain);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64",
            "pindex->nHeight",
            "pindex->nStakeModifier"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckStakeModifierCheckpoints",
          "args": [
            "pindex->nHeight",
            "pindex->nStakeModifierChecksum"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "CheckStakeModifierCheckpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "394-401",
          "snippet": "bool CheckStakeModifierCheckpoints(int nHeight, unsigned int nStakeModifierChecksum)\n{\n    MapModifierCheckpoints& checkpoints = (fTestNet ? mapStakeModifierCheckpointsTestNet : mapStakeModifierCheckpoints);\n\n    if (checkpoints.count(nHeight))\n        return nStakeModifierChecksum == checkpoints[nHeight];\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "static std::map<int, unsigned int> mapStakeModifierCheckpoints =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;",
            "static std::map<int, unsigned int> mapStakeModifierCheckpointsTestNet =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic std::map<int, unsigned int> mapStakeModifierCheckpoints =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;\nstatic std::map<int, unsigned int> mapStakeModifierCheckpointsTestNet =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;\n\nbool CheckStakeModifierCheckpoints(int nHeight, unsigned int nStakeModifierChecksum)\n{\n    MapModifierCheckpoints& checkpoints = (fTestNet ? mapStakeModifierCheckpointsTestNet : mapStakeModifierCheckpoints);\n\n    if (checkpoints.count(nHeight))\n        return nStakeModifierChecksum == checkpoints[nHeight];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetStakeModifierChecksum",
          "args": [
            "pindex"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeModifierChecksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "380-391",
          "snippet": "unsigned int GetStakeModifierChecksum(const CBlockIndex* pindex)\n{\n    assert (pindex->pprev || pindex->GetBlockHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n    // Hash previous checksum with flags, hashProofOfStake and nStakeModifier\n    CDataStream ss(SER_GETHASH, 0);\n    if (pindex->pprev)\n        ss << pindex->pprev->nStakeModifierChecksum;\n    ss << pindex->nFlags << pindex->hashProofOfStake << pindex->nStakeModifier;\n    uint256 hashChecksum = Hash(ss.begin(), ss.end());\n    hashChecksum >>= (256 - 32);\n    return hashChecksum.Get64();\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nunsigned int GetStakeModifierChecksum(const CBlockIndex* pindex)\n{\n    assert (pindex->pprev || pindex->GetBlockHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n    // Hash previous checksum with flags, hashProofOfStake and nStakeModifier\n    CDataStream ss(SER_GETHASH, 0);\n    if (pindex->pprev)\n        ss << pindex->pprev->nStakeModifierChecksum;\n    ss << pindex->nFlags << pindex->hashProofOfStake << pindex->nStakeModifier;\n    uint256 hashChecksum = Hash(ss.begin(), ss.end());\n    hashChecksum >>= (256 - 32);\n    return hashChecksum.Get64();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockTrust",
          "args": [],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTrust",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2317-2414",
          "snippet": "uint256 CBlockIndex::GetBlockTrust() const {\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    if(bnTarget <= 0) return(0);\n\n    /* Old protocol */\n\n    if(!fTestNet && (nHeight < nForkOne))\n      return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n\n    /* New protocol: 80% PoS, 20% PoW */\n\n    uint256 nBlockTrust = 1;\n\n    if(IsProofOfWork()) {\n\n        uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n        uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n\n        /* The minimal PoW trust score prior to correction */\n        if(nPoWTrust < 4) nPoWTrust = 4;\n\n        /* Fixed trust for the first 10 blocks */\n        if((pprev == NULL) || (pprev->nHeight < 10))\n          return(nPoWTrust);\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n\n        if(pindexP1->IsProofOfStake()) {\n            /* 100% trust for PoW following PoS */\n            nBlockTrust = nPoWTrust;\n        } else {\n            if(pindexP2->IsProofOfStake()) {\n                /* 50% trust for PoS->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 1);\n            } else {\n                /* 25% trust for PoW->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 2);\n            }\n        }\n\n    } else {\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n        const CBlockIndex* pindexP3 = pindexP2->pprev;\n\n        /* PoS difficulty is very low and of little use for trust scoring;\n         * use full trust of the previous PoW block as a basis instead */\n        uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n\n        if(pindexP1->IsProofOfWork()) {\n            /* 200% trust for PoS following PoW */\n            if(pindexP2->IsProofOfStake()) {\n                /* PoS->PoW->PoS: 100% to 200% */\n                nBlockTrust = (nPrevTrust << 1);\n            } else {\n                if(pindexP3->IsProofOfStake()) {\n                    /* PoS->PoW->PoW->PoS: 50% to 200% */\n                    nBlockTrust = (nPrevTrust << 2);\n                } else {\n                    /* PoW->PoW->PoW->PoS: 25% to 200% */\n                    nBlockTrust = (nPrevTrust << 3);\n                }\n            }\n        } else {\n            if(pindexP2->IsProofOfWork()) {\n                /* 150% of trust for PoW->PoS->PoS */\n                nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n            } else {\n                if(pindexP3->IsProofOfWork()) {\n                    /* 120% of trust for PoW->PoS->PoS->PoS */\n                    nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                } else {\n                    const CBlockIndex* pindexP4 = pindexP3->pprev;\n                    if(pindexP4->IsProofOfWork()) {\n                        /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                        nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                    } else {\n                        const CBlockIndex* pindexP5 = pindexP4->pprev;\n                        if(pindexP5->IsProofOfWork()) {\n                            /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = (nPrevTrust >> 1);\n                        } else {\n                            /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = nPrevTrust;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    return(nBlockTrust);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlockIndex {\n  uint256 CBlockIndex::GetBlockTrust() const {\n      CBigNum bnTarget;\n      bnTarget.SetCompact(nBits);\n  \n      if(bnTarget <= 0) return(0);\n  \n      /* Old protocol */\n  \n      if(!fTestNet && (nHeight < nForkOne))\n        return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n  \n      /* New protocol: 80% PoS, 20% PoW */\n  \n      uint256 nBlockTrust = 1;\n  \n      if(IsProofOfWork()) {\n  \n          uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n          uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n  \n          /* The minimal PoW trust score prior to correction */\n          if(nPoWTrust < 4) nPoWTrust = 4;\n  \n          /* Fixed trust for the first 10 blocks */\n          if((pprev == NULL) || (pprev->nHeight < 10))\n            return(nPoWTrust);\n  \n          const CBlockIndex* pindexP1 = pprev;\n          const CBlockIndex* pindexP2 = pindexP1->pprev;\n  \n          if(pindexP1->IsProofOfStake()) {\n              /* 100% trust for PoW following PoS */\n              nBlockTrust = nPoWTrust;\n          } else {\n              if(pindexP2->IsProofOfStake()) {\n                  /* 50% trust for PoS->PoW->PoW */\n                  nBlockTrust = (nPoWTrust >> 1);\n              } else {\n                  /* 25% trust for PoW->PoW->PoW */\n                  nBlockTrust = (nPoWTrust >> 2);\n              }\n          }\n  \n      } else {\n  \n          const CBlockIndex* pindexP1 = pprev;\n          const CBlockIndex* pindexP2 = pindexP1->pprev;\n          const CBlockIndex* pindexP3 = pindexP2->pprev;\n  \n          /* PoS difficulty is very low and of little use for trust scoring;\n           * use full trust of the previous PoW block as a basis instead */\n          uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n  \n          if(pindexP1->IsProofOfWork()) {\n              /* 200% trust for PoS following PoW */\n              if(pindexP2->IsProofOfStake()) {\n                  /* PoS->PoW->PoS: 100% to 200% */\n                  nBlockTrust = (nPrevTrust << 1);\n              } else {\n                  if(pindexP3->IsProofOfStake()) {\n                      /* PoS->PoW->PoW->PoS: 50% to 200% */\n                      nBlockTrust = (nPrevTrust << 2);\n                  } else {\n                      /* PoW->PoW->PoW->PoS: 25% to 200% */\n                      nBlockTrust = (nPrevTrust << 3);\n                  }\n              }\n          } else {\n              if(pindexP2->IsProofOfWork()) {\n                  /* 150% of trust for PoW->PoS->PoS */\n                  nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n              } else {\n                  if(pindexP3->IsProofOfWork()) {\n                      /* 120% of trust for PoW->PoS->PoS->PoS */\n                      nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                  } else {\n                      const CBlockIndex* pindexP4 = pindexP3->pprev;\n                      if(pindexP4->IsProofOfWork()) {\n                          /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                          nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                      } else {\n                          const CBlockIndex* pindexP5 = pindexP4->pprev;\n                          if(pindexP5->IsProofOfWork()) {\n                              /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                              nBlockTrust = (nPrevTrust >> 1);\n                          } else {\n                              /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                              nBlockTrust = nPrevTrust;\n                          }\n                      }\n                  }\n              }\n          }\n  \n      }\n  \n      return(nBlockTrust);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "vSortedByHeight.begin()",
            "vSortedByHeight.end()"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "sortView",
          "container": "CoinControlDialog",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/coincontroldialog.cpp",
          "lines": "313-319",
          "snippet": "void CoinControlDialog::sortView(int column, Qt::SortOrder order)\n{\n    sortColumn = column;\n    sortOrder = order;\n    ui->treeWidget->sortItems(column, order);\n    ui->treeWidget->header()->setSortIndicator((sortColumn == COLUMN_AMOUNT_INT64 ? COLUMN_AMOUNT : (sortColumn == COLUMN_PRIORITY_INT64 ? COLUMN_PRIORITY : sortColumn)), sortOrder);\n}",
          "includes": [
            "#include <QTreeWidgetItem>",
            "#include <QTreeWidget>",
            "#include <QString>",
            "#include <QIcon>",
            "#include <QFlags>",
            "#include <QDialogButtonBox>",
            "#include <QDateTime>",
            "#include <QCursor>",
            "#include <QColor>",
            "#include <QClipboard>",
            "#include <QCheckBox>",
            "#include <QApplication>",
            "#include \"coincontrol.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"init.h\"",
            "#include \"ui_coincontroldialog.h\"",
            "#include \"coincontroldialog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QTreeWidgetItem>\n#include <QTreeWidget>\n#include <QString>\n#include <QIcon>\n#include <QFlags>\n#include <QDialogButtonBox>\n#include <QDateTime>\n#include <QCursor>\n#include <QColor>\n#include <QClipboard>\n#include <QCheckBox>\n#include <QApplication>\n#include \"coincontrol.h\"\n#include \"optionsmodel.h\"\n#include \"addresstablemodel.h\"\n#include \"walletmodel.h\"\n#include \"bitcoinunits.h\"\n#include \"init.h\"\n#include \"ui_coincontroldialog.h\"\n#include \"coincontroldialog.h\"\n\nCoinControlDialog {\n  void CoinControlDialog::sortView(int column, Qt::SortOrder order)\n  {\n      sortColumn = column;\n      sortOrder = order;\n      ui->treeWidget->sortItems(column, order);\n      ui->treeWidget->header()->setSortIndicator((sortColumn == COLUMN_AMOUNT_INT64 ? COLUMN_AMOUNT : (sortColumn == COLUMN_PRIORITY_INT64 ? COLUMN_PRIORITY : sortColumn)), sortOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSortedByHeight.end",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSortedByHeight.begin",
          "args": [],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSortedByHeight.push_back",
          "args": [
            "make_pair(pindex->nHeight, pindex)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pindex->nHeight",
            "pindex"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vSortedByHeight.reserve",
          "args": [
            "mapBlockIndex.size()"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator->Next",
          "args": [],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setStakeSeen.insert",
          "args": [
            "make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pindexNew->prevoutStake",
            "pindexNew->nStakeTime"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindexNew->IsProofOfStake",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"LoadBlockIndex() : CheckIndex failed at %d\"",
            "pindexNew->nHeight"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexNew->CheckIndex",
          "args": [],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "CheckIndex",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1296-1299",
          "snippet": "bool CheckIndex() const\n    {\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool CheckIndex() const\n      {\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "InsertBlockIndex",
          "args": [
            "diskindex.hashNext"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InsertBlockIndex",
          "args": [
            "diskindex.hashPrev"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "InsertBlockIndex",
          "args": [
            "blockHash"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ssValue.write",
          "args": [
            "iterator->value().data()",
            "iterator->value().size()"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "write",
          "container": "SSLIOStreamDevice",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bitcoinrpc.cpp",
          "lines": "598-603",
          "snippet": "std::streamsize write(const char* s, std::streamsize n)\n    {\n        handshake(ssl::stream_base::client); // HTTPS clients write first\n        if (fUseSSL) return asio::write(stream, asio::buffer(s, n));\n        return asio::write(stream.next_layer(), asio::buffer(s, n));\n    }",
          "includes": [
            "#include <list>",
            "#include <boost/shared_ptr.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/asio/ssl.hpp>",
            "#include <boost/algorithm/string.hpp>",
            "#include <boost/iostreams/stream.hpp>",
            "#include <boost/iostreams/concepts.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/bind.hpp>",
            "#include <boost/bind/bind.hpp>",
            "#include <boost/asio/ip/v6_only.hpp>",
            "#include <boost/asio.hpp>",
            "#include \"db.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include <boost/shared_ptr.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/asio/ssl.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/iostreams/stream.hpp>\n#include <boost/iostreams/concepts.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/bind.hpp>\n#include <boost/bind/bind.hpp>\n#include <boost/asio/ip/v6_only.hpp>\n#include <boost/asio.hpp>\n#include \"db.h\"\n#include \"bitcoinrpc.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"util.h\"\n#include \"init.h\"\n\nSSLIOStreamDevice {\n  std::streamsize write(const char* s, std::streamsize n)\n      {\n          handshake(ssl::stream_base::client); // HTTPS clients write first\n          if (fUseSSL) return asio::write(stream, asio::buffer(s, n));\n          return asio::write(stream.next_layer(), asio::buffer(s, n));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator->value",
          "args": [],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QValueComboBox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/qvaluecombobox.cpp",
          "lines": "9-12",
          "snippet": "QVariant QValueComboBox::value() const\n{\n    return itemData(currentIndex(), role);\n}",
          "includes": [
            "#include \"qvaluecombobox.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qvaluecombobox.h\"\n\nQValueComboBox {\n  QVariant QValueComboBox::value() const\n  {\n      return itemData(currentIndex(), role);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator->key",
          "args": [],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "LRUHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/cache.cc",
          "lines": "37-45",
          "snippet": "Slice key() const {\n    // For cheaper lookups, we allow a temporary Handle object\n    // to store a pointer to a key in \"value\".\n    if (next == this) {\n      return *(reinterpret_cast<Slice*>(value));\n    } else {\n      return Slice(key_data, key_length);\n    }\n  }",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/hash.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/hash.h\"\n#include \"port/port.h\"\n#include \"leveldb/cache.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n\nLRUHandle {\n  Slice key() const {\n      // For cheaper lookups, we allow a temporary Handle object\n      // to store a pointer to a key in \"value\".\n      if (next == this) {\n        return *(reinterpret_cast<Slice*>(value));\n      } else {\n        return Slice(key_data, key_length);\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator->Valid",
          "args": [],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "280-280",
          "snippet": "virtual bool Valid() const { return iter_->Valid(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual bool Valid() const { return iter_->Valid(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iterator->Seek",
          "args": [
            "ssStartKey.str()"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "281-286",
          "snippet": "virtual void Seek(const Slice& target) {\n    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n    std::string encoded;\n    AppendInternalKey(&encoded, ikey);\n    iter_->Seek(encoded);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void Seek(const Slice& target) {\n      ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);\n      std::string encoded;\n      AppendInternalKey(&encoded, ikey);\n      iter_->Seek(encoded);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ssStartKey.str",
          "args": [],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "789-792",
          "snippet": "std::string str() const\n    {\n        return (std::string(begin(), end()));\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  std::string str() const\n      {\n          return (std::string(begin(), end()));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"blockindex\")",
            "uint256(0)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint256",
          "args": [
            "0"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "setuint256",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "250-276",
          "snippet": "void setuint256(uint256 n)\n    {\n        unsigned char pch[sizeof(n) + 6];\n        unsigned char* p = pch + 4;\n        bool fLeadingZeroes = true;\n        unsigned char* pbegin = (unsigned char*)&n;\n        unsigned char* psrc = pbegin + sizeof(n);\n        while (psrc != pbegin)\n        {\n            unsigned char c = *(--psrc);\n            if (fLeadingZeroes)\n            {\n                if (c == 0)\n                    continue;\n                if (c & 0x80)\n                    *p++ = 0;\n                fLeadingZeroes = false;\n            }\n            *p++ = c;\n        }\n        unsigned int nSize = p - (pch + 4);\n        pch[0] = (nSize >> 24) & 0xff;\n        pch[1] = (nSize >> 16) & 0xff;\n        pch[2] = (nSize >> 8) & 0xff;\n        pch[3] = (nSize >> 0) & 0xff;\n        BN_mpi2bn(pch, p - pch, this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void setuint256(uint256 n)\n      {\n          unsigned char pch[sizeof(n) + 6];\n          unsigned char* p = pch + 4;\n          bool fLeadingZeroes = true;\n          unsigned char* pbegin = (unsigned char*)&n;\n          unsigned char* psrc = pbegin + sizeof(n);\n          while (psrc != pbegin)\n          {\n              unsigned char c = *(--psrc);\n              if (fLeadingZeroes)\n              {\n                  if (c == 0)\n                      continue;\n                  if (c & 0x80)\n                      *p++ = 0;\n                  fLeadingZeroes = false;\n              }\n              *p++ = c;\n          }\n          unsigned int nSize = p - (pch + 4);\n          pch[0] = (nSize >> 24) & 0xff;\n          pch[1] = (nSize >> 16) & 0xff;\n          pch[2] = (nSize >> 8) & 0xff;\n          pch[3] = (nSize >> 0) & 0xff;\n          BN_mpi2bn(pch, p - pch, this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"blockindex\""
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "pdb->NewIterator",
          "args": [
            "leveldb::ReadOptions()"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::ReadOptions",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nleveldb::DB *txdb;\n\nCTxDB {\n  bool CTxDB::LoadBlockIndex()\n  {\n      if (mapBlockIndex.size() > 0) {\n          // Already loaded once in this session. It can happen during migration\n          // from BDB.\n          return true;\n      }\n      // The block index is an in-memory structure that maps hashes to on-disk\n      // locations where the contents of the block can be found. Here, we scan it\n      // out of the DB and into mapBlockIndex.\n      leveldb::Iterator *iterator = pdb->NewIterator(leveldb::ReadOptions());\n      // Seek to start key.\n      CDataStream ssStartKey(SER_DISK, CLIENT_VERSION);\n      ssStartKey << make_pair(string(\"blockindex\"), uint256(0));\n      iterator->Seek(ssStartKey.str());\n      // Now read each entry.\n      while (iterator->Valid())\n      {\n          // Unpack keys and values.\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.write(iterator->key().data(), iterator->key().size());\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.write(iterator->value().data(), iterator->value().size());\n          string strType;\n          ssKey >> strType;\n          // Did we reach the end of the data to read?\n          if (fRequestShutdown || strType != \"blockindex\")\n              break;\n          CDiskBlockIndex diskindex;\n          ssValue >> diskindex;\n  \n          uint256 blockHash = diskindex.GetBlockHash();\n  \n          // Construct block index object\n          CBlockIndex* pindexNew    = InsertBlockIndex(blockHash);\n          pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n          pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n          pindexNew->nFile          = diskindex.nFile;\n          pindexNew->nBlockPos      = diskindex.nBlockPos;\n          pindexNew->nHeight        = diskindex.nHeight;\n          pindexNew->nMint          = diskindex.nMint;\n          pindexNew->nMoneySupply   = diskindex.nMoneySupply;\n          pindexNew->nFlags         = diskindex.nFlags;\n          pindexNew->nStakeModifier = diskindex.nStakeModifier;\n          pindexNew->prevoutStake   = diskindex.prevoutStake;\n          pindexNew->nStakeTime     = diskindex.nStakeTime;\n          pindexNew->hashProofOfStake = diskindex.hashProofOfStake;\n          pindexNew->nVersion       = diskindex.nVersion;\n          pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n          pindexNew->nTime          = diskindex.nTime;\n          pindexNew->nBits          = diskindex.nBits;\n          pindexNew->nNonce         = diskindex.nNonce;\n  \n          // Watch for genesis block\n          if (pindexGenesisBlock == NULL && blockHash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n              pindexGenesisBlock = pindexNew;\n  \n          if (!pindexNew->CheckIndex()) {\n              delete iterator;\n              return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n          }\n  \n          // NovaCoin: build setStakeSeen\n          if (pindexNew->IsProofOfStake())\n              setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n  \n          iterator->Next();\n      }\n      delete iterator;\n  \n      if (fRequestShutdown)\n          return true;\n  \n      // Calculate nChainTrust\n      vector<pair<int, CBlockIndex*> > vSortedByHeight;\n      vSortedByHeight.reserve(mapBlockIndex.size());\n      BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n      {\n          CBlockIndex* pindex = item.second;\n          vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n      }\n      sort(vSortedByHeight.begin(), vSortedByHeight.end());\n      BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n      {\n          CBlockIndex* pindex = item.second;\n          pindex->nChainTrust = (pindex->pprev ? pindex->pprev->nChainTrust : 0) + pindex->GetBlockTrust();\n          // NovaCoin: calculate stake modifier checksum\n          pindex->nStakeModifierChecksum = GetStakeModifierChecksum(pindex);\n          if (!CheckStakeModifierCheckpoints(pindex->nHeight, pindex->nStakeModifierChecksum))\n              return error(\"CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindex->nHeight, pindex->nStakeModifier);\n      }\n  \n      // Load hashBestChain pointer to end of best chain\n      if (!ReadHashBestChain(hashBestChain))\n      {\n          if (pindexGenesisBlock == NULL)\n              return true;\n          return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n      }\n      if (!mapBlockIndex.count(hashBestChain))\n          return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n      pindexBest = mapBlockIndex[hashBestChain];\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexBest->nChainTrust;\n  \n      printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, CBigNum(nBestChainTrust).ToString().c_str(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      // NovaCoin: load hashSyncCheckpoint\n      if (!ReadSyncCheckpoint(Checkpoints::hashSyncCheckpoint))\n          return error(\"CTxDB::LoadBlockIndex() : hashSyncCheckpoint not loaded\");\n      printf(\"LoadBlockIndex(): synchronized checkpoint %s\\n\", Checkpoints::hashSyncCheckpoint.ToString().c_str());\n  \n      // Load bnBestInvalidTrust, OK if it doesn't exist\n      CBigNum bnBestInvalidTrust;\n      ReadBestInvalidTrust(bnBestInvalidTrust);\n      nBestInvalidTrust = bnBestInvalidTrust.getuint256();\n  \n      // Verify blocks in the best chain\n      int nCheckLevel = GetArg(\"-checklevel\", 1);\n      int nCheckDepth = GetArg( \"-checkblocks\", 500);\n      if (nCheckDepth == 0)\n          nCheckDepth = 1000000000; // suffices until the year 19000\n      if (nCheckDepth > nBestHeight)\n          nCheckDepth = nBestHeight;\n      printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n      CBlockIndex* pindexFork = NULL;\n      map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n      for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n      {\n          if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n              break;\n          CBlock block;\n          if (!block.ReadFromDisk(pindex))\n              return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n          // check level 1: verify block validity\n          if((nCheckLevel > 0) && !block.CheckBlock()) {\n              printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n              pindexFork = pindex->pprev;\n          }\n          // check level 2: verify transaction index validity\n          if (nCheckLevel>1)\n          {\n              pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n              mapBlockPos[pos] = pindex;\n              BOOST_FOREACH(const CTransaction &tx, block.vtx)\n              {\n                  uint256 hashTx = tx.GetHash();\n                  CTxIndex txindex;\n                  if (ReadTxIndex(hashTx, txindex))\n                  {\n                      // check level 3: checker transaction hashes\n                      if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                      {\n                          // either an error or a duplicate transaction\n                          CTransaction txFound;\n                          if (!txFound.ReadFromDisk(txindex.pos))\n                          {\n                              printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n                              pindexFork = pindex->pprev;\n                          }\n                          else\n                              if (txFound.GetHash() != hashTx) // not a duplicate tx\n                              {\n                                  printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n                                  pindexFork = pindex->pprev;\n                              }\n                      }\n                      // check level 4: check whether spent txouts were spent within the main chain\n                      unsigned int nOutput = 0;\n                      if (nCheckLevel>3)\n                      {\n                          BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n                          {\n                              if (!txpos.IsNull())\n                              {\n                                  pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n                                  if (!mapBlockPos.count(posFind))\n                                  {\n                                      printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                      pindexFork = pindex->pprev;\n                                  }\n                                  // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                  if (nCheckLevel>5)\n                                  {\n                                      CTransaction txSpend;\n                                      if (!txSpend.ReadFromDisk(txpos))\n                                      {\n                                          printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n                                          pindexFork = pindex->pprev;\n                                      }\n                                      else if (!txSpend.CheckTransaction())\n                                      {\n                                          printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n                                          pindexFork = pindex->pprev;\n                                      }\n                                      else\n                                      {\n                                          bool fFound = false;\n                                          BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n                                              if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n                                                  fFound = true;\n                                          if (!fFound)\n                                          {\n                                              printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n                                              pindexFork = pindex->pprev;\n                                          }\n                                      }\n                                  }\n                              }\n                              nOutput++;\n                          }\n                      }\n                  }\n                  // check level 5: check whether all prevouts are marked spent\n                  if (nCheckLevel>4)\n                  {\n                       BOOST_FOREACH(const CTxIn &txin, tx.vin)\n                       {\n                            CTxIndex txindex;\n                            if (ReadTxIndex(txin.prevout.hash, txindex))\n                                if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n                                {\n                                    printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n                                    pindexFork = pindex->pprev;\n                                }\n                       }\n                  }\n              }\n          }\n      }\n      if (pindexFork && !fRequestShutdown)\n      {\n          // Reorg back to the fork\n          printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n          CBlock block;\n          if (!block.ReadFromDisk(pindexFork))\n              return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n          CTxDB txdb;\n          block.SetBestChain(txdb, pindexFork);\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "WriteCheckpointPubKey",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "302-305",
    "snippet": "bool CTxDB::WriteCheckpointPubKey(const string& strPubKey)\n{\n    return Write(string(\"strCheckpointPubKey\"), strPubKey);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "string(\"strCheckpointPubKey\")",
            "strPubKey"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"strCheckpointPubKey\""
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteCheckpointPubKey(const string& strPubKey)\n  {\n      return Write(string(\"strCheckpointPubKey\"), strPubKey);\n  }\n}"
  },
  {
    "function_name": "ReadCheckpointPubKey",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "297-300",
    "snippet": "bool CTxDB::ReadCheckpointPubKey(string& strPubKey)\n{\n    return Read(string(\"strCheckpointPubKey\"), strPubKey);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "string(\"strCheckpointPubKey\")",
            "strPubKey"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "256-260",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"strCheckpointPubKey\""
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadCheckpointPubKey(string& strPubKey)\n  {\n      return Read(string(\"strCheckpointPubKey\"), strPubKey);\n  }\n}"
  },
  {
    "function_name": "WriteSyncCheckpoint",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "292-295",
    "snippet": "bool CTxDB::WriteSyncCheckpoint(uint256 hashCheckpoint)\n{\n    return Write(string(\"hashSyncCheckpoint\"), hashCheckpoint);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "string(\"hashSyncCheckpoint\")",
            "hashCheckpoint"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"hashSyncCheckpoint\""
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteSyncCheckpoint(uint256 hashCheckpoint)\n  {\n      return Write(string(\"hashSyncCheckpoint\"), hashCheckpoint);\n  }\n}"
  },
  {
    "function_name": "ReadSyncCheckpoint",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "287-290",
    "snippet": "bool CTxDB::ReadSyncCheckpoint(uint256& hashCheckpoint)\n{\n    return Read(string(\"hashSyncCheckpoint\"), hashCheckpoint);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "string(\"hashSyncCheckpoint\")",
            "hashCheckpoint"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "256-260",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"hashSyncCheckpoint\""
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadSyncCheckpoint(uint256& hashCheckpoint)\n  {\n      return Read(string(\"hashSyncCheckpoint\"), hashCheckpoint);\n  }\n}"
  },
  {
    "function_name": "WriteBestInvalidTrust",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "282-285",
    "snippet": "bool CTxDB::WriteBestInvalidTrust(CBigNum bnBestInvalidTrust)\n{\n    return Write(string(\"bnBestInvalidTrust\"), bnBestInvalidTrust);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "string(\"bnBestInvalidTrust\")",
            "bnBestInvalidTrust"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"bnBestInvalidTrust\""
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteBestInvalidTrust(CBigNum bnBestInvalidTrust)\n  {\n      return Write(string(\"bnBestInvalidTrust\"), bnBestInvalidTrust);\n  }\n}"
  },
  {
    "function_name": "ReadBestInvalidTrust",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "277-280",
    "snippet": "bool CTxDB::ReadBestInvalidTrust(CBigNum& bnBestInvalidTrust)\n{\n    return Read(string(\"bnBestInvalidTrust\"), bnBestInvalidTrust);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "string(\"bnBestInvalidTrust\")",
            "bnBestInvalidTrust"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "256-260",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"bnBestInvalidTrust\""
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadBestInvalidTrust(CBigNum& bnBestInvalidTrust)\n  {\n      return Read(string(\"bnBestInvalidTrust\"), bnBestInvalidTrust);\n  }\n}"
  },
  {
    "function_name": "WriteHashBestChain",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "272-275",
    "snippet": "bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n{\n    return Write(string(\"hashBestChain\"), hashBestChain);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "string(\"hashBestChain\")",
            "hashBestChain"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"hashBestChain\""
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n  {\n      return Write(string(\"hashBestChain\"), hashBestChain);\n  }\n}"
  },
  {
    "function_name": "ReadHashBestChain",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "267-270",
    "snippet": "bool CTxDB::ReadHashBestChain(uint256& hashBestChain)\n{\n    return Read(string(\"hashBestChain\"), hashBestChain);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "string(\"hashBestChain\")",
            "hashBestChain"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "256-260",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"hashBestChain\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadHashBestChain(uint256& hashBestChain)\n  {\n      return Read(string(\"hashBestChain\"), hashBestChain);\n  }\n}"
  },
  {
    "function_name": "WriteBlockIndex",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "262-265",
    "snippet": "bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n{\n    return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "make_pair(string(\"blockindex\"), blockindex.GetBlockHash())",
            "blockindex"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"blockindex\")",
            "blockindex.GetBlockHash()"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockindex.GetBlockHash",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"blockindex\""
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n  {\n      return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n  }\n}"
  },
  {
    "function_name": "ReadDiskTx",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "256-260",
    "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadDiskTx",
          "args": [
            "outpoint.hash",
            "tx",
            "txindex"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "251-254",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex)\n{\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
  },
  {
    "function_name": "ReadDiskTx",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "251-254",
    "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex)\n{\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadDiskTx",
          "args": [
            "outpoint.hash",
            "tx",
            "txindex"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "251-254",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex)\n{\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex)\n  {\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
  },
  {
    "function_name": "ReadDiskTx",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "245-249",
    "snippet": "bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(hash, tx, txindex);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadDiskTx",
          "args": [
            "hash",
            "tx",
            "txindex"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "251-254",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx, CTxIndex& txindex)\n{\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(hash, tx, txindex);\n  }\n}"
  },
  {
    "function_name": "ReadDiskTx",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "236-243",
    "snippet": "bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex)\n{\n    assert(!fClient);\n    tx.SetNull();\n    if (!ReadTxIndex(hash, txindex))\n        return false;\n    return (tx.ReadFromDisk(txindex.pos));\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tx.ReadFromDisk",
          "args": [
            "txindex.pos"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "601-626",
          "snippet": "bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n    {\n        CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n\n        // Read transaction\n        if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n            return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        // Return file pointer\n        if (pfileRet)\n        {\n            if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n            *pfileRet = filein.release();\n        }\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool ReadFromDisk(CDiskTxPos pos, FILE** pfileRet=NULL)\n      {\n          CAutoFile filein = CAutoFile(OpenBlockFile(pos.nFile, 0, pfileRet ? \"rb+\" : \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CTransaction::ReadFromDisk() : OpenBlockFile failed\");\n  \n          // Read transaction\n          if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n              return error(\"CTransaction::ReadFromDisk() : fseek failed\");\n  \n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          // Return file pointer\n          if (pfileRet)\n          {\n              if (fseek(filein, pos.nTxPos, SEEK_SET) != 0)\n                  return error(\"CTransaction::ReadFromDisk() : second fseek failed\");\n              *pfileRet = filein.release();\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadTxIndex",
          "args": [
            "hash",
            "txindex"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ReadTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "199-204",
          "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.SetNull",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CKeyMetadata",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "50-54",
          "snippet": "void SetNull()\n    {\n        nVersion = CKeyMetadata::CURRENT_VERSION;\n        nCreateTime = 0;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCKeyMetadata {\n  void SetNull()\n      {\n          nVersion = CKeyMetadata::CURRENT_VERSION;\n          nCreateTime = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!fClient"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(uint256 hash, CTransaction& tx, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      tx.SetNull();\n      if (!ReadTxIndex(hash, txindex))\n          return false;\n      return (tx.ReadFromDisk(txindex.pos));\n  }\n}"
  },
  {
    "function_name": "ContainsTx",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "230-234",
    "snippet": "bool CTxDB::ContainsTx(uint256 hash)\n{\n    assert(!fClient);\n    return Exists(make_pair(string(\"tx\"), hash));\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Exists",
          "args": [
            "make_pair(string(\"tx\"), hash)"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "Exists",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "145-162",
          "snippet": "bool Exists(const K& key)\n    {\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        std::string unused;\n\n        if (activeBatch) {\n            bool deleted;\n            if (ScanBatch(ssKey, &unused, &deleted) && !deleted) {\n                return true;\n            }\n        }\n\n\n        leveldb::Status status = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &unused);\n        return status.IsNotFound() == false;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Exists(const K& key)\n      {\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          std::string unused;\n  \n          if (activeBatch) {\n              bool deleted;\n              if (ScanBatch(ssKey, &unused, &deleted) && !deleted) {\n                  return true;\n              }\n          }\n  \n  \n          leveldb::Status status = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &unused);\n          return status.IsNotFound() == false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"tx\")",
            "hash"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"tx\""
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!fClient"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ContainsTx(uint256 hash)\n  {\n      assert(!fClient);\n      return Exists(make_pair(string(\"tx\"), hash));\n  }\n}"
  },
  {
    "function_name": "EraseTxIndex",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "222-228",
    "snippet": "bool CTxDB::EraseTxIndex(const CTransaction& tx)\n{\n    assert(!fClient);\n    uint256 hash = tx.GetHash();\n\n    return Erase(make_pair(string(\"tx\"), hash));\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Erase",
          "args": [
            "make_pair(string(\"tx\"), hash)"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "EraseTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "222-228",
          "snippet": "bool CTxDB::EraseTxIndex(const CTransaction& tx)\n{\n    assert(!fClient);\n    uint256 hash = tx.GetHash();\n\n    return Erase(make_pair(string(\"tx\"), hash));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"tx\")",
            "hash"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"tx\""
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!fClient"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::EraseTxIndex(const CTransaction& tx)\n  {\n      assert(!fClient);\n      uint256 hash = tx.GetHash();\n  \n      return Erase(make_pair(string(\"tx\"), hash));\n  }\n}"
  },
  {
    "function_name": "AddTxIndex",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "212-220",
    "snippet": "bool CTxDB::AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeight)\n{\n    assert(!fClient);\n\n    // Add to tx index\n    uint256 hash = tx.GetHash();\n    CTxIndex txindex(pos, tx.vout.size());\n    return Write(make_pair(string(\"tx\"), hash), txindex);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "make_pair(string(\"tx\"), hash)",
            "txindex"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"tx\")",
            "hash"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"tx\""
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "tx.vout.size",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!fClient"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::AddTxIndex(const CTransaction& tx, const CDiskTxPos& pos, int nHeight)\n  {\n      assert(!fClient);\n  \n      // Add to tx index\n      uint256 hash = tx.GetHash();\n      CTxIndex txindex(pos, tx.vout.size());\n      return Write(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
  },
  {
    "function_name": "UpdateTxIndex",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "206-210",
    "snippet": "bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n{\n    assert(!fClient);\n    return Write(make_pair(string(\"tx\"), hash), txindex);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Write",
          "args": [
            "make_pair(string(\"tx\"), hash)",
            "txindex"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"tx\")",
            "hash"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"tx\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!fClient"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n  {\n      assert(!fClient);\n      return Write(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
  },
  {
    "function_name": "ReadTxIndex",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "199-204",
    "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Read",
          "args": [
            "make_pair(string(\"tx\"), hash)",
            "txindex"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ReadDiskTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "256-260",
          "snippet": "bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n{\n    CTxIndex txindex;\n    return ReadDiskTx(outpoint.hash, tx, txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadDiskTx(COutPoint outpoint, CTransaction& tx)\n  {\n      CTxIndex txindex;\n      return ReadDiskTx(outpoint.hash, tx, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "string(\"tx\")",
            "hash"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"tx\""
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "txindex.SetNull",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CKeyMetadata",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "50-54",
          "snippet": "void SetNull()\n    {\n        nVersion = CKeyMetadata::CURRENT_VERSION;\n        nCreateTime = 0;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCKeyMetadata {\n  void SetNull()\n      {\n          nVersion = CKeyMetadata::CURRENT_VERSION;\n          nCreateTime = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!fClient"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
  },
  {
    "function_name": "ScanBatch",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "185-197",
    "snippet": "bool CTxDB::ScanBatch(const CDataStream &key, string *value, bool *deleted) const {\n    assert(activeBatch);\n    *deleted = false;\n    CBatchScanner scanner;\n    scanner.needle = key.str();\n    scanner.deleted = deleted;\n    scanner.foundValue = value;\n    leveldb::Status status = activeBatch->Iterate(&scanner);\n    if (!status.ok()) {\n        throw runtime_error(status.ToString());\n    }\n    return scanner.foundEntry;\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "status.ToString()"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "activeBatch->Iterate",
          "args": [
            "&scanner"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "Iterate",
          "container": "WriteBatch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "42-80",
          "snippet": "Status WriteBatch::Iterate(Handler* handler) const {\n  Slice input(rep_);\n  if (input.size() < kHeader) {\n    return Status::Corruption(\"malformed WriteBatch (too small)\");\n  }\n\n  input.remove_prefix(kHeader);\n  Slice key, value;\n  int found = 0;\n  while (!input.empty()) {\n    found++;\n    char tag = input[0];\n    input.remove_prefix(1);\n    switch (tag) {\n      case kTypeValue:\n        if (GetLengthPrefixedSlice(&input, &key) &&\n            GetLengthPrefixedSlice(&input, &value)) {\n          handler->Put(key, value);\n        } else {\n          return Status::Corruption(\"bad WriteBatch Put\");\n        }\n        break;\n      case kTypeDeletion:\n        if (GetLengthPrefixedSlice(&input, &key)) {\n          handler->Delete(key);\n        } else {\n          return Status::Corruption(\"bad WriteBatch Delete\");\n        }\n        break;\n      default:\n        return Status::Corruption(\"unknown WriteBatch tag\");\n    }\n  }\n  if (found != WriteBatchInternal::Count(this)) {\n    return Status::Corruption(\"WriteBatch has wrong count\");\n  } else {\n    return Status::OK();\n  }\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatch {\n  Status WriteBatch::Iterate(Handler* handler) const {\n    Slice input(rep_);\n    if (input.size() < kHeader) {\n      return Status::Corruption(\"malformed WriteBatch (too small)\");\n    }\n  \n    input.remove_prefix(kHeader);\n    Slice key, value;\n    int found = 0;\n    while (!input.empty()) {\n      found++;\n      char tag = input[0];\n      input.remove_prefix(1);\n      switch (tag) {\n        case kTypeValue:\n          if (GetLengthPrefixedSlice(&input, &key) &&\n              GetLengthPrefixedSlice(&input, &value)) {\n            handler->Put(key, value);\n          } else {\n            return Status::Corruption(\"bad WriteBatch Put\");\n          }\n          break;\n        case kTypeDeletion:\n          if (GetLengthPrefixedSlice(&input, &key)) {\n            handler->Delete(key);\n          } else {\n            return Status::Corruption(\"bad WriteBatch Delete\");\n          }\n          break;\n        default:\n          return Status::Corruption(\"unknown WriteBatch tag\");\n      }\n    }\n    if (found != WriteBatchInternal::Count(this)) {\n      return Status::Corruption(\"WriteBatch has wrong count\");\n    } else {\n      return Status::OK();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.str",
          "args": [],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "str",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "789-792",
          "snippet": "std::string str() const\n    {\n        return (std::string(begin(), end()));\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  std::string str() const\n      {\n          return (std::string(begin(), end()));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "activeBatch"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ScanBatch(const CDataStream &key, string *value, bool *deleted) const {\n      assert(activeBatch);\n      *deleted = false;\n      CBatchScanner scanner;\n      scanner.needle = key.str();\n      scanner.deleted = deleted;\n      scanner.foundValue = value;\n      leveldb::Status status = activeBatch->Iterate(&scanner);\n      if (!status.ok()) {\n          throw runtime_error(status.ToString());\n      }\n      return scanner.foundEntry;\n  }\n}"
  },
  {
    "function_name": "Delete",
    "container": "CBatchScanner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "172-177",
    "snippet": "virtual void Delete(const leveldb::Slice& key) {\n        if (key.ToString() == needle) {\n            foundEntry = true;\n            *deleted = true;\n        }\n    }",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key.ToString",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCBatchScanner {\n  virtual void Delete(const leveldb::Slice& key) {\n          if (key.ToString() == needle) {\n              foundEntry = true;\n              *deleted = true;\n          }\n      }\n}"
  },
  {
    "function_name": "Put",
    "container": "CBatchScanner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "164-170",
    "snippet": "virtual void Put(const leveldb::Slice& key, const leveldb::Slice& value) {\n        if (key.ToString() == needle) {\n            foundEntry = true;\n            *deleted = false;\n            *foundValue = value.ToString();\n        }\n    }",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "value.ToString",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCBatchScanner {\n  virtual void Put(const leveldb::Slice& key, const leveldb::Slice& value) {\n          if (key.ToString() == needle) {\n              foundEntry = true;\n              *deleted = false;\n              *foundValue = value.ToString();\n          }\n      }\n}"
  },
  {
    "function_name": "CBatchScanner",
    "container": "CBatchScanner",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "162-162",
    "snippet": "CBatchScanner() : foundEntry(false) {}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCBatchScanner {\n  CBatchScanner() : foundEntry(false) {}\n}"
  },
  {
    "function_name": "TxnCommit",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "142-153",
    "snippet": "bool CTxDB::TxnCommit()\n{\n    assert(activeBatch);\n    leveldb::Status status = pdb->Write(leveldb::WriteOptions(), activeBatch);\n    delete activeBatch;\n    activeBatch = NULL;\n    if (!status.ok()) {\n        printf(\"LevelDB batch commit failure: %s\\n\", status.ToString().c_str());\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"LevelDB batch commit failure: %s\\n\"",
            "status.ToString().c_str()"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pdb->Write",
          "args": [
            "leveldb::WriteOptions()",
            "activeBatch"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::WriteOptions",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "activeBatch"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::TxnCommit()\n  {\n      assert(activeBatch);\n      leveldb::Status status = pdb->Write(leveldb::WriteOptions(), activeBatch);\n      delete activeBatch;\n      activeBatch = NULL;\n      if (!status.ok()) {\n          printf(\"LevelDB batch commit failure: %s\\n\", status.ToString().c_str());\n          return false;\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "TxnBegin",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "135-140",
    "snippet": "bool CTxDB::TxnBegin()\n{\n    assert(!activeBatch);\n    activeBatch = new leveldb::WriteBatch();\n    return true;\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!activeBatch"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::TxnBegin()\n  {\n      assert(!activeBatch);\n      activeBatch = new leveldb::WriteBatch();\n      return true;\n  }\n}"
  },
  {
    "function_name": "Close",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "123-133",
    "snippet": "void CTxDB::Close()\n{\n    delete txdb;\n    txdb = pdb = NULL;\n    delete options.filter_policy;\n    options.filter_policy = NULL;\n    delete options.block_cache;\n    options.block_cache = NULL;\n    delete activeBatch;\n    activeBatch = NULL;\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [
      "leveldb::DB *txdb;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nleveldb::DB *txdb;\n\nCTxDB {\n  void CTxDB::Close()\n  {\n      delete txdb;\n      txdb = pdb = NULL;\n      delete options.filter_policy;\n      options.filter_policy = NULL;\n      delete options.block_cache;\n      options.block_cache = NULL;\n      delete activeBatch;\n      activeBatch = NULL;\n  }\n}"
  },
  {
    "function_name": "CTxDB",
    "container": "CTxDB",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "68-121",
    "snippet": "CTxDB::CTxDB(const char* pszMode)\n{\n    assert(pszMode);\n    activeBatch = NULL;\n    fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n\n    if (txdb) {\n        pdb = txdb;\n        return;\n    }\n\n    bool fCreate = strchr(pszMode, 'c');\n\n    options = GetOptions();\n    options.create_if_missing = fCreate;\n    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n\n    init_blockindex(options); // Init directory\n    pdb = txdb;\n\n    if (Exists(string(\"version\")))\n    {\n        ReadVersion(nVersion);\n        printf(\"Transaction index version is %d\\n\", nVersion);\n\n        if (nVersion < DATABASE_VERSION)\n        {\n            printf(\"Required index version is %d, removing old database\\n\", DATABASE_VERSION);\n\n            // Leveldb instance destruction\n            delete txdb;\n            txdb = pdb = NULL;\n            delete activeBatch;\n            activeBatch = NULL;\n\n            init_blockindex(options, true); // Remove directory and create new database\n            pdb = txdb;\n\n            bool fTmp = fReadOnly;\n            fReadOnly = false;\n            WriteVersion(DATABASE_VERSION); // Save transaction index version\n            fReadOnly = fTmp;\n        }\n    }\n    else if (fCreate)\n    {\n        bool fTmp = fReadOnly;\n        fReadOnly = false;\n        WriteVersion(DATABASE_VERSION);\n        fReadOnly = fTmp;\n    }\n\n    printf(\"Opened LevelDB successfully\\n\");\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [
      "leveldb::DB *txdb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Opened LevelDB successfully\\n\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteVersion",
          "args": [
            "DATABASE_VERSION"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "WriteVersion",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "181-184",
          "snippet": "bool WriteVersion(int nVersion)\n    {\n        return Write(std::string(\"version\"), nVersion);\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool WriteVersion(int nVersion)\n      {\n          return Write(std::string(\"version\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_blockindex",
          "args": [
            "options",
            "true"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Required index version is %d, removing old database\\n\"",
            "DATABASE_VERSION"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadVersion",
          "args": [
            "nVersion"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "ReadVersion",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "175-179",
          "snippet": "bool ReadVersion(int& nVersion)\n    {\n        nVersion = 0;\n        return Read(std::string(\"version\"), nVersion);\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool ReadVersion(int& nVersion)\n      {\n          nVersion = 0;\n          return Read(std::string(\"version\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Exists",
          "args": [
            "string(\"version\")"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "Exists",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "145-162",
          "snippet": "bool Exists(const K& key)\n    {\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        std::string unused;\n\n        if (activeBatch) {\n            bool deleted;\n            if (ScanBatch(ssKey, &unused, &deleted) && !deleted) {\n                return true;\n            }\n        }\n\n\n        leveldb::Status status = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &unused);\n        return status.IsNotFound() == false;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Exists(const K& key)\n      {\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          std::string unused;\n  \n          if (activeBatch) {\n              bool deleted;\n              if (ScanBatch(ssKey, &unused, &deleted) && !deleted) {\n                  return true;\n              }\n          }\n  \n  \n          leveldb::Status status = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &unused);\n          return status.IsNotFound() == false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"version\""
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "init_blockindex",
          "args": [
            "options"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "init_blockindex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "36-64",
          "snippet": "void init_blockindex(leveldb::Options& options, bool fRemoveOld = false) {\n    // First time init.\n    filesystem::path directory = GetDataDir() / \"txleveldb\";\n\n    if (fRemoveOld) {\n        filesystem::remove_all(directory); // remove directory\n        unsigned int nFile = 1;\n\n        while (true)\n        {\n            filesystem::path strBlockFile = GetDataDir() / strprintf(\"blk%04u.dat\", nFile);\n\n            // Break if no such file\n            if( !filesystem::exists( strBlockFile ) )\n                break;\n\n            filesystem::remove(strBlockFile);\n\n            nFile++;\n        }\n    }\n\n    filesystem::create_directory(directory);\n    printf(\"Opening LevelDB in %s\\n\", directory.string().c_str());\n    leveldb::Status status = leveldb::DB::Open(options, directory.string(), &txdb);\n    if (!status.ok()) {\n        throw runtime_error(strprintf(\"init_blockindex(): error opening database environment %s\", status.ToString().c_str()));\n    }\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [
            "leveldb::DB *txdb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nleveldb::DB *txdb;\n\nvoid init_blockindex(leveldb::Options& options, bool fRemoveOld = false) {\n    // First time init.\n    filesystem::path directory = GetDataDir() / \"txleveldb\";\n\n    if (fRemoveOld) {\n        filesystem::remove_all(directory); // remove directory\n        unsigned int nFile = 1;\n\n        while (true)\n        {\n            filesystem::path strBlockFile = GetDataDir() / strprintf(\"blk%04u.dat\", nFile);\n\n            // Break if no such file\n            if( !filesystem::exists( strBlockFile ) )\n                break;\n\n            filesystem::remove(strBlockFile);\n\n            nFile++;\n        }\n    }\n\n    filesystem::create_directory(directory);\n    printf(\"Opening LevelDB in %s\\n\", directory.string().c_str());\n    leveldb::Status status = leveldb::DB::Open(options, directory.string(), &txdb);\n    if (!status.ok()) {\n        throw runtime_error(strprintf(\"init_blockindex(): error opening database environment %s\", status.ToString().c_str()));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::NewBloomFilterPolicy",
          "args": [
            "10"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetOptions",
          "args": [],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "GetOptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "28-34",
          "snippet": "static leveldb::Options GetOptions() {\n    leveldb::Options options;\n    int nCacheSizeMB = GetArg(\"-dbcache\", 25);\n    options.block_cache = leveldb::NewLRUCache(nCacheSizeMB * 1048576);\n    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n    return options;\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nstatic leveldb::Options GetOptions() {\n    leveldb::Options options;\n    int nCacheSizeMB = GetArg(\"-dbcache\", 25);\n    options.block_cache = leveldb::NewLRUCache(nCacheSizeMB * 1048576);\n    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n    return options;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pszMode",
            "'c'"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pszMode",
            "'w'"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "pszMode",
            "'+'"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pszMode"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nleveldb::DB *txdb;\n\nCTxDB {\n  CTxDB::CTxDB(const char* pszMode)\n  {\n      assert(pszMode);\n      activeBatch = NULL;\n      fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n  \n      if (txdb) {\n          pdb = txdb;\n          return;\n      }\n  \n      bool fCreate = strchr(pszMode, 'c');\n  \n      options = GetOptions();\n      options.create_if_missing = fCreate;\n      options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n  \n      init_blockindex(options); // Init directory\n      pdb = txdb;\n  \n      if (Exists(string(\"version\")))\n      {\n          ReadVersion(nVersion);\n          printf(\"Transaction index version is %d\\n\", nVersion);\n  \n          if (nVersion < DATABASE_VERSION)\n          {\n              printf(\"Required index version is %d, removing old database\\n\", DATABASE_VERSION);\n  \n              // Leveldb instance destruction\n              delete txdb;\n              txdb = pdb = NULL;\n              delete activeBatch;\n              activeBatch = NULL;\n  \n              init_blockindex(options, true); // Remove directory and create new database\n              pdb = txdb;\n  \n              bool fTmp = fReadOnly;\n              fReadOnly = false;\n              WriteVersion(DATABASE_VERSION); // Save transaction index version\n              fReadOnly = fTmp;\n          }\n      }\n      else if (fCreate)\n      {\n          bool fTmp = fReadOnly;\n          fReadOnly = false;\n          WriteVersion(DATABASE_VERSION);\n          fReadOnly = fTmp;\n      }\n  \n      printf(\"Opened LevelDB successfully\\n\");\n  }\n}"
  },
  {
    "function_name": "init_blockindex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "36-64",
    "snippet": "void init_blockindex(leveldb::Options& options, bool fRemoveOld = false) {\n    // First time init.\n    filesystem::path directory = GetDataDir() / \"txleveldb\";\n\n    if (fRemoveOld) {\n        filesystem::remove_all(directory); // remove directory\n        unsigned int nFile = 1;\n\n        while (true)\n        {\n            filesystem::path strBlockFile = GetDataDir() / strprintf(\"blk%04u.dat\", nFile);\n\n            // Break if no such file\n            if( !filesystem::exists( strBlockFile ) )\n                break;\n\n            filesystem::remove(strBlockFile);\n\n            nFile++;\n        }\n    }\n\n    filesystem::create_directory(directory);\n    printf(\"Opening LevelDB in %s\\n\", directory.string().c_str());\n    leveldb::Status status = leveldb::DB::Open(options, directory.string(), &txdb);\n    if (!status.ok()) {\n        throw runtime_error(strprintf(\"init_blockindex(): error opening database environment %s\", status.ToString().c_str()));\n    }\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [
      "leveldb::DB *txdb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "strprintf(\"init_blockindex(): error opening database environment %s\", status.ToString().c_str())"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"init_blockindex(): error opening database environment %s\"",
            "status.ToString().c_str()"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "status.ok",
          "args": [],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::DB::Open",
          "args": [
            "options",
            "directory.string()",
            "&txdb"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1445-1477",
          "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "directory.string",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directory.string",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "directory.string",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::create_directory",
          "args": [
            "directory"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::remove",
          "args": [
            "strBlockFile"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::exists",
          "args": [
            "strBlockFile"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filesystem::remove_all",
          "args": [
            "directory"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nleveldb::DB *txdb;\n\nvoid init_blockindex(leveldb::Options& options, bool fRemoveOld = false) {\n    // First time init.\n    filesystem::path directory = GetDataDir() / \"txleveldb\";\n\n    if (fRemoveOld) {\n        filesystem::remove_all(directory); // remove directory\n        unsigned int nFile = 1;\n\n        while (true)\n        {\n            filesystem::path strBlockFile = GetDataDir() / strprintf(\"blk%04u.dat\", nFile);\n\n            // Break if no such file\n            if( !filesystem::exists( strBlockFile ) )\n                break;\n\n            filesystem::remove(strBlockFile);\n\n            nFile++;\n        }\n    }\n\n    filesystem::create_directory(directory);\n    printf(\"Opening LevelDB in %s\\n\", directory.string().c_str());\n    leveldb::Status status = leveldb::DB::Open(options, directory.string(), &txdb);\n    if (!status.ok()) {\n        throw runtime_error(strprintf(\"init_blockindex(): error opening database environment %s\", status.ToString().c_str()));\n    }\n}"
  },
  {
    "function_name": "GetOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
    "lines": "28-34",
    "snippet": "static leveldb::Options GetOptions() {\n    leveldb::Options options;\n    int nCacheSizeMB = GetArg(\"-dbcache\", 25);\n    options.block_cache = leveldb::NewLRUCache(nCacheSizeMB * 1048576);\n    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n    return options;\n}",
    "includes": [
      "#include \"main.h\"",
      "#include \"util.h\"",
      "#include \"txdb.h\"",
      "#include \"checkpoints.h\"",
      "#include \"kernel.h\"",
      "#include <memenv/memenv.h>",
      "#include <leveldb/filter_policy.h>",
      "#include <leveldb/cache.h>",
      "#include <leveldb/env.h>",
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/version.hpp>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leveldb::NewBloomFilterPolicy",
          "args": [
            "10"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::NewLRUCache",
          "args": [
            "nCacheSizeMB * 1048576"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-dbcache\"",
            "25"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nstatic leveldb::Options GetOptions() {\n    leveldb::Options options;\n    int nCacheSizeMB = GetArg(\"-dbcache\", 25);\n    options.block_cache = leveldb::NewLRUCache(nCacheSizeMB * 1048576);\n    options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n    return options;\n}"
  }
]