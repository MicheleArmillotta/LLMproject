[
  {
    "function_name": "gotoBlockExplorer",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "333-338",
    "snippet": "void BlockExplorer::gotoBlockExplorer(QString TxID) {\n\n    if(!TxID.isEmpty()) setTxID(TxID);\n\n    show();\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show",
          "args": [],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "on_showQRCode_clicked",
          "container": "AddressBookPage",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/addressbookpage.cpp",
          "lines": "336-353",
          "snippet": "void AddressBookPage::on_showQRCode_clicked()\n{\n#ifdef USE_QRCODE\n    QTableView *table = ui->tableView;\n    QModelIndexList indexes = table->selectionModel()->selectedRows(AddressTableModel::Address);\n\n    foreach (QModelIndex index, indexes)\n    {\n        QString address = index.data().toString(), label = index.sibling(index.row(), 0).data(Qt::EditRole).toString();\n\n        QRCodeDialog *dialog = new QRCodeDialog(address, label, tab == ReceivingTab, this);\n        if(optionsModel)\n            dialog->setModel(optionsModel);\n        dialog->setAttribute(Qt::WA_DeleteOnClose);\n        dialog->show();\n    }\n#endif\n}",
          "includes": [
            "#include \"qrcodedialog.h\"",
            "#include <QMenu>",
            "#include <QMessageBox>",
            "#include <QClipboard>",
            "#include <QSortFilterProxyModel>",
            "#include \"guiutil.h\"",
            "#include \"csvmodelwriter.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"bitcoingui.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"ui_addressbookpage.h\"",
            "#include \"addressbookpage.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qrcodedialog.h\"\n#include <QMenu>\n#include <QMessageBox>\n#include <QClipboard>\n#include <QSortFilterProxyModel>\n#include \"guiutil.h\"\n#include \"csvmodelwriter.h\"\n#include \"editaddressdialog.h\"\n#include \"bitcoingui.h\"\n#include \"optionsmodel.h\"\n#include \"addresstablemodel.h\"\n#include \"ui_addressbookpage.h\"\n#include \"addressbookpage.h\"\n\nAddressBookPage {\n  void AddressBookPage::on_showQRCode_clicked()\n  {\n  #ifdef USE_QRCODE\n      QTableView *table = ui->tableView;\n      QModelIndexList indexes = table->selectionModel()->selectedRows(AddressTableModel::Address);\n  \n      foreach (QModelIndex index, indexes)\n      {\n          QString address = index.data().toString(), label = index.sibling(index.row(), 0).data(Qt::EditRole).toString();\n  \n          QRCodeDialog *dialog = new QRCodeDialog(address, label, tab == ReceivingTab, this);\n          if(optionsModel)\n              dialog->setModel(optionsModel);\n          dialog->setAttribute(Qt::WA_DeleteOnClose);\n          dialog->show();\n      }\n  #endif\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTxID",
          "args": [
            "TxID"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "setTxID",
          "container": "BlockExplorer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "297-315",
          "snippet": "void BlockExplorer::setTxID(const QString &TxID) {\n    ui->txLine->setText(TxID);\n    ui->txLine->setFocus();\n    updateExplorer(false);\n\n    uint256 hash;\n    hash.SetHex(TxID.toStdString());\n\n    CTransaction tx;\n    uint256 hashBlock = 0;\n    if(GetTransaction(hash, tx, hashBlock)) {\n        CBlockIndex *pindex = mapBlockIndex[hashBlock];\n        if(!pindex)\n          ui->numberBox->setValue(nBestHeight);\n        else\n          ui->numberBox->setValue(pindex->nHeight);\n        updateExplorer(true);\n    }\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "double GetDifficulty(const CBlockIndex *pindex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\ndouble GetDifficulty(const CBlockIndex *pindex);\n\nBlockExplorer {\n  void BlockExplorer::setTxID(const QString &TxID) {\n      ui->txLine->setText(TxID);\n      ui->txLine->setFocus();\n      updateExplorer(false);\n  \n      uint256 hash;\n      hash.SetHex(TxID.toStdString());\n  \n      CTransaction tx;\n      uint256 hashBlock = 0;\n      if(GetTransaction(hash, tx, hashBlock)) {\n          CBlockIndex *pindex = mapBlockIndex[hashBlock];\n          if(!pindex)\n            ui->numberBox->setValue(nBestHeight);\n          else\n            ui->numberBox->setValue(pindex->nHeight);\n          updateExplorer(true);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TxID.isEmpty",
          "args": [],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  void BlockExplorer::gotoBlockExplorer(QString TxID) {\n  \n      if(!TxID.isEmpty()) setTxID(TxID);\n  \n      show();\n  }\n}"
  },
  {
    "function_name": "~BlockExplorer",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "329-331",
    "snippet": "BlockExplorer::~BlockExplorer() {\n    delete(ui);\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  BlockExplorer::~BlockExplorer() {\n      delete(ui);\n  }\n}"
  },
  {
    "function_name": "setClientModel",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "325-327",
    "snippet": "void BlockExplorer::setClientModel(ClientModel *model) {\n    this->clientModel = model;\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  void BlockExplorer::setClientModel(ClientModel *model) {\n      this->clientModel = model;\n  }\n}"
  },
  {
    "function_name": "blockClicked",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "321-323",
    "snippet": "void BlockExplorer::blockClicked() {\n    updateExplorer(true);\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "updateExplorer",
          "args": [
            "true"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "updateExplorer",
          "container": "BlockExplorer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "104-295",
          "snippet": "void BlockExplorer::updateExplorer(bool block) {\n    uchar data[32];\n    uint256 hash;\n    uint i, j;\n\n    if(block) {\n\n        int nHeight = ui->numberBox->value();\n        if(nHeight > pindexBest->nHeight) {\n            ui->numberBox->setValue(pindexBest->nHeight);\n            nHeight = pindexBest->nHeight;\n        }\n\n        const CBlockIndex *pindex = getBlockIndex(nHeight);\n        CBlock block;\n\n        if(!pindex || !block.ReadFromDisk(pindex, true)) {\n            setBlockError(ui);\n            return;\n        }\n\n        ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n          .arg(QString::number(block.nVersion)) \\\n          .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n          .arg(QString::number(nHeight)) \\\n          .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n\n        hash = pindex->GetBlockHash();\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        hash = pindex->hashMerkleRoot;\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        if(pindex->IsProofOfWork()) {\n            hash = block.vtx[0].GetHash();\n            ui->baseText->setText(tr(\"Coin base:\"));\n            ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n            ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n              .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n        } else {\n            hash = block.vtx[1].GetHash();\n            ui->baseText->setText(tr(\"Coin stake:\"));\n            ui->diffText->setText(tr(\"Difficulty, target:\"));\n            ui->diffData->setText(QString(\"%1  0x%2\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')));\n        }\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n\n        /* List of payments */\n        std::string strTx = \"\";\n        for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n            hash = block.vtx[i].GetHash();\n\n            strTx.append(hash.ToString());\n            strTx.append(\"\\n\");\n\n            for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                const CTxOut &txout = block.vtx[i].vout[j];\n\n                CTxDestination address;\n                if(!ExtractDestination(txout.scriptPubKey, address))\n                  address = CNoDestination();\n\n                strTx.append(CBitcoinAddress(address).ToString());\n                strTx.append(\"  \");\n                strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                strTx.append(\" HAL\\n\");\n            }\n            strTx.append(\"\\n\");\n        }\n        ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n\n    } else {\n\n        std::string TxID = ui->txLine->text().toUtf8().constData();\n        ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n\n        int nHeight = 0;\n        int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n        uint256 hash;\n        hash.SetHex(TxID);\n\n        CTransaction tx;\n        uint256 hashBlock = 0;\n        if(!GetTransaction(hash, tx, hashBlock)) {\n            setTxError(ui);\n            return;\n        }\n\n        map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n        if(mi != mapBlockIndex.end() && (*mi).second) {\n             CBlockIndex *pindex = (*mi).second;\n             if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n        }\n\n        if(nHeight) {\n            ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n              .arg(QString::number(nHeight)));\n        } else {\n            ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n        }\n\n        /* List of inputs */\n        std::string strIn = \"\";\n        for(i = 0; i < tx.vin.size(); i++) {\n            int64 nCurrentValueIn = 0;\n            uint256 hash_in, hashBlock_in = 0;\n            const CTxIn &vin = tx.vin[i];\n\n            hash_in = vin.prevout.hash;\n            CTransaction txPrev;\n            if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n              continue;\n\n            CTxDestination address;\n            if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n            nValueIn += nCurrentValueIn;\n\n            strIn.append(hash_in.ToString());\n            strIn.append(\"-\");\n            strIn.append(boost::to_string(vin.prevout.n));\n            strIn.append(\"\\n\");\n            strIn.append(CBitcoinAddress(address).ToString());\n            strIn.append(\"  \");\n            strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n            strIn.append(\" HAL\\n\\n\");\n        }\n        if(!strIn.size()) strIn.append(\"N/A\");\n        ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n\n        /* List of outputs */\n        std::string strOut = \"\";\n        for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n            int64 nCurrentValueOut = 0;\n            const CTxOut &txout = tx.vout[i];\n\n            CTxDestination address;\n            if(!ExtractDestination(txout.scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueOut = txout.nValue;\n            nValueOut += nCurrentValueOut;\n\n            strOut.append(CBitcoinAddress(address).ToString());\n            strOut.append(\"  \");\n            strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n            strOut.append(\" HAL\\n\");\n        }\n        ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n\n        ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n\n        if(tx.IsCoinBase() || tx.IsCoinStake()) {\n            int64 nSubsidy = 0;\n\n            if(tx.IsCoinBase())\n              nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n            else {\n                uint64_t nCoinAge;\n                CTxDB txdb(\"r\");\n                tx.GetCoinAge(txdb, nCoinAge);\n                nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n            }\n\n            nFees = nValueOut - nValueIn - nSubsidy;\n            ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n            ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n              .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n              .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n        } else {\n            nFees = nValueIn - nValueOut;\n            ui->feeText->setText(QString(tr(\"Fee paid:\")));\n            ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n        }\n\n    }\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "double GetDifficulty(const CBlockIndex *pindex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\ndouble GetDifficulty(const CBlockIndex *pindex);\n\nBlockExplorer {\n  void BlockExplorer::updateExplorer(bool block) {\n      uchar data[32];\n      uint256 hash;\n      uint i, j;\n  \n      if(block) {\n  \n          int nHeight = ui->numberBox->value();\n          if(nHeight > pindexBest->nHeight) {\n              ui->numberBox->setValue(pindexBest->nHeight);\n              nHeight = pindexBest->nHeight;\n          }\n  \n          const CBlockIndex *pindex = getBlockIndex(nHeight);\n          CBlock block;\n  \n          if(!pindex || !block.ReadFromDisk(pindex, true)) {\n              setBlockError(ui);\n              return;\n          }\n  \n          ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n            .arg(QString::number(block.nVersion)) \\\n            .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n            .arg(QString::number(nHeight)) \\\n            .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n  \n          hash = pindex->GetBlockHash();\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          hash = pindex->hashMerkleRoot;\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          if(pindex->IsProofOfWork()) {\n              hash = block.vtx[0].GetHash();\n              ui->baseText->setText(tr(\"Coin base:\"));\n              ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n              ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n                .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n          } else {\n              hash = block.vtx[1].GetHash();\n              ui->baseText->setText(tr(\"Coin stake:\"));\n              ui->diffText->setText(tr(\"Difficulty, target:\"));\n              ui->diffData->setText(QString(\"%1  0x%2\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')));\n          }\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n  \n          /* List of payments */\n          std::string strTx = \"\";\n          for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n              hash = block.vtx[i].GetHash();\n  \n              strTx.append(hash.ToString());\n              strTx.append(\"\\n\");\n  \n              for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                  const CTxOut &txout = block.vtx[i].vout[j];\n  \n                  CTxDestination address;\n                  if(!ExtractDestination(txout.scriptPubKey, address))\n                    address = CNoDestination();\n  \n                  strTx.append(CBitcoinAddress(address).ToString());\n                  strTx.append(\"  \");\n                  strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                  strTx.append(\" HAL\\n\");\n              }\n              strTx.append(\"\\n\");\n          }\n          ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n  \n      } else {\n  \n          std::string TxID = ui->txLine->text().toUtf8().constData();\n          ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n  \n          int nHeight = 0;\n          int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n          uint256 hash;\n          hash.SetHex(TxID);\n  \n          CTransaction tx;\n          uint256 hashBlock = 0;\n          if(!GetTransaction(hash, tx, hashBlock)) {\n              setTxError(ui);\n              return;\n          }\n  \n          map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n          if(mi != mapBlockIndex.end() && (*mi).second) {\n               CBlockIndex *pindex = (*mi).second;\n               if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n          }\n  \n          if(nHeight) {\n              ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n                .arg(QString::number(nHeight)));\n          } else {\n              ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n          }\n  \n          /* List of inputs */\n          std::string strIn = \"\";\n          for(i = 0; i < tx.vin.size(); i++) {\n              int64 nCurrentValueIn = 0;\n              uint256 hash_in, hashBlock_in = 0;\n              const CTxIn &vin = tx.vin[i];\n  \n              hash_in = vin.prevout.hash;\n              CTransaction txPrev;\n              if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n                continue;\n  \n              CTxDestination address;\n              if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n              nValueIn += nCurrentValueIn;\n  \n              strIn.append(hash_in.ToString());\n              strIn.append(\"-\");\n              strIn.append(boost::to_string(vin.prevout.n));\n              strIn.append(\"\\n\");\n              strIn.append(CBitcoinAddress(address).ToString());\n              strIn.append(\"  \");\n              strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n              strIn.append(\" HAL\\n\\n\");\n          }\n          if(!strIn.size()) strIn.append(\"N/A\");\n          ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n  \n          /* List of outputs */\n          std::string strOut = \"\";\n          for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n              int64 nCurrentValueOut = 0;\n              const CTxOut &txout = tx.vout[i];\n  \n              CTxDestination address;\n              if(!ExtractDestination(txout.scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueOut = txout.nValue;\n              nValueOut += nCurrentValueOut;\n  \n              strOut.append(CBitcoinAddress(address).ToString());\n              strOut.append(\"  \");\n              strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n              strOut.append(\" HAL\\n\");\n          }\n          ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n  \n          ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n  \n          if(tx.IsCoinBase() || tx.IsCoinStake()) {\n              int64 nSubsidy = 0;\n  \n              if(tx.IsCoinBase())\n                nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n              else {\n                  uint64_t nCoinAge;\n                  CTxDB txdb(\"r\");\n                  tx.GetCoinAge(txdb, nCoinAge);\n                  nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n              }\n  \n              nFees = nValueOut - nValueIn - nSubsidy;\n              ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n              ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n                .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n                .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n          } else {\n              nFees = nValueIn - nValueOut;\n              ui->feeText->setText(QString(tr(\"Fee paid:\")));\n              ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n          }\n  \n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  void BlockExplorer::blockClicked() {\n      updateExplorer(true);\n  }\n}"
  },
  {
    "function_name": "txClicked",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "317-319",
    "snippet": "void BlockExplorer::txClicked() {\n    updateExplorer(false);\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "updateExplorer",
          "args": [
            "false"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "updateExplorer",
          "container": "BlockExplorer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "104-295",
          "snippet": "void BlockExplorer::updateExplorer(bool block) {\n    uchar data[32];\n    uint256 hash;\n    uint i, j;\n\n    if(block) {\n\n        int nHeight = ui->numberBox->value();\n        if(nHeight > pindexBest->nHeight) {\n            ui->numberBox->setValue(pindexBest->nHeight);\n            nHeight = pindexBest->nHeight;\n        }\n\n        const CBlockIndex *pindex = getBlockIndex(nHeight);\n        CBlock block;\n\n        if(!pindex || !block.ReadFromDisk(pindex, true)) {\n            setBlockError(ui);\n            return;\n        }\n\n        ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n          .arg(QString::number(block.nVersion)) \\\n          .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n          .arg(QString::number(nHeight)) \\\n          .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n\n        hash = pindex->GetBlockHash();\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        hash = pindex->hashMerkleRoot;\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        if(pindex->IsProofOfWork()) {\n            hash = block.vtx[0].GetHash();\n            ui->baseText->setText(tr(\"Coin base:\"));\n            ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n            ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n              .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n        } else {\n            hash = block.vtx[1].GetHash();\n            ui->baseText->setText(tr(\"Coin stake:\"));\n            ui->diffText->setText(tr(\"Difficulty, target:\"));\n            ui->diffData->setText(QString(\"%1  0x%2\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')));\n        }\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n\n        /* List of payments */\n        std::string strTx = \"\";\n        for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n            hash = block.vtx[i].GetHash();\n\n            strTx.append(hash.ToString());\n            strTx.append(\"\\n\");\n\n            for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                const CTxOut &txout = block.vtx[i].vout[j];\n\n                CTxDestination address;\n                if(!ExtractDestination(txout.scriptPubKey, address))\n                  address = CNoDestination();\n\n                strTx.append(CBitcoinAddress(address).ToString());\n                strTx.append(\"  \");\n                strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                strTx.append(\" HAL\\n\");\n            }\n            strTx.append(\"\\n\");\n        }\n        ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n\n    } else {\n\n        std::string TxID = ui->txLine->text().toUtf8().constData();\n        ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n\n        int nHeight = 0;\n        int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n        uint256 hash;\n        hash.SetHex(TxID);\n\n        CTransaction tx;\n        uint256 hashBlock = 0;\n        if(!GetTransaction(hash, tx, hashBlock)) {\n            setTxError(ui);\n            return;\n        }\n\n        map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n        if(mi != mapBlockIndex.end() && (*mi).second) {\n             CBlockIndex *pindex = (*mi).second;\n             if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n        }\n\n        if(nHeight) {\n            ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n              .arg(QString::number(nHeight)));\n        } else {\n            ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n        }\n\n        /* List of inputs */\n        std::string strIn = \"\";\n        for(i = 0; i < tx.vin.size(); i++) {\n            int64 nCurrentValueIn = 0;\n            uint256 hash_in, hashBlock_in = 0;\n            const CTxIn &vin = tx.vin[i];\n\n            hash_in = vin.prevout.hash;\n            CTransaction txPrev;\n            if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n              continue;\n\n            CTxDestination address;\n            if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n            nValueIn += nCurrentValueIn;\n\n            strIn.append(hash_in.ToString());\n            strIn.append(\"-\");\n            strIn.append(boost::to_string(vin.prevout.n));\n            strIn.append(\"\\n\");\n            strIn.append(CBitcoinAddress(address).ToString());\n            strIn.append(\"  \");\n            strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n            strIn.append(\" HAL\\n\\n\");\n        }\n        if(!strIn.size()) strIn.append(\"N/A\");\n        ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n\n        /* List of outputs */\n        std::string strOut = \"\";\n        for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n            int64 nCurrentValueOut = 0;\n            const CTxOut &txout = tx.vout[i];\n\n            CTxDestination address;\n            if(!ExtractDestination(txout.scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueOut = txout.nValue;\n            nValueOut += nCurrentValueOut;\n\n            strOut.append(CBitcoinAddress(address).ToString());\n            strOut.append(\"  \");\n            strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n            strOut.append(\" HAL\\n\");\n        }\n        ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n\n        ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n\n        if(tx.IsCoinBase() || tx.IsCoinStake()) {\n            int64 nSubsidy = 0;\n\n            if(tx.IsCoinBase())\n              nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n            else {\n                uint64_t nCoinAge;\n                CTxDB txdb(\"r\");\n                tx.GetCoinAge(txdb, nCoinAge);\n                nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n            }\n\n            nFees = nValueOut - nValueIn - nSubsidy;\n            ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n            ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n              .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n              .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n        } else {\n            nFees = nValueIn - nValueOut;\n            ui->feeText->setText(QString(tr(\"Fee paid:\")));\n            ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n        }\n\n    }\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "double GetDifficulty(const CBlockIndex *pindex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\ndouble GetDifficulty(const CBlockIndex *pindex);\n\nBlockExplorer {\n  void BlockExplorer::updateExplorer(bool block) {\n      uchar data[32];\n      uint256 hash;\n      uint i, j;\n  \n      if(block) {\n  \n          int nHeight = ui->numberBox->value();\n          if(nHeight > pindexBest->nHeight) {\n              ui->numberBox->setValue(pindexBest->nHeight);\n              nHeight = pindexBest->nHeight;\n          }\n  \n          const CBlockIndex *pindex = getBlockIndex(nHeight);\n          CBlock block;\n  \n          if(!pindex || !block.ReadFromDisk(pindex, true)) {\n              setBlockError(ui);\n              return;\n          }\n  \n          ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n            .arg(QString::number(block.nVersion)) \\\n            .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n            .arg(QString::number(nHeight)) \\\n            .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n  \n          hash = pindex->GetBlockHash();\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          hash = pindex->hashMerkleRoot;\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          if(pindex->IsProofOfWork()) {\n              hash = block.vtx[0].GetHash();\n              ui->baseText->setText(tr(\"Coin base:\"));\n              ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n              ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n                .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n          } else {\n              hash = block.vtx[1].GetHash();\n              ui->baseText->setText(tr(\"Coin stake:\"));\n              ui->diffText->setText(tr(\"Difficulty, target:\"));\n              ui->diffData->setText(QString(\"%1  0x%2\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')));\n          }\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n  \n          /* List of payments */\n          std::string strTx = \"\";\n          for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n              hash = block.vtx[i].GetHash();\n  \n              strTx.append(hash.ToString());\n              strTx.append(\"\\n\");\n  \n              for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                  const CTxOut &txout = block.vtx[i].vout[j];\n  \n                  CTxDestination address;\n                  if(!ExtractDestination(txout.scriptPubKey, address))\n                    address = CNoDestination();\n  \n                  strTx.append(CBitcoinAddress(address).ToString());\n                  strTx.append(\"  \");\n                  strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                  strTx.append(\" HAL\\n\");\n              }\n              strTx.append(\"\\n\");\n          }\n          ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n  \n      } else {\n  \n          std::string TxID = ui->txLine->text().toUtf8().constData();\n          ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n  \n          int nHeight = 0;\n          int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n          uint256 hash;\n          hash.SetHex(TxID);\n  \n          CTransaction tx;\n          uint256 hashBlock = 0;\n          if(!GetTransaction(hash, tx, hashBlock)) {\n              setTxError(ui);\n              return;\n          }\n  \n          map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n          if(mi != mapBlockIndex.end() && (*mi).second) {\n               CBlockIndex *pindex = (*mi).second;\n               if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n          }\n  \n          if(nHeight) {\n              ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n                .arg(QString::number(nHeight)));\n          } else {\n              ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n          }\n  \n          /* List of inputs */\n          std::string strIn = \"\";\n          for(i = 0; i < tx.vin.size(); i++) {\n              int64 nCurrentValueIn = 0;\n              uint256 hash_in, hashBlock_in = 0;\n              const CTxIn &vin = tx.vin[i];\n  \n              hash_in = vin.prevout.hash;\n              CTransaction txPrev;\n              if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n                continue;\n  \n              CTxDestination address;\n              if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n              nValueIn += nCurrentValueIn;\n  \n              strIn.append(hash_in.ToString());\n              strIn.append(\"-\");\n              strIn.append(boost::to_string(vin.prevout.n));\n              strIn.append(\"\\n\");\n              strIn.append(CBitcoinAddress(address).ToString());\n              strIn.append(\"  \");\n              strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n              strIn.append(\" HAL\\n\\n\");\n          }\n          if(!strIn.size()) strIn.append(\"N/A\");\n          ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n  \n          /* List of outputs */\n          std::string strOut = \"\";\n          for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n              int64 nCurrentValueOut = 0;\n              const CTxOut &txout = tx.vout[i];\n  \n              CTxDestination address;\n              if(!ExtractDestination(txout.scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueOut = txout.nValue;\n              nValueOut += nCurrentValueOut;\n  \n              strOut.append(CBitcoinAddress(address).ToString());\n              strOut.append(\"  \");\n              strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n              strOut.append(\" HAL\\n\");\n          }\n          ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n  \n          ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n  \n          if(tx.IsCoinBase() || tx.IsCoinStake()) {\n              int64 nSubsidy = 0;\n  \n              if(tx.IsCoinBase())\n                nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n              else {\n                  uint64_t nCoinAge;\n                  CTxDB txdb(\"r\");\n                  tx.GetCoinAge(txdb, nCoinAge);\n                  nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n              }\n  \n              nFees = nValueOut - nValueIn - nSubsidy;\n              ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n              ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n                .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n                .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n          } else {\n              nFees = nValueIn - nValueOut;\n              ui->feeText->setText(QString(tr(\"Fee paid:\")));\n              ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n          }\n  \n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  void BlockExplorer::txClicked() {\n      updateExplorer(false);\n  }\n}"
  },
  {
    "function_name": "setTxID",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "297-315",
    "snippet": "void BlockExplorer::setTxID(const QString &TxID) {\n    ui->txLine->setText(TxID);\n    ui->txLine->setFocus();\n    updateExplorer(false);\n\n    uint256 hash;\n    hash.SetHex(TxID.toStdString());\n\n    CTransaction tx;\n    uint256 hashBlock = 0;\n    if(GetTransaction(hash, tx, hashBlock)) {\n        CBlockIndex *pindex = mapBlockIndex[hashBlock];\n        if(!pindex)\n          ui->numberBox->setValue(nBestHeight);\n        else\n          ui->numberBox->setValue(pindex->nHeight);\n        updateExplorer(true);\n    }\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "double GetDifficulty(const CBlockIndex *pindex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "updateExplorer",
          "args": [
            "true"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "updateExplorer",
          "container": "BlockExplorer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "104-295",
          "snippet": "void BlockExplorer::updateExplorer(bool block) {\n    uchar data[32];\n    uint256 hash;\n    uint i, j;\n\n    if(block) {\n\n        int nHeight = ui->numberBox->value();\n        if(nHeight > pindexBest->nHeight) {\n            ui->numberBox->setValue(pindexBest->nHeight);\n            nHeight = pindexBest->nHeight;\n        }\n\n        const CBlockIndex *pindex = getBlockIndex(nHeight);\n        CBlock block;\n\n        if(!pindex || !block.ReadFromDisk(pindex, true)) {\n            setBlockError(ui);\n            return;\n        }\n\n        ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n          .arg(QString::number(block.nVersion)) \\\n          .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n          .arg(QString::number(nHeight)) \\\n          .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n\n        hash = pindex->GetBlockHash();\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        hash = pindex->hashMerkleRoot;\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        if(pindex->IsProofOfWork()) {\n            hash = block.vtx[0].GetHash();\n            ui->baseText->setText(tr(\"Coin base:\"));\n            ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n            ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n              .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n        } else {\n            hash = block.vtx[1].GetHash();\n            ui->baseText->setText(tr(\"Coin stake:\"));\n            ui->diffText->setText(tr(\"Difficulty, target:\"));\n            ui->diffData->setText(QString(\"%1  0x%2\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')));\n        }\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n\n        /* List of payments */\n        std::string strTx = \"\";\n        for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n            hash = block.vtx[i].GetHash();\n\n            strTx.append(hash.ToString());\n            strTx.append(\"\\n\");\n\n            for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                const CTxOut &txout = block.vtx[i].vout[j];\n\n                CTxDestination address;\n                if(!ExtractDestination(txout.scriptPubKey, address))\n                  address = CNoDestination();\n\n                strTx.append(CBitcoinAddress(address).ToString());\n                strTx.append(\"  \");\n                strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                strTx.append(\" HAL\\n\");\n            }\n            strTx.append(\"\\n\");\n        }\n        ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n\n    } else {\n\n        std::string TxID = ui->txLine->text().toUtf8().constData();\n        ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n\n        int nHeight = 0;\n        int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n        uint256 hash;\n        hash.SetHex(TxID);\n\n        CTransaction tx;\n        uint256 hashBlock = 0;\n        if(!GetTransaction(hash, tx, hashBlock)) {\n            setTxError(ui);\n            return;\n        }\n\n        map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n        if(mi != mapBlockIndex.end() && (*mi).second) {\n             CBlockIndex *pindex = (*mi).second;\n             if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n        }\n\n        if(nHeight) {\n            ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n              .arg(QString::number(nHeight)));\n        } else {\n            ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n        }\n\n        /* List of inputs */\n        std::string strIn = \"\";\n        for(i = 0; i < tx.vin.size(); i++) {\n            int64 nCurrentValueIn = 0;\n            uint256 hash_in, hashBlock_in = 0;\n            const CTxIn &vin = tx.vin[i];\n\n            hash_in = vin.prevout.hash;\n            CTransaction txPrev;\n            if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n              continue;\n\n            CTxDestination address;\n            if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n            nValueIn += nCurrentValueIn;\n\n            strIn.append(hash_in.ToString());\n            strIn.append(\"-\");\n            strIn.append(boost::to_string(vin.prevout.n));\n            strIn.append(\"\\n\");\n            strIn.append(CBitcoinAddress(address).ToString());\n            strIn.append(\"  \");\n            strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n            strIn.append(\" HAL\\n\\n\");\n        }\n        if(!strIn.size()) strIn.append(\"N/A\");\n        ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n\n        /* List of outputs */\n        std::string strOut = \"\";\n        for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n            int64 nCurrentValueOut = 0;\n            const CTxOut &txout = tx.vout[i];\n\n            CTxDestination address;\n            if(!ExtractDestination(txout.scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueOut = txout.nValue;\n            nValueOut += nCurrentValueOut;\n\n            strOut.append(CBitcoinAddress(address).ToString());\n            strOut.append(\"  \");\n            strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n            strOut.append(\" HAL\\n\");\n        }\n        ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n\n        ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n\n        if(tx.IsCoinBase() || tx.IsCoinStake()) {\n            int64 nSubsidy = 0;\n\n            if(tx.IsCoinBase())\n              nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n            else {\n                uint64_t nCoinAge;\n                CTxDB txdb(\"r\");\n                tx.GetCoinAge(txdb, nCoinAge);\n                nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n            }\n\n            nFees = nValueOut - nValueIn - nSubsidy;\n            ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n            ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n              .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n              .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n        } else {\n            nFees = nValueIn - nValueOut;\n            ui->feeText->setText(QString(tr(\"Fee paid:\")));\n            ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n        }\n\n    }\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "double GetDifficulty(const CBlockIndex *pindex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\ndouble GetDifficulty(const CBlockIndex *pindex);\n\nBlockExplorer {\n  void BlockExplorer::updateExplorer(bool block) {\n      uchar data[32];\n      uint256 hash;\n      uint i, j;\n  \n      if(block) {\n  \n          int nHeight = ui->numberBox->value();\n          if(nHeight > pindexBest->nHeight) {\n              ui->numberBox->setValue(pindexBest->nHeight);\n              nHeight = pindexBest->nHeight;\n          }\n  \n          const CBlockIndex *pindex = getBlockIndex(nHeight);\n          CBlock block;\n  \n          if(!pindex || !block.ReadFromDisk(pindex, true)) {\n              setBlockError(ui);\n              return;\n          }\n  \n          ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n            .arg(QString::number(block.nVersion)) \\\n            .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n            .arg(QString::number(nHeight)) \\\n            .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n  \n          hash = pindex->GetBlockHash();\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          hash = pindex->hashMerkleRoot;\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          if(pindex->IsProofOfWork()) {\n              hash = block.vtx[0].GetHash();\n              ui->baseText->setText(tr(\"Coin base:\"));\n              ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n              ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n                .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n          } else {\n              hash = block.vtx[1].GetHash();\n              ui->baseText->setText(tr(\"Coin stake:\"));\n              ui->diffText->setText(tr(\"Difficulty, target:\"));\n              ui->diffData->setText(QString(\"%1  0x%2\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')));\n          }\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n  \n          /* List of payments */\n          std::string strTx = \"\";\n          for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n              hash = block.vtx[i].GetHash();\n  \n              strTx.append(hash.ToString());\n              strTx.append(\"\\n\");\n  \n              for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                  const CTxOut &txout = block.vtx[i].vout[j];\n  \n                  CTxDestination address;\n                  if(!ExtractDestination(txout.scriptPubKey, address))\n                    address = CNoDestination();\n  \n                  strTx.append(CBitcoinAddress(address).ToString());\n                  strTx.append(\"  \");\n                  strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                  strTx.append(\" HAL\\n\");\n              }\n              strTx.append(\"\\n\");\n          }\n          ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n  \n      } else {\n  \n          std::string TxID = ui->txLine->text().toUtf8().constData();\n          ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n  \n          int nHeight = 0;\n          int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n          uint256 hash;\n          hash.SetHex(TxID);\n  \n          CTransaction tx;\n          uint256 hashBlock = 0;\n          if(!GetTransaction(hash, tx, hashBlock)) {\n              setTxError(ui);\n              return;\n          }\n  \n          map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n          if(mi != mapBlockIndex.end() && (*mi).second) {\n               CBlockIndex *pindex = (*mi).second;\n               if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n          }\n  \n          if(nHeight) {\n              ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n                .arg(QString::number(nHeight)));\n          } else {\n              ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n          }\n  \n          /* List of inputs */\n          std::string strIn = \"\";\n          for(i = 0; i < tx.vin.size(); i++) {\n              int64 nCurrentValueIn = 0;\n              uint256 hash_in, hashBlock_in = 0;\n              const CTxIn &vin = tx.vin[i];\n  \n              hash_in = vin.prevout.hash;\n              CTransaction txPrev;\n              if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n                continue;\n  \n              CTxDestination address;\n              if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n              nValueIn += nCurrentValueIn;\n  \n              strIn.append(hash_in.ToString());\n              strIn.append(\"-\");\n              strIn.append(boost::to_string(vin.prevout.n));\n              strIn.append(\"\\n\");\n              strIn.append(CBitcoinAddress(address).ToString());\n              strIn.append(\"  \");\n              strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n              strIn.append(\" HAL\\n\\n\");\n          }\n          if(!strIn.size()) strIn.append(\"N/A\");\n          ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n  \n          /* List of outputs */\n          std::string strOut = \"\";\n          for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n              int64 nCurrentValueOut = 0;\n              const CTxOut &txout = tx.vout[i];\n  \n              CTxDestination address;\n              if(!ExtractDestination(txout.scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueOut = txout.nValue;\n              nValueOut += nCurrentValueOut;\n  \n              strOut.append(CBitcoinAddress(address).ToString());\n              strOut.append(\"  \");\n              strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n              strOut.append(\" HAL\\n\");\n          }\n          ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n  \n          ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n  \n          if(tx.IsCoinBase() || tx.IsCoinStake()) {\n              int64 nSubsidy = 0;\n  \n              if(tx.IsCoinBase())\n                nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n              else {\n                  uint64_t nCoinAge;\n                  CTxDB txdb(\"r\");\n                  tx.GetCoinAge(txdb, nCoinAge);\n                  nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n              }\n  \n              nFees = nValueOut - nValueIn - nSubsidy;\n              ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n              ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n                .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n                .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n          } else {\n              nFees = nValueIn - nValueOut;\n              ui->feeText->setText(QString(tr(\"Fee paid:\")));\n              ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n          }\n  \n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ui->numberBox->setValue",
          "args": [
            "pindex->nHeight"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "SendCoinsEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/sendcoinsentry.cpp",
          "lines": "150-155",
          "snippet": "void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n{\n    ui->payTo->setText(value.address);\n    ui->addAsLabel->setText(value.label);\n    ui->payAmount->setValue(value.amount);\n}",
          "includes": [
            "#include <QClipboard>",
            "#include <QApplication>",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"guiutil.h\"",
            "#include \"ui_sendcoinsentry.h\"",
            "#include \"sendcoinsentry.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QClipboard>\n#include <QApplication>\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"addressbookpage.h\"\n#include \"bitcoinunits.h\"\n#include \"guiutil.h\"\n#include \"ui_sendcoinsentry.h\"\n#include \"sendcoinsentry.h\"\n\nSendCoinsEntry {\n  void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n  {\n      ui->payTo->setText(value.address);\n      ui->addAsLabel->setText(value.label);\n      ui->payAmount->setValue(value.amount);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTransaction",
          "args": [
            "hash",
            "tx",
            "hashBlock"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "890-913",
          "snippet": "bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_main;",
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.SetHex",
          "args": [
            "TxID.toStdString()"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "SetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "346-374",
          "snippet": "void SetHex(const std::string& str)\n    {\n        // skip 0x\n        const char* psz = str.c_str();\n        while (isspace(*psz))\n            psz++;\n        bool fNegative = false;\n        if (*psz == '-')\n        {\n            fNegative = true;\n            psz++;\n        }\n        if (psz[0] == '0' && tolower(psz[1]) == 'x')\n            psz += 2;\n        while (isspace(*psz))\n            psz++;\n\n        // hex string to bignum\n        static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n        *this = 0;\n        while (isxdigit(*psz))\n        {\n            *this <<= 4;\n            int n = phexdigit[(unsigned char)*psz++];\n            *this += n;\n        }\n        if (fNegative)\n            *this = 0 - *this;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void SetHex(const std::string& str)\n      {\n          // skip 0x\n          const char* psz = str.c_str();\n          while (isspace(*psz))\n              psz++;\n          bool fNegative = false;\n          if (*psz == '-')\n          {\n              fNegative = true;\n              psz++;\n          }\n          if (psz[0] == '0' && tolower(psz[1]) == 'x')\n              psz += 2;\n          while (isspace(*psz))\n              psz++;\n  \n          // hex string to bignum\n          static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n          *this = 0;\n          while (isxdigit(*psz))\n          {\n              *this <<= 4;\n              int n = phexdigit[(unsigned char)*psz++];\n              *this += n;\n          }\n          if (fNegative)\n              *this = 0 - *this;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "TxID.toStdString",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->txLine->setFocus",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "setFocus",
          "container": "SendCoinsEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/sendcoinsentry.cpp",
          "lines": "162-165",
          "snippet": "void SendCoinsEntry::setFocus()\n{\n    ui->payTo->setFocus();\n}",
          "includes": [
            "#include <QClipboard>",
            "#include <QApplication>",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"guiutil.h\"",
            "#include \"ui_sendcoinsentry.h\"",
            "#include \"sendcoinsentry.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QClipboard>\n#include <QApplication>\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"addressbookpage.h\"\n#include \"bitcoinunits.h\"\n#include \"guiutil.h\"\n#include \"ui_sendcoinsentry.h\"\n#include \"sendcoinsentry.h\"\n\nSendCoinsEntry {\n  void SendCoinsEntry::setFocus()\n  {\n      ui->payTo->setFocus();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ui->txLine->setText",
          "args": [
            "TxID"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "setText",
          "container": "BitcoinAmountField",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoinamountfield.cpp",
          "lines": "48-54",
          "snippet": "void BitcoinAmountField::setText(const QString &text)\n{\n    if (text.isEmpty())\n        amount->clear();\n    else\n        amount->setValue(text.toDouble());\n}",
          "includes": [
            "#include <qmath.h>",
            "#include <QApplication>",
            "#include <QComboBox>",
            "#include <QDoubleSpinBox>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QRegExpValidator>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"qvaluecombobox.h\"",
            "#include \"bitcoinamountfield.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qmath.h>\n#include <QApplication>\n#include <QComboBox>\n#include <QDoubleSpinBox>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QRegExpValidator>\n#include <QLineEdit>\n#include <QLabel>\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"qvaluecombobox.h\"\n#include \"bitcoinamountfield.h\"\n\nBitcoinAmountField {\n  void BitcoinAmountField::setText(const QString &text)\n  {\n      if (text.isEmpty())\n          amount->clear();\n      else\n          amount->setValue(text.toDouble());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\ndouble GetDifficulty(const CBlockIndex *pindex);\n\nBlockExplorer {\n  void BlockExplorer::setTxID(const QString &TxID) {\n      ui->txLine->setText(TxID);\n      ui->txLine->setFocus();\n      updateExplorer(false);\n  \n      uint256 hash;\n      hash.SetHex(TxID.toStdString());\n  \n      CTransaction tx;\n      uint256 hashBlock = 0;\n      if(GetTransaction(hash, tx, hashBlock)) {\n          CBlockIndex *pindex = mapBlockIndex[hashBlock];\n          if(!pindex)\n            ui->numberBox->setValue(nBestHeight);\n          else\n            ui->numberBox->setValue(pindex->nHeight);\n          updateExplorer(true);\n      }\n  }\n}"
  },
  {
    "function_name": "updateExplorer",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "104-295",
    "snippet": "void BlockExplorer::updateExplorer(bool block) {\n    uchar data[32];\n    uint256 hash;\n    uint i, j;\n\n    if(block) {\n\n        int nHeight = ui->numberBox->value();\n        if(nHeight > pindexBest->nHeight) {\n            ui->numberBox->setValue(pindexBest->nHeight);\n            nHeight = pindexBest->nHeight;\n        }\n\n        const CBlockIndex *pindex = getBlockIndex(nHeight);\n        CBlock block;\n\n        if(!pindex || !block.ReadFromDisk(pindex, true)) {\n            setBlockError(ui);\n            return;\n        }\n\n        ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n          .arg(QString::number(block.nVersion)) \\\n          .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n          .arg(QString::number(nHeight)) \\\n          .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n\n        hash = pindex->GetBlockHash();\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        hash = pindex->hashMerkleRoot;\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        if(pindex->IsProofOfWork()) {\n            hash = block.vtx[0].GetHash();\n            ui->baseText->setText(tr(\"Coin base:\"));\n            ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n            ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n              .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n        } else {\n            hash = block.vtx[1].GetHash();\n            ui->baseText->setText(tr(\"Coin stake:\"));\n            ui->diffText->setText(tr(\"Difficulty, target:\"));\n            ui->diffData->setText(QString(\"%1  0x%2\") \\\n              .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n              .arg(block.nBits, 8, 16, QLatin1Char('0')));\n        }\n        bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n        ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n\n        ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n\n        /* List of payments */\n        std::string strTx = \"\";\n        for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n            hash = block.vtx[i].GetHash();\n\n            strTx.append(hash.ToString());\n            strTx.append(\"\\n\");\n\n            for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                const CTxOut &txout = block.vtx[i].vout[j];\n\n                CTxDestination address;\n                if(!ExtractDestination(txout.scriptPubKey, address))\n                  address = CNoDestination();\n\n                strTx.append(CBitcoinAddress(address).ToString());\n                strTx.append(\"  \");\n                strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                strTx.append(\" HAL\\n\");\n            }\n            strTx.append(\"\\n\");\n        }\n        ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n\n    } else {\n\n        std::string TxID = ui->txLine->text().toUtf8().constData();\n        ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n\n        int nHeight = 0;\n        int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n        uint256 hash;\n        hash.SetHex(TxID);\n\n        CTransaction tx;\n        uint256 hashBlock = 0;\n        if(!GetTransaction(hash, tx, hashBlock)) {\n            setTxError(ui);\n            return;\n        }\n\n        map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n        if(mi != mapBlockIndex.end() && (*mi).second) {\n             CBlockIndex *pindex = (*mi).second;\n             if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n        }\n\n        if(nHeight) {\n            ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n              .arg(QString::number(nHeight)));\n        } else {\n            ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n              .arg(QString::number(tx.nVersion)) \\\n              .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n        }\n\n        /* List of inputs */\n        std::string strIn = \"\";\n        for(i = 0; i < tx.vin.size(); i++) {\n            int64 nCurrentValueIn = 0;\n            uint256 hash_in, hashBlock_in = 0;\n            const CTxIn &vin = tx.vin[i];\n\n            hash_in = vin.prevout.hash;\n            CTransaction txPrev;\n            if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n              continue;\n\n            CTxDestination address;\n            if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n            nValueIn += nCurrentValueIn;\n\n            strIn.append(hash_in.ToString());\n            strIn.append(\"-\");\n            strIn.append(boost::to_string(vin.prevout.n));\n            strIn.append(\"\\n\");\n            strIn.append(CBitcoinAddress(address).ToString());\n            strIn.append(\"  \");\n            strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n            strIn.append(\" HAL\\n\\n\");\n        }\n        if(!strIn.size()) strIn.append(\"N/A\");\n        ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n\n        /* List of outputs */\n        std::string strOut = \"\";\n        for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n            int64 nCurrentValueOut = 0;\n            const CTxOut &txout = tx.vout[i];\n\n            CTxDestination address;\n            if(!ExtractDestination(txout.scriptPubKey, address))\n              address = CNoDestination();\n\n            nCurrentValueOut = txout.nValue;\n            nValueOut += nCurrentValueOut;\n\n            strOut.append(CBitcoinAddress(address).ToString());\n            strOut.append(\"  \");\n            strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n            strOut.append(\" HAL\\n\");\n        }\n        ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n\n        ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n\n        if(tx.IsCoinBase() || tx.IsCoinStake()) {\n            int64 nSubsidy = 0;\n\n            if(tx.IsCoinBase())\n              nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n            else {\n                uint64_t nCoinAge;\n                CTxDB txdb(\"r\");\n                tx.GetCoinAge(txdb, nCoinAge);\n                nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n            }\n\n            nFees = nValueOut - nValueIn - nSubsidy;\n            ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n            ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n              .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n              .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n        } else {\n            nFees = nValueIn - nValueOut;\n            ui->feeText->setText(QString(tr(\"Fee paid:\")));\n            ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n        }\n\n    }\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "double GetDifficulty(const CBlockIndex *pindex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ui->feeData->setText",
          "args": [
            "QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\""
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "setText",
          "container": "BitcoinAmountField",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoinamountfield.cpp",
          "lines": "48-54",
          "snippet": "void BitcoinAmountField::setText(const QString &text)\n{\n    if (text.isEmpty())\n        amount->clear();\n    else\n        amount->setValue(text.toDouble());\n}",
          "includes": [
            "#include <qmath.h>",
            "#include <QApplication>",
            "#include <QComboBox>",
            "#include <QDoubleSpinBox>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QRegExpValidator>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"qvaluecombobox.h\"",
            "#include \"bitcoinamountfield.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qmath.h>\n#include <QApplication>\n#include <QComboBox>\n#include <QDoubleSpinBox>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QRegExpValidator>\n#include <QLineEdit>\n#include <QLabel>\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"qvaluecombobox.h\"\n#include \"bitcoinamountfield.h\"\n\nBitcoinAmountField {\n  void BitcoinAmountField::setText(const QString &text)\n  {\n      if (text.isEmpty())\n          amount->clear();\n      else\n          amount->setValue(text.toDouble());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "(double)nFees / (double)COIN",
            "'f'",
            "6"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "tr(\"Fee paid:\")"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [
            "\"Fee paid:\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "SendCoinsEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/sendcoinsentry.cpp",
          "lines": "150-155",
          "snippet": "void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n{\n    ui->payTo->setText(value.address);\n    ui->addAsLabel->setText(value.label);\n    ui->payAmount->setValue(value.amount);\n}",
          "includes": [
            "#include <QClipboard>",
            "#include <QApplication>",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"guiutil.h\"",
            "#include \"ui_sendcoinsentry.h\"",
            "#include \"sendcoinsentry.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QClipboard>\n#include <QApplication>\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"addressbookpage.h\"\n#include \"bitcoinunits.h\"\n#include \"guiutil.h\"\n#include \"ui_sendcoinsentry.h\"\n#include \"sendcoinsentry.h\"\n\nSendCoinsEntry {\n  void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n  {\n      ui->payTo->setText(value.address);\n      ui->addAsLabel->setText(value.label);\n      ui->payAmount->setValue(value.amount);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number((double)nFees / (double)COIN, 'f', 6)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "(double)nFees / (double)COIN",
            "'f'",
            "6"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number((double)nSubsidy / (double)COIN, 'f', 6)"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "(double)nSubsidy / (double)COIN",
            "'f'",
            "6"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"%1 + %2 HAL\""
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "tr(\"Reward + fees:\")"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProofOfStakeReward",
          "args": [
            "nHeight",
            "nCoinAge",
            "0LL"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "GetProofOfStakeReward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1005-1029",
          "snippet": "int64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetCoinAge",
          "args": [
            "txdb",
            "nCoinAge"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "GetCoinAge",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1962-2001",
          "snippet": "bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n{\n    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n    nCoinAge = 0;\n\n    if (IsCoinBase())\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // First try finding the previous transaction in database\n        CTransaction txPrev;\n        CTxIndex txindex;\n        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n            continue;  // previous transaction not in main chain\n        if (nTime < txPrev.nTime)\n            return false;  // Transaction timestamp violation\n\n        // Read block header\n        CBlock block;\n        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n            return false; // unable to read block of previous transaction\n        if (block.GetBlockTime() + nStakeMinAge > nTime)\n            continue; // only count coins meeting min age requirement\n\n        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n\n        if(fDebug && GetBoolArg(\"-printcoinage\"))\n          printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n            nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n    }\n\n    CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n    nCoinAge = bnCoinDay.getuint64();\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint nStakeMinAge = 60 * 60 * 12;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nuint nStakeMinAge = 60 * 60 * 12;\n\nCTransaction {\n  bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n  {\n      CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n      nCoinAge = 0;\n  \n      if (IsCoinBase())\n          return true;\n  \n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          // First try finding the previous transaction in database\n          CTransaction txPrev;\n          CTxIndex txindex;\n          if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n              continue;  // previous transaction not in main chain\n          if (nTime < txPrev.nTime)\n              return false;  // Transaction timestamp violation\n  \n          // Read block header\n          CBlock block;\n          if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n              return false; // unable to read block of previous transaction\n          if (block.GetBlockTime() + nStakeMinAge > nTime)\n              continue; // only count coins meeting min age requirement\n  \n          int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n          bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n  \n          if(fDebug && GetBoolArg(\"-printcoinage\"))\n            printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n              nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n      }\n  \n      CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n      nCoinAge = bnCoinDay.getuint64();\n      if(fDebug && GetBoolArg(\"-printcoinage\"))\n        printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n  \n      return(true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetProofOfWorkReward",
          "args": [
            "nHeight",
            "0LL"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "GetProofOfWorkReward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "976-1003",
          "snippet": "int64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinBase",
          "args": [],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "(double)nValueOut / (double)COIN",
            "'f'",
            "6"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "strOut.c_str()"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strOut.c_str",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strOut.append",
          "args": [
            "\" HAL\\n\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strOut.append",
          "args": [
            "boost::to_string((double)nCurrentValueOut / (double)COIN)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::to_string",
          "args": [
            "(double)nCurrentValueOut / (double)COIN"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strOut.append",
          "args": [
            "\"  \""
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strOut.append",
          "args": [
            "CBitcoinAddress(address).ToString()"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "IsScript",
          "container": "CBitcoinAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "384-394",
          "snippet": "bool IsScript() const {\n        if (!IsValid())\n            return false;\n        switch (nVersion) {\n        case SCRIPT_ADDRESS:\n        case SCRIPT_ADDRESS_TEST: {\n            return true;\n        }\n        default: return false;\n        }\n    }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddress {\n  bool IsScript() const {\n          if (!IsValid())\n              return false;\n          switch (nVersion) {\n          case SCRIPT_ADDRESS:\n          case SCRIPT_ADDRESS_TEST: {\n              return true;\n          }\n          default: return false;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBitcoinAddress",
          "args": [
            "address"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "operator()",
          "container": "CBitcoinAddressVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/base58.h",
          "lines": "399-399",
          "snippet": "bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }",
          "includes": [
            "#include \"script.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include <vector>\n#include <string>\n\nCBitcoinAddressVisitor {\n  bool inline CBitcoinAddressVisitor::operator()(const CNoDestination &id) const { return false; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CNoDestination",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExtractDestination",
          "args": [
            "txout.scriptPubKey",
            "address"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1590-1614",
          "snippet": "bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.vout.size",
          "args": [],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "TransactionTablePriv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "170-173",
          "snippet": "int size()\n    {\n        return cachedWallet.size();\n    }",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTablePriv {\n  int size()\n      {\n          return cachedWallet.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "strIn.c_str()"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.c_str",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "\"N/A\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "\" HAL\\n\\n\""
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "boost::to_string((double)nCurrentValueIn / (double)COIN)"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::to_string",
          "args": [
            "(double)nCurrentValueIn / (double)COIN"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "\"  \""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "CBitcoinAddress(address).ToString()"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "\"\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "boost::to_string(vin.prevout.n)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::to_string",
          "args": [
            "vin.prevout.n"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "\"-\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strIn.append",
          "args": [
            "hash_in.ToString()"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_in.ToString",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CNoDestination",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTransaction",
          "args": [
            "hash_in",
            "txPrev",
            "hashBlock_in"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "890-913",
          "snippet": "bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CCriticalSection cs_main;",
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "DateTimeStrFormat(tx.nTime).c_str()"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "tx.nTime"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "386-389",
          "snippet": "inline std::string DateTimeStrFormat(int64_t nTime)\n{\n    return DateTimeStrFormat(strTimestampFormat.c_str(), nTime);\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(int64_t nTime)\n{\n    return DateTimeStrFormat(strTimestampFormat.c_str(), nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number(tx.nVersion)"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "tx.nVersion"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"v%1  (%2)\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number(nHeight)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "nHeight"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "DateTimeStrFormat(tx.nTime).c_str()"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number(tx.nVersion)"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "tx.nVersion"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"v%1  (%2)  in block #%3\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->IsInMainChain",
          "args": [],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.find",
          "args": [
            "hashBlock"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTxError",
          "args": [
            "ui"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "setTxError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "77-86",
          "snippet": "static void setTxError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->txData->setText(err);\n    ui->txTimeData->setText(err);\n    ui->valueData->setText(err);\n    ui->feeData->setText(err);\n    ui->inputData->setText(err);\n    ui->outputData->setText(err);\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nstatic void setTxError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->txData->setText(err);\n    ui->txTimeData->setText(err);\n    ui->valueData->setText(err);\n    ui->feeData->setText(err);\n    ui->inputData->setText(err);\n    ui->outputData->setText(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.SetHex",
          "args": [
            "TxID"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "SetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "346-374",
          "snippet": "void SetHex(const std::string& str)\n    {\n        // skip 0x\n        const char* psz = str.c_str();\n        while (isspace(*psz))\n            psz++;\n        bool fNegative = false;\n        if (*psz == '-')\n        {\n            fNegative = true;\n            psz++;\n        }\n        if (psz[0] == '0' && tolower(psz[1]) == 'x')\n            psz += 2;\n        while (isspace(*psz))\n            psz++;\n\n        // hex string to bignum\n        static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n        *this = 0;\n        while (isxdigit(*psz))\n        {\n            *this <<= 4;\n            int n = phexdigit[(unsigned char)*psz++];\n            *this += n;\n        }\n        if (fNegative)\n            *this = 0 - *this;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void SetHex(const std::string& str)\n      {\n          // skip 0x\n          const char* psz = str.c_str();\n          while (isspace(*psz))\n              psz++;\n          bool fNegative = false;\n          if (*psz == '-')\n          {\n              fNegative = true;\n              psz++;\n          }\n          if (psz[0] == '0' && tolower(psz[1]) == 'x')\n              psz += 2;\n          while (isspace(*psz))\n              psz++;\n  \n          // hex string to bignum\n          static const signed char phexdigit[256] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0xa,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0,0,0,0,0 };\n          *this = 0;\n          while (isxdigit(*psz))\n          {\n              *this <<= 4;\n              int n = phexdigit[(unsigned char)*psz++];\n              *this += n;\n          }\n          if (fNegative)\n              *this = 0 - *this;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "TxID.c_str()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TxID.c_str",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->txLine->text",
          "args": [],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "text",
          "container": "BitcoinAmountField",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoinamountfield.cpp",
          "lines": "83-89",
          "snippet": "QString BitcoinAmountField::text() const\n{\n    if (amount->text().isEmpty())\n        return QString();\n    else\n        return amount->text();\n}",
          "includes": [
            "#include <qmath.h>",
            "#include <QApplication>",
            "#include <QComboBox>",
            "#include <QDoubleSpinBox>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QRegExpValidator>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"qvaluecombobox.h\"",
            "#include \"bitcoinamountfield.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qmath.h>\n#include <QApplication>\n#include <QComboBox>\n#include <QDoubleSpinBox>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QRegExpValidator>\n#include <QLineEdit>\n#include <QLabel>\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"qvaluecombobox.h\"\n#include \"bitcoinamountfield.h\"\n\nBitcoinAmountField {\n  QString BitcoinAmountField::text() const\n  {\n      if (amount->text().isEmpty())\n          return QString();\n      else\n          return amount->text();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "strTx.c_str()"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.c_str",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.append",
          "args": [
            "\"\\n\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.append",
          "args": [
            "\" HAL\\n\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.append",
          "args": [
            "boost::to_string((double)txout.nValue / (double)COIN)"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boost::to_string",
          "args": [
            "(double)txout.nValue / (double)COIN"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.append",
          "args": [
            "\"  \""
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.append",
          "args": [
            "CBitcoinAddress(address).ToString()"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNoDestination",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.append",
          "args": [
            "\"\\n\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strTx.append",
          "args": [
            "hash.ToString()"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.vtx[i].GetHash",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->IsProofOfStake",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "(double)pindex->nMoneySupply / (double)COIN",
            "'f'",
            "6"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "QByteArray((char *) &data[0], 32).toHex()"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray",
          "args": [
            "(char *) &data[0]",
            "32"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes_reverse",
          "args": [
            "(uchar *) &data[0]",
            "(uchar *) &hash",
            "32"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "bytes_reverse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "43-48",
          "snippet": "static void bytes_reverse(uchar *output, const uchar *input, uint size) {\n    uint i;\n\n    for(i = 0; i < size; i++)\n      output[i] = input[size - 1 - i];\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nstatic void bytes_reverse(uchar *output, const uchar *input, uint size) {\n    uint i;\n\n    for(i = 0; i < size; i++)\n      output[i] = input[size - 1 - i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "block.nBits",
            "8",
            "16",
            "QLatin1Char('0')"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'0'"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number(GetDifficulty(pindex), 'f', 6)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "GetDifficulty(pindex)",
            "'f'",
            "6"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDifficulty",
          "args": [
            "pindex"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "GetDifficulty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcblockchain.cpp",
          "lines": "15-44",
          "snippet": "double GetDifficulty(const CBlockIndex* blockindex)\n{\n    // Floating point number that is a multiple of the minimum difficulty,\n    // minimum difficulty = 1.0.\n    if (blockindex == NULL)\n    {\n        if (pindexBest == NULL)\n            return 1.0;\n        else\n            blockindex = GetLastBlockIndex(pindexBest, false);\n    }\n\n    int nShift = (blockindex->nBits >> 24) & 0xff;\n\n    double dDiff =\n        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n\n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}",
          "includes": [
            "#include \"bitcoinrpc.h\"",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bitcoinrpc.h\"\n#include \"main.h\"\n\ndouble GetDifficulty(const CBlockIndex* blockindex)\n{\n    // Floating point number that is a multiple of the minimum difficulty,\n    // minimum difficulty = 1.0.\n    if (blockindex == NULL)\n    {\n        if (pindexBest == NULL)\n            return 1.0;\n        else\n            blockindex = GetLastBlockIndex(pindexBest, false);\n    }\n\n    int nShift = (blockindex->nBits >> 24) & 0xff;\n\n    double dDiff =\n        (double)0x0000ffff / (double)(blockindex->nBits & 0x00ffffff);\n\n    while (nShift < 29)\n    {\n        dDiff *= 256.0;\n        nShift++;\n    }\n    while (nShift > 29)\n    {\n        dDiff /= 256.0;\n        nShift--;\n    }\n\n    return dDiff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"%1  0x%2\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "block.nNonce",
            "8",
            "16",
            "QLatin1Char('0')"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'0'"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "block.nBits",
            "8",
            "16",
            "QLatin1Char('0')"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QLatin1Char",
          "args": [
            "'0'"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number(GetDifficulty(pindex), 'f', 6)"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "GetDifficulty(pindex)",
            "'f'",
            "6"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"%1  0x%2  0x%3\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->IsProofOfWork",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "QByteArray((char *) &data[0], 32).toHex()"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray",
          "args": [],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray",
          "args": [
            "(char *) &data[0]",
            "32"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "QByteArray((char *) &data[0], 32).toHex()"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray",
          "args": [],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QByteArray",
          "args": [
            "(char *) &data[0]",
            "32"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"Proof-of-Stake\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"Proof-of-Work\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number(nHeight)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "nHeight"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::fromUtf8",
          "args": [
            "DateTimeStrFormat(pindex->nTime).c_str()"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "QString::number(block.nVersion)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString::number",
          "args": [
            "block.nVersion"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QString",
          "args": [
            "\"v%1  (%2)  #%3  %4\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setBlockError",
          "args": [
            "ui"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "setBlockError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "68-75",
          "snippet": "static void setBlockError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->blockTimeData->setText(err);\n    ui->hashData->setText(err);\n    ui->merkleData->setText(err);\n    ui->baseData->setText(err);\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nstatic void setBlockError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->blockTimeData->setText(err);\n    ui->hashData->setText(err);\n    ui->merkleData->setText(err);\n    ui->baseData->setText(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindex",
            "true"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1097-1117",
          "snippet": "bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n    {\n        SetNull();\n\n        // Open history file to read\n        CAutoFile filein = CAutoFile(OpenBlockFile(nFile, nBlockPos, \"rb\"), SER_DISK, CLIENT_VERSION);\n        if (!filein)\n            return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n        if (!fReadTransactions)\n            filein.nType |= SER_BLOCKHEADERONLY;\n\n        // Read block\n        try {\n            filein >> *this;\n        }\n        catch (std::exception &e) {\n            return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n        }\n\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool ReadFromDisk(unsigned int nFile, unsigned int nBlockPos, bool fReadTransactions=true)\n      {\n          SetNull();\n  \n          // Open history file to read\n          CAutoFile filein = CAutoFile(OpenBlockFile(nFile, nBlockPos, \"rb\"), SER_DISK, CLIENT_VERSION);\n          if (!filein)\n              return error(\"CBlock::ReadFromDisk() : OpenBlockFile failed\");\n          if (!fReadTransactions)\n              filein.nType |= SER_BLOCKHEADERONLY;\n  \n          // Read block\n          try {\n              filein >> *this;\n          }\n          catch (std::exception &e) {\n              return error(\"%s() : deserialize or I/O error\", __PRETTY_FUNCTION__);\n          }\n  \n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "getBlockIndex",
          "args": [
            "nHeight"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->numberBox->value",
          "args": [],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "QValueComboBox",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/qvaluecombobox.cpp",
          "lines": "9-12",
          "snippet": "QVariant QValueComboBox::value() const\n{\n    return itemData(currentIndex(), role);\n}",
          "includes": [
            "#include \"qvaluecombobox.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qvaluecombobox.h\"\n\nQValueComboBox {\n  QVariant QValueComboBox::value() const\n  {\n      return itemData(currentIndex(), role);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\ndouble GetDifficulty(const CBlockIndex *pindex);\n\nBlockExplorer {\n  void BlockExplorer::updateExplorer(bool block) {\n      uchar data[32];\n      uint256 hash;\n      uint i, j;\n  \n      if(block) {\n  \n          int nHeight = ui->numberBox->value();\n          if(nHeight > pindexBest->nHeight) {\n              ui->numberBox->setValue(pindexBest->nHeight);\n              nHeight = pindexBest->nHeight;\n          }\n  \n          const CBlockIndex *pindex = getBlockIndex(nHeight);\n          CBlock block;\n  \n          if(!pindex || !block.ReadFromDisk(pindex, true)) {\n              setBlockError(ui);\n              return;\n          }\n  \n          ui->blockTimeData->setText(QString(\"v%1  (%2)  #%3  %4\") \\\n            .arg(QString::number(block.nVersion)) \\\n            .arg(QString::fromUtf8(DateTimeStrFormat(pindex->nTime).c_str())) \\\n            .arg(QString::number(nHeight)) \\\n            .arg(pindex->IsProofOfWork() ? QString(\"Proof-of-Work\") : QString(\"Proof-of-Stake\")));\n  \n          hash = pindex->GetBlockHash();\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->hashData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          hash = pindex->hashMerkleRoot;\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->merkleData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          if(pindex->IsProofOfWork()) {\n              hash = block.vtx[0].GetHash();\n              ui->baseText->setText(tr(\"Coin base:\"));\n              ui->diffText->setText(tr(\"Difficulty, target, nonce:\"));\n              ui->diffData->setText(QString(\"%1  0x%2  0x%3\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')) \\\n                .arg(block.nNonce, 8, 16, QLatin1Char('0')));\n          } else {\n              hash = block.vtx[1].GetHash();\n              ui->baseText->setText(tr(\"Coin stake:\"));\n              ui->diffText->setText(tr(\"Difficulty, target:\"));\n              ui->diffData->setText(QString(\"%1  0x%2\") \\\n                .arg(QString::number(GetDifficulty(pindex), 'f', 6)) \\\n                .arg(block.nBits, 8, 16, QLatin1Char('0')));\n          }\n          bytes_reverse((uchar *) &data[0], (uchar *) &hash, 32);\n          ui->baseData->setText(QString::fromUtf8(QByteArray((char *) &data[0], 32).toHex()));\n  \n          ui->coinSupplyData->setText(QString::number((double)pindex->nMoneySupply / (double)COIN, 'f', 6) + \" HAL\");\n  \n          /* List of payments */\n          std::string strTx = \"\";\n          for(i = (pindex->IsProofOfStake() ? 1 : 0); i < block.vtx.size(); i++) {\n              hash = block.vtx[i].GetHash();\n  \n              strTx.append(hash.ToString());\n              strTx.append(\"\\n\");\n  \n              for(j = (block.vtx[i].IsCoinStake() ? 1 : 0); j < block.vtx[i].vout.size(); j++) {\n                  const CTxOut &txout = block.vtx[i].vout[j];\n  \n                  CTxDestination address;\n                  if(!ExtractDestination(txout.scriptPubKey, address))\n                    address = CNoDestination();\n  \n                  strTx.append(CBitcoinAddress(address).ToString());\n                  strTx.append(\"  \");\n                  strTx.append(boost::to_string((double)txout.nValue / (double)COIN));\n                  strTx.append(\" HAL\\n\");\n              }\n              strTx.append(\"\\n\");\n          }\n          ui->blockTxData->setText(QString::fromUtf8(strTx.c_str()));\n  \n      } else {\n  \n          std::string TxID = ui->txLine->text().toUtf8().constData();\n          ui->txData->setText(QString::fromUtf8(TxID.c_str()));\n  \n          int nHeight = 0;\n          int64 nValueIn = 0, nValueOut = 0, nFees = 0;\n          uint256 hash;\n          hash.SetHex(TxID);\n  \n          CTransaction tx;\n          uint256 hashBlock = 0;\n          if(!GetTransaction(hash, tx, hashBlock)) {\n              setTxError(ui);\n              return;\n          }\n  \n          map<uint256, CBlockIndex *>::iterator mi = mapBlockIndex.find(hashBlock);\n          if(mi != mapBlockIndex.end() && (*mi).second) {\n               CBlockIndex *pindex = (*mi).second;\n               if(pindex->IsInMainChain()) nHeight = pindex->nHeight;\n          }\n  \n          if(nHeight) {\n              ui->txTimeData->setText(QString(\"v%1  (%2)  in block #%3\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str()))\n                .arg(QString::number(nHeight)));\n          } else {\n              ui->txTimeData->setText(QString(\"v%1  (%2)\") \\\n                .arg(QString::number(tx.nVersion)) \\\n                .arg(QString::fromUtf8(DateTimeStrFormat(tx.nTime).c_str())));\n          }\n  \n          /* List of inputs */\n          std::string strIn = \"\";\n          for(i = 0; i < tx.vin.size(); i++) {\n              int64 nCurrentValueIn = 0;\n              uint256 hash_in, hashBlock_in = 0;\n              const CTxIn &vin = tx.vin[i];\n  \n              hash_in = vin.prevout.hash;\n              CTransaction txPrev;\n              if(!GetTransaction(hash_in, txPrev, hashBlock_in))\n                continue;\n  \n              CTxDestination address;\n              if(!ExtractDestination(txPrev.vout[vin.prevout.n].scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueIn = txPrev.vout[vin.prevout.n].nValue;\n              nValueIn += nCurrentValueIn;\n  \n              strIn.append(hash_in.ToString());\n              strIn.append(\"-\");\n              strIn.append(boost::to_string(vin.prevout.n));\n              strIn.append(\"\\n\");\n              strIn.append(CBitcoinAddress(address).ToString());\n              strIn.append(\"  \");\n              strIn.append(boost::to_string((double)nCurrentValueIn / (double)COIN));\n              strIn.append(\" HAL\\n\\n\");\n          }\n          if(!strIn.size()) strIn.append(\"N/A\");\n          ui->inputData->setText(QString::fromUtf8(strIn.c_str()));\n  \n          /* List of outputs */\n          std::string strOut = \"\";\n          for(i = (tx.IsCoinStake() ? 1 : 0); i < tx.vout.size(); i++) {\n              int64 nCurrentValueOut = 0;\n              const CTxOut &txout = tx.vout[i];\n  \n              CTxDestination address;\n              if(!ExtractDestination(txout.scriptPubKey, address))\n                address = CNoDestination();\n  \n              nCurrentValueOut = txout.nValue;\n              nValueOut += nCurrentValueOut;\n  \n              strOut.append(CBitcoinAddress(address).ToString());\n              strOut.append(\"  \");\n              strOut.append(boost::to_string((double)nCurrentValueOut / (double)COIN));\n              strOut.append(\" HAL\\n\");\n          }\n          ui->outputData->setText(QString::fromUtf8(strOut.c_str()));\n  \n          ui->valueData->setText(QString::number((double)nValueOut / (double)COIN, 'f', 6) + \" HAL\");\n  \n          if(tx.IsCoinBase() || tx.IsCoinStake()) {\n              int64 nSubsidy = 0;\n  \n              if(tx.IsCoinBase())\n                nSubsidy = GetProofOfWorkReward(nHeight, 0LL);\n              else {\n                  uint64_t nCoinAge;\n                  CTxDB txdb(\"r\");\n                  tx.GetCoinAge(txdb, nCoinAge);\n                  nSubsidy = GetProofOfStakeReward(nHeight, nCoinAge, 0LL);\n              }\n  \n              nFees = nValueOut - nValueIn - nSubsidy;\n              ui->feeText->setText(QString(tr(\"Reward + fees:\")));\n              ui->feeData->setText(QString(\"%1 + %2 HAL\") \\\n                .arg(QString::number((double)nSubsidy / (double)COIN, 'f', 6)) \\\n                .arg(QString::number((double)nFees / (double)COIN, 'f', 6)));\n          } else {\n              nFees = nValueIn - nValueOut;\n              ui->feeText->setText(QString(tr(\"Fee paid:\")));\n              ui->feeData->setText(QString::number((double)nFees / (double)COIN, 'f', 6) + \" HAL\");\n          }\n  \n      }\n  }\n}"
  },
  {
    "function_name": "BlockExplorer",
    "container": "BlockExplorer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "88-102",
    "snippet": "BlockExplorer::BlockExplorer(QWidget *parent) :\n  QDialog(parent, (Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint)),\n  ui(new Ui::BlockExplorer) {\n\n    ui->setupUi(this);\n\n    setBaseSize(760, 470);\n\n#if (QT_VERSION >= 0x040700)\n    ui->txLine->setPlaceholderText(tr(\"Payment ID\"));\n#endif\n\n    connect(ui->blockButton, SIGNAL(pressed()), this, SLOT(blockClicked()));\n    connect(ui->txButton, SIGNAL(pressed()), this, SLOT(txClicked()));\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "ui->txButton",
            "SIGNAL(pressed())",
            "this",
            "SLOT(txClicked())"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOT",
          "args": [
            "txClicked()"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txClicked",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "txClicked",
          "container": "BlockExplorer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "317-319",
          "snippet": "void BlockExplorer::txClicked() {\n    updateExplorer(false);\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  void BlockExplorer::txClicked() {\n      updateExplorer(false);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIGNAL",
          "args": [
            "pressed()"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pressed",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "IsCompressed",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "92-94",
          "snippet": "bool IsCompressed() const {\n        return vchPubKey.size() == 33;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  bool IsCompressed() const {\n          return vchPubKey.size() == 33;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "ui->blockButton",
            "SIGNAL(pressed())",
            "this",
            "SLOT(blockClicked())"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SLOT",
          "args": [
            "blockClicked()"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blockClicked",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "blockClicked",
          "container": "BlockExplorer",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
          "lines": "321-323",
          "snippet": "void BlockExplorer::blockClicked() {\n    updateExplorer(true);\n}",
          "includes": [
            "#include <QString>",
            "#include <QByteArray>",
            "#include \"txdb.h\"",
            "#include \"main.h\"",
            "#include \"uint256.h\"",
            "#include \"base58.h\"",
            "#include \"clientmodel.h\"",
            "#include \"ui_blockexplorer.h\"",
            "#include \"blockexplorer.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  void BlockExplorer::blockClicked() {\n      updateExplorer(true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIGNAL",
          "args": [
            "pressed()"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->txLine->setPlaceholderText",
          "args": [
            "tr(\"Payment ID\")"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tr",
          "args": [
            "\"Payment ID\""
          ],
          "line": 97
        },
        "resolved": true,
        "details": {
          "function_name": "setValue",
          "container": "SendCoinsEntry",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/sendcoinsentry.cpp",
          "lines": "150-155",
          "snippet": "void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n{\n    ui->payTo->setText(value.address);\n    ui->addAsLabel->setText(value.label);\n    ui->payAmount->setValue(value.amount);\n}",
          "includes": [
            "#include <QClipboard>",
            "#include <QApplication>",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"guiutil.h\"",
            "#include \"ui_sendcoinsentry.h\"",
            "#include \"sendcoinsentry.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QClipboard>\n#include <QApplication>\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"addressbookpage.h\"\n#include \"bitcoinunits.h\"\n#include \"guiutil.h\"\n#include \"ui_sendcoinsentry.h\"\n#include \"sendcoinsentry.h\"\n\nSendCoinsEntry {\n  void SendCoinsEntry::setValue(const SendCoinsRecipient &value)\n  {\n      ui->payTo->setText(value.address);\n      ui->addAsLabel->setText(value.label);\n      ui->payAmount->setValue(value.amount);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setBaseSize",
          "args": [
            "760",
            "470"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ui->setupUi",
          "args": [
            "this"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nBlockExplorer {\n  BlockExplorer::BlockExplorer(QWidget *parent) :\n    QDialog(parent, (Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint)),\n    ui(new Ui::BlockExplorer) {\n  \n      ui->setupUi(this);\n  \n      setBaseSize(760, 470);\n  \n  #if (QT_VERSION >= 0x040700)\n      ui->txLine->setPlaceholderText(tr(\"Payment ID\"));\n  #endif\n  \n      connect(ui->blockButton, SIGNAL(pressed()), this, SLOT(blockClicked()));\n      connect(ui->txButton, SIGNAL(pressed()), this, SLOT(txClicked()));\n  }\n}"
  },
  {
    "function_name": "setTxError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "77-86",
    "snippet": "static void setTxError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->txData->setText(err);\n    ui->txTimeData->setText(err);\n    ui->valueData->setText(err);\n    ui->feeData->setText(err);\n    ui->inputData->setText(err);\n    ui->outputData->setText(err);\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ui->outputData->setText",
          "args": [
            "err"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "setText",
          "container": "BitcoinAmountField",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoinamountfield.cpp",
          "lines": "48-54",
          "snippet": "void BitcoinAmountField::setText(const QString &text)\n{\n    if (text.isEmpty())\n        amount->clear();\n    else\n        amount->setValue(text.toDouble());\n}",
          "includes": [
            "#include <qmath.h>",
            "#include <QApplication>",
            "#include <QComboBox>",
            "#include <QDoubleSpinBox>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QRegExpValidator>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"qvaluecombobox.h\"",
            "#include \"bitcoinamountfield.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qmath.h>\n#include <QApplication>\n#include <QComboBox>\n#include <QDoubleSpinBox>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QRegExpValidator>\n#include <QLineEdit>\n#include <QLabel>\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"qvaluecombobox.h\"\n#include \"bitcoinamountfield.h\"\n\nBitcoinAmountField {\n  void BitcoinAmountField::setText(const QString &text)\n  {\n      if (text.isEmpty())\n          amount->clear();\n      else\n          amount->setValue(text.toDouble());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nstatic void setTxError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->txData->setText(err);\n    ui->txTimeData->setText(err);\n    ui->valueData->setText(err);\n    ui->feeData->setText(err);\n    ui->inputData->setText(err);\n    ui->outputData->setText(err);\n}"
  },
  {
    "function_name": "setBlockError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "68-75",
    "snippet": "static void setBlockError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->blockTimeData->setText(err);\n    ui->hashData->setText(err);\n    ui->merkleData->setText(err);\n    ui->baseData->setText(err);\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ui->baseData->setText",
          "args": [
            "err"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "setText",
          "container": "BitcoinAmountField",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoinamountfield.cpp",
          "lines": "48-54",
          "snippet": "void BitcoinAmountField::setText(const QString &text)\n{\n    if (text.isEmpty())\n        amount->clear();\n    else\n        amount->setValue(text.toDouble());\n}",
          "includes": [
            "#include <qmath.h>",
            "#include <QApplication>",
            "#include <QComboBox>",
            "#include <QDoubleSpinBox>",
            "#include <QKeyEvent>",
            "#include <QHBoxLayout>",
            "#include <QRegExpValidator>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"qvaluecombobox.h\"",
            "#include \"bitcoinamountfield.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qmath.h>\n#include <QApplication>\n#include <QComboBox>\n#include <QDoubleSpinBox>\n#include <QKeyEvent>\n#include <QHBoxLayout>\n#include <QRegExpValidator>\n#include <QLineEdit>\n#include <QLabel>\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"qvaluecombobox.h\"\n#include \"bitcoinamountfield.h\"\n\nBitcoinAmountField {\n  void BitcoinAmountField::setText(const QString &text)\n  {\n      if (text.isEmpty())\n          amount->clear();\n      else\n          amount->setValue(text.toDouble());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nstatic void setBlockError(Ui::BlockExplorer *ui) {\n    QString err = \"ERROR!\";\n\n    ui->blockTimeData->setText(err);\n    ui->hashData->setText(err);\n    ui->merkleData->setText(err);\n    ui->baseData->setText(err);\n}"
  },
  {
    "function_name": "bytes_reverse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/blockexplorer.cpp",
    "lines": "43-48",
    "snippet": "static void bytes_reverse(uchar *output, const uchar *input, uint size) {\n    uint i;\n\n    for(i = 0; i < size; i++)\n      output[i] = input[size - 1 - i];\n}",
    "includes": [
      "#include <QString>",
      "#include <QByteArray>",
      "#include \"txdb.h\"",
      "#include \"main.h\"",
      "#include \"uint256.h\"",
      "#include \"base58.h\"",
      "#include \"clientmodel.h\"",
      "#include \"ui_blockexplorer.h\"",
      "#include \"blockexplorer.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <QString>\n#include <QByteArray>\n#include \"txdb.h\"\n#include \"main.h\"\n#include \"uint256.h\"\n#include \"base58.h\"\n#include \"clientmodel.h\"\n#include \"ui_blockexplorer.h\"\n#include \"blockexplorer.h\"\n\nstatic void bytes_reverse(uchar *output, const uchar *input, uint size) {\n    uint i;\n\n    for(i = 0; i < size; i++)\n      output[i] = input[size - 1 - i];\n}"
  }
]