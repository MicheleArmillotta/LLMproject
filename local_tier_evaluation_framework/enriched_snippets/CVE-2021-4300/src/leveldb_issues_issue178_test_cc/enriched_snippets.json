[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue178_test.cc",
    "lines": "90-92",
    "snippet": "int main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/db.h\"",
      "#include <cstdlib>",
      "#include <sstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leveldb::test::RunAllTests",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "RunAllTests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "36-58",
          "snippet": "int RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nint RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/db.h\"\n#include <cstdlib>\n#include <sstream>\n#include <iostream>\n\nint main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue178_test.cc",
    "lines": "30-86",
    "snippet": "TEST(Issue178, Test) {\n  // Get rid of any state from an old run.\n  std::string dbpath = leveldb::test::TmpDir() + \"/leveldb_cbug_test\";\n  DestroyDB(dbpath, leveldb::Options());\n\n  // Open database.  Disable compression since it affects the creation\n  // of layers and the code below is trying to test against a very\n  // specific scenario.\n  leveldb::DB* db;\n  leveldb::Options db_options;\n  db_options.create_if_missing = true;\n  db_options.compression = leveldb::kNoCompression;\n  ASSERT_OK(leveldb::DB::Open(db_options, dbpath, &db));\n\n  // create first key range\n  leveldb::WriteBatch batch;\n  for (size_t i = 0; i < kNumKeys; i++) {\n    batch.Put(Key1(i), \"value for range 1 key\");\n  }\n  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));\n\n  // create second key range\n  batch.Clear();\n  for (size_t i = 0; i < kNumKeys; i++) {\n    batch.Put(Key2(i), \"value for range 2 key\");\n  }\n  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));\n\n  // delete second key range\n  batch.Clear();\n  for (size_t i = 0; i < kNumKeys; i++) {\n    batch.Delete(Key2(i));\n  }\n  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));\n\n  // compact database\n  std::string start_key = Key1(0);\n  std::string end_key = Key1(kNumKeys - 1);\n  leveldb::Slice least(start_key.data(), start_key.size());\n  leveldb::Slice greatest(end_key.data(), end_key.size());\n\n  // commenting out the line below causes the example to work correctly\n  db->CompactRange(&least, &greatest);\n\n  // count the keys\n  leveldb::Iterator* iter = db->NewIterator(leveldb::ReadOptions());\n  size_t num_keys = 0;\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    num_keys++;\n  }\n  delete iter;\n  ASSERT_EQ(kNumKeys, num_keys) << \"Bad number of keys\";\n\n  // close database\n  delete db;\n  DestroyDB(dbpath, leveldb::Options());\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/db.h\"",
      "#include <cstdlib>",
      "#include <sstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DestroyDB",
          "args": [
            "dbpath",
            "leveldb::Options()"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "DestroyDB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1482-1511",
          "snippet": "Status DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nStatus DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::Options",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "Options",
          "container": "Options",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/options.cc",
          "lines": "12-26",
          "snippet": "Options::Options()\n    : comparator(BytewiseComparator()),\n      create_if_missing(false),\n      error_if_exists(false),\n      paranoid_checks(false),\n      env(Env::Default()),\n      info_log(NULL),\n      write_buffer_size(4<<20),\n      max_open_files(1000),\n      block_cache(NULL),\n      block_size(4096),\n      block_restart_interval(16),\n      compression(kSnappyCompression),\n      filter_policy(NULL) {\n}",
          "includes": [
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/options.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/options.h\"\n\nOptions {\n  Options::Options()\n      : comparator(BytewiseComparator()),\n        create_if_missing(false),\n        error_if_exists(false),\n        paranoid_checks(false),\n        env(Env::Default()),\n        info_log(NULL),\n        write_buffer_size(4<<20),\n        max_open_files(1000),\n        block_cache(NULL),\n        block_size(4096),\n        block_restart_interval(16),\n        compression(kSnappyCompression),\n        filter_policy(NULL) {\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "kNumKeys",
            "num_keys"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "25-45",
          "snippet": "uint32_t Next() {\n    static const uint32_t M = 2147483647L;   // 2^31-1\n    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n    // We are computing\n    //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n    //\n    // seed_ must not be zero or M, or else all subsequent computed values\n    // will be zero or M respectively.  For all other values, seed_ will end\n    // up cycling through every number in [1,M-1]\n    uint64_t product = seed_ * A;\n\n    // Compute (product % M) using the fact that ((x << 31) % M) == x.\n    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n    // The first reduction may overflow by 1 bit, so we may need to\n    // repeat.  mod == M is not possible; using > allows the faster\n    // sign-bit-based test.\n    if (seed_ > M) {\n      seed_ -= M;\n    }\n    return seed_;\n  }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Next() {\n      static const uint32_t M = 2147483647L;   // 2^31-1\n      static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0\n      // We are computing\n      //       seed_ = (seed_ * A) % M,    where M = 2^31-1\n      //\n      // seed_ must not be zero or M, or else all subsequent computed values\n      // will be zero or M respectively.  For all other values, seed_ will end\n      // up cycling through every number in [1,M-1]\n      uint64_t product = seed_ * A;\n  \n      // Compute (product % M) using the fact that ((x << 31) % M) == x.\n      seed_ = static_cast<uint32_t>((product >> 31) + (product & M));\n      // The first reduction may overflow by 1 bit, so we may need to\n      // repeat.  mod == M is not possible; using > allows the faster\n      // sign-bit-based test.\n      if (seed_ > M) {\n        seed_ -= M;\n      }\n      return seed_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "280-280",
          "snippet": "virtual bool Valid() const { return iter_->Valid(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual bool Valid() const { return iter_->Valid(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "KeyConvertingIterator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "287-287",
          "snippet": "virtual void SeekToFirst() { iter_->SeekToFirst(); }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nKeyConvertingIterator {\n  virtual void SeekToFirst() { iter_->SeekToFirst(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db->NewIterator",
          "args": [
            "leveldb::ReadOptions()"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::ReadOptions",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db->CompactRange",
          "args": [
            "&least",
            "&greatest"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "CompactRange",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "536-551",
          "snippet": "void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n  int max_level_with_files = 1;\n  {\n    MutexLock l(&mutex_);\n    Version* base = versions_->current();\n    for (int level = 1; level < config::kNumLevels; level++) {\n      if (base->OverlapInLevel(level, begin, end)) {\n        max_level_with_files = level;\n      }\n    }\n  }\n  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n  for (int level = 0; level < max_level_with_files; level++) {\n    TEST_CompactRange(level, begin, end);\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::CompactRange(const Slice* begin, const Slice* end) {\n    int max_level_with_files = 1;\n    {\n      MutexLock l(&mutex_);\n      Version* base = versions_->current();\n      for (int level = 1; level < config::kNumLevels; level++) {\n        if (base->OverlapInLevel(level, begin, end)) {\n          max_level_with_files = level;\n        }\n      }\n    }\n    TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap\n    for (int level = 0; level < max_level_with_files; level++) {\n      TEST_CompactRange(level, begin, end);\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_key.size",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_key.data",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_key.data",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Key1",
          "args": [
            "kNumKeys - 1"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "Key1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue178_test.cc",
          "lines": "18-22",
          "snippet": "std::string Key1(int i) {\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"my_key_%d\", i);\n  return buf;\n}",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/db.h\"",
            "#include <cstdlib>",
            "#include <sstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/db.h\"\n#include <cstdlib>\n#include <sstream>\n#include <iostream>\n\nstd::string Key1(int i) {\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"my_key_%d\", i);\n  return buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Write(leveldb::WriteOptions(), &batch)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db->Write",
          "args": [
            "leveldb::WriteOptions()",
            "&batch"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::WriteOptions",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Delete",
          "args": [
            "Key2(i)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "CBatchScanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "172-177",
          "snippet": "virtual void Delete(const leveldb::Slice& key) {\n        if (key.ToString() == needle) {\n            foundEntry = true;\n            *deleted = true;\n        }\n    }",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCBatchScanner {\n  virtual void Delete(const leveldb::Slice& key) {\n          if (key.ToString() == needle) {\n              foundEntry = true;\n              *deleted = true;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Key2",
          "args": [
            "i"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "Key2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue178_test.cc",
          "lines": "24-26",
          "snippet": "std::string Key2(int i) {\n  return Key1(i) + \"_xxx\";\n}",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/db.h\"",
            "#include <cstdlib>",
            "#include <sstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/db.h\"\n#include <cstdlib>\n#include <sstream>\n#include <iostream>\n\nstd::string Key2(int i) {\n  return Key1(i) + \"_xxx\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Clear",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "Histogram",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/histogram.cc",
          "lines": "33-42",
          "snippet": "void Histogram::Clear() {\n  min_ = kBucketLimit[kNumBuckets-1];\n  max_ = 0;\n  num_ = 0;\n  sum_ = 0;\n  sum_squares_ = 0;\n  for (int i = 0; i < kNumBuckets; i++) {\n    buckets_[i] = 0;\n  }\n}",
          "includes": [
            "#include \"util/histogram.h\"",
            "#include \"port/port.h\"",
            "#include <stdio.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/histogram.h\"\n#include \"port/port.h\"\n#include <stdio.h>\n#include <math.h>\n\nHistogram {\n  void Histogram::Clear() {\n    min_ = kBucketLimit[kNumBuckets-1];\n    max_ = 0;\n    num_ = 0;\n    sum_ = 0;\n    sum_squares_ = 0;\n    for (int i = 0; i < kNumBuckets; i++) {\n      buckets_[i] = 0;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Write(leveldb::WriteOptions(), &batch)"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "batch.Put",
          "args": [
            "Key2(i)",
            "\"value for range 2 key\""
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "CBatchScanner",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "164-170",
          "snippet": "virtual void Put(const leveldb::Slice& key, const leveldb::Slice& value) {\n        if (key.ToString() == needle) {\n            foundEntry = true;\n            *deleted = false;\n            *foundValue = value.ToString();\n        }\n    }",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCBatchScanner {\n  virtual void Put(const leveldb::Slice& key, const leveldb::Slice& value) {\n          if (key.ToString() == needle) {\n              foundEntry = true;\n              *deleted = false;\n              *foundValue = value.ToString();\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db->Write(leveldb::WriteOptions(), &batch)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "leveldb::DB::Open(db_options, dbpath, &db)"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leveldb::DB::Open",
          "args": [
            "db_options",
            "dbpath",
            "&db"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1445-1477",
          "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::test::TmpDir",
          "args": [],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "TmpDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "60-65",
          "snippet": "std::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nstd::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/db.h\"\n#include <cstdlib>\n#include <sstream>\n#include <iostream>\n\nTEST(Issue178, Test) {\n  // Get rid of any state from an old run.\n  std::string dbpath = leveldb::test::TmpDir() + \"/leveldb_cbug_test\";\n  DestroyDB(dbpath, leveldb::Options());\n\n  // Open database.  Disable compression since it affects the creation\n  // of layers and the code below is trying to test against a very\n  // specific scenario.\n  leveldb::DB* db;\n  leveldb::Options db_options;\n  db_options.create_if_missing = true;\n  db_options.compression = leveldb::kNoCompression;\n  ASSERT_OK(leveldb::DB::Open(db_options, dbpath, &db));\n\n  // create first key range\n  leveldb::WriteBatch batch;\n  for (size_t i = 0; i < kNumKeys; i++) {\n    batch.Put(Key1(i), \"value for range 1 key\");\n  }\n  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));\n\n  // create second key range\n  batch.Clear();\n  for (size_t i = 0; i < kNumKeys; i++) {\n    batch.Put(Key2(i), \"value for range 2 key\");\n  }\n  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));\n\n  // delete second key range\n  batch.Clear();\n  for (size_t i = 0; i < kNumKeys; i++) {\n    batch.Delete(Key2(i));\n  }\n  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));\n\n  // compact database\n  std::string start_key = Key1(0);\n  std::string end_key = Key1(kNumKeys - 1);\n  leveldb::Slice least(start_key.data(), start_key.size());\n  leveldb::Slice greatest(end_key.data(), end_key.size());\n\n  // commenting out the line below causes the example to work correctly\n  db->CompactRange(&least, &greatest);\n\n  // count the keys\n  leveldb::Iterator* iter = db->NewIterator(leveldb::ReadOptions());\n  size_t num_keys = 0;\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    num_keys++;\n  }\n  delete iter;\n  ASSERT_EQ(kNumKeys, num_keys) << \"Bad number of keys\";\n\n  // close database\n  delete db;\n  DestroyDB(dbpath, leveldb::Options());\n}"
  },
  {
    "function_name": "Key2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue178_test.cc",
    "lines": "24-26",
    "snippet": "std::string Key2(int i) {\n  return Key1(i) + \"_xxx\";\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/db.h\"",
      "#include <cstdlib>",
      "#include <sstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Key1",
          "args": [
            "i"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "Key1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue178_test.cc",
          "lines": "18-22",
          "snippet": "std::string Key1(int i) {\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"my_key_%d\", i);\n  return buf;\n}",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/db.h\"",
            "#include <cstdlib>",
            "#include <sstream>",
            "#include <iostream>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/db.h\"\n#include <cstdlib>\n#include <sstream>\n#include <iostream>\n\nstd::string Key1(int i) {\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"my_key_%d\", i);\n  return buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/db.h\"\n#include <cstdlib>\n#include <sstream>\n#include <iostream>\n\nstd::string Key2(int i) {\n  return Key1(i) + \"_xxx\";\n}"
  },
  {
    "function_name": "Key1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/issues/issue178_test.cc",
    "lines": "18-22",
    "snippet": "std::string Key1(int i) {\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"my_key_%d\", i);\n  return buf;\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/db.h\"",
      "#include <cstdlib>",
      "#include <sstream>",
      "#include <iostream>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"my_key_%d\"",
            "i"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/db.h\"\n#include <cstdlib>\n#include <sstream>\n#include <iostream>\n\nstd::string Key1(int i) {\n  char buf[100];\n  snprintf(buf, sizeof(buf), \"my_key_%d\", i);\n  return buf;\n}"
  }
]