[
  {
    "function_name": "Connected_",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "509-527",
    "snippet": "void CAddrMan::Connected_(const CService &addr, int64_t nTime)\n{\n    CAddrInfo *pinfo = Find(addr);\n\n    // if not found, bail out\n    if (!pinfo)\n        return;\n\n    CAddrInfo &info = *pinfo;\n\n    // check whether we are talking about the exact same CService (including same port)\n    if (info != addr)\n        return;\n\n    // update info\n    int64_t nUpdateInterval = 20 * 60;\n    if (nTime - info.nTime > nUpdateInterval)\n        info.nTime = nTime;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Find",
          "args": [
            "addr"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "Find",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "505-513",
          "snippet": "int Find(opcodetype op) const\n    {\n        int nFound = 0;\n        opcodetype opcode;\n        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n            if (opcode == op)\n                ++nFound;\n        return nFound;\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  int Find(opcodetype op) const\n      {\n          int nFound = 0;\n          opcodetype opcode;\n          for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n              if (opcode == op)\n                  ++nFound;\n          return nFound;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::Connected_(const CService &addr, int64_t nTime)\n  {\n      CAddrInfo *pinfo = Find(addr);\n  \n      // if not found, bail out\n      if (!pinfo)\n          return;\n  \n      CAddrInfo &info = *pinfo;\n  \n      // check whether we are talking about the exact same CService (including same port)\n      if (info != addr)\n          return;\n  \n      // update info\n      int64_t nUpdateInterval = 20 * 60;\n      if (nTime - info.nTime > nUpdateInterval)\n          info.nTime = nTime;\n  }\n}"
  },
  {
    "function_name": "GetAddr_",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "493-507",
    "snippet": "void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n{\n    int nNodes = ADAGSAN_GETADDR_MAX_PCT*vRandom.size()/100;\n    if (nNodes > ADAGSAN_GETADDR_MAX)\n        nNodes = ADAGSAN_GETADDR_MAX;\n\n    // perform a random shuffle over the first nNodes elements of vRandom (selecting from all)\n    for (int n = 0; n<nNodes; n++)\n    {\n        int nRndPos = GetRandInt(vRandom.size() - n) + n;\n        SwapRandom(n, nRndPos);\n        assert(mapInfo.count(vRandom[n]) == 1);\n        vAddr.push_back(mapInfo[vRandom[n]]);\n    }\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vAddr.push_back",
          "args": [
            "mapInfo[vRandom[n]]"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(vRandom[n]) == 1"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapInfo.count",
          "args": [
            "vRandom[n]"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SwapRandom",
          "args": [
            "n",
            "nRndPos"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "SwapRandom",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "105-123",
          "snippet": "void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n{\n    if (nRndPos1 == nRndPos2)\n        return;\n\n    assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());\n\n    int nId1 = vRandom[nRndPos1];\n    int nId2 = vRandom[nRndPos2];\n\n    assert(mapInfo.count(nId1) == 1);\n    assert(mapInfo.count(nId2) == 1);\n\n    mapInfo[nId1].nRandomPos = nRndPos2;\n    mapInfo[nId2].nRandomPos = nRndPos1;\n\n    vRandom[nRndPos1] = nId2;\n    vRandom[nRndPos2] = nId1;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n  {\n      if (nRndPos1 == nRndPos2)\n          return;\n  \n      assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());\n  \n      int nId1 = vRandom[nRndPos1];\n      int nId2 = vRandom[nRndPos2];\n  \n      assert(mapInfo.count(nId1) == 1);\n      assert(mapInfo.count(nId2) == 1);\n  \n      mapInfo[nId1].nRandomPos = nRndPos2;\n      mapInfo[nId2].nRandomPos = nRndPos1;\n  \n      vRandom[nRndPos1] = nId2;\n      vRandom[nRndPos2] = nId1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "vRandom.size() - n"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRandom.size",
          "args": [],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::GetAddr_(std::vector<CAddress> &vAddr)\n  {\n      int nNodes = ADAGSAN_GETADDR_MAX_PCT*vRandom.size()/100;\n      if (nNodes > ADAGSAN_GETADDR_MAX)\n          nNodes = ADAGSAN_GETADDR_MAX;\n  \n      // perform a random shuffle over the first nNodes elements of vRandom (selecting from all)\n      for (int n = 0; n<nNodes; n++)\n      {\n          int nRndPos = GetRandInt(vRandom.size() - n) + n;\n          SwapRandom(n, nRndPos);\n          assert(mapInfo.count(vRandom[n]) == 1);\n          vAddr.push_back(mapInfo[vRandom[n]]);\n      }\n  }\n}"
  },
  {
    "function_name": "Check_",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "434-490",
    "snippet": "int CAddrMan::Check_()\n{\n    std::set<int> setTried;\n    std::map<int, int> mapNew;\n\n    if (vRandom.size() != nTried + nNew) return -7;\n\n    for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n    {\n        int n = (*it).first;\n        CAddrInfo &info = (*it).second;\n        if (info.fInTried)\n        {\n\n            if (!info.nLastSuccess) return -1;\n            if (info.nRefCount) return -2;\n            setTried.insert(n);\n        } else {\n            if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n            if (!info.nRefCount) return -4;\n            mapNew[n] = info.nRefCount;\n        }\n        if (mapAddr[info] != n) return -5;\n        if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n        if (info.nLastTry < 0) return -6;\n        if (info.nLastSuccess < 0) return -8;\n    }\n\n    if (setTried.size() != nTried) return -9;\n    if (mapNew.size() != nNew) return -10;\n\n    for (int n=0; n<vvTried.size(); n++)\n    {\n        std::vector<int> &vTried = vvTried[n];\n        for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n        {\n            if (!setTried.count(*it)) return -11;\n            setTried.erase(*it);\n        }\n    }\n\n    for (int n=0; n<vvNew.size(); n++)\n    {\n        std::set<int> &vNew = vvNew[n];\n        for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n        {\n            if (!mapNew.count(*it)) return -12;\n            if (--mapNew[*it] == 0)\n                mapNew.erase(*it);\n        }\n    }\n\n    if (setTried.size()) return -13;\n    if (mapNew.size()) return -15;\n\n    return 0;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapNew.size",
          "args": [],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapNew.erase",
          "args": [
            "*it"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapNew.count",
          "args": [
            "*it"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.end",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.begin",
          "args": [],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setTried.insert",
          "args": [
            "n"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::Check_()\n  {\n      std::set<int> setTried;\n      std::map<int, int> mapNew;\n  \n      if (vRandom.size() != nTried + nNew) return -7;\n  \n      for (std::map<int, CAddrInfo>::iterator it = mapInfo.begin(); it != mapInfo.end(); it++)\n      {\n          int n = (*it).first;\n          CAddrInfo &info = (*it).second;\n          if (info.fInTried)\n          {\n  \n              if (!info.nLastSuccess) return -1;\n              if (info.nRefCount) return -2;\n              setTried.insert(n);\n          } else {\n              if (info.nRefCount < 0 || info.nRefCount > ADAGSAN_NEW_BUCKETS_PER_ADDRESS) return -3;\n              if (!info.nRefCount) return -4;\n              mapNew[n] = info.nRefCount;\n          }\n          if (mapAddr[info] != n) return -5;\n          if (info.nRandomPos<0 || info.nRandomPos>=vRandom.size() || vRandom[info.nRandomPos] != n) return -14;\n          if (info.nLastTry < 0) return -6;\n          if (info.nLastSuccess < 0) return -8;\n      }\n  \n      if (setTried.size() != nTried) return -9;\n      if (mapNew.size() != nNew) return -10;\n  \n      for (int n=0; n<vvTried.size(); n++)\n      {\n          std::vector<int> &vTried = vvTried[n];\n          for (std::vector<int>::iterator it = vTried.begin(); it != vTried.end(); it++)\n          {\n              if (!setTried.count(*it)) return -11;\n              setTried.erase(*it);\n          }\n      }\n  \n      for (int n=0; n<vvNew.size(); n++)\n      {\n          std::set<int> &vNew = vvNew[n];\n          for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n          {\n              if (!mapNew.count(*it)) return -12;\n              if (--mapNew[*it] == 0)\n                  mapNew.erase(*it);\n          }\n      }\n  \n      if (setTried.size()) return -13;\n      if (mapNew.size()) return -15;\n  \n      return 0;\n  }\n}"
  },
  {
    "function_name": "Select_",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "389-431",
    "snippet": "CAddress CAddrMan::Select_(int nUnkBias)\n{\n    if (size() == 0)\n        return CAddress();\n\n    double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n    double nCorNew = sqrt(nNew) * nUnkBias;\n    if ((nCorTried + nCorNew)*GetRandInt(1<<30)/(1<<30) < nCorTried)\n    {\n        // use a tried node\n        double fChanceFactor = 1.0;\n        while(1)\n        {\n            int nKBucket = GetRandInt(vvTried.size());\n            std::vector<int> &vTried = vvTried[nKBucket];\n            if (vTried.size() == 0) continue;\n            int nPos = GetRandInt(vTried.size());\n            assert(mapInfo.count(vTried[nPos]) == 1);\n            CAddrInfo &info = mapInfo[vTried[nPos]];\n            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                return info;\n            fChanceFactor *= 1.2;\n        }\n    } else {\n        // use a new node\n        double fChanceFactor = 1.0;\n        while(1)\n        {\n            int nUBucket = GetRandInt(vvNew.size());\n            std::set<int> &vNew = vvNew[nUBucket];\n            if (vNew.size() == 0) continue;\n            int nPos = GetRandInt(vNew.size());\n            std::set<int>::iterator it = vNew.begin();\n            while (nPos--)\n                it++;\n            assert(mapInfo.count(*it) == 1);\n            CAddrInfo &info = mapInfo[*it];\n            if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                return info;\n            fChanceFactor *= 1.2;\n        }\n    }\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "info.GetChance",
          "args": [],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "1<<30"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(*it) == 1"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapInfo.count",
          "args": [
            "*it"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.begin",
          "args": [],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.size",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "info.GetChance",
          "args": [],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(vTried[nPos]) == 1"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "nNew"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sqrt",
          "args": [
            "nTried"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CAddress",
          "args": [],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CAddress",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "89-94",
          "snippet": "void CAddress::Init()\n{\n    nServices = NODE_NETWORK;\n    nTime = 100000000;\n    nLastTry = 0;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nCAddress {\n  void CAddress::Init()\n  {\n      nServices = NODE_NETWORK;\n      nTime = 100000000;\n      nLastTry = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  CAddress CAddrMan::Select_(int nUnkBias)\n  {\n      if (size() == 0)\n          return CAddress();\n  \n      double nCorTried = sqrt(nTried) * (100.0 - nUnkBias);\n      double nCorNew = sqrt(nNew) * nUnkBias;\n      if ((nCorTried + nCorNew)*GetRandInt(1<<30)/(1<<30) < nCorTried)\n      {\n          // use a tried node\n          double fChanceFactor = 1.0;\n          while(1)\n          {\n              int nKBucket = GetRandInt(vvTried.size());\n              std::vector<int> &vTried = vvTried[nKBucket];\n              if (vTried.size() == 0) continue;\n              int nPos = GetRandInt(vTried.size());\n              assert(mapInfo.count(vTried[nPos]) == 1);\n              CAddrInfo &info = mapInfo[vTried[nPos]];\n              if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                  return info;\n              fChanceFactor *= 1.2;\n          }\n      } else {\n          // use a new node\n          double fChanceFactor = 1.0;\n          while(1)\n          {\n              int nUBucket = GetRandInt(vvNew.size());\n              std::set<int> &vNew = vvNew[nUBucket];\n              if (vNew.size() == 0) continue;\n              int nPos = GetRandInt(vNew.size());\n              std::set<int>::iterator it = vNew.begin();\n              while (nPos--)\n                  it++;\n              assert(mapInfo.count(*it) == 1);\n              CAddrInfo &info = mapInfo[*it];\n              if (GetRandInt(1<<30) < fChanceFactor*info.GetChance()*(1<<30))\n                  return info;\n              fChanceFactor *= 1.2;\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "Attempt_",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "370-387",
    "snippet": "void CAddrMan::Attempt_(const CService &addr, int64_t nTime)\n{\n    CAddrInfo *pinfo = Find(addr);\n\n    // if not found, bail out\n    if (!pinfo)\n        return;\n\n    CAddrInfo &info = *pinfo;\n\n    // check whether we are talking about the exact same CService (including same port)\n    if (info != addr)\n        return;\n\n    // update info\n    info.nLastTry = nTime;\n    info.nAttempts++;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Find",
          "args": [
            "addr"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "Find",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "505-513",
          "snippet": "int Find(opcodetype op) const\n    {\n        int nFound = 0;\n        opcodetype opcode;\n        for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n            if (opcode == op)\n                ++nFound;\n        return nFound;\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  int Find(opcodetype op) const\n      {\n          int nFound = 0;\n          opcodetype opcode;\n          for (const_iterator pc = begin(); pc != end() && GetOp(pc, opcode);)\n              if (opcode == op)\n                  ++nFound;\n          return nFound;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::Attempt_(const CService &addr, int64_t nTime)\n  {\n      CAddrInfo *pinfo = Find(addr);\n  \n      // if not found, bail out\n      if (!pinfo)\n          return;\n  \n      CAddrInfo &info = *pinfo;\n  \n      // check whether we are talking about the exact same CService (including same port)\n      if (info != addr)\n          return;\n  \n      // update info\n      info.nLastTry = nTime;\n      info.nAttempts++;\n  }\n}"
  },
  {
    "function_name": "Add_",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "312-368",
    "snippet": "bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n{\n    if (!addr.IsRoutable())\n        return false;\n\n    bool fNew = false;\n    int nId;\n    CAddrInfo *pinfo = Find(addr, &nId);\n\n    if (pinfo)\n    {\n        // periodically update nTime\n        bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n        int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n        if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n            pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);\n\n        // add services\n        pinfo->nServices |= addr.nServices;\n\n        // do not update if no new information is present\n        if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n            return false;\n\n        // do not update if the entry was already in the \"tried\" table\n        if (pinfo->fInTried)\n            return false;\n\n        // do not update if the max reference count is reached\n        if (pinfo->nRefCount == ADAGSAN_NEW_BUCKETS_PER_ADDRESS)\n            return false;\n\n        // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n        int nFactor = 1;\n        for (int n=0; n<pinfo->nRefCount; n++)\n            nFactor *= 2;\n        if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n            return false;\n    } else {\n        pinfo = Create(addr, source, &nId);\n        pinfo->nTime = max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n//        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n        nNew++;\n        fNew = true;\n    }\n\n    int nUBucket = pinfo->GetNewBucket(nKey, source);\n    std::set<int> &vNew = vvNew[nUBucket];\n    if (!vNew.count(nId))\n    {\n        pinfo->nRefCount++;\n        if (vNew.size() == ADAGSAN_NEW_BUCKET_SIZE)\n            ShrinkNew(nUBucket);\n        vvNew[nUBucket].insert(nId);\n    }\n    return fNew;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vvNew[nUBucket].insert",
          "args": [
            "nId"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ShrinkNew",
          "args": [
            "nUBucket"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ShrinkNew",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "149-201",
          "snippet": "int CAddrMan::ShrinkNew(int nUBucket)\n{\n    assert(nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size());\n    std::set<int> &vNew = vvNew[nUBucket];\n\n    // first look for deletable items\n    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n    {\n        assert(mapInfo.count(*it));\n        CAddrInfo &info = mapInfo[*it];\n        if (info.IsTerrible())\n        {\n            if (--info.nRefCount == 0)\n            {\n                SwapRandom(info.nRandomPos, vRandom.size()-1);\n                vRandom.pop_back();\n                mapAddr.erase(info);\n                mapInfo.erase(*it);\n                nNew--;\n            }\n            vNew.erase(it);\n            return 0;\n        }\n    }\n\n    // otherwise, select four randomly, and pick the oldest of those to replace\n    int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n    int nI = 0;\n    int nOldest = -1;\n    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n    {\n        if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n        {\n            assert(nOldest == -1 || mapInfo.count(*it) == 1);\n            if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n                nOldest = *it;\n        }\n        nI++;\n    }\n    assert(mapInfo.count(nOldest) == 1);\n    CAddrInfo &info = mapInfo[nOldest];\n    if (--info.nRefCount == 0)\n    {\n        SwapRandom(info.nRandomPos, vRandom.size()-1);\n        vRandom.pop_back();\n        mapAddr.erase(info);\n        mapInfo.erase(nOldest);\n        nNew--;\n    }\n    vNew.erase(nOldest);\n\n    return 1;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::ShrinkNew(int nUBucket)\n  {\n      assert(nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size());\n      std::set<int> &vNew = vvNew[nUBucket];\n  \n      // first look for deletable items\n      for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n      {\n          assert(mapInfo.count(*it));\n          CAddrInfo &info = mapInfo[*it];\n          if (info.IsTerrible())\n          {\n              if (--info.nRefCount == 0)\n              {\n                  SwapRandom(info.nRandomPos, vRandom.size()-1);\n                  vRandom.pop_back();\n                  mapAddr.erase(info);\n                  mapInfo.erase(*it);\n                  nNew--;\n              }\n              vNew.erase(it);\n              return 0;\n          }\n      }\n  \n      // otherwise, select four randomly, and pick the oldest of those to replace\n      int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n      int nI = 0;\n      int nOldest = -1;\n      for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n      {\n          if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n          {\n              assert(nOldest == -1 || mapInfo.count(*it) == 1);\n              if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n                  nOldest = *it;\n          }\n          nI++;\n      }\n      assert(mapInfo.count(nOldest) == 1);\n      CAddrInfo &info = mapInfo[nOldest];\n      if (--info.nRefCount == 0)\n      {\n          SwapRandom(info.nRandomPos, vRandom.size()-1);\n          vRandom.pop_back();\n          mapAddr.erase(info);\n          mapInfo.erase(nOldest);\n          nNew--;\n      }\n      vNew.erase(nOldest);\n  \n      return 1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.size",
          "args": [],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.count",
          "args": [
            "nId"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pinfo->GetNewBucket",
          "args": [
            "nKey",
            "source"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "GetNewBucket",
          "container": "CAddrInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "23-35",
          "snippet": "int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n{\n    CDataStream ss1(SER_GETHASH, 0);\n    std::vector<unsigned char> vchGroupKey = GetGroup();\n    std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n\n    CDataStream ss2(SER_GETHASH, 0);\n    ss2 << nKey << vchSourceGroupKey << (hash1 % ADAGSAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n    return hash2 % ADAGSAN_NEW_BUCKET_COUNT;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrInfo {\n  int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n  {\n      CDataStream ss1(SER_GETHASH, 0);\n      std::vector<unsigned char> vchGroupKey = GetGroup();\n      std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n      ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n      uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n  \n      CDataStream ss2(SER_GETHASH, 0);\n      ss2 << nKey << vchSourceGroupKey << (hash1 % ADAGSAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n      uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n      return hash2 % ADAGSAN_NEW_BUCKET_COUNT;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "(int64_t)0",
            "(int64_t)pinfo->nTime - nTimePenalty"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_max_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "433-435",
          "snippet": "void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Create",
          "args": [
            "addr",
            "source",
            "&nId"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "CreateFilter",
          "container": "BloomFilterPolicy",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/bloom.cc",
          "lines": "35-61",
          "snippet": "virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n    // Compute bloom filter size (in both bits and bytes)\n    size_t bits = n * bits_per_key_;\n\n    // For small n, we can see a very high false positive rate.  Fix it\n    // by enforcing a minimum bloom filter length.\n    if (bits < 64) bits = 64;\n\n    size_t bytes = (bits + 7) / 8;\n    bits = bytes * 8;\n\n    const size_t init_size = dst->size();\n    dst->resize(init_size + bytes, 0);\n    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter\n    char* array = &(*dst)[init_size];\n    for (size_t i = 0; i < n; i++) {\n      // Use double-hashing to generate a sequence of hash values.\n      // See analysis in [Kirsch,Mitzenmacher 2006].\n      uint32_t h = BloomHash(keys[i]);\n      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits\n      for (size_t j = 0; j < k_; j++) {\n        const uint32_t bitpos = h % bits;\n        array[bitpos/8] |= (1 << (bitpos % 8));\n        h += delta;\n      }\n    }\n  }",
          "includes": [
            "#include \"util/hash.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/hash.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n\nBloomFilterPolicy {\n  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n      // Compute bloom filter size (in both bits and bytes)\n      size_t bits = n * bits_per_key_;\n  \n      // For small n, we can see a very high false positive rate.  Fix it\n      // by enforcing a minimum bloom filter length.\n      if (bits < 64) bits = 64;\n  \n      size_t bytes = (bits + 7) / 8;\n      bits = bytes * 8;\n  \n      const size_t init_size = dst->size();\n      dst->resize(init_size + bytes, 0);\n      dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter\n      char* array = &(*dst)[init_size];\n      for (size_t i = 0; i < n; i++) {\n        // Use double-hashing to generate a sequence of hash values.\n        // See analysis in [Kirsch,Mitzenmacher 2006].\n        uint32_t h = BloomHash(keys[i]);\n        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits\n        for (size_t j = 0; j < k_; j++) {\n          const uint32_t bitpos = h % bits;\n          array[bitpos/8] |= (1 << (bitpos % 8));\n          h += delta;\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "nFactor"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Find",
          "args": [
            "addr",
            "&nId"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "FindShortestSeparator",
          "container": "BytewiseComparatorImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/comparator.cc",
          "lines": "29-51",
          "snippet": "virtual void FindShortestSeparator(\n      std::string* start,\n      const Slice& limit) const {\n    // Find length of common prefix\n    size_t min_length = std::min(start->size(), limit.size());\n    size_t diff_index = 0;\n    while ((diff_index < min_length) &&\n           ((*start)[diff_index] == limit[diff_index])) {\n      diff_index++;\n    }\n\n    if (diff_index >= min_length) {\n      // Do not shorten if one string is a prefix of the other\n    } else {\n      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);\n      if (diff_byte < static_cast<uint8_t>(0xff) &&\n          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {\n        (*start)[diff_index]++;\n        start->resize(diff_index + 1);\n        assert(Compare(*start, limit) < 0);\n      }\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdint.h>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/comparator.h\"\n#include <stdint.h>\n#include <algorithm>\n\nBytewiseComparatorImpl {\n  virtual void FindShortestSeparator(\n        std::string* start,\n        const Slice& limit) const {\n      // Find length of common prefix\n      size_t min_length = std::min(start->size(), limit.size());\n      size_t diff_index = 0;\n      while ((diff_index < min_length) &&\n             ((*start)[diff_index] == limit[diff_index])) {\n        diff_index++;\n      }\n  \n      if (diff_index >= min_length) {\n        // Do not shorten if one string is a prefix of the other\n      } else {\n        uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);\n        if (diff_byte < static_cast<uint8_t>(0xff) &&\n            diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {\n          (*start)[diff_index]++;\n          start->resize(diff_index + 1);\n          assert(Compare(*start, limit) < 0);\n        }\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.IsRoutable",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  bool CAddrMan::Add_(const CAddress &addr, const CNetAddr& source, int64_t nTimePenalty)\n  {\n      if (!addr.IsRoutable())\n          return false;\n  \n      bool fNew = false;\n      int nId;\n      CAddrInfo *pinfo = Find(addr, &nId);\n  \n      if (pinfo)\n      {\n          // periodically update nTime\n          bool fCurrentlyOnline = (GetAdjustedTime() - addr.nTime < 24 * 60 * 60);\n          int64_t nUpdateInterval = (fCurrentlyOnline ? 60 * 60 : 24 * 60 * 60);\n          if (addr.nTime && (!pinfo->nTime || pinfo->nTime < addr.nTime - nUpdateInterval - nTimePenalty))\n              pinfo->nTime = max((int64_t)0, addr.nTime - nTimePenalty);\n  \n          // add services\n          pinfo->nServices |= addr.nServices;\n  \n          // do not update if no new information is present\n          if (!addr.nTime || (pinfo->nTime && addr.nTime <= pinfo->nTime))\n              return false;\n  \n          // do not update if the entry was already in the \"tried\" table\n          if (pinfo->fInTried)\n              return false;\n  \n          // do not update if the max reference count is reached\n          if (pinfo->nRefCount == ADAGSAN_NEW_BUCKETS_PER_ADDRESS)\n              return false;\n  \n          // stochastic test: previous nRefCount == N: 2^N times harder to increase it\n          int nFactor = 1;\n          for (int n=0; n<pinfo->nRefCount; n++)\n              nFactor *= 2;\n          if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n              return false;\n      } else {\n          pinfo = Create(addr, source, &nId);\n          pinfo->nTime = max((int64_t)0, (int64_t)pinfo->nTime - nTimePenalty);\n  //        printf(\"Added %s [nTime=%fhr]\\n\", pinfo->ToString().c_str(), (GetAdjustedTime() - pinfo->nTime) / 3600.0);\n          nNew++;\n          fNew = true;\n      }\n  \n      int nUBucket = pinfo->GetNewBucket(nKey, source);\n      std::set<int> &vNew = vvNew[nUBucket];\n      if (!vNew.count(nId))\n      {\n          pinfo->nRefCount++;\n          if (vNew.size() == ADAGSAN_NEW_BUCKET_SIZE)\n              ShrinkNew(nUBucket);\n          vvNew[nUBucket].insert(nId);\n      }\n      return fNew;\n  }\n}"
  },
  {
    "function_name": "Good_",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "261-310",
    "snippet": "void CAddrMan::Good_(const CService &addr, int64_t nTime)\n{\n//    printf(\"Good: addr=%s\\n\", addr.ToString().c_str());\n\n    int nId;\n    CAddrInfo *pinfo = Find(addr, &nId);\n\n    // if not found, bail out\n    if (!pinfo)\n        return;\n\n    CAddrInfo &info = *pinfo;\n\n    // check whether we are talking about the exact same CService (including same port)\n    if (info != addr)\n        return;\n\n    // update info\n    info.nLastSuccess = nTime;\n    info.nLastTry = nTime;\n    info.nTime = nTime;\n    info.nAttempts = 0;\n\n    // if it is already in the tried set, don't do anything else\n    if (info.fInTried)\n        return;\n\n    // find a bucket it is in now\n    int nRnd = GetRandInt(vvNew.size());\n    int nUBucket = -1;\n    for (unsigned int n = 0; n < vvNew.size(); n++)\n    {\n        int nB = (n+nRnd) % vvNew.size();\n        std::set<int> &vNew = vvNew[nB];\n        if (vNew.count(nId))\n        {\n            nUBucket = nB;\n            break;\n        }\n    }\n\n    // if no bucket is found, something bad happened;\n    // TODO: maybe re-add the node, but for now, just bail out\n    if (nUBucket == -1) return;\n\n    printf(\"Moving %s to tried\\n\", addr.ToString().c_str());\n\n    // move nId to the tried tables\n    MakeTried(info, nId, nUBucket);\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MakeTried",
          "args": [
            "info",
            "nId",
            "nUBucket"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "MakeTried",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "203-259",
          "snippet": "void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n{\n    assert(vvNew[nOrigin].count(nId) == 1);\n\n    // remove the entry from all new buckets\n    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n    {\n        if ((*it).erase(nId))\n            info.nRefCount--;\n    }\n    nNew--;\n\n    assert(info.nRefCount == 0);\n\n    // what tried bucket to move the entry to\n    int nKBucket = info.GetTriedBucket(nKey);\n    std::vector<int> &vTried = vvTried[nKBucket];\n\n    // first check whether there is place to just add it\n    if (vTried.size() < ADAGSAN_TRIED_BUCKET_SIZE)\n    {\n        vTried.push_back(nId);\n        nTried++;\n        info.fInTried = true;\n        return;\n    }\n\n    // otherwise, find an item to evict\n    int nPos = SelectTried(nKBucket);\n\n    // find which new bucket it belongs to\n    assert(mapInfo.count(vTried[nPos]) == 1);\n    int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n    std::set<int> &vNew = vvNew[nUBucket];\n\n    // remove the to-be-replaced tried entry from the tried set\n    CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n    infoOld.fInTried = false;\n    infoOld.nRefCount = 1;\n    // do not update nTried, as we are going to move something else there immediately\n\n    // check whether there is place in that one,\n    if (vNew.size() < ADAGSAN_NEW_BUCKET_SIZE)\n    {\n        // if so, move it back there\n        vNew.insert(vTried[nPos]);\n    } else {\n        // otherwise, move it to the new bucket nId came from (there is certainly place there)\n        vvNew[nOrigin].insert(vTried[nPos]);\n    }\n    nNew++;\n\n    vTried[nPos] = nId;\n    // we just overwrote an entry in vTried; no need to update nTried\n    info.fInTried = true;\n    return;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n  {\n      assert(vvNew[nOrigin].count(nId) == 1);\n  \n      // remove the entry from all new buckets\n      for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n      {\n          if ((*it).erase(nId))\n              info.nRefCount--;\n      }\n      nNew--;\n  \n      assert(info.nRefCount == 0);\n  \n      // what tried bucket to move the entry to\n      int nKBucket = info.GetTriedBucket(nKey);\n      std::vector<int> &vTried = vvTried[nKBucket];\n  \n      // first check whether there is place to just add it\n      if (vTried.size() < ADAGSAN_TRIED_BUCKET_SIZE)\n      {\n          vTried.push_back(nId);\n          nTried++;\n          info.fInTried = true;\n          return;\n      }\n  \n      // otherwise, find an item to evict\n      int nPos = SelectTried(nKBucket);\n  \n      // find which new bucket it belongs to\n      assert(mapInfo.count(vTried[nPos]) == 1);\n      int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n      std::set<int> &vNew = vvNew[nUBucket];\n  \n      // remove the to-be-replaced tried entry from the tried set\n      CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n      infoOld.fInTried = false;\n      infoOld.nRefCount = 1;\n      // do not update nTried, as we are going to move something else there immediately\n  \n      // check whether there is place in that one,\n      if (vNew.size() < ADAGSAN_NEW_BUCKET_SIZE)\n      {\n          // if so, move it back there\n          vNew.insert(vTried[nPos]);\n      } else {\n          // otherwise, move it to the new bucket nId came from (there is certainly place there)\n          vvNew[nOrigin].insert(vTried[nPos]);\n      }\n      nNew++;\n  \n      vTried[nPos] = nId;\n      // we just overwrote an entry in vTried; no need to update nTried\n      info.fInTried = true;\n      return;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Moving %s to tried\\n\"",
            "addr.ToString().c_str()"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.ToString",
          "args": [],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.count",
          "args": [
            "nId"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vvNew.size",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "vvNew.size()"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Find",
          "args": [
            "addr",
            "&nId"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "FindShortestSeparator",
          "container": "BytewiseComparatorImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/comparator.cc",
          "lines": "29-51",
          "snippet": "virtual void FindShortestSeparator(\n      std::string* start,\n      const Slice& limit) const {\n    // Find length of common prefix\n    size_t min_length = std::min(start->size(), limit.size());\n    size_t diff_index = 0;\n    while ((diff_index < min_length) &&\n           ((*start)[diff_index] == limit[diff_index])) {\n      diff_index++;\n    }\n\n    if (diff_index >= min_length) {\n      // Do not shorten if one string is a prefix of the other\n    } else {\n      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);\n      if (diff_byte < static_cast<uint8_t>(0xff) &&\n          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {\n        (*start)[diff_index]++;\n        start->resize(diff_index + 1);\n        assert(Compare(*start, limit) < 0);\n      }\n    }\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdint.h>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/comparator.h\"\n#include <stdint.h>\n#include <algorithm>\n\nBytewiseComparatorImpl {\n  virtual void FindShortestSeparator(\n        std::string* start,\n        const Slice& limit) const {\n      // Find length of common prefix\n      size_t min_length = std::min(start->size(), limit.size());\n      size_t diff_index = 0;\n      while ((diff_index < min_length) &&\n             ((*start)[diff_index] == limit[diff_index])) {\n        diff_index++;\n      }\n  \n      if (diff_index >= min_length) {\n        // Do not shorten if one string is a prefix of the other\n      } else {\n        uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);\n        if (diff_byte < static_cast<uint8_t>(0xff) &&\n            diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {\n          (*start)[diff_index]++;\n          start->resize(diff_index + 1);\n          assert(Compare(*start, limit) < 0);\n        }\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::Good_(const CService &addr, int64_t nTime)\n  {\n  //    printf(\"Good: addr=%s\\n\", addr.ToString().c_str());\n  \n      int nId;\n      CAddrInfo *pinfo = Find(addr, &nId);\n  \n      // if not found, bail out\n      if (!pinfo)\n          return;\n  \n      CAddrInfo &info = *pinfo;\n  \n      // check whether we are talking about the exact same CService (including same port)\n      if (info != addr)\n          return;\n  \n      // update info\n      info.nLastSuccess = nTime;\n      info.nLastTry = nTime;\n      info.nTime = nTime;\n      info.nAttempts = 0;\n  \n      // if it is already in the tried set, don't do anything else\n      if (info.fInTried)\n          return;\n  \n      // find a bucket it is in now\n      int nRnd = GetRandInt(vvNew.size());\n      int nUBucket = -1;\n      for (unsigned int n = 0; n < vvNew.size(); n++)\n      {\n          int nB = (n+nRnd) % vvNew.size();\n          std::set<int> &vNew = vvNew[nB];\n          if (vNew.count(nId))\n          {\n              nUBucket = nB;\n              break;\n          }\n      }\n  \n      // if no bucket is found, something bad happened;\n      // TODO: maybe re-add the node, but for now, just bail out\n      if (nUBucket == -1) return;\n  \n      printf(\"Moving %s to tried\\n\", addr.ToString().c_str());\n  \n      // move nId to the tried tables\n      MakeTried(info, nId, nUBucket);\n  }\n}"
  },
  {
    "function_name": "MakeTried",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "203-259",
    "snippet": "void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n{\n    assert(vvNew[nOrigin].count(nId) == 1);\n\n    // remove the entry from all new buckets\n    for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n    {\n        if ((*it).erase(nId))\n            info.nRefCount--;\n    }\n    nNew--;\n\n    assert(info.nRefCount == 0);\n\n    // what tried bucket to move the entry to\n    int nKBucket = info.GetTriedBucket(nKey);\n    std::vector<int> &vTried = vvTried[nKBucket];\n\n    // first check whether there is place to just add it\n    if (vTried.size() < ADAGSAN_TRIED_BUCKET_SIZE)\n    {\n        vTried.push_back(nId);\n        nTried++;\n        info.fInTried = true;\n        return;\n    }\n\n    // otherwise, find an item to evict\n    int nPos = SelectTried(nKBucket);\n\n    // find which new bucket it belongs to\n    assert(mapInfo.count(vTried[nPos]) == 1);\n    int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n    std::set<int> &vNew = vvNew[nUBucket];\n\n    // remove the to-be-replaced tried entry from the tried set\n    CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n    infoOld.fInTried = false;\n    infoOld.nRefCount = 1;\n    // do not update nTried, as we are going to move something else there immediately\n\n    // check whether there is place in that one,\n    if (vNew.size() < ADAGSAN_NEW_BUCKET_SIZE)\n    {\n        // if so, move it back there\n        vNew.insert(vTried[nPos]);\n    } else {\n        // otherwise, move it to the new bucket nId came from (there is certainly place there)\n        vvNew[nOrigin].insert(vTried[nPos]);\n    }\n    nNew++;\n\n    vTried[nPos] = nId;\n    // we just overwrote an entry in vTried; no need to update nTried\n    info.fInTried = true;\n    return;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vvNew[nOrigin].insert",
          "args": [
            "vTried[nPos]"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.size",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapInfo[vTried[nPos]].GetNewBucket",
          "args": [
            "nKey"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "GetNewBucket",
          "container": "CAddrInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "83-86",
          "snippet": "int GetNewBucket(const std::vector<unsigned char> &nKey) const\n    {\n        return GetNewBucket(nKey, source);\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nCAddrInfo {\n  int GetNewBucket(const std::vector<unsigned char> &nKey) const\n      {\n          return GetNewBucket(nKey, source);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(vTried[nPos]) == 1"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapInfo.count",
          "args": [
            "vTried[nPos]"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SelectTried",
          "args": [
            "nKBucket"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "SelectTried",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "125-147",
          "snippet": "int CAddrMan::SelectTried(int nKBucket)\n{\n    std::vector<int> &vTried = vvTried[nKBucket];\n\n    // random shuffle the first few elements (using the entire list)\n    // find the least recently tried among them\n    int64_t nOldest = -1;\n    int nOldestPos = -1;\n    for (unsigned int i = 0; i < ADAGSAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++)\n    {\n        int nPos = GetRandInt(vTried.size() - i) + i;\n        int nTemp = vTried[nPos];\n        vTried[nPos] = vTried[i];\n        vTried[i] = nTemp;\n        assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n        if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n           nOldest = nTemp;\n           nOldestPos = nPos;\n        }\n    }\n\n    return nOldestPos;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::SelectTried(int nKBucket)\n  {\n      std::vector<int> &vTried = vvTried[nKBucket];\n  \n      // random shuffle the first few elements (using the entire list)\n      // find the least recently tried among them\n      int64_t nOldest = -1;\n      int nOldestPos = -1;\n      for (unsigned int i = 0; i < ADAGSAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++)\n      {\n          int nPos = GetRandInt(vTried.size() - i) + i;\n          int nTemp = vTried[nPos];\n          vTried[nPos] = vTried[i];\n          vTried[i] = nTemp;\n          assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n          if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n             nOldest = nTemp;\n             nOldestPos = nPos;\n          }\n      }\n  \n      return nOldestPos;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vTried.push_back",
          "args": [
            "nId"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info.GetTriedBucket",
          "args": [
            "nKey"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "GetTriedBucket",
          "container": "CAddrInfo",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "9-21",
          "snippet": "int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n{\n    CDataStream ss1(SER_GETHASH, 0);\n    std::vector<unsigned char> vchKey = GetKey();\n    ss1 << nKey << vchKey;\n    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n\n    CDataStream ss2(SER_GETHASH, 0);\n    std::vector<unsigned char> vchGroupKey = GetGroup();\n    ss2 << nKey << vchGroupKey << (hash1 % ADAGSAN_TRIED_BUCKETS_PER_GROUP);\n    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n    return hash2 % ADAGSAN_TRIED_BUCKET_COUNT;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrInfo {\n  int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n  {\n      CDataStream ss1(SER_GETHASH, 0);\n      std::vector<unsigned char> vchKey = GetKey();\n      ss1 << nKey << vchKey;\n      uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n  \n      CDataStream ss2(SER_GETHASH, 0);\n      std::vector<unsigned char> vchGroupKey = GetGroup();\n      ss2 << nKey << vchGroupKey << (hash1 % ADAGSAN_TRIED_BUCKETS_PER_GROUP);\n      uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n      return hash2 % ADAGSAN_TRIED_BUCKET_COUNT;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "info.nRefCount == 0"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "nId"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vvNew.end",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vvNew.begin",
          "args": [],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "vvNew[nOrigin].count(nId) == 1"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::MakeTried(CAddrInfo& info, int nId, int nOrigin)\n  {\n      assert(vvNew[nOrigin].count(nId) == 1);\n  \n      // remove the entry from all new buckets\n      for (std::vector<std::set<int> >::iterator it = vvNew.begin(); it != vvNew.end(); it++)\n      {\n          if ((*it).erase(nId))\n              info.nRefCount--;\n      }\n      nNew--;\n  \n      assert(info.nRefCount == 0);\n  \n      // what tried bucket to move the entry to\n      int nKBucket = info.GetTriedBucket(nKey);\n      std::vector<int> &vTried = vvTried[nKBucket];\n  \n      // first check whether there is place to just add it\n      if (vTried.size() < ADAGSAN_TRIED_BUCKET_SIZE)\n      {\n          vTried.push_back(nId);\n          nTried++;\n          info.fInTried = true;\n          return;\n      }\n  \n      // otherwise, find an item to evict\n      int nPos = SelectTried(nKBucket);\n  \n      // find which new bucket it belongs to\n      assert(mapInfo.count(vTried[nPos]) == 1);\n      int nUBucket = mapInfo[vTried[nPos]].GetNewBucket(nKey);\n      std::set<int> &vNew = vvNew[nUBucket];\n  \n      // remove the to-be-replaced tried entry from the tried set\n      CAddrInfo& infoOld = mapInfo[vTried[nPos]];\n      infoOld.fInTried = false;\n      infoOld.nRefCount = 1;\n      // do not update nTried, as we are going to move something else there immediately\n  \n      // check whether there is place in that one,\n      if (vNew.size() < ADAGSAN_NEW_BUCKET_SIZE)\n      {\n          // if so, move it back there\n          vNew.insert(vTried[nPos]);\n      } else {\n          // otherwise, move it to the new bucket nId came from (there is certainly place there)\n          vvNew[nOrigin].insert(vTried[nPos]);\n      }\n      nNew++;\n  \n      vTried[nPos] = nId;\n      // we just overwrote an entry in vTried; no need to update nTried\n      info.fInTried = true;\n      return;\n  }\n}"
  },
  {
    "function_name": "ShrinkNew",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "149-201",
    "snippet": "int CAddrMan::ShrinkNew(int nUBucket)\n{\n    assert(nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size());\n    std::set<int> &vNew = vvNew[nUBucket];\n\n    // first look for deletable items\n    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n    {\n        assert(mapInfo.count(*it));\n        CAddrInfo &info = mapInfo[*it];\n        if (info.IsTerrible())\n        {\n            if (--info.nRefCount == 0)\n            {\n                SwapRandom(info.nRandomPos, vRandom.size()-1);\n                vRandom.pop_back();\n                mapAddr.erase(info);\n                mapInfo.erase(*it);\n                nNew--;\n            }\n            vNew.erase(it);\n            return 0;\n        }\n    }\n\n    // otherwise, select four randomly, and pick the oldest of those to replace\n    int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n    int nI = 0;\n    int nOldest = -1;\n    for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n    {\n        if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n        {\n            assert(nOldest == -1 || mapInfo.count(*it) == 1);\n            if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n                nOldest = *it;\n        }\n        nI++;\n    }\n    assert(mapInfo.count(nOldest) == 1);\n    CAddrInfo &info = mapInfo[nOldest];\n    if (--info.nRefCount == 0)\n    {\n        SwapRandom(info.nRandomPos, vRandom.size()-1);\n        vRandom.pop_back();\n        mapAddr.erase(info);\n        mapInfo.erase(nOldest);\n        nNew--;\n    }\n    vNew.erase(nOldest);\n\n    return 1;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vNew.erase",
          "args": [
            "nOldest"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRandom.pop_back",
          "args": [],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SwapRandom",
          "args": [
            "info.nRandomPos",
            "vRandom.size()-1"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "SwapRandom",
          "container": "CAddrMan",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
          "lines": "105-123",
          "snippet": "void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n{\n    if (nRndPos1 == nRndPos2)\n        return;\n\n    assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());\n\n    int nId1 = vRandom[nRndPos1];\n    int nId2 = vRandom[nRndPos2];\n\n    assert(mapInfo.count(nId1) == 1);\n    assert(mapInfo.count(nId2) == 1);\n\n    mapInfo[nId1].nRandomPos = nRndPos2;\n    mapInfo[nId2].nRandomPos = nRndPos1;\n\n    vRandom[nRndPos1] = nId2;\n    vRandom[nRndPos2] = nId1;\n}",
          "includes": [
            "#include \"addrman.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n  {\n      if (nRndPos1 == nRndPos2)\n          return;\n  \n      assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());\n  \n      int nId1 = vRandom[nRndPos1];\n      int nId2 = vRandom[nRndPos2];\n  \n      assert(mapInfo.count(nId1) == 1);\n      assert(mapInfo.count(nId2) == 1);\n  \n      mapInfo[nId1].nRandomPos = nRndPos2;\n      mapInfo[nId2].nRandomPos = nRndPos1;\n  \n      vRandom[nRndPos1] = nId2;\n      vRandom[nRndPos2] = nId1;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRandom.size",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(nOldest) == 1"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapInfo.count",
          "args": [
            "nOldest"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nOldest == -1 || mapInfo.count(*it) == 1"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vNew.end",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vNew.begin",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "vNew.size()"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRandom.pop_back",
          "args": [],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info.IsTerrible",
          "args": [],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(*it)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size()"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::ShrinkNew(int nUBucket)\n  {\n      assert(nUBucket >= 0 && (unsigned int)nUBucket < vvNew.size());\n      std::set<int> &vNew = vvNew[nUBucket];\n  \n      // first look for deletable items\n      for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n      {\n          assert(mapInfo.count(*it));\n          CAddrInfo &info = mapInfo[*it];\n          if (info.IsTerrible())\n          {\n              if (--info.nRefCount == 0)\n              {\n                  SwapRandom(info.nRandomPos, vRandom.size()-1);\n                  vRandom.pop_back();\n                  mapAddr.erase(info);\n                  mapInfo.erase(*it);\n                  nNew--;\n              }\n              vNew.erase(it);\n              return 0;\n          }\n      }\n  \n      // otherwise, select four randomly, and pick the oldest of those to replace\n      int n[4] = {GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size()), GetRandInt(vNew.size())};\n      int nI = 0;\n      int nOldest = -1;\n      for (std::set<int>::iterator it = vNew.begin(); it != vNew.end(); it++)\n      {\n          if (nI == n[0] || nI == n[1] || nI == n[2] || nI == n[3])\n          {\n              assert(nOldest == -1 || mapInfo.count(*it) == 1);\n              if (nOldest == -1 || mapInfo[*it].nTime < mapInfo[nOldest].nTime)\n                  nOldest = *it;\n          }\n          nI++;\n      }\n      assert(mapInfo.count(nOldest) == 1);\n      CAddrInfo &info = mapInfo[nOldest];\n      if (--info.nRefCount == 0)\n      {\n          SwapRandom(info.nRandomPos, vRandom.size()-1);\n          vRandom.pop_back();\n          mapAddr.erase(info);\n          mapInfo.erase(nOldest);\n          nNew--;\n      }\n      vNew.erase(nOldest);\n  \n      return 1;\n  }\n}"
  },
  {
    "function_name": "SelectTried",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "125-147",
    "snippet": "int CAddrMan::SelectTried(int nKBucket)\n{\n    std::vector<int> &vTried = vvTried[nKBucket];\n\n    // random shuffle the first few elements (using the entire list)\n    // find the least recently tried among them\n    int64_t nOldest = -1;\n    int nOldestPos = -1;\n    for (unsigned int i = 0; i < ADAGSAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++)\n    {\n        int nPos = GetRandInt(vTried.size() - i) + i;\n        int nTemp = vTried[nPos];\n        vTried[nPos] = vTried[i];\n        vTried[i] = nTemp;\n        assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n        if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n           nOldest = nTemp;\n           nOldestPos = nPos;\n        }\n    }\n\n    return nOldestPos;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nOldest == -1 || mapInfo.count(nTemp) == 1"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapInfo.count",
          "args": [
            "nTemp"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetRandInt",
          "args": [
            "vTried.size() - i"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vTried.size",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  int CAddrMan::SelectTried(int nKBucket)\n  {\n      std::vector<int> &vTried = vvTried[nKBucket];\n  \n      // random shuffle the first few elements (using the entire list)\n      // find the least recently tried among them\n      int64_t nOldest = -1;\n      int nOldestPos = -1;\n      for (unsigned int i = 0; i < ADAGSAN_TRIED_ENTRIES_INSPECT_ON_EVICT && i < vTried.size(); i++)\n      {\n          int nPos = GetRandInt(vTried.size() - i) + i;\n          int nTemp = vTried[nPos];\n          vTried[nPos] = vTried[i];\n          vTried[i] = nTemp;\n          assert(nOldest == -1 || mapInfo.count(nTemp) == 1);\n          if (nOldest == -1 || mapInfo[nTemp].nLastSuccess < mapInfo[nOldest].nLastSuccess) {\n             nOldest = nTemp;\n             nOldestPos = nPos;\n          }\n      }\n  \n      return nOldestPos;\n  }\n}"
  },
  {
    "function_name": "SwapRandom",
    "container": "CAddrMan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "105-123",
    "snippet": "void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n{\n    if (nRndPos1 == nRndPos2)\n        return;\n\n    assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());\n\n    int nId1 = vRandom[nRndPos1];\n    int nId2 = vRandom[nRndPos2];\n\n    assert(mapInfo.count(nId1) == 1);\n    assert(mapInfo.count(nId2) == 1);\n\n    mapInfo[nId1].nRandomPos = nRndPos2;\n    mapInfo[nId2].nRandomPos = nRndPos1;\n\n    vRandom[nRndPos1] = nId2;\n    vRandom[nRndPos2] = nId1;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(nId2) == 1"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapInfo.count",
          "args": [
            "nId2"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "mapInfo.count(nId1) == 1"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size()"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRandom.size",
          "args": [],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrMan {\n  void CAddrMan::SwapRandom(unsigned int nRndPos1, unsigned int nRndPos2)\n  {\n      if (nRndPos1 == nRndPos2)\n          return;\n  \n      assert(nRndPos1 < vRandom.size() && nRndPos2 < vRandom.size());\n  \n      int nId1 = vRandom[nRndPos1];\n      int nId2 = vRandom[nRndPos2];\n  \n      assert(mapInfo.count(nId1) == 1);\n      assert(mapInfo.count(nId2) == 1);\n  \n      mapInfo[nId1].nRandomPos = nRndPos2;\n      mapInfo[nId2].nRandomPos = nRndPos1;\n  \n      vRandom[nRndPos1] = nId2;\n      vRandom[nRndPos2] = nId1;\n  }\n}"
  },
  {
    "function_name": "GetChance",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "57-78",
    "snippet": "double CAddrInfo::GetChance(int64_t nNow) const\n{\n    double fChance = 1.0;\n\n    int64_t nSinceLastSeen = nNow - nTime;\n    int64_t nSinceLastTry = nNow - nLastTry;\n\n    if (nSinceLastSeen < 0) nSinceLastSeen = 0;\n    if (nSinceLastTry < 0) nSinceLastTry = 0;\n\n    fChance *= 600.0 / (600.0 + nSinceLastSeen);\n\n    // deprioritize very recent attempts away\n    if (nSinceLastTry < 60*10)\n        fChance *= 0.01;\n\n    // deprioritize 50% after each failed attempt\n    for (int n=0; n<nAttempts; n++)\n        fChance /= 1.5;\n\n    return fChance;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrInfo {\n  double CAddrInfo::GetChance(int64_t nNow) const\n  {\n      double fChance = 1.0;\n  \n      int64_t nSinceLastSeen = nNow - nTime;\n      int64_t nSinceLastTry = nNow - nLastTry;\n  \n      if (nSinceLastSeen < 0) nSinceLastSeen = 0;\n      if (nSinceLastTry < 0) nSinceLastTry = 0;\n  \n      fChance *= 600.0 / (600.0 + nSinceLastSeen);\n  \n      // deprioritize very recent attempts away\n      if (nSinceLastTry < 60*10)\n          fChance *= 0.01;\n  \n      // deprioritize 50% after each failed attempt\n      for (int n=0; n<nAttempts; n++)\n          fChance /= 1.5;\n  \n      return fChance;\n  }\n}"
  },
  {
    "function_name": "IsTerrible",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "37-55",
    "snippet": "bool CAddrInfo::IsTerrible(int64_t nNow) const\n{\n    if (nLastTry && nLastTry >= nNow-60) // never remove things tried the last minute\n        return false;\n\n    if (nTime > nNow + 10*60) // came in a flying DeLorean\n        return true;\n\n    if (nTime==0 || nNow-nTime > ADAGSAN_HORIZON_DAYS*86400) // not seen in over a month\n        return true;\n\n    if (nLastSuccess==0 && nAttempts>=ADAGSAN_RETRIES) // tried three times and never a success\n        return true;\n\n    if (nNow-nLastSuccess > ADAGSAN_MIN_FAIL_DAYS*86400 && nAttempts>=ADAGSAN_MAX_FAILURES) // 10 successive failures in the last week\n        return true;\n\n    return false;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrInfo {\n  bool CAddrInfo::IsTerrible(int64_t nNow) const\n  {\n      if (nLastTry && nLastTry >= nNow-60) // never remove things tried the last minute\n          return false;\n  \n      if (nTime > nNow + 10*60) // came in a flying DeLorean\n          return true;\n  \n      if (nTime==0 || nNow-nTime > ADAGSAN_HORIZON_DAYS*86400) // not seen in over a month\n          return true;\n  \n      if (nLastSuccess==0 && nAttempts>=ADAGSAN_RETRIES) // tried three times and never a success\n          return true;\n  \n      if (nNow-nLastSuccess > ADAGSAN_MIN_FAIL_DAYS*86400 && nAttempts>=ADAGSAN_MAX_FAILURES) // 10 successive failures in the last week\n          return true;\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "GetNewBucket",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "23-35",
    "snippet": "int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n{\n    CDataStream ss1(SER_GETHASH, 0);\n    std::vector<unsigned char> vchGroupKey = GetGroup();\n    std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n    ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n\n    CDataStream ss2(SER_GETHASH, 0);\n    ss2 << nKey << vchSourceGroupKey << (hash1 % ADAGSAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n    return hash2 % ADAGSAN_NEW_BUCKET_COUNT;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Hash",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "ss2.begin()",
            "ss2.end()"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss2.end",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss2.begin",
          "args": [],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "src.GetGroup",
          "args": [],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "GetGroup",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "849-920",
          "snippet": "std::vector<unsigned char> CNetAddr::GetGroup() const\n{\n    std::vector<unsigned char> vchRet;\n    int nClass = NET_IPV6;\n    int nStartByte = 0;\n    int nBits = 16;\n\n    // all local addresses belong to the same group\n    if (IsLocal())\n    {\n        nClass = 255;\n        nBits = 0;\n    }\n\n    // all unroutable addresses belong to the same group\n    if (!IsRoutable())\n    {\n        nClass = NET_UNROUTABLE;\n        nBits = 0;\n    }\n    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 12;\n    }\n    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n    else if (IsRFC3964())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 2;\n    }\n    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n    else if (IsRFC4380())\n    {\n        vchRet.push_back(NET_IPV4);\n        vchRet.push_back(GetByte(3) ^ 0xFF);\n        vchRet.push_back(GetByte(2) ^ 0xFF);\n        return vchRet;\n    }\n    else if (IsTor())\n    {\n        nClass = NET_TOR;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    else if (IsI2P())\n    {\n        nClass = NET_I2P;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    // for he.net, use /36 groups\n    else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n        nBits = 36;\n    // for the rest of the IPv6 network, use /32 groups\n    else\n        nBits = 32;\n\n    vchRet.push_back(nClass);\n    while (nBits >= 8)\n    {\n        vchRet.push_back(GetByte(15 - nStartByte));\n        nStartByte++;\n        nBits -= 8;\n    }\n    if (nBits > 0)\n        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n\n    return vchRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::vector<unsigned char> CNetAddr::GetGroup() const\n  {\n      std::vector<unsigned char> vchRet;\n      int nClass = NET_IPV6;\n      int nStartByte = 0;\n      int nBits = 16;\n  \n      // all local addresses belong to the same group\n      if (IsLocal())\n      {\n          nClass = 255;\n          nBits = 0;\n      }\n  \n      // all unroutable addresses belong to the same group\n      if (!IsRoutable())\n      {\n          nClass = NET_UNROUTABLE;\n          nBits = 0;\n      }\n      // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n      // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n      else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 12;\n      }\n      // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n      else if (IsRFC3964())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 2;\n      }\n      // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n      else if (IsRFC4380())\n      {\n          vchRet.push_back(NET_IPV4);\n          vchRet.push_back(GetByte(3) ^ 0xFF);\n          vchRet.push_back(GetByte(2) ^ 0xFF);\n          return vchRet;\n      }\n      else if (IsTor())\n      {\n          nClass = NET_TOR;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      else if (IsI2P())\n      {\n          nClass = NET_I2P;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      // for he.net, use /36 groups\n      else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n          nBits = 36;\n      // for the rest of the IPv6 network, use /32 groups\n      else\n          nBits = 32;\n  \n      vchRet.push_back(nClass);\n      while (nBits >= 8)\n      {\n          vchRet.push_back(GetByte(15 - nStartByte));\n          nStartByte++;\n          nBits -= 8;\n      }\n      if (nBits > 0)\n          vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n  \n      return vchRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrInfo {\n  int CAddrInfo::GetNewBucket(const std::vector<unsigned char> &nKey, const CNetAddr& src) const\n  {\n      CDataStream ss1(SER_GETHASH, 0);\n      std::vector<unsigned char> vchGroupKey = GetGroup();\n      std::vector<unsigned char> vchSourceGroupKey = src.GetGroup();\n      ss1 << nKey << vchGroupKey << vchSourceGroupKey;\n      uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n  \n      CDataStream ss2(SER_GETHASH, 0);\n      ss2 << nKey << vchSourceGroupKey << (hash1 % ADAGSAN_NEW_BUCKETS_PER_SOURCE_GROUP);\n      uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n      return hash2 % ADAGSAN_NEW_BUCKET_COUNT;\n  }\n}"
  },
  {
    "function_name": "GetTriedBucket",
    "container": "CAddrInfo",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.cpp",
    "lines": "9-21",
    "snippet": "int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n{\n    CDataStream ss1(SER_GETHASH, 0);\n    std::vector<unsigned char> vchKey = GetKey();\n    ss1 << nKey << vchKey;\n    uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n\n    CDataStream ss2(SER_GETHASH, 0);\n    std::vector<unsigned char> vchGroupKey = GetGroup();\n    ss2 << nKey << vchGroupKey << (hash1 % ADAGSAN_TRIED_BUCKETS_PER_GROUP);\n    uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n    return hash2 % ADAGSAN_TRIED_BUCKET_COUNT;\n}",
    "includes": [
      "#include \"addrman.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Hash",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "ss2.begin()",
            "ss2.end()"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss2.end",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss2.begin",
          "args": [],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetGroup",
          "args": [],
          "line": 17
        },
        "resolved": true,
        "details": {
          "function_name": "GetGroup",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "849-920",
          "snippet": "std::vector<unsigned char> CNetAddr::GetGroup() const\n{\n    std::vector<unsigned char> vchRet;\n    int nClass = NET_IPV6;\n    int nStartByte = 0;\n    int nBits = 16;\n\n    // all local addresses belong to the same group\n    if (IsLocal())\n    {\n        nClass = 255;\n        nBits = 0;\n    }\n\n    // all unroutable addresses belong to the same group\n    if (!IsRoutable())\n    {\n        nClass = NET_UNROUTABLE;\n        nBits = 0;\n    }\n    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 12;\n    }\n    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n    else if (IsRFC3964())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 2;\n    }\n    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n    else if (IsRFC4380())\n    {\n        vchRet.push_back(NET_IPV4);\n        vchRet.push_back(GetByte(3) ^ 0xFF);\n        vchRet.push_back(GetByte(2) ^ 0xFF);\n        return vchRet;\n    }\n    else if (IsTor())\n    {\n        nClass = NET_TOR;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    else if (IsI2P())\n    {\n        nClass = NET_I2P;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    // for he.net, use /36 groups\n    else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n        nBits = 36;\n    // for the rest of the IPv6 network, use /32 groups\n    else\n        nBits = 32;\n\n    vchRet.push_back(nClass);\n    while (nBits >= 8)\n    {\n        vchRet.push_back(GetByte(15 - nStartByte));\n        nStartByte++;\n        nBits -= 8;\n    }\n    if (nBits > 0)\n        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n\n    return vchRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::vector<unsigned char> CNetAddr::GetGroup() const\n  {\n      std::vector<unsigned char> vchRet;\n      int nClass = NET_IPV6;\n      int nStartByte = 0;\n      int nBits = 16;\n  \n      // all local addresses belong to the same group\n      if (IsLocal())\n      {\n          nClass = 255;\n          nBits = 0;\n      }\n  \n      // all unroutable addresses belong to the same group\n      if (!IsRoutable())\n      {\n          nClass = NET_UNROUTABLE;\n          nBits = 0;\n      }\n      // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n      // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n      else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 12;\n      }\n      // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n      else if (IsRFC3964())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 2;\n      }\n      // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n      else if (IsRFC4380())\n      {\n          vchRet.push_back(NET_IPV4);\n          vchRet.push_back(GetByte(3) ^ 0xFF);\n          vchRet.push_back(GetByte(2) ^ 0xFF);\n          return vchRet;\n      }\n      else if (IsTor())\n      {\n          nClass = NET_TOR;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      else if (IsI2P())\n      {\n          nClass = NET_I2P;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      // for he.net, use /36 groups\n      else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n          nBits = 36;\n      // for the rest of the IPv6 network, use /32 groups\n      else\n          nBits = 32;\n  \n      vchRet.push_back(nClass);\n      while (nBits >= 8)\n      {\n          vchRet.push_back(GetByte(15 - nStartByte));\n          nStartByte++;\n          nBits -= 8;\n      }\n      if (nBits > 0)\n          vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n  \n      return vchRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetKey",
          "args": [],
          "line": 12
        },
        "resolved": true,
        "details": {
          "function_name": "GetKey",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1148-1156",
          "snippet": "std::vector<unsigned char> CService::GetKey() const\n{\n     std::vector<unsigned char> vKey;\n     vKey.resize(18);\n     memcpy(&vKey[0], ip, 16);\n     vKey[16] = port / 0x100;\n     vKey[17] = port & 0x0FF;\n     return vKey;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::vector<unsigned char> CService::GetKey() const\n  {\n       std::vector<unsigned char> vKey;\n       vKey.resize(18);\n       memcpy(&vKey[0], ip, 16);\n       vKey[16] = port / 0x100;\n       vKey[17] = port & 0x0FF;\n       return vKey;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"addrman.h\"\n\nCAddrInfo {\n  int CAddrInfo::GetTriedBucket(const std::vector<unsigned char> &nKey) const\n  {\n      CDataStream ss1(SER_GETHASH, 0);\n      std::vector<unsigned char> vchKey = GetKey();\n      ss1 << nKey << vchKey;\n      uint64_t hash1 = Hash(ss1.begin(), ss1.end()).Get64();\n  \n      CDataStream ss2(SER_GETHASH, 0);\n      std::vector<unsigned char> vchGroupKey = GetGroup();\n      ss2 << nKey << vchGroupKey << (hash1 % ADAGSAN_TRIED_BUCKETS_PER_GROUP);\n      uint64_t hash2 = Hash(ss2.begin(), ss2.end()).Get64();\n      return hash2 % ADAGSAN_TRIED_BUCKET_COUNT;\n  }\n}"
  }
]