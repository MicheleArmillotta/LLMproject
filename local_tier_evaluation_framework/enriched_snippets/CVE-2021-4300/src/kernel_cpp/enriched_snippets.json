[
  {
    "function_name": "CheckStakeModifierCheckpoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "394-401",
    "snippet": "bool CheckStakeModifierCheckpoints(int nHeight, unsigned int nStakeModifierChecksum)\n{\n    MapModifierCheckpoints& checkpoints = (fTestNet ? mapStakeModifierCheckpointsTestNet : mapStakeModifierCheckpoints);\n\n    if (checkpoints.count(nHeight))\n        return nStakeModifierChecksum == checkpoints[nHeight];\n    return true;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "static std::map<int, unsigned int> mapStakeModifierCheckpoints =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;",
      "static std::map<int, unsigned int> mapStakeModifierCheckpointsTestNet =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "checkpoints.count",
          "args": [
            "nHeight"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic std::map<int, unsigned int> mapStakeModifierCheckpoints =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;\nstatic std::map<int, unsigned int> mapStakeModifierCheckpointsTestNet =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;\n\nbool CheckStakeModifierCheckpoints(int nHeight, unsigned int nStakeModifierChecksum)\n{\n    MapModifierCheckpoints& checkpoints = (fTestNet ? mapStakeModifierCheckpointsTestNet : mapStakeModifierCheckpoints);\n\n    if (checkpoints.count(nHeight))\n        return nStakeModifierChecksum == checkpoints[nHeight];\n    return true;\n}"
  },
  {
    "function_name": "GetStakeModifierChecksum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "380-391",
    "snippet": "unsigned int GetStakeModifierChecksum(const CBlockIndex* pindex)\n{\n    assert (pindex->pprev || pindex->GetBlockHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n    // Hash previous checksum with flags, hashProofOfStake and nStakeModifier\n    CDataStream ss(SER_GETHASH, 0);\n    if (pindex->pprev)\n        ss << pindex->pprev->nStakeModifierChecksum;\n    ss << pindex->nFlags << pindex->hashProofOfStake << pindex->nStakeModifier;\n    uint256 hashChecksum = Hash(ss.begin(), ss.end());\n    hashChecksum >>= (256 - 32);\n    return hashChecksum.Get64();\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hashChecksum.Get64",
          "args": [],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "Get64",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "359-362",
          "snippet": "uint64_t Get64(int n=0) const\n    {\n        return pn[2*n] | (uint64_t)pn[2*n+1] << 32;\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  uint64_t Get64(int n=0) const\n      {\n          return pn[2*n] | (uint64_t)pn[2*n+1] << 32;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "ss.begin()",
            "ss.end()"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.end",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.begin",
          "args": [],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pindex->pprev || pindex->GetBlockHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nunsigned int GetStakeModifierChecksum(const CBlockIndex* pindex)\n{\n    assert (pindex->pprev || pindex->GetBlockHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n    // Hash previous checksum with flags, hashProofOfStake and nStakeModifier\n    CDataStream ss(SER_GETHASH, 0);\n    if (pindex->pprev)\n        ss << pindex->pprev->nStakeModifierChecksum;\n    ss << pindex->nFlags << pindex->hashProofOfStake << pindex->nStakeModifier;\n    uint256 hashChecksum = Hash(ss.begin(), ss.end());\n    hashChecksum >>= (256 - 32);\n    return hashChecksum.Get64();\n}"
  },
  {
    "function_name": "CheckCoinStakeTimestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "373-377",
    "snippet": "bool CheckCoinStakeTimestamp(int64_t nTimeBlock, int64_t nTimeTx)\n{\n    // v0.3 protocol\n    return (nTimeBlock == nTimeTx);\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool CheckCoinStakeTimestamp(int64_t nTimeBlock, int64_t nTimeTx)\n{\n    // v0.3 protocol\n    return (nTimeBlock == nTimeTx);\n}"
  },
  {
    "function_name": "CheckProofOfStake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "342-370",
    "snippet": "bool CheckProofOfStake(const CTransaction& tx, unsigned int nBits, uint256& hashProofOfStake, uint256& targetProofOfStake)\n{\n    if (!tx.IsCoinStake())\n        return error(\"CheckProofOfStake() : called on non-coinstake %s\", tx.GetHash().ToString().c_str());\n\n    // Kernel (input 0) must match the stake hash target per coin age (nBits)\n    const CTxIn& txin = tx.vin[0];\n\n    // First try finding the previous transaction in database\n    CTxDB txdb(\"r\");\n    CTransaction txPrev;\n    CTxIndex txindex;\n    if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: read txPrev failed\"));  // previous transaction not in main chain, may occur during initial download\n\n    // Verify signature\n    if (!VerifySignature(txPrev, tx, 0, 0))\n        return tx.DoS(100, error(\"CheckProofOfStake() : VerifySignature failed on coinstake %s\", tx.GetHash().ToString().c_str()));\n\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n        return fDebug? error(\"CheckProofOfStake() : read block failed\") : false; // unable to read block of previous transaction\n\n    if (!CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, txPrev, txin.prevout, tx.nTime, hashProofOfStake, targetProofOfStake, fDebug))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\", tx.GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str())); // may occur during initial download or if behind on block chain sync\n\n    return true;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tx.DoS",
          "args": [
            "1",
            "error(\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\", tx.GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str())"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "DoS",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "865-865",
          "snippet": "bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\"",
            "tx.GetHash().ToString().c_str()",
            "hashProofOfStake.ToString().c_str()"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashProofOfStake.ToString",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckStakeKernelHash",
          "args": [
            "nBits",
            "block",
            "txindex.pos.nTxPos - txindex.pos.nBlockPos",
            "txPrev",
            "txin.prevout",
            "tx.nTime",
            "hashProofOfStake",
            "targetProofOfStake",
            "fDebug"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "CheckStakeKernelHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "280-339",
          "snippet": "bool CheckStakeKernelHash(unsigned int nBits, const CBlock& blockFrom, unsigned int nTxPrevOffset, const CTransaction& txPrev, const COutPoint& prevout, unsigned int nTimeTx, uint256& hashProofOfStake, uint256& targetProofOfStake, bool fPrintProofOfStake)\n{\n    if (nTimeTx < txPrev.nTime)  // Transaction timestamp violation\n        return error(\"CheckStakeKernelHash() : nTime violation\");\n\n    unsigned int nTimeBlockFrom = blockFrom.GetBlockTime();\n    if (nTimeBlockFrom + nStakeMinAge > nTimeTx) // Min age requirement\n        return error(\"CheckStakeKernelHash() : min age violation\");\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n    int64_t nValueIn = txPrev.vout[prevout.n].nValue;\n\n    uint256 hashBlockFrom = blockFrom.GetHash();\n\n    CBigNum bnCoinDayWeight = CBigNum(nValueIn) * GetWeight((int64_t)txPrev.nTime, (int64_t)nTimeTx) / COIN / (24 * 60 * 60);\n    targetProofOfStake = (bnCoinDayWeight * bnTargetPerCoinDay).getuint256();\n\n    // Calculate hash\n    CDataStream ss(SER_GETHASH, 0);\n    uint64_t nStakeModifier = 0;\n    int nStakeModifierHeight = 0;\n    int64_t nStakeModifierTime = 0;\n\n    if (!GetKernelStakeModifier(hashBlockFrom, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake))\n        return false;\n    ss << nStakeModifier;\n\n    ss << nTimeBlockFrom << nTxPrevOffset << txPrev.nTime << prevout.n << nTimeTx;\n    hashProofOfStake = Hash(ss.begin(), ss.end());\n    if (fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight,\n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : check modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n\n    // Now check if proof-of-stake hash meets target protocol\n    if (CBigNum(hashProofOfStake) > bnCoinDayWeight * bnTargetPerCoinDay)\n        return false;\n    if (fDebug && !fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight, \n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : pass modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool CheckStakeKernelHash(unsigned int nBits, const CBlock& blockFrom, unsigned int nTxPrevOffset, const CTransaction& txPrev, const COutPoint& prevout, unsigned int nTimeTx, uint256& hashProofOfStake, uint256& targetProofOfStake, bool fPrintProofOfStake)\n{\n    if (nTimeTx < txPrev.nTime)  // Transaction timestamp violation\n        return error(\"CheckStakeKernelHash() : nTime violation\");\n\n    unsigned int nTimeBlockFrom = blockFrom.GetBlockTime();\n    if (nTimeBlockFrom + nStakeMinAge > nTimeTx) // Min age requirement\n        return error(\"CheckStakeKernelHash() : min age violation\");\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n    int64_t nValueIn = txPrev.vout[prevout.n].nValue;\n\n    uint256 hashBlockFrom = blockFrom.GetHash();\n\n    CBigNum bnCoinDayWeight = CBigNum(nValueIn) * GetWeight((int64_t)txPrev.nTime, (int64_t)nTimeTx) / COIN / (24 * 60 * 60);\n    targetProofOfStake = (bnCoinDayWeight * bnTargetPerCoinDay).getuint256();\n\n    // Calculate hash\n    CDataStream ss(SER_GETHASH, 0);\n    uint64_t nStakeModifier = 0;\n    int nStakeModifierHeight = 0;\n    int64_t nStakeModifierTime = 0;\n\n    if (!GetKernelStakeModifier(hashBlockFrom, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake))\n        return false;\n    ss << nStakeModifier;\n\n    ss << nTimeBlockFrom << nTxPrevOffset << txPrev.nTime << prevout.n << nTimeTx;\n    hashProofOfStake = Hash(ss.begin(), ss.end());\n    if (fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight,\n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : check modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n\n    // Now check if proof-of-stake hash meets target protocol\n    if (CBigNum(hashProofOfStake) > bnCoinDayWeight * bnTargetPerCoinDay)\n        return false;\n    if (fDebug && !fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight, \n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : pass modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckProofOfStake() : read block failed\""
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "txindex.pos.nFile",
            "txindex.pos.nBlockPos",
            "false"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n  {\n      SetNull();\n      if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n          return false;\n      if (!ReadFromDisk(txindexRet.pos))\n          return false;\n      if (prevout.n >= vout.size())\n      {\n          SetNull();\n          return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckProofOfStake() : VerifySignature failed on coinstake %s\"",
            "tx.GetHash().ToString().c_str()"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VerifySignature",
          "args": [
            "txPrev",
            "tx",
            "0",
            "0"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "VerifySignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1766-1778",
          "snippet": "bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool CheckProofOfStake(const CTransaction& tx, unsigned int nBits, uint256& hashProofOfStake, uint256& targetProofOfStake)\n{\n    if (!tx.IsCoinStake())\n        return error(\"CheckProofOfStake() : called on non-coinstake %s\", tx.GetHash().ToString().c_str());\n\n    // Kernel (input 0) must match the stake hash target per coin age (nBits)\n    const CTxIn& txin = tx.vin[0];\n\n    // First try finding the previous transaction in database\n    CTxDB txdb(\"r\");\n    CTransaction txPrev;\n    CTxIndex txindex;\n    if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: read txPrev failed\"));  // previous transaction not in main chain, may occur during initial download\n\n    // Verify signature\n    if (!VerifySignature(txPrev, tx, 0, 0))\n        return tx.DoS(100, error(\"CheckProofOfStake() : VerifySignature failed on coinstake %s\", tx.GetHash().ToString().c_str()));\n\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n        return fDebug? error(\"CheckProofOfStake() : read block failed\") : false; // unable to read block of previous transaction\n\n    if (!CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, txPrev, txin.prevout, tx.nTime, hashProofOfStake, targetProofOfStake, fDebug))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\", tx.GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str())); // may occur during initial download or if behind on block chain sync\n\n    return true;\n}"
  },
  {
    "function_name": "CheckStakeKernelHash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "280-339",
    "snippet": "bool CheckStakeKernelHash(unsigned int nBits, const CBlock& blockFrom, unsigned int nTxPrevOffset, const CTransaction& txPrev, const COutPoint& prevout, unsigned int nTimeTx, uint256& hashProofOfStake, uint256& targetProofOfStake, bool fPrintProofOfStake)\n{\n    if (nTimeTx < txPrev.nTime)  // Transaction timestamp violation\n        return error(\"CheckStakeKernelHash() : nTime violation\");\n\n    unsigned int nTimeBlockFrom = blockFrom.GetBlockTime();\n    if (nTimeBlockFrom + nStakeMinAge > nTimeTx) // Min age requirement\n        return error(\"CheckStakeKernelHash() : min age violation\");\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n    int64_t nValueIn = txPrev.vout[prevout.n].nValue;\n\n    uint256 hashBlockFrom = blockFrom.GetHash();\n\n    CBigNum bnCoinDayWeight = CBigNum(nValueIn) * GetWeight((int64_t)txPrev.nTime, (int64_t)nTimeTx) / COIN / (24 * 60 * 60);\n    targetProofOfStake = (bnCoinDayWeight * bnTargetPerCoinDay).getuint256();\n\n    // Calculate hash\n    CDataStream ss(SER_GETHASH, 0);\n    uint64_t nStakeModifier = 0;\n    int nStakeModifierHeight = 0;\n    int64_t nStakeModifierTime = 0;\n\n    if (!GetKernelStakeModifier(hashBlockFrom, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake))\n        return false;\n    ss << nStakeModifier;\n\n    ss << nTimeBlockFrom << nTxPrevOffset << txPrev.nTime << prevout.n << nTimeTx;\n    hashProofOfStake = Hash(ss.begin(), ss.end());\n    if (fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight,\n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : check modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n\n    // Now check if proof-of-stake hash meets target protocol\n    if (CBigNum(hashProofOfStake) > bnCoinDayWeight * bnTargetPerCoinDay)\n        return false;\n    if (fDebug && !fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight, \n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : pass modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n    return true;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CheckStakeKernelHash() : pass modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\"",
            "nStakeModifier",
            "nTimeBlockFrom",
            "nTxPrevOffset",
            "txPrev.nTime",
            "prevout.n",
            "nTimeTx",
            "hashProofOfStake.ToString().c_str()"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashProofOfStake.ToString",
          "args": [],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\"",
            "nStakeModifier",
            "nStakeModifierHeight",
            "DateTimeStrFormat(nStakeModifierTime).c_str()",
            "mapBlockIndex[hashBlockFrom]->nHeight",
            "DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "blockFrom.GetBlockTime()"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "386-389",
          "snippet": "inline std::string DateTimeStrFormat(int64_t nTime)\n{\n    return DateTimeStrFormat(strTimestampFormat.c_str(), nTime);\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(int64_t nTime)\n{\n    return DateTimeStrFormat(strTimestampFormat.c_str(), nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockFrom.GetBlockTime",
          "args": [],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "hashProofOfStake"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CheckStakeKernelHash() : check modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\"",
            "nStakeModifier",
            "nTimeBlockFrom",
            "nTxPrevOffset",
            "txPrev.nTime",
            "prevout.n",
            "nTimeTx",
            "hashProofOfStake.ToString().c_str()"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\"",
            "nStakeModifier",
            "nStakeModifierHeight",
            "DateTimeStrFormat(nStakeModifierTime).c_str()",
            "mapBlockIndex[hashBlockFrom]->nHeight",
            "DateTimeStrFormat(blockFrom.GetBlockTime()).c_str()"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "ss.begin()",
            "ss.end()"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.end",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.begin",
          "args": [],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetKernelStakeModifier",
          "args": [
            "hashBlockFrom",
            "nStakeModifier",
            "nStakeModifierHeight",
            "nStakeModifierTime",
            "fPrintProofOfStake"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "GetKernelStakeModifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "227-257",
          "snippet": "static bool GetKernelStakeModifier(uint256 hashBlockFrom, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)\n{\n    nStakeModifier = 0;\n    if (!mapBlockIndex.count(hashBlockFrom))\n        return error(\"GetKernelStakeModifier() : block not indexed\");\n    const CBlockIndex* pindexFrom = mapBlockIndex[hashBlockFrom];\n    nStakeModifierHeight = pindexFrom->nHeight;\n    nStakeModifierTime = pindexFrom->GetBlockTime();\n    int64_t nStakeModifierSelectionInterval = GetStakeModifierSelectionInterval();\n    const CBlockIndex* pindex = pindexFrom;\n    // loop to find the stake modifier later by a selection interval\n    while (nStakeModifierTime < pindexFrom->GetBlockTime() + nStakeModifierSelectionInterval)\n    {\n        if (!pindex->pnext)\n        {   // reached best block; may happen if node is behind on block chain\n            if (fPrintProofOfStake || (pindex->GetBlockTime() + nStakeMinAge - nStakeModifierSelectionInterval > GetAdjustedTime()))\n                return error(\"GetKernelStakeModifier() : reached best block %s at height %d from block %s\",\n                    pindex->GetBlockHash().ToString().c_str(), pindex->nHeight, hashBlockFrom.ToString().c_str());\n            else\n                return false;\n        }\n        pindex = pindex->pnext;\n        if (pindex->GeneratedStakeModifier())\n        {\n            nStakeModifierHeight = pindex->nHeight;\n            nStakeModifierTime = pindex->GetBlockTime();\n        }\n    }\n    nStakeModifier = pindex->nStakeModifier;\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic bool GetKernelStakeModifier(uint256 hashBlockFrom, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)\n{\n    nStakeModifier = 0;\n    if (!mapBlockIndex.count(hashBlockFrom))\n        return error(\"GetKernelStakeModifier() : block not indexed\");\n    const CBlockIndex* pindexFrom = mapBlockIndex[hashBlockFrom];\n    nStakeModifierHeight = pindexFrom->nHeight;\n    nStakeModifierTime = pindexFrom->GetBlockTime();\n    int64_t nStakeModifierSelectionInterval = GetStakeModifierSelectionInterval();\n    const CBlockIndex* pindex = pindexFrom;\n    // loop to find the stake modifier later by a selection interval\n    while (nStakeModifierTime < pindexFrom->GetBlockTime() + nStakeModifierSelectionInterval)\n    {\n        if (!pindex->pnext)\n        {   // reached best block; may happen if node is behind on block chain\n            if (fPrintProofOfStake || (pindex->GetBlockTime() + nStakeMinAge - nStakeModifierSelectionInterval > GetAdjustedTime()))\n                return error(\"GetKernelStakeModifier() : reached best block %s at height %d from block %s\",\n                    pindex->GetBlockHash().ToString().c_str(), pindex->nHeight, hashBlockFrom.ToString().c_str());\n            else\n                return false;\n        }\n        pindex = pindex->pnext;\n        if (pindex->GeneratedStakeModifier())\n        {\n            nStakeModifierHeight = pindex->nHeight;\n            nStakeModifierTime = pindex->GetBlockTime();\n        }\n    }\n    nStakeModifier = pindex->nStakeModifier;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetWeight",
          "args": [
            "(int64_t)txPrev.nTime",
            "(int64_t)nTimeTx"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "GetWeight",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "38-46",
          "snippet": "int64_t GetWeight(int64_t nIntervalBegin, int64_t nIntervalEnd) {\n    uint nStakeMaxAge = GetStakeMaxAge(nIntervalEnd);\n\n    int64_t nTimeWeight = nIntervalEnd - nIntervalBegin - nStakeMinAge;\n    if(nTimeWeight > (int64)nStakeMaxAge)\n      nTimeWeight = (int64)nStakeMaxAge;\n\n    return(nTimeWeight);\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nint64_t GetWeight(int64_t nIntervalBegin, int64_t nIntervalEnd) {\n    uint nStakeMaxAge = GetStakeMaxAge(nIntervalEnd);\n\n    int64_t nTimeWeight = nIntervalEnd - nIntervalBegin - nStakeMinAge;\n    if(nTimeWeight > (int64)nStakeMaxAge)\n      nTimeWeight = (int64)nStakeMaxAge;\n\n    return(nTimeWeight);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockFrom.GetHash",
          "args": [],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bnTargetPerCoinDay.SetCompact",
          "args": [
            "nBits"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckStakeKernelHash() : min age violation\""
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool CheckStakeKernelHash(unsigned int nBits, const CBlock& blockFrom, unsigned int nTxPrevOffset, const CTransaction& txPrev, const COutPoint& prevout, unsigned int nTimeTx, uint256& hashProofOfStake, uint256& targetProofOfStake, bool fPrintProofOfStake)\n{\n    if (nTimeTx < txPrev.nTime)  // Transaction timestamp violation\n        return error(\"CheckStakeKernelHash() : nTime violation\");\n\n    unsigned int nTimeBlockFrom = blockFrom.GetBlockTime();\n    if (nTimeBlockFrom + nStakeMinAge > nTimeTx) // Min age requirement\n        return error(\"CheckStakeKernelHash() : min age violation\");\n\n    CBigNum bnTargetPerCoinDay;\n    bnTargetPerCoinDay.SetCompact(nBits);\n    int64_t nValueIn = txPrev.vout[prevout.n].nValue;\n\n    uint256 hashBlockFrom = blockFrom.GetHash();\n\n    CBigNum bnCoinDayWeight = CBigNum(nValueIn) * GetWeight((int64_t)txPrev.nTime, (int64_t)nTimeTx) / COIN / (24 * 60 * 60);\n    targetProofOfStake = (bnCoinDayWeight * bnTargetPerCoinDay).getuint256();\n\n    // Calculate hash\n    CDataStream ss(SER_GETHASH, 0);\n    uint64_t nStakeModifier = 0;\n    int nStakeModifierHeight = 0;\n    int64_t nStakeModifierTime = 0;\n\n    if (!GetKernelStakeModifier(hashBlockFrom, nStakeModifier, nStakeModifierHeight, nStakeModifierTime, fPrintProofOfStake))\n        return false;\n    ss << nStakeModifier;\n\n    ss << nTimeBlockFrom << nTxPrevOffset << txPrev.nTime << prevout.n << nTimeTx;\n    hashProofOfStake = Hash(ss.begin(), ss.end());\n    if (fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight,\n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : check modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n\n    // Now check if proof-of-stake hash meets target protocol\n    if (CBigNum(hashProofOfStake) > bnCoinDayWeight * bnTargetPerCoinDay)\n        return false;\n    if (fDebug && !fPrintProofOfStake)\n    {\n        printf(\"CheckStakeKernelHash() : using modifier 0x%016\"PRIx64\" at height=%d timestamp=%s for block from height=%d timestamp=%s\\n\",\n            nStakeModifier, nStakeModifierHeight, \n            DateTimeStrFormat(nStakeModifierTime).c_str(),\n            mapBlockIndex[hashBlockFrom]->nHeight,\n            DateTimeStrFormat(blockFrom.GetBlockTime()).c_str());\n        printf(\"CheckStakeKernelHash() : pass modifier=0x%016\"PRIx64\" nTimeBlockFrom=%u nTxPrevOffset=%u nTimeTxPrev=%u nPrevout=%u nTimeTx=%u hashProof=%s\\n\",\n            nStakeModifier,\n            nTimeBlockFrom, nTxPrevOffset, txPrev.nTime, prevout.n, nTimeTx,\n            hashProofOfStake.ToString().c_str());\n    }\n    return true;\n}"
  },
  {
    "function_name": "GetKernelStakeModifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "227-257",
    "snippet": "static bool GetKernelStakeModifier(uint256 hashBlockFrom, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)\n{\n    nStakeModifier = 0;\n    if (!mapBlockIndex.count(hashBlockFrom))\n        return error(\"GetKernelStakeModifier() : block not indexed\");\n    const CBlockIndex* pindexFrom = mapBlockIndex[hashBlockFrom];\n    nStakeModifierHeight = pindexFrom->nHeight;\n    nStakeModifierTime = pindexFrom->GetBlockTime();\n    int64_t nStakeModifierSelectionInterval = GetStakeModifierSelectionInterval();\n    const CBlockIndex* pindex = pindexFrom;\n    // loop to find the stake modifier later by a selection interval\n    while (nStakeModifierTime < pindexFrom->GetBlockTime() + nStakeModifierSelectionInterval)\n    {\n        if (!pindex->pnext)\n        {   // reached best block; may happen if node is behind on block chain\n            if (fPrintProofOfStake || (pindex->GetBlockTime() + nStakeMinAge - nStakeModifierSelectionInterval > GetAdjustedTime()))\n                return error(\"GetKernelStakeModifier() : reached best block %s at height %d from block %s\",\n                    pindex->GetBlockHash().ToString().c_str(), pindex->nHeight, hashBlockFrom.ToString().c_str());\n            else\n                return false;\n        }\n        pindex = pindex->pnext;\n        if (pindex->GeneratedStakeModifier())\n        {\n            nStakeModifierHeight = pindex->nHeight;\n            nStakeModifierTime = pindex->GetBlockTime();\n        }\n    }\n    nStakeModifier = pindex->nStakeModifier;\n    return true;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pindex->GetBlockTime",
          "args": [],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GeneratedStakeModifier",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "GeneratedStakeModifier",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1407-1410",
          "snippet": "bool GeneratedStakeModifier() const\n    {\n        return (nFlags & BLOCK_STAKE_MODIFIER);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool GeneratedStakeModifier() const\n      {\n          return (nFlags & BLOCK_STAKE_MODIFIER);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"GetKernelStakeModifier() : reached best block %s at height %d from block %s\"",
            "pindex->GetBlockHash().ToString().c_str()",
            "pindex->nHeight",
            "hashBlockFrom.ToString().c_str()"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashBlockFrom.ToString",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetStakeModifierSelectionInterval",
          "args": [],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeModifierSelectionInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "71-77",
          "snippet": "static int64_t GetStakeModifierSelectionInterval()\n{\n    int64_t nSelectionInterval = 0;\n    for (int nSection=0; nSection<64; nSection++)\n        nSelectionInterval += GetStakeModifierSelectionIntervalSection(nSection);\n    return nSelectionInterval;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic int64_t GetStakeModifierSelectionInterval()\n{\n    int64_t nSelectionInterval = 0;\n    for (int nSection=0; nSection<64; nSection++)\n        nSelectionInterval += GetStakeModifierSelectionIntervalSection(nSection);\n    return nSelectionInterval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"GetKernelStakeModifier() : block not indexed\""
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hashBlockFrom"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic bool GetKernelStakeModifier(uint256 hashBlockFrom, uint64_t& nStakeModifier, int& nStakeModifierHeight, int64_t& nStakeModifierTime, bool fPrintProofOfStake)\n{\n    nStakeModifier = 0;\n    if (!mapBlockIndex.count(hashBlockFrom))\n        return error(\"GetKernelStakeModifier() : block not indexed\");\n    const CBlockIndex* pindexFrom = mapBlockIndex[hashBlockFrom];\n    nStakeModifierHeight = pindexFrom->nHeight;\n    nStakeModifierTime = pindexFrom->GetBlockTime();\n    int64_t nStakeModifierSelectionInterval = GetStakeModifierSelectionInterval();\n    const CBlockIndex* pindex = pindexFrom;\n    // loop to find the stake modifier later by a selection interval\n    while (nStakeModifierTime < pindexFrom->GetBlockTime() + nStakeModifierSelectionInterval)\n    {\n        if (!pindex->pnext)\n        {   // reached best block; may happen if node is behind on block chain\n            if (fPrintProofOfStake || (pindex->GetBlockTime() + nStakeMinAge - nStakeModifierSelectionInterval > GetAdjustedTime()))\n                return error(\"GetKernelStakeModifier() : reached best block %s at height %d from block %s\",\n                    pindex->GetBlockHash().ToString().c_str(), pindex->nHeight, hashBlockFrom.ToString().c_str());\n            else\n                return false;\n        }\n        pindex = pindex->pnext;\n        if (pindex->GeneratedStakeModifier())\n        {\n            nStakeModifierHeight = pindex->nHeight;\n            nStakeModifierTime = pindex->GetBlockTime();\n        }\n    }\n    nStakeModifier = pindex->nStakeModifier;\n    return true;\n}"
  },
  {
    "function_name": "ComputeNextStakeModifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "138-223",
    "snippet": "bool ComputeNextStakeModifier(const CBlockIndex* pindexPrev, uint64_t& nStakeModifier, bool& fGeneratedStakeModifier)\n{\n    nStakeModifier = 0;\n    fGeneratedStakeModifier = false;\n    if (!pindexPrev)\n    {\n        fGeneratedStakeModifier = true;\n        return true;  // genesis block's modifier is 0\n    }\n    // First find current stake modifier and its generation block time\n    // if it's not old enough, return the same stake modifier\n    int64_t nModifierTime = 0;\n    if (!GetLastStakeModifier(pindexPrev, nStakeModifier, nModifierTime))\n        return error(\"ComputeNextStakeModifier: unable to get last modifier\");\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: prev modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifier, DateTimeStrFormat(nModifierTime).c_str());\n    }\n    if (nModifierTime / nModifierInterval >= pindexPrev->GetBlockTime() / nModifierInterval)\n        return true;\n\n    // Sort candidate blocks by timestamp\n    vector<pair<int64_t, uint256> > vSortedByTimestamp;\n    vSortedByTimestamp.reserve(64 * nModifierInterval / 2 * nBaseTargetSpacing);\n    int64_t nSelectionInterval = GetStakeModifierSelectionInterval();\n    int64_t nSelectionIntervalStart = (pindexPrev->GetBlockTime() / nModifierInterval) * nModifierInterval - nSelectionInterval;\n    const CBlockIndex* pindex = pindexPrev;\n    while (pindex && pindex->GetBlockTime() >= nSelectionIntervalStart)\n    {\n        vSortedByTimestamp.push_back(make_pair(pindex->GetBlockTime(), pindex->GetBlockHash()));\n        pindex = pindex->pprev;\n    }\n    int nHeightFirstCandidate = pindex ? (pindex->nHeight + 1) : 0;\n    reverse(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n    sort(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n\n    // Select 64 blocks from candidate blocks to generate stake modifier\n    uint64_t nStakeModifierNew = 0;\n    int64_t nSelectionIntervalStop = nSelectionIntervalStart;\n    map<uint256, const CBlockIndex*> mapSelectedBlocks;\n    for (int nRound=0; nRound<min(64, (int)vSortedByTimestamp.size()); nRound++)\n    {\n        // add an interval section to the current selection round\n        nSelectionIntervalStop += GetStakeModifierSelectionIntervalSection(nRound);\n        // select a block from the candidates of current round\n        if (!SelectBlockFromCandidates(vSortedByTimestamp, mapSelectedBlocks, nSelectionIntervalStop, nStakeModifier, &pindex))\n            return error(\"ComputeNextStakeModifier: unable to select block at round %d\", nRound);\n        // write the entropy bit of the selected block\n        nStakeModifierNew |= (((uint64_t)pindex->GetStakeEntropyBit()) << nRound);\n        // add the selected block from candidates to selected list\n        mapSelectedBlocks.insert(make_pair(pindex->GetBlockHash(), pindex));\n        if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n            printf(\"ComputeNextStakeModifier: selected round %d stop=%s height=%d bit=%d\\n\", nRound, DateTimeStrFormat(nSelectionIntervalStop).c_str(), pindex->nHeight, pindex->GetStakeEntropyBit());\n    }\n\n    // Print selection map for visualization of the selected blocks\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n    {\n        string strSelectionMap = \"\";\n        // '-' indicates proof-of-work blocks not selected\n        strSelectionMap.insert(0, pindexPrev->nHeight - nHeightFirstCandidate + 1, '-');\n        pindex = pindexPrev;\n        while (pindex && pindex->nHeight >= nHeightFirstCandidate)\n        {\n            // '=' indicates proof-of-stake blocks not selected\n            if (pindex->IsProofOfStake())\n                strSelectionMap.replace(pindex->nHeight - nHeightFirstCandidate, 1, \"=\");\n            pindex = pindex->pprev;\n        }\n        BOOST_FOREACH(const PAIRTYPE(uint256, const CBlockIndex*)& item, mapSelectedBlocks)\n        {\n            // 'S' indicates selected proof-of-stake blocks\n            // 'W' indicates selected proof-of-work blocks\n            strSelectionMap.replace(item.second->nHeight - nHeightFirstCandidate, 1, item.second->IsProofOfStake()? \"S\" : \"W\");\n        }\n        printf(\"ComputeNextStakeModifier: selection height [%d, %d] map %s\\n\", nHeightFirstCandidate, pindexPrev->nHeight, strSelectionMap.c_str());\n    }\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: new modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifierNew, DateTimeStrFormat(pindexPrev->GetBlockTime()).c_str());\n    }\n\n    nStakeModifier = nStakeModifierNew;\n    fGeneratedStakeModifier = true;\n    return true;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ComputeNextStakeModifier: new modifier=0x%016\"PRIx64\" time=%s\\n\"",
            "nStakeModifierNew",
            "DateTimeStrFormat(pindexPrev->GetBlockTime()).c_str()"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "pindexPrev->GetBlockTime()"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "386-389",
          "snippet": "inline std::string DateTimeStrFormat(int64_t nTime)\n{\n    return DateTimeStrFormat(strTimestampFormat.c_str(), nTime);\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(int64_t nTime)\n{\n    return DateTimeStrFormat(strTimestampFormat.c_str(), nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexPrev->GetBlockTime",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ComputeNextStakeModifier: selection height [%d, %d] map %s\\n\"",
            "nHeightFirstCandidate",
            "pindexPrev->nHeight",
            "strSelectionMap.c_str()"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strSelectionMap.c_str",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strSelectionMap.replace",
          "args": [
            "item.second->nHeight - nHeightFirstCandidate",
            "1",
            "item.second->IsProofOfStake()? \"S\" : \"W\""
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "item.second->IsProofOfStake",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strSelectionMap.replace",
          "args": [
            "pindex->nHeight - nHeightFirstCandidate",
            "1",
            "\"=\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strSelectionMap.insert",
          "args": [
            "0",
            "pindexPrev->nHeight - nHeightFirstCandidate + 1",
            "'-'"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "839-850",
          "snippet": "void insert(iterator it, const char* first, const char* last)\n    {\n        assert(last - first >= 0);\n        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n        {\n            // special case for inserting at the front when there's room\n            nReadPos -= (last - first);\n            memcpy(&vch[nReadPos], &first[0], last - first);\n        }\n        else\n            vch.insert(it, first, last);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void insert(iterator it, const char* first, const char* last)\n      {\n          assert(last - first >= 0);\n          if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n          {\n              // special case for inserting at the front when there's room\n              nReadPos -= (last - first);\n              memcpy(&vch[nReadPos], &first[0], last - first);\n          }\n          else\n              vch.insert(it, first, last);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printstakemodifier\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ComputeNextStakeModifier: selected round %d stop=%s height=%d bit=%d\\n\"",
            "nRound",
            "DateTimeStrFormat(nSelectionIntervalStop).c_str()",
            "pindex->nHeight",
            "pindex->GetStakeEntropyBit()"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetStakeEntropyBit",
          "args": [],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeEntropyBit",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1394-1397",
          "snippet": "unsigned int GetStakeEntropyBit() const\n    {\n        return ((nFlags & BLOCK_STAKE_ENTROPY) >> 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  unsigned int GetStakeEntropyBit() const\n      {\n          return ((nFlags & BLOCK_STAKE_ENTROPY) >> 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printstakemodifier\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapSelectedBlocks.insert",
          "args": [
            "make_pair(pindex->GetBlockHash(), pindex)"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pindex->GetBlockHash()",
            "pindex"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ComputeNextStakeModifier: unable to select block at round %d\"",
            "nRound"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SelectBlockFromCandidates",
          "args": [
            "vSortedByTimestamp",
            "mapSelectedBlocks",
            "nSelectionIntervalStop",
            "nStakeModifier",
            "&pindex"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "SelectBlockFromCandidates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "82-123",
          "snippet": "static bool SelectBlockFromCandidates(vector<pair<int64_t, uint256> >& vSortedByTimestamp, map<uint256, const CBlockIndex*>& mapSelectedBlocks,\n    int64_t nSelectionIntervalStop, uint64_t nStakeModifierPrev, const CBlockIndex** pindexSelected)\n{\n    bool fSelected = false;\n    uint256 hashBest = 0;\n    *pindexSelected = (const CBlockIndex*) 0;\n    BOOST_FOREACH(const PAIRTYPE(int64_t, uint256)& item, vSortedByTimestamp)\n    {\n        if (!mapBlockIndex.count(item.second))\n            return error(\"SelectBlockFromCandidates: failed to find block index for candidate block %s\", item.second.ToString().c_str());\n        const CBlockIndex* pindex = mapBlockIndex[item.second];\n        if (fSelected && pindex->GetBlockTime() > nSelectionIntervalStop)\n            break;\n        if (mapSelectedBlocks.count(pindex->GetBlockHash()) > 0)\n            continue;\n        // compute the selection hash by hashing its proof-hash and the\n        // previous proof-of-stake modifier\n        uint256 hashProof = pindex->IsProofOfStake()? pindex->hashProofOfStake : pindex->GetBlockHash();\n        CDataStream ss(SER_GETHASH, 0);\n        ss << hashProof << nStakeModifierPrev;\n        uint256 hashSelection = Hash(ss.begin(), ss.end());\n        // the selection hash is divided by 2**32 so that proof-of-stake block\n        // is always favored over proof-of-work block. this is to preserve\n        // the energy efficiency property\n        if (pindex->IsProofOfStake())\n            hashSelection >>= 32;\n        if (fSelected && hashSelection < hashBest)\n        {\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n        else if (!fSelected)\n        {\n            fSelected = true;\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n    }\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n        printf(\"SelectBlockFromCandidates: selection hash=%s\\n\", hashBest.ToString().c_str());\n    return fSelected;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic bool SelectBlockFromCandidates(vector<pair<int64_t, uint256> >& vSortedByTimestamp, map<uint256, const CBlockIndex*>& mapSelectedBlocks,\n    int64_t nSelectionIntervalStop, uint64_t nStakeModifierPrev, const CBlockIndex** pindexSelected)\n{\n    bool fSelected = false;\n    uint256 hashBest = 0;\n    *pindexSelected = (const CBlockIndex*) 0;\n    BOOST_FOREACH(const PAIRTYPE(int64_t, uint256)& item, vSortedByTimestamp)\n    {\n        if (!mapBlockIndex.count(item.second))\n            return error(\"SelectBlockFromCandidates: failed to find block index for candidate block %s\", item.second.ToString().c_str());\n        const CBlockIndex* pindex = mapBlockIndex[item.second];\n        if (fSelected && pindex->GetBlockTime() > nSelectionIntervalStop)\n            break;\n        if (mapSelectedBlocks.count(pindex->GetBlockHash()) > 0)\n            continue;\n        // compute the selection hash by hashing its proof-hash and the\n        // previous proof-of-stake modifier\n        uint256 hashProof = pindex->IsProofOfStake()? pindex->hashProofOfStake : pindex->GetBlockHash();\n        CDataStream ss(SER_GETHASH, 0);\n        ss << hashProof << nStakeModifierPrev;\n        uint256 hashSelection = Hash(ss.begin(), ss.end());\n        // the selection hash is divided by 2**32 so that proof-of-stake block\n        // is always favored over proof-of-work block. this is to preserve\n        // the energy efficiency property\n        if (pindex->IsProofOfStake())\n            hashSelection >>= 32;\n        if (fSelected && hashSelection < hashBest)\n        {\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n        else if (!fSelected)\n        {\n            fSelected = true;\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n    }\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n        printf(\"SelectBlockFromCandidates: selection hash=%s\\n\", hashBest.ToString().c_str());\n    return fSelected;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetStakeModifierSelectionIntervalSection",
          "args": [
            "nRound"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeModifierSelectionIntervalSection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "64-68",
          "snippet": "static int64_t GetStakeModifierSelectionIntervalSection(int nSection)\n{\n    assert (nSection >= 0 && nSection < 64);\n    return (nModifierInterval * 63 / (63 + ((63 - nSection) * (MODIFIER_INTERVAL_RATIO - 1))));\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic int64_t GetStakeModifierSelectionIntervalSection(int nSection)\n{\n    assert (nSection >= 0 && nSection < 64);\n    return (nModifierInterval * 63 / (63 + ((63 - nSection) * (MODIFIER_INTERVAL_RATIO - 1))));\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "64",
            "(int)vSortedByTimestamp.size()"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "TimingResistantEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "569-576",
          "snippet": "bool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSortedByTimestamp.size",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "vSortedByTimestamp.begin()",
            "vSortedByTimestamp.end()"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "sortView",
          "container": "CoinControlDialog",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/coincontroldialog.cpp",
          "lines": "313-319",
          "snippet": "void CoinControlDialog::sortView(int column, Qt::SortOrder order)\n{\n    sortColumn = column;\n    sortOrder = order;\n    ui->treeWidget->sortItems(column, order);\n    ui->treeWidget->header()->setSortIndicator((sortColumn == COLUMN_AMOUNT_INT64 ? COLUMN_AMOUNT : (sortColumn == COLUMN_PRIORITY_INT64 ? COLUMN_PRIORITY : sortColumn)), sortOrder);\n}",
          "includes": [
            "#include <QTreeWidgetItem>",
            "#include <QTreeWidget>",
            "#include <QString>",
            "#include <QIcon>",
            "#include <QFlags>",
            "#include <QDialogButtonBox>",
            "#include <QDateTime>",
            "#include <QCursor>",
            "#include <QColor>",
            "#include <QClipboard>",
            "#include <QCheckBox>",
            "#include <QApplication>",
            "#include \"coincontrol.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"init.h\"",
            "#include \"ui_coincontroldialog.h\"",
            "#include \"coincontroldialog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QTreeWidgetItem>\n#include <QTreeWidget>\n#include <QString>\n#include <QIcon>\n#include <QFlags>\n#include <QDialogButtonBox>\n#include <QDateTime>\n#include <QCursor>\n#include <QColor>\n#include <QClipboard>\n#include <QCheckBox>\n#include <QApplication>\n#include \"coincontrol.h\"\n#include \"optionsmodel.h\"\n#include \"addresstablemodel.h\"\n#include \"walletmodel.h\"\n#include \"bitcoinunits.h\"\n#include \"init.h\"\n#include \"ui_coincontroldialog.h\"\n#include \"coincontroldialog.h\"\n\nCoinControlDialog {\n  void CoinControlDialog::sortView(int column, Qt::SortOrder order)\n  {\n      sortColumn = column;\n      sortOrder = order;\n      ui->treeWidget->sortItems(column, order);\n      ui->treeWidget->header()->setSortIndicator((sortColumn == COLUMN_AMOUNT_INT64 ? COLUMN_AMOUNT : (sortColumn == COLUMN_PRIORITY_INT64 ? COLUMN_PRIORITY : sortColumn)), sortOrder);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSortedByTimestamp.end",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSortedByTimestamp.begin",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reverse",
          "args": [
            "vSortedByTimestamp.begin()",
            "vSortedByTimestamp.end()"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vSortedByTimestamp.push_back",
          "args": [
            "make_pair(pindex->GetBlockTime(), pindex->GetBlockHash())"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pindex->GetBlockTime()",
            "pindex->GetBlockHash()"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetStakeModifierSelectionInterval",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeModifierSelectionInterval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "71-77",
          "snippet": "static int64_t GetStakeModifierSelectionInterval()\n{\n    int64_t nSelectionInterval = 0;\n    for (int nSection=0; nSection<64; nSection++)\n        nSelectionInterval += GetStakeModifierSelectionIntervalSection(nSection);\n    return nSelectionInterval;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic int64_t GetStakeModifierSelectionInterval()\n{\n    int64_t nSelectionInterval = 0;\n    for (int nSection=0; nSection<64; nSection++)\n        nSelectionInterval += GetStakeModifierSelectionIntervalSection(nSection);\n    return nSelectionInterval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSortedByTimestamp.reserve",
          "args": [
            "64 * nModifierInterval / 2 * nBaseTargetSpacing"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ComputeNextStakeModifier: prev modifier=0x%016\"PRIx64\" time=%s\\n\"",
            "nStakeModifier",
            "DateTimeStrFormat(nModifierTime).c_str()"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ComputeNextStakeModifier: unable to get last modifier\""
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastStakeModifier",
          "args": [
            "pindexPrev",
            "nStakeModifier",
            "nModifierTime"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "GetLastStakeModifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "50-61",
          "snippet": "static bool GetLastStakeModifier(const CBlockIndex* pindex, uint64_t& nStakeModifier, int64_t& nModifierTime)\n{\n    if (!pindex)\n        return error(\"GetLastStakeModifier: null pindex\");\n    while (pindex && pindex->pprev && !pindex->GeneratedStakeModifier())\n        pindex = pindex->pprev;\n    if (!pindex->GeneratedStakeModifier())\n        return error(\"GetLastStakeModifier: no generation at genesis block\");\n    nStakeModifier = pindex->nStakeModifier;\n    nModifierTime = pindex->GetBlockTime();\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic bool GetLastStakeModifier(const CBlockIndex* pindex, uint64_t& nStakeModifier, int64_t& nModifierTime)\n{\n    if (!pindex)\n        return error(\"GetLastStakeModifier: null pindex\");\n    while (pindex && pindex->pprev && !pindex->GeneratedStakeModifier())\n        pindex = pindex->pprev;\n    if (!pindex->GeneratedStakeModifier())\n        return error(\"GetLastStakeModifier: no generation at genesis block\");\n    nStakeModifier = pindex->nStakeModifier;\n    nModifierTime = pindex->GetBlockTime();\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool ComputeNextStakeModifier(const CBlockIndex* pindexPrev, uint64_t& nStakeModifier, bool& fGeneratedStakeModifier)\n{\n    nStakeModifier = 0;\n    fGeneratedStakeModifier = false;\n    if (!pindexPrev)\n    {\n        fGeneratedStakeModifier = true;\n        return true;  // genesis block's modifier is 0\n    }\n    // First find current stake modifier and its generation block time\n    // if it's not old enough, return the same stake modifier\n    int64_t nModifierTime = 0;\n    if (!GetLastStakeModifier(pindexPrev, nStakeModifier, nModifierTime))\n        return error(\"ComputeNextStakeModifier: unable to get last modifier\");\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: prev modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifier, DateTimeStrFormat(nModifierTime).c_str());\n    }\n    if (nModifierTime / nModifierInterval >= pindexPrev->GetBlockTime() / nModifierInterval)\n        return true;\n\n    // Sort candidate blocks by timestamp\n    vector<pair<int64_t, uint256> > vSortedByTimestamp;\n    vSortedByTimestamp.reserve(64 * nModifierInterval / 2 * nBaseTargetSpacing);\n    int64_t nSelectionInterval = GetStakeModifierSelectionInterval();\n    int64_t nSelectionIntervalStart = (pindexPrev->GetBlockTime() / nModifierInterval) * nModifierInterval - nSelectionInterval;\n    const CBlockIndex* pindex = pindexPrev;\n    while (pindex && pindex->GetBlockTime() >= nSelectionIntervalStart)\n    {\n        vSortedByTimestamp.push_back(make_pair(pindex->GetBlockTime(), pindex->GetBlockHash()));\n        pindex = pindex->pprev;\n    }\n    int nHeightFirstCandidate = pindex ? (pindex->nHeight + 1) : 0;\n    reverse(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n    sort(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n\n    // Select 64 blocks from candidate blocks to generate stake modifier\n    uint64_t nStakeModifierNew = 0;\n    int64_t nSelectionIntervalStop = nSelectionIntervalStart;\n    map<uint256, const CBlockIndex*> mapSelectedBlocks;\n    for (int nRound=0; nRound<min(64, (int)vSortedByTimestamp.size()); nRound++)\n    {\n        // add an interval section to the current selection round\n        nSelectionIntervalStop += GetStakeModifierSelectionIntervalSection(nRound);\n        // select a block from the candidates of current round\n        if (!SelectBlockFromCandidates(vSortedByTimestamp, mapSelectedBlocks, nSelectionIntervalStop, nStakeModifier, &pindex))\n            return error(\"ComputeNextStakeModifier: unable to select block at round %d\", nRound);\n        // write the entropy bit of the selected block\n        nStakeModifierNew |= (((uint64_t)pindex->GetStakeEntropyBit()) << nRound);\n        // add the selected block from candidates to selected list\n        mapSelectedBlocks.insert(make_pair(pindex->GetBlockHash(), pindex));\n        if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n            printf(\"ComputeNextStakeModifier: selected round %d stop=%s height=%d bit=%d\\n\", nRound, DateTimeStrFormat(nSelectionIntervalStop).c_str(), pindex->nHeight, pindex->GetStakeEntropyBit());\n    }\n\n    // Print selection map for visualization of the selected blocks\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n    {\n        string strSelectionMap = \"\";\n        // '-' indicates proof-of-work blocks not selected\n        strSelectionMap.insert(0, pindexPrev->nHeight - nHeightFirstCandidate + 1, '-');\n        pindex = pindexPrev;\n        while (pindex && pindex->nHeight >= nHeightFirstCandidate)\n        {\n            // '=' indicates proof-of-stake blocks not selected\n            if (pindex->IsProofOfStake())\n                strSelectionMap.replace(pindex->nHeight - nHeightFirstCandidate, 1, \"=\");\n            pindex = pindex->pprev;\n        }\n        BOOST_FOREACH(const PAIRTYPE(uint256, const CBlockIndex*)& item, mapSelectedBlocks)\n        {\n            // 'S' indicates selected proof-of-stake blocks\n            // 'W' indicates selected proof-of-work blocks\n            strSelectionMap.replace(item.second->nHeight - nHeightFirstCandidate, 1, item.second->IsProofOfStake()? \"S\" : \"W\");\n        }\n        printf(\"ComputeNextStakeModifier: selection height [%d, %d] map %s\\n\", nHeightFirstCandidate, pindexPrev->nHeight, strSelectionMap.c_str());\n    }\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: new modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifierNew, DateTimeStrFormat(pindexPrev->GetBlockTime()).c_str());\n    }\n\n    nStakeModifier = nStakeModifierNew;\n    fGeneratedStakeModifier = true;\n    return true;\n}"
  },
  {
    "function_name": "SelectBlockFromCandidates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "82-123",
    "snippet": "static bool SelectBlockFromCandidates(vector<pair<int64_t, uint256> >& vSortedByTimestamp, map<uint256, const CBlockIndex*>& mapSelectedBlocks,\n    int64_t nSelectionIntervalStop, uint64_t nStakeModifierPrev, const CBlockIndex** pindexSelected)\n{\n    bool fSelected = false;\n    uint256 hashBest = 0;\n    *pindexSelected = (const CBlockIndex*) 0;\n    BOOST_FOREACH(const PAIRTYPE(int64_t, uint256)& item, vSortedByTimestamp)\n    {\n        if (!mapBlockIndex.count(item.second))\n            return error(\"SelectBlockFromCandidates: failed to find block index for candidate block %s\", item.second.ToString().c_str());\n        const CBlockIndex* pindex = mapBlockIndex[item.second];\n        if (fSelected && pindex->GetBlockTime() > nSelectionIntervalStop)\n            break;\n        if (mapSelectedBlocks.count(pindex->GetBlockHash()) > 0)\n            continue;\n        // compute the selection hash by hashing its proof-hash and the\n        // previous proof-of-stake modifier\n        uint256 hashProof = pindex->IsProofOfStake()? pindex->hashProofOfStake : pindex->GetBlockHash();\n        CDataStream ss(SER_GETHASH, 0);\n        ss << hashProof << nStakeModifierPrev;\n        uint256 hashSelection = Hash(ss.begin(), ss.end());\n        // the selection hash is divided by 2**32 so that proof-of-stake block\n        // is always favored over proof-of-work block. this is to preserve\n        // the energy efficiency property\n        if (pindex->IsProofOfStake())\n            hashSelection >>= 32;\n        if (fSelected && hashSelection < hashBest)\n        {\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n        else if (!fSelected)\n        {\n            fSelected = true;\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n    }\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n        printf(\"SelectBlockFromCandidates: selection hash=%s\\n\", hashBest.ToString().c_str());\n    return fSelected;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SelectBlockFromCandidates: selection hash=%s\\n\"",
            "hashBest.ToString().c_str()"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBest.ToString",
          "args": [],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printstakemodifier\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->IsProofOfStake",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "ss.begin()",
            "ss.end()"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.end",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.begin",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapSelectedBlocks.count",
          "args": [
            "pindex->GetBlockHash()"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockTime",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SelectBlockFromCandidates: failed to find block index for candidate block %s\"",
            "item.second.ToString().c_str()"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic bool SelectBlockFromCandidates(vector<pair<int64_t, uint256> >& vSortedByTimestamp, map<uint256, const CBlockIndex*>& mapSelectedBlocks,\n    int64_t nSelectionIntervalStop, uint64_t nStakeModifierPrev, const CBlockIndex** pindexSelected)\n{\n    bool fSelected = false;\n    uint256 hashBest = 0;\n    *pindexSelected = (const CBlockIndex*) 0;\n    BOOST_FOREACH(const PAIRTYPE(int64_t, uint256)& item, vSortedByTimestamp)\n    {\n        if (!mapBlockIndex.count(item.second))\n            return error(\"SelectBlockFromCandidates: failed to find block index for candidate block %s\", item.second.ToString().c_str());\n        const CBlockIndex* pindex = mapBlockIndex[item.second];\n        if (fSelected && pindex->GetBlockTime() > nSelectionIntervalStop)\n            break;\n        if (mapSelectedBlocks.count(pindex->GetBlockHash()) > 0)\n            continue;\n        // compute the selection hash by hashing its proof-hash and the\n        // previous proof-of-stake modifier\n        uint256 hashProof = pindex->IsProofOfStake()? pindex->hashProofOfStake : pindex->GetBlockHash();\n        CDataStream ss(SER_GETHASH, 0);\n        ss << hashProof << nStakeModifierPrev;\n        uint256 hashSelection = Hash(ss.begin(), ss.end());\n        // the selection hash is divided by 2**32 so that proof-of-stake block\n        // is always favored over proof-of-work block. this is to preserve\n        // the energy efficiency property\n        if (pindex->IsProofOfStake())\n            hashSelection >>= 32;\n        if (fSelected && hashSelection < hashBest)\n        {\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n        else if (!fSelected)\n        {\n            fSelected = true;\n            hashBest = hashSelection;\n            *pindexSelected = (const CBlockIndex*) pindex;\n        }\n    }\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n        printf(\"SelectBlockFromCandidates: selection hash=%s\\n\", hashBest.ToString().c_str());\n    return fSelected;\n}"
  },
  {
    "function_name": "GetStakeModifierSelectionInterval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "71-77",
    "snippet": "static int64_t GetStakeModifierSelectionInterval()\n{\n    int64_t nSelectionInterval = 0;\n    for (int nSection=0; nSection<64; nSection++)\n        nSelectionInterval += GetStakeModifierSelectionIntervalSection(nSection);\n    return nSelectionInterval;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetStakeModifierSelectionIntervalSection",
          "args": [
            "nSection"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeModifierSelectionIntervalSection",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "64-68",
          "snippet": "static int64_t GetStakeModifierSelectionIntervalSection(int nSection)\n{\n    assert (nSection >= 0 && nSection < 64);\n    return (nModifierInterval * 63 / (63 + ((63 - nSection) * (MODIFIER_INTERVAL_RATIO - 1))));\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic int64_t GetStakeModifierSelectionIntervalSection(int nSection)\n{\n    assert (nSection >= 0 && nSection < 64);\n    return (nModifierInterval * 63 / (63 + ((63 - nSection) * (MODIFIER_INTERVAL_RATIO - 1))));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic int64_t GetStakeModifierSelectionInterval()\n{\n    int64_t nSelectionInterval = 0;\n    for (int nSection=0; nSection<64; nSection++)\n        nSelectionInterval += GetStakeModifierSelectionIntervalSection(nSection);\n    return nSelectionInterval;\n}"
  },
  {
    "function_name": "GetStakeModifierSelectionIntervalSection",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "64-68",
    "snippet": "static int64_t GetStakeModifierSelectionIntervalSection(int nSection)\n{\n    assert (nSection >= 0 && nSection < 64);\n    return (nModifierInterval * 63 / (63 + ((63 - nSection) * (MODIFIER_INTERVAL_RATIO - 1))));\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nSection >= 0 && nSection < 64"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic int64_t GetStakeModifierSelectionIntervalSection(int nSection)\n{\n    assert (nSection >= 0 && nSection < 64);\n    return (nModifierInterval * 63 / (63 + ((63 - nSection) * (MODIFIER_INTERVAL_RATIO - 1))));\n}"
  },
  {
    "function_name": "GetLastStakeModifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "50-61",
    "snippet": "static bool GetLastStakeModifier(const CBlockIndex* pindex, uint64_t& nStakeModifier, int64_t& nModifierTime)\n{\n    if (!pindex)\n        return error(\"GetLastStakeModifier: null pindex\");\n    while (pindex && pindex->pprev && !pindex->GeneratedStakeModifier())\n        pindex = pindex->pprev;\n    if (!pindex->GeneratedStakeModifier())\n        return error(\"GetLastStakeModifier: no generation at genesis block\");\n    nStakeModifier = pindex->nStakeModifier;\n    nModifierTime = pindex->GetBlockTime();\n    return true;\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pindex->GetBlockTime",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"GetLastStakeModifier: no generation at genesis block\""
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GeneratedStakeModifier",
          "args": [],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "GeneratedStakeModifier",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1407-1410",
          "snippet": "bool GeneratedStakeModifier() const\n    {\n        return (nFlags & BLOCK_STAKE_MODIFIER);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool GeneratedStakeModifier() const\n      {\n          return (nFlags & BLOCK_STAKE_MODIFIER);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic bool GetLastStakeModifier(const CBlockIndex* pindex, uint64_t& nStakeModifier, int64_t& nModifierTime)\n{\n    if (!pindex)\n        return error(\"GetLastStakeModifier: null pindex\");\n    while (pindex && pindex->pprev && !pindex->GeneratedStakeModifier())\n        pindex = pindex->pprev;\n    if (!pindex->GeneratedStakeModifier())\n        return error(\"GetLastStakeModifier: no generation at genesis block\");\n    nStakeModifier = pindex->nStakeModifier;\n    nModifierTime = pindex->GetBlockTime();\n    return true;\n}"
  },
  {
    "function_name": "GetWeight",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "38-46",
    "snippet": "int64_t GetWeight(int64_t nIntervalBegin, int64_t nIntervalEnd) {\n    uint nStakeMaxAge = GetStakeMaxAge(nIntervalEnd);\n\n    int64_t nTimeWeight = nIntervalEnd - nIntervalBegin - nStakeMinAge;\n    if(nTimeWeight > (int64)nStakeMaxAge)\n      nTimeWeight = (int64)nStakeMaxAge;\n\n    return(nTimeWeight);\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetStakeMaxAge",
          "args": [
            "nIntervalEnd"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeMaxAge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "28-34",
          "snippet": "uint GetStakeMaxAge(uint nStakeTime) {\n\n    if(nStakeTime > nStakeMaxAgeForkTime)\n      return(nStakeMaxAgeTwo);\n    else\n      return(nStakeMaxAgeOne);\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nuint GetStakeMaxAge(uint nStakeTime) {\n\n    if(nStakeTime > nStakeMaxAgeForkTime)\n      return(nStakeMaxAgeTwo);\n    else\n      return(nStakeMaxAgeOne);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nint64_t GetWeight(int64_t nIntervalBegin, int64_t nIntervalEnd) {\n    uint nStakeMaxAge = GetStakeMaxAge(nIntervalEnd);\n\n    int64_t nTimeWeight = nIntervalEnd - nIntervalBegin - nStakeMinAge;\n    if(nTimeWeight > (int64)nStakeMaxAge)\n      nTimeWeight = (int64)nStakeMaxAge;\n\n    return(nTimeWeight);\n}"
  },
  {
    "function_name": "GetStakeMaxAge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
    "lines": "28-34",
    "snippet": "uint GetStakeMaxAge(uint nStakeTime) {\n\n    if(nStakeTime > nStakeMaxAgeForkTime)\n      return(nStakeMaxAgeTwo);\n    else\n      return(nStakeMaxAgeOne);\n}",
    "includes": [
      "#include \"txdb.h\"",
      "#include \"kernel.h\"",
      "#include <boost/assign/list_of.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nuint GetStakeMaxAge(uint nStakeTime) {\n\n    if(nStakeTime > nStakeMaxAgeForkTime)\n      return(nStakeMaxAgeTwo);\n    else\n      return(nStakeMaxAgeOne);\n}"
  }
]