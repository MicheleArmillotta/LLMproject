[
  {
    "function_name": "SendMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "3837-3995",
    "snippet": "bool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64_t nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64_t nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64_t nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CCriticalSection cs_main;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pto->PushMessage",
          "args": [
            "\"getdata\"",
            "vGetData"
          ],
          "line": 3991
        },
        "resolved": true,
        "details": {
          "function_name": "PushMessage",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "425-438",
          "snippet": "void PushMessage(const char* pszCommand, const T1& a1)\n    {\n        try\n        {\n            BeginMessage(pszCommand);\n            vSend << a1;\n            EndMessage();\n        }\n        catch (...)\n        {\n            AbortMessage();\n            throw;\n        }\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushMessage(const char* pszCommand, const T1& a1)\n      {\n          try\n          {\n              BeginMessage(pszCommand);\n              vSend << a1;\n              EndMessage();\n          }\n          catch (...)\n          {\n              AbortMessage();\n              throw;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vGetData.empty",
          "args": [],
          "line": 3990
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pto->mapAskFor.erase",
          "args": [
            "pto->mapAskFor.begin()"
          ],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pto->mapAskFor.begin",
          "args": [],
          "line": 3988
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vGetData.clear",
          "args": [],
          "line": 3984
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vGetData.size",
          "args": [],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vGetData.push_back",
          "args": [
            "inv"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"sending getdata: %s\\n\"",
            "inv.ToString().c_str()"
          ],
          "line": 3979
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inv.ToString",
          "args": [],
          "line": 3979
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "AlreadyHave",
          "args": [
            "txdb",
            "inv"
          ],
          "line": 3976
        },
        "resolved": true,
        "details": {
          "function_name": "AlreadyHave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "3016-3038",
          "snippet": "bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "map<uint256, CTransaction> mapOrphanTransactions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nmap<uint256, CBlockIndex*> mapBlockIndex;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmap<uint256, CTransaction> mapOrphanTransactions;\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "vInv.push_back",
          "args": [
            "inv"
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pto->setInventoryKnown.insert",
          "args": [
            "inv"
          ],
          "line": 3951
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vInvWait.push_back",
          "args": [
            "inv"
          ],
          "line": 3945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTransaction",
          "args": [
            "inv.hash",
            "wtx"
          ],
          "line": 3938
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "130-136",
          "snippet": "bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "BEGIN(hashRand)",
            "END(hashRand)"
          ],
          "line": 3931
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "END",
          "args": [
            "hashRand"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEGIN",
          "args": [
            "hashRand"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRandHash",
          "args": [],
          "line": 3929
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "193-198",
          "snippet": "uint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nuint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pto->setInventoryKnown.count",
          "args": [
            "inv"
          ],
          "line": 3920
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vInvWait.reserve",
          "args": [
            "pto->vInventoryToSend.size()"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "pto->cs_inventory"
          ],
          "line": 3915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vAddr.push_back",
          "args": [
            "addr"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pnode->PushAddress",
          "args": [
            "addr"
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "PushAddress",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "288-295",
          "snippet": "void PushAddress(const CAddress& addr)\n    {\n        // Known checking here is only to save space from duplicates.\n        // SendMessages will filter it again for knowns that were added\n        // after addresses were pushed.\n        if (addr.IsValid() && !setAddrKnown.count(addr))\n            vAddrToSend.push_back(addr);\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushAddress(const CAddress& addr)\n      {\n          // Known checking here is only to save space from duplicates.\n          // SendMessages will filter it again for knowns that were added\n          // after addresses were pushed.\n          if (addr.IsValid() && !setAddrKnown.count(addr))\n              vAddrToSend.push_back(addr);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr.IsRoutable",
          "args": [],
          "line": 3874
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLocalAddress",
          "args": [
            "&pnode->addr"
          ],
          "line": 3873
        },
        "resolved": true,
        "details": {
          "function_name": "GetLocalAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "131-142",
          "snippet": "CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
            "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\n\nCAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsInitialBlockDownload",
          "args": [],
          "line": 3860
        },
        "resolved": true,
        "details": {
          "function_name": "IsInitialBlockDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1220-1233",
          "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nBestHeight = -1;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ResendWalletTransactions",
          "args": [],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TRY_LOCK",
          "args": [
            "cs_main",
            "lockMain"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool SendMessages(CNode* pto, bool fSendTrickle)\n{\n    TRY_LOCK(cs_main, lockMain);\n    if (lockMain) {\n        // Don't send anything until we get their version message\n        if (pto->nVersion == 0)\n            return true;\n\n        // Keep-alive ping. We send a nonce of zero because we don't use it anywhere\n        // right now.\n        if (pto->nLastSend && GetTime() - pto->nLastSend > 30 * 60 && pto->vSend.empty()) {\n            uint64_t nonce = 0;\n            if (pto->nVersion > BIP0031_VERSION)\n                pto->PushMessage(\"ping\", nonce);\n            else\n                pto->PushMessage(\"ping\");\n        }\n\n        // Resend wallet transactions that haven't gotten in a block yet\n        ResendWalletTransactions();\n\n        // Address refresh broadcast\n        static int64_t nLastRebroadcast;\n        if (!IsInitialBlockDownload() && (GetTime() - nLastRebroadcast > 24 * 60 * 60))\n        {\n            {\n                LOCK(cs_vNodes);\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                {\n                    // Periodically clear setAddrKnown to allow refresh broadcasts\n                    if (nLastRebroadcast)\n                        pnode->setAddrKnown.clear();\n\n                    // Rebroadcast our address\n                    if (!fNoListen)\n                    {\n                        CAddress addr = GetLocalAddress(&pnode->addr);\n                        if (addr.IsRoutable())\n                            pnode->PushAddress(addr);\n                    }\n                }\n            }\n            nLastRebroadcast = GetTime();\n        }\n\n        //\n        // Message: addr\n        //\n        if (fSendTrickle)\n        {\n            vector<CAddress> vAddr;\n            vAddr.reserve(pto->vAddrToSend.size());\n            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n            {\n                // returns true if wasn't already contained in the set\n                if (pto->setAddrKnown.insert(addr).second)\n                {\n                    vAddr.push_back(addr);\n                    // receiver rejects addr messages larger than 1000\n                    if (vAddr.size() >= 1000)\n                    {\n                        pto->PushMessage(\"addr\", vAddr);\n                        vAddr.clear();\n                    }\n                }\n            }\n            pto->vAddrToSend.clear();\n            if (!vAddr.empty())\n                pto->PushMessage(\"addr\", vAddr);\n        }\n\n\n        //\n        // Message: inventory\n        //\n        vector<CInv> vInv;\n        vector<CInv> vInvWait;\n        {\n            LOCK(pto->cs_inventory);\n            vInv.reserve(pto->vInventoryToSend.size());\n            vInvWait.reserve(pto->vInventoryToSend.size());\n            BOOST_FOREACH(const CInv& inv, pto->vInventoryToSend)\n            {\n                if (pto->setInventoryKnown.count(inv))\n                    continue;\n\n                // trickle out tx inv to protect privacy\n                if (inv.type == MSG_TX && !fSendTrickle)\n                {\n                    // 1/4 of tx invs blast to all immediately\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint256 hashRand = inv.hash ^ hashSalt;\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    bool fTrickleWait = ((hashRand & 3) != 0);\n\n                    // always trickle our own transactions\n                    if (!fTrickleWait)\n                    {\n                        CWalletTx wtx;\n                        if (GetTransaction(inv.hash, wtx))\n                            if (wtx.fFromMe)\n                                fTrickleWait = true;\n                    }\n\n                    if (fTrickleWait)\n                    {\n                        vInvWait.push_back(inv);\n                        continue;\n                    }\n                }\n\n                // returns true if wasn't already contained in the set\n                if (pto->setInventoryKnown.insert(inv).second)\n                {\n                    vInv.push_back(inv);\n                    if (vInv.size() >= 1000)\n                    {\n                        pto->PushMessage(\"inv\", vInv);\n                        vInv.clear();\n                    }\n                }\n            }\n            pto->vInventoryToSend = vInvWait;\n        }\n        if (!vInv.empty())\n            pto->PushMessage(\"inv\", vInv);\n\n\n        //\n        // Message: getdata\n        //\n        vector<CInv> vGetData;\n        int64_t nNow = GetTime() * 1000000;\n        CTxDB txdb(\"r\");\n        while (!pto->mapAskFor.empty() && (*pto->mapAskFor.begin()).first <= nNow)\n        {\n            const CInv& inv = (*pto->mapAskFor.begin()).second;\n            if (!AlreadyHave(txdb, inv))\n            {\n                if (fDebugNet)\n                    printf(\"sending getdata: %s\\n\", inv.ToString().c_str());\n                vGetData.push_back(inv);\n                if (vGetData.size() >= 1000)\n                {\n                    pto->PushMessage(\"getdata\", vGetData);\n                    vGetData.clear();\n                }\n                mapAlreadyAskedFor[inv] = nNow;\n            }\n            pto->mapAskFor.erase(pto->mapAskFor.begin());\n        }\n        if (!vGetData.empty())\n            pto->PushMessage(\"getdata\", vGetData);\n\n    }\n    return true;\n}"
  },
  {
    "function_name": "ProcessMessages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "3715-3834",
    "snippet": "bool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while (true)\n    {\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %\"PRIpdd\" BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from under-length message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from over-long size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CCriticalSection cs_main;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "unsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vRecv.Compact",
          "args": [],
          "line": 3832
        },
        "resolved": true,
        "details": {
          "function_name": "Compact",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "890-894",
          "snippet": "inline void Compact()\n    {\n        vch.erase(vch.begin(), vch.begin() + nReadPos);\n        nReadPos = 0;\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  inline void Compact()\n      {\n          vch.erase(vch.begin(), vch.begin() + nReadPos);\n          nReadPos = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessMessage(%s, %u bytes) FAILED\\n\"",
            "strCommand.c_str()",
            "nMessageSize"
          ],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strCommand.c_str",
          "args": [],
          "line": 3829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintExceptionContinue",
          "args": [
            "NULL",
            "\"ProcessMessages()\""
          ],
          "line": 3825
        },
        "resolved": true,
        "details": {
          "function_name": "PrintExceptionContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1005-1011",
          "snippet": "void PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "string strMiscWarning;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring strMiscWarning;\n\nvoid PrintExceptionContinue(std::exception* pex, const char* pszThread)\n{\n    std::string message = FormatException(pex, pszThread);\n    printf(\"\\n\\n************************\\n%s\\n\", message.c_str());\n    fprintf(stderr, \"\\n\\n************************\\n%s\\n\", message.c_str());\n    strMiscWarning = message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\"",
            "strCommand.c_str()",
            "nMessageSize",
            "e.what()"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strCommand.c_str",
          "args": [],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "e.what()",
            "\"size too large\""
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\"",
            "strCommand.c_str()",
            "nMessageSize",
            "e.what()"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strCommand.c_str",
          "args": [],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "e.what()",
            "\"end of data\""
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e.what",
          "args": [],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ProcessMessage",
          "args": [
            "pfrom",
            "strCommand",
            "vMsg"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "3048-3713",
          "snippet": "bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64_t nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64_t nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < MIN_PROTO_VERSION)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        /* Disconnect all obsolete clients */\n        uint nAdjTime = GetAdjustedTime();\n        if(nAdjTime > nStakeMaxAgeForkTime) {\n            if(pfrom->nVersion < MIN_PROTOCOL_VERSION) {\n                printf(\"obsolete node %s with client %d, disconnecting\\n\",\n                  pfrom->addr.ToString().c_str(), pfrom->nVersion);\n                pfrom->fDisconnect = true;\n                return(true);\n            }\n        }\n\n        // record my external IP reported by peer\n        if (addrFrom.IsRoutable() && addrMe.IsRoutable())\n            addrSeenByPeer = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        if (GetBoolArg(\"-synctime\", true))\n            AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            addrman.Good(pfrom->addr);\n        } else {\n            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n            {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay sync-checkpoint\n        {\n            LOCK(Checkpoints::cs_hashSyncCheckpoint);\n            if (!Checkpoints::checkpointMessage.IsNull())\n                Checkpoints::checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // ppcoin: ask for pending sync-checkpoint if any\n        if (!IsInitialBlockDownload())\n            Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %\"PRIszu\"\", vAddr.size());\n        }\n\n        // Store the new addresses\n        vector<CAddress> vAddrOk;\n        int64_t nNow = GetAdjustedTime();\n        int64_t nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            pfrom->AddAddressKnown(addr);\n            bool fReachable = IsReachable(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                {\n                    LOCK(cs_vNodes);\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint64_t hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < CADDR_TIME_VERSION)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n            // Do not store addresses outside our network\n            if (fReachable)\n                vAddrOk.push_back(addr);\n        }\n        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n        if (pfrom->fOneShot)\n            pfrom->fDisconnect = true;\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // ppcoin: send latest proof-of-work block to allow the\n                        // download node to accept as orphan (proof-of-stake \n                        // block might be rejected by stake connection check)\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash()));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                bool pushed = false;\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end()) {\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                        pushed = true;\n                    }\n                }\n                if (!pushed && inv.type == MSG_TX) {\n                    LOCK(mempool.cs);\n                    if (mempool.exists(inv.hash)) {\n                        CTransaction tx = mempool.lookup(inv.hash);\n                        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                        ss.reserve(1000);\n                        ss << tx;\n                        pfrom->PushMessage(\"tx\", ss);\n                    }\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                // ppcoin: tell downloading node about the latest block if it's\n                // without risk being rejected due to stake connection check\n                if (hashStop != hashBestChain && pindex->GetBlockTime() + nStakeMinAge > pindexBest->GetBlockTime())\n                    pfrom->PushInventory(CInv(MSG_BLOCK, hashBestChain));\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n    else if (strCommand == \"checkpoint\")\n    {\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayTransaction(tx, inv.hash);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (set<uint256>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const uint256& orphanTxHash = *mi;\n                    CTransaction& orphanTx = mapOrphanTransactions[orphanTxHash];\n                    bool fMissingInputs2 = false;\n\n                    if (orphanTx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayTransaction(orphanTx, orphanTxHash);\n                        mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanTxHash));\n                        vWorkQueue.push_back(orphanTxHash);\n                        vEraseQueue.push_back(orphanTxHash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(orphanTxHash);\n                        printf(\"   removed invalid orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(tx);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n\n        printf(\"received block %s\\n\", hashBlock.ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Don't return addresses older than nCutOff timestamp\n        int64_t nCutOff = GetTime() - (nNodeLifespan * 24 * 60 * 60);\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            if(addr.nTime > nCutOff)\n                pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"mempool\")\n    {\n        std::vector<uint256> vtxid;\n        mempool.queryHashes(vtxid);\n        vector<CInv> vInv;\n        for (unsigned int i = 0; i < vtxid.size(); i++) {\n            CInv inv(MSG_TX, vtxid[i]);\n            vInv.push_back(inv);\n            if (i == (MAX_INV_SZ - 1))\n                    break;\n        }\n        if (vInv.size() > 0)\n            pfrom->PushMessage(\"inv\", vInv);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64_t nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        uint256 alertHash = alert.GetHash();\n        if (pfrom->setKnown.count(alertHash) == 0)\n        {\n            if (alert.ProcessAlert())\n            {\n                // Relay\n                pfrom->setKnown.insert(alertHash);\n                {\n                    LOCK(cs_vNodes);\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                        alert.RelayTo(pnode);\n                }\n            }\n            else {\n                // Small DoS penalty so peers that send us lots of\n                // duplicate/expired/invalid-signature/whatever alerts\n                // eventually get banned.\n                // This isn't a Misbehaving(100) (immediate ban) because the\n                // peer might be an older or different implementation with\n                // a different signature key, etc.\n                pfrom->Misbehaving(10);\n            }\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "uint nStakeMinAge = 60 * 60 * 12;",
            "int nBestHeight = -1;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;",
            "CMedianFilter<int> cPeerBlockCounts(5, 0);",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "map<uint256, CTransaction> mapOrphanTransactions;",
            "map<uint256, set<uint256> > mapOrphanTransactionsByPrev;",
            "extern map<uint256, CAlert> mapAlerts;",
            "extern CCriticalSection cs_mapAlerts;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nuint nStakeMinAge = 60 * 60 * 12;\nint nBestHeight = -1;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nCMedianFilter<int> cPeerBlockCounts(5, 0);\nmap<uint256, CBlock*> mapOrphanBlocks;\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\nextern map<uint256, CAlert> mapAlerts;\nextern CCriticalSection cs_mapAlerts;\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64_t nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64_t nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < MIN_PROTO_VERSION)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        /* Disconnect all obsolete clients */\n        uint nAdjTime = GetAdjustedTime();\n        if(nAdjTime > nStakeMaxAgeForkTime) {\n            if(pfrom->nVersion < MIN_PROTOCOL_VERSION) {\n                printf(\"obsolete node %s with client %d, disconnecting\\n\",\n                  pfrom->addr.ToString().c_str(), pfrom->nVersion);\n                pfrom->fDisconnect = true;\n                return(true);\n            }\n        }\n\n        // record my external IP reported by peer\n        if (addrFrom.IsRoutable() && addrMe.IsRoutable())\n            addrSeenByPeer = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        if (GetBoolArg(\"-synctime\", true))\n            AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            addrman.Good(pfrom->addr);\n        } else {\n            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n            {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay sync-checkpoint\n        {\n            LOCK(Checkpoints::cs_hashSyncCheckpoint);\n            if (!Checkpoints::checkpointMessage.IsNull())\n                Checkpoints::checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // ppcoin: ask for pending sync-checkpoint if any\n        if (!IsInitialBlockDownload())\n            Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %\"PRIszu\"\", vAddr.size());\n        }\n\n        // Store the new addresses\n        vector<CAddress> vAddrOk;\n        int64_t nNow = GetAdjustedTime();\n        int64_t nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            pfrom->AddAddressKnown(addr);\n            bool fReachable = IsReachable(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                {\n                    LOCK(cs_vNodes);\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint64_t hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < CADDR_TIME_VERSION)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n            // Do not store addresses outside our network\n            if (fReachable)\n                vAddrOk.push_back(addr);\n        }\n        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n        if (pfrom->fOneShot)\n            pfrom->fDisconnect = true;\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // ppcoin: send latest proof-of-work block to allow the\n                        // download node to accept as orphan (proof-of-stake \n                        // block might be rejected by stake connection check)\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash()));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                bool pushed = false;\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end()) {\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                        pushed = true;\n                    }\n                }\n                if (!pushed && inv.type == MSG_TX) {\n                    LOCK(mempool.cs);\n                    if (mempool.exists(inv.hash)) {\n                        CTransaction tx = mempool.lookup(inv.hash);\n                        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                        ss.reserve(1000);\n                        ss << tx;\n                        pfrom->PushMessage(\"tx\", ss);\n                    }\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                // ppcoin: tell downloading node about the latest block if it's\n                // without risk being rejected due to stake connection check\n                if (hashStop != hashBestChain && pindex->GetBlockTime() + nStakeMinAge > pindexBest->GetBlockTime())\n                    pfrom->PushInventory(CInv(MSG_BLOCK, hashBestChain));\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n    else if (strCommand == \"checkpoint\")\n    {\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayTransaction(tx, inv.hash);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (set<uint256>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const uint256& orphanTxHash = *mi;\n                    CTransaction& orphanTx = mapOrphanTransactions[orphanTxHash];\n                    bool fMissingInputs2 = false;\n\n                    if (orphanTx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayTransaction(orphanTx, orphanTxHash);\n                        mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanTxHash));\n                        vWorkQueue.push_back(orphanTxHash);\n                        vEraseQueue.push_back(orphanTxHash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(orphanTxHash);\n                        printf(\"   removed invalid orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(tx);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n\n        printf(\"received block %s\\n\", hashBlock.ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Don't return addresses older than nCutOff timestamp\n        int64_t nCutOff = GetTime() - (nNodeLifespan * 24 * 60 * 60);\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            if(addr.nTime > nCutOff)\n                pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"mempool\")\n    {\n        std::vector<uint256> vtxid;\n        mempool.queryHashes(vtxid);\n        vector<CInv> vInv;\n        for (unsigned int i = 0; i < vtxid.size(); i++) {\n            CInv inv(MSG_TX, vtxid[i]);\n            vInv.push_back(inv);\n            if (i == (MAX_INV_SZ - 1))\n                    break;\n        }\n        if (vInv.size() > 0)\n            pfrom->PushMessage(\"inv\", vInv);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64_t nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        uint256 alertHash = alert.GetHash();\n        if (pfrom->setKnown.count(alertHash) == 0)\n        {\n            if (alert.ProcessAlert())\n            {\n                // Relay\n                pfrom->setKnown.insert(alertHash);\n                {\n                    LOCK(cs_vNodes);\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                        alert.RelayTo(pnode);\n                }\n            }\n            else {\n                // Small DoS penalty so peers that send us lots of\n                // duplicate/expired/invalid-signature/whatever alerts\n                // eventually get banned.\n                // This isn't a Misbehaving(100) (immediate ban) because the\n                // peer might be an older or different implementation with\n                // a different signature key, etc.\n                pfrom->Misbehaving(10);\n            }\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_main"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRecv.ignore",
          "args": [
            "nMessageSize"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRecv.begin",
          "args": [],
          "line": 3791
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\"",
            "strCommand.c_str()",
            "nMessageSize",
            "nChecksum",
            "hdr.nChecksum"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strCommand.c_str",
          "args": [],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&nChecksum",
            "&hash",
            "sizeof(nChecksum)"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "vRecv.begin()",
            "vRecv.begin() + nMessageSize"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRecv.insert",
          "args": [
            "vRecv.begin()",
            "vHeaderSave.begin()",
            "vHeaderSave.end()"
          ],
          "line": 3775
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "839-850",
          "snippet": "void insert(iterator it, const char* first, const char* last)\n    {\n        assert(last - first >= 0);\n        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n        {\n            // special case for inserting at the front when there's room\n            nReadPos -= (last - first);\n            memcpy(&vch[nReadPos], &first[0], last - first);\n        }\n        else\n            vch.insert(it, first, last);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void insert(iterator it, const char* first, const char* last)\n      {\n          assert(last - first >= 0);\n          if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n          {\n              // special case for inserting at the front when there's room\n              nReadPos -= (last - first);\n              memcpy(&vch[nReadPos], &first[0], last - first);\n          }\n          else\n              vch.insert(it, first, last);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vHeaderSave.end",
          "args": [],
          "line": 3775
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRecv.size",
          "args": [],
          "line": 3772
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\"",
            "strCommand.c_str()",
            "nMessageSize"
          ],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strCommand.c_str",
          "args": [],
          "line": 3769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hdr.GetCommand",
          "args": [],
          "line": 3763
        },
        "resolved": true,
        "details": {
          "function_name": "GetCommand",
          "container": "CMessageHeader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "38-44",
          "snippet": "std::string CMessageHeader::GetCommand() const\n{\n    if (pchCommand[COMMAND_SIZE-1] == 0)\n        return std::string(pchCommand, pchCommand + strlen(pchCommand));\n    else\n        return std::string(pchCommand, pchCommand + COMMAND_SIZE);\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nCMessageHeader {\n  std::string CMessageHeader::GetCommand() const\n  {\n      if (pchCommand[COMMAND_SIZE-1] == 0)\n          return std::string(pchCommand, pchCommand + strlen(pchCommand));\n      else\n          return std::string(pchCommand, pchCommand + COMMAND_SIZE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\"",
            "hdr.GetCommand().c_str()"
          ],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hdr.IsValid",
          "args": [],
          "line": 3758
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRecv.erase",
          "args": [
            "vRecv.begin()",
            "pstart"
          ],
          "line": 3752
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "870-888",
          "snippet": "iterator erase(iterator first, iterator last)\n    {\n        if (first == vch.begin() + nReadPos)\n        {\n            // special case for erasing from the front\n            if (last == vch.end())\n            {\n                nReadPos = 0;\n                return vch.erase(vch.begin(), vch.end());\n            }\n            else\n            {\n                nReadPos = (last - vch.begin());\n                return last;\n            }\n        }\n        else\n            return vch.erase(first, last);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  iterator erase(iterator first, iterator last)\n      {\n          if (first == vch.begin() + nReadPos)\n          {\n              // special case for erasing from the front\n              if (last == vch.end())\n              {\n                  nReadPos = 0;\n                  return vch.erase(vch.begin(), vch.end());\n              }\n              else\n              {\n                  nReadPos = (last - vch.begin());\n                  return last;\n              }\n          }\n          else\n              return vch.erase(first, last);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\""
          ],
          "line": 3745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vRecv.GetSerializeSize",
          "args": [
            "CMessageHeader()"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": "CAutoFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "1109-1113",
          "snippet": "unsigned int GetSerializeSize(const T& obj)\n    {\n        // Tells the size of the object if serialized to this stream\n        return ::GetSerializeSize(obj, nType, nVersion);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCAutoFile {\n  unsigned int GetSerializeSize(const T& obj)\n      {\n          // Tells the size of the object if serialized to this stream\n          return ::GetSerializeSize(obj, nType, nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CMessageHeader",
          "args": [],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CMessageHeader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "46-74",
          "snippet": "bool CMessageHeader::IsValid() const\n{\n    // Check start string\n    if (memcmp(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart)) != 0)\n        return false;\n\n    // Check the command string for errors\n    for (const char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)\n    {\n        if (*p1 == 0)\n        {\n            // Must be all zeros after the first zero\n            for (; p1 < pchCommand + COMMAND_SIZE; p1++)\n                if (*p1 != 0)\n                    return false;\n        }\n        else if (*p1 < ' ' || *p1 > 0x7E)\n            return false;\n    }\n\n    // Message size\n    if (nMessageSize > MAX_SIZE)\n    {\n        printf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nCMessageHeader {\n  bool CMessageHeader::IsValid() const\n  {\n      // Check start string\n      if (memcmp(pchMessageStart, ::pchMessageStart, sizeof(pchMessageStart)) != 0)\n          return false;\n  \n      // Check the command string for errors\n      for (const char* p1 = pchCommand; p1 < pchCommand + COMMAND_SIZE; p1++)\n      {\n          if (*p1 == 0)\n          {\n              // Must be all zeros after the first zero\n              for (; p1 < pchCommand + COMMAND_SIZE; p1++)\n                  if (*p1 != 0)\n                      return false;\n          }\n          else if (*p1 < ' ' || *p1 > 0x7E)\n              return false;\n      }\n  \n      // Message size\n      if (nMessageSize > MAX_SIZE)\n      {\n          printf(\"CMessageHeader::IsValid() : (%s, %u bytes) nMessageSize > MAX_SIZE\\n\", GetCommand().c_str(), nMessageSize);\n          return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "search",
          "args": [
            "vRecv.begin()",
            "vRecv.end()",
            "BEGIN(pchMessageStart)",
            "END(pchMessageStart)"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END",
          "args": [
            "pchMessageStart"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEGIN",
          "args": [
            "pchMessageStart"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SendBufferSize",
          "args": [],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "SendBufferSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "30-30",
          "snippet": "inline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\ninline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }"
        }
      },
      {
        "call_info": {
          "callee": "vRecv.empty",
          "args": [],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nunsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };\n\nbool ProcessMessages(CNode* pfrom)\n{\n    CDataStream& vRecv = pfrom->vRecv;\n    if (vRecv.empty())\n        return true;\n    //if (fDebug)\n    //    printf(\"ProcessMessages(%u bytes)\\n\", vRecv.size());\n\n    //\n    // Message format\n    //  (4) message start\n    //  (12) command\n    //  (4) size\n    //  (4) checksum\n    //  (x) data\n    //\n\n    while (true)\n    {\n        // Don't bother if send buffer is too full to respond anyway\n        if (pfrom->vSend.size() >= SendBufferSize())\n            break;\n\n        // Scan for message start\n        CDataStream::iterator pstart = search(vRecv.begin(), vRecv.end(), BEGIN(pchMessageStart), END(pchMessageStart));\n        int nHeaderSize = vRecv.GetSerializeSize(CMessageHeader());\n        if (vRecv.end() - pstart < nHeaderSize)\n        {\n            if ((int)vRecv.size() > nHeaderSize)\n            {\n                printf(\"\\n\\nPROCESSMESSAGE MESSAGESTART NOT FOUND\\n\\n\");\n                vRecv.erase(vRecv.begin(), vRecv.end() - nHeaderSize);\n            }\n            break;\n        }\n        if (pstart - vRecv.begin() > 0)\n            printf(\"\\n\\nPROCESSMESSAGE SKIPPED %\"PRIpdd\" BYTES\\n\\n\", pstart - vRecv.begin());\n        vRecv.erase(vRecv.begin(), pstart);\n\n        // Read header\n        vector<char> vHeaderSave(vRecv.begin(), vRecv.begin() + nHeaderSize);\n        CMessageHeader hdr;\n        vRecv >> hdr;\n        if (!hdr.IsValid())\n        {\n            printf(\"\\n\\nPROCESSMESSAGE: ERRORS IN HEADER %s\\n\\n\\n\", hdr.GetCommand().c_str());\n            continue;\n        }\n        string strCommand = hdr.GetCommand();\n\n        // Message size\n        unsigned int nMessageSize = hdr.nMessageSize;\n        if (nMessageSize > MAX_SIZE)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : nMessageSize > MAX_SIZE\\n\", strCommand.c_str(), nMessageSize);\n            continue;\n        }\n        if (nMessageSize > vRecv.size())\n        {\n            // Rewind and wait for rest of message\n            vRecv.insert(vRecv.begin(), vHeaderSave.begin(), vHeaderSave.end());\n            break;\n        }\n\n        // Checksum\n        uint256 hash = Hash(vRecv.begin(), vRecv.begin() + nMessageSize);\n        unsigned int nChecksum = 0;\n        memcpy(&nChecksum, &hash, sizeof(nChecksum));\n        if (nChecksum != hdr.nChecksum)\n        {\n            printf(\"ProcessMessages(%s, %u bytes) : CHECKSUM ERROR nChecksum=%08x hdr.nChecksum=%08x\\n\",\n               strCommand.c_str(), nMessageSize, nChecksum, hdr.nChecksum);\n            continue;\n        }\n\n        // Copy message to its own buffer\n        CDataStream vMsg(vRecv.begin(), vRecv.begin() + nMessageSize, vRecv.nType, vRecv.nVersion);\n        vRecv.ignore(nMessageSize);\n\n        // Process message\n        bool fRet = false;\n        try\n        {\n            {\n                LOCK(cs_main);\n                fRet = ProcessMessage(pfrom, strCommand, vMsg);\n            }\n            if (fShutdown)\n                return true;\n        }\n        catch (std::ios_base::failure& e)\n        {\n            if (strstr(e.what(), \"end of data\"))\n            {\n                // Allow exceptions from under-length message on vRecv\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else if (strstr(e.what(), \"size too large\"))\n            {\n                // Allow exceptions from over-long size\n                printf(\"ProcessMessages(%s, %u bytes) : Exception '%s' caught\\n\", strCommand.c_str(), nMessageSize, e.what());\n            }\n            else\n            {\n                PrintExceptionContinue(&e, \"ProcessMessages()\");\n            }\n        }\n        catch (std::exception& e) {\n            PrintExceptionContinue(&e, \"ProcessMessages()\");\n        } catch (...) {\n            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n        }\n\n        if (!fRet)\n            printf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand.c_str(), nMessageSize);\n    }\n\n    vRecv.Compact();\n    return true;\n}"
  },
  {
    "function_name": "ProcessMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "3048-3713",
    "snippet": "bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64_t nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64_t nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < MIN_PROTO_VERSION)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        /* Disconnect all obsolete clients */\n        uint nAdjTime = GetAdjustedTime();\n        if(nAdjTime > nStakeMaxAgeForkTime) {\n            if(pfrom->nVersion < MIN_PROTOCOL_VERSION) {\n                printf(\"obsolete node %s with client %d, disconnecting\\n\",\n                  pfrom->addr.ToString().c_str(), pfrom->nVersion);\n                pfrom->fDisconnect = true;\n                return(true);\n            }\n        }\n\n        // record my external IP reported by peer\n        if (addrFrom.IsRoutable() && addrMe.IsRoutable())\n            addrSeenByPeer = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        if (GetBoolArg(\"-synctime\", true))\n            AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            addrman.Good(pfrom->addr);\n        } else {\n            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n            {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay sync-checkpoint\n        {\n            LOCK(Checkpoints::cs_hashSyncCheckpoint);\n            if (!Checkpoints::checkpointMessage.IsNull())\n                Checkpoints::checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // ppcoin: ask for pending sync-checkpoint if any\n        if (!IsInitialBlockDownload())\n            Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %\"PRIszu\"\", vAddr.size());\n        }\n\n        // Store the new addresses\n        vector<CAddress> vAddrOk;\n        int64_t nNow = GetAdjustedTime();\n        int64_t nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            pfrom->AddAddressKnown(addr);\n            bool fReachable = IsReachable(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                {\n                    LOCK(cs_vNodes);\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint64_t hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < CADDR_TIME_VERSION)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n            // Do not store addresses outside our network\n            if (fReachable)\n                vAddrOk.push_back(addr);\n        }\n        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n        if (pfrom->fOneShot)\n            pfrom->fDisconnect = true;\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // ppcoin: send latest proof-of-work block to allow the\n                        // download node to accept as orphan (proof-of-stake \n                        // block might be rejected by stake connection check)\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash()));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                bool pushed = false;\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end()) {\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                        pushed = true;\n                    }\n                }\n                if (!pushed && inv.type == MSG_TX) {\n                    LOCK(mempool.cs);\n                    if (mempool.exists(inv.hash)) {\n                        CTransaction tx = mempool.lookup(inv.hash);\n                        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                        ss.reserve(1000);\n                        ss << tx;\n                        pfrom->PushMessage(\"tx\", ss);\n                    }\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                // ppcoin: tell downloading node about the latest block if it's\n                // without risk being rejected due to stake connection check\n                if (hashStop != hashBestChain && pindex->GetBlockTime() + nStakeMinAge > pindexBest->GetBlockTime())\n                    pfrom->PushInventory(CInv(MSG_BLOCK, hashBestChain));\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n    else if (strCommand == \"checkpoint\")\n    {\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayTransaction(tx, inv.hash);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (set<uint256>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const uint256& orphanTxHash = *mi;\n                    CTransaction& orphanTx = mapOrphanTransactions[orphanTxHash];\n                    bool fMissingInputs2 = false;\n\n                    if (orphanTx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayTransaction(orphanTx, orphanTxHash);\n                        mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanTxHash));\n                        vWorkQueue.push_back(orphanTxHash);\n                        vEraseQueue.push_back(orphanTxHash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(orphanTxHash);\n                        printf(\"   removed invalid orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(tx);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n\n        printf(\"received block %s\\n\", hashBlock.ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Don't return addresses older than nCutOff timestamp\n        int64_t nCutOff = GetTime() - (nNodeLifespan * 24 * 60 * 60);\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            if(addr.nTime > nCutOff)\n                pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"mempool\")\n    {\n        std::vector<uint256> vtxid;\n        mempool.queryHashes(vtxid);\n        vector<CInv> vInv;\n        for (unsigned int i = 0; i < vtxid.size(); i++) {\n            CInv inv(MSG_TX, vtxid[i]);\n            vInv.push_back(inv);\n            if (i == (MAX_INV_SZ - 1))\n                    break;\n        }\n        if (vInv.size() > 0)\n            pfrom->PushMessage(\"inv\", vInv);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64_t nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        uint256 alertHash = alert.GetHash();\n        if (pfrom->setKnown.count(alertHash) == 0)\n        {\n            if (alert.ProcessAlert())\n            {\n                // Relay\n                pfrom->setKnown.insert(alertHash);\n                {\n                    LOCK(cs_vNodes);\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                        alert.RelayTo(pnode);\n                }\n            }\n            else {\n                // Small DoS penalty so peers that send us lots of\n                // duplicate/expired/invalid-signature/whatever alerts\n                // eventually get banned.\n                // This isn't a Misbehaving(100) (immediate ban) because the\n                // peer might be an older or different implementation with\n                // a different signature key, etc.\n                pfrom->Misbehaving(10);\n            }\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;",
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "uint nStakeMinAge = 60 * 60 * 12;",
      "int nBestHeight = -1;",
      "uint256 hashBestChain = 0;",
      "CBlockIndex* pindexBest = NULL;",
      "CMedianFilter<int> cPeerBlockCounts(5, 0);",
      "map<uint256, CBlock*> mapOrphanBlocks;",
      "map<uint256, CTransaction> mapOrphanTransactions;",
      "map<uint256, set<uint256> > mapOrphanTransactionsByPrev;",
      "extern map<uint256, CAlert> mapAlerts;",
      "extern CCriticalSection cs_mapAlerts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AddressCurrentlyConnected",
          "args": [
            "pfrom->addr"
          ],
          "line": 3709
        },
        "resolved": true,
        "details": {
          "function_name": "AddressCurrentlyConnected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "450-453",
          "snippet": "void AddressCurrentlyConnected(const CService& addr)\n{\n    addrman.Connected(addr);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CAddrMan addrman;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCAddrMan addrman;\n\nvoid AddressCurrentlyConnected(const CService& addr)\n{\n    addrman.Connected(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->Misbehaving",
          "args": [
            "10"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "Misbehaving",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "606-629",
          "snippet": "bool CNode::Misbehaving(int howmuch)\n{\n    if (addr.IsLocal())\n    {\n        printf(\"Warning: Local node %s misbehaving (delta: %d)!\\n\", addrName.c_str(), howmuch);\n        return false;\n    }\n\n    nMisbehavior += howmuch;\n    if (nMisbehavior >= GetArg(\"-banscore\", 100))\n    {\n        int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n        printf(\"Misbehaving: %s (%d -> %d) DISCONNECTING\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n        {\n            LOCK(cs_setBanned);\n            if (setBanned[addr] < banTime)\n                setBanned[addr] = banTime;\n        }\n        CloseSocketDisconnect();\n        return true;\n    } else\n        printf(\"Misbehaving: %s (%d -> %d)\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n    return false;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "std::map<CNetAddr, int64_t> CNode::setBanned;",
            "CCriticalSection CNode::cs_setBanned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstd::map<CNetAddr, int64_t> CNode::setBanned;\nCCriticalSection CNode::cs_setBanned;\n\nCNode {\n  bool CNode::Misbehaving(int howmuch)\n  {\n      if (addr.IsLocal())\n      {\n          printf(\"Warning: Local node %s misbehaving (delta: %d)!\\n\", addrName.c_str(), howmuch);\n          return false;\n      }\n  \n      nMisbehavior += howmuch;\n      if (nMisbehavior >= GetArg(\"-banscore\", 100))\n      {\n          int64_t banTime = GetTime()+GetArg(\"-bantime\", 60*60*24);  // Default 24-hour ban\n          printf(\"Misbehaving: %s (%d -> %d) DISCONNECTING\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n          {\n              LOCK(cs_setBanned);\n              if (setBanned[addr] < banTime)\n                  setBanned[addr] = banTime;\n          }\n          CloseSocketDisconnect();\n          return true;\n      } else\n          printf(\"Misbehaving: %s (%d -> %d)\\n\", addr.ToString().c_str(), nMisbehavior-howmuch, nMisbehavior);\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alert.RelayTo",
          "args": [
            "pnode"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTo",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "143-153",
          "snippet": "bool RelayTo(CNode* pnode) const\n    {\n        // returns true if wasn't already sent\n        if (pnode->hashCheckpointKnown != hashCheckpoint)\n        {\n            pnode->hashCheckpointKnown = hashCheckpoint;\n            pnode->PushMessage(\"checkpoint\", *this);\n            return true;\n        }\n        return false;\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCSyncCheckpoint {\n  bool RelayTo(CNode* pnode) const\n      {\n          // returns true if wasn't already sent\n          if (pnode->hashCheckpointKnown != hashCheckpoint)\n          {\n              pnode->hashCheckpointKnown = hashCheckpoint;\n              pnode->PushMessage(\"checkpoint\", *this);\n              return true;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfrom->setKnown.insert",
          "args": [
            "alertHash"
          ],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alert.ProcessAlert",
          "args": [],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfrom->setKnown.count",
          "args": [
            "alertHash"
          ],
          "line": 3675
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "alert.GetHash",
          "args": [],
          "line": 3674
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->PushMessage",
          "args": [
            "\"pong\"",
            "nonce"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "PushMessage",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "425-438",
          "snippet": "void PushMessage(const char* pszCommand, const T1& a1)\n    {\n        try\n        {\n            BeginMessage(pszCommand);\n            vSend << a1;\n            EndMessage();\n        }\n        catch (...)\n        {\n            AbortMessage();\n            throw;\n        }\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushMessage(const char* pszCommand, const T1& a1)\n      {\n          try\n          {\n              BeginMessage(pszCommand);\n              vSend << a1;\n              EndMessage();\n          }\n          catch (...)\n          {\n              AbortMessage();\n              throw;\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracker.fn",
          "args": [
            "tracker.param1",
            "vRecv"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracker.IsNull",
          "args": [],
          "line": 3642
        },
        "resolved": true,
        "details": {
          "function_name": "IsNull",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1585-1588",
          "snippet": "bool IsNull()\n    {\n        return vHave.empty();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  bool IsNull()\n      {\n          return vHave.empty();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->mapRequests.erase",
          "args": [
            "mi"
          ],
          "line": 3639
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->mapRequests.end",
          "args": [],
          "line": 3636
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->mapRequests.find",
          "args": [
            "hashReply"
          ],
          "line": 3635
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "pfrom->cs_mapRequests"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwalletMain->GetKeyFromPool",
          "args": [
            "mapReuseKey[pfrom->addr]",
            "true"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "\"\""
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-allowreceivebyip\""
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vInv.size",
          "args": [],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vInv.push_back",
          "args": [
            "inv"
          ],
          "line": 3591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.queryHashes",
          "args": [
            "vtxid"
          ],
          "line": 3587
        },
        "resolved": true,
        "details": {
          "function_name": "queryHashes",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "776-784",
          "snippet": "void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n{\n    vtxid.clear();\n\n    LOCK(cs);\n    vtxid.reserve(mapTx.size());\n    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n        vtxid.push_back((*mi).first);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCTxMemPool {\n  void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n  {\n      vtxid.clear();\n  \n      LOCK(cs);\n      vtxid.reserve(mapTx.size());\n      for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n          vtxid.push_back((*mi).first);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->PushAddress",
          "args": [
            "addr"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "PushAddress",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "288-295",
          "snippet": "void PushAddress(const CAddress& addr)\n    {\n        // Known checking here is only to save space from duplicates.\n        // SendMessages will filter it again for knowns that were added\n        // after addresses were pushed.\n        if (addr.IsValid() && !setAddrKnown.count(addr))\n            vAddrToSend.push_back(addr);\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushAddress(const CAddress& addr)\n      {\n          // Known checking here is only to save space from duplicates.\n          // SendMessages will filter it again for knowns that were added\n          // after addresses were pushed.\n          if (addr.IsValid() && !setAddrKnown.count(addr))\n              vAddrToSend.push_back(addr);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrman.GetAddr",
          "args": [],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "GetAddr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "479-489",
          "snippet": "std::vector<CAddress> GetAddr()\n    {\n        Check();\n        std::vector<CAddress> vAddr;\n        {\n            LOCK(cs);\n            GetAddr_(vAddr);\n        }\n        Check();\n        return vAddr;\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nstd::vector<CAddress> GetAddr()\n    {\n        Check();\n        std::vector<CAddress> vAddr;\n        {\n            LOCK(cs);\n            GetAddr_(vAddr);\n        }\n        Check();\n        return vAddr;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->vAddrToSend.clear",
          "args": [],
          "line": 3576
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 3575
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessBlock",
          "args": [
            "pfrom",
            "&block"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2428-2512",
          "snippet": "bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "set<pair<COutPoint, unsigned int> > setStakeSeen;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexBest = NULL;",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "multimap<uint256, CBlock*> mapOrphanBlocksByPrev;",
            "set<pair<COutPoint, unsigned int> > setStakeSeenOrphan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->AddInventoryKnown",
          "args": [
            "inv"
          ],
          "line": 3564
        },
        "resolved": true,
        "details": {
          "function_name": "AddInventoryKnown",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "298-304",
          "snippet": "void AddInventoryKnown(const CInv& inv)\n    {\n        {\n            LOCK(cs_inventory);\n            setInventoryKnown.insert(inv);\n        }\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void AddInventoryKnown(const CInv& inv)\n      {\n          {\n              LOCK(cs_inventory);\n              setInventoryKnown.insert(inv);\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"received block %s\\n\"",
            "hashBlock.ToString().substr(0,20).c_str()"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBlock.ToString",
          "args": [],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBlock.ToString",
          "args": [
            "0",
            "20"
          ],
          "line": 3560
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LimitOrphanTxSize",
          "args": [
            "MAX_ORPHAN_TRANSACTIONS"
          ],
          "line": 3546
        },
        "resolved": true,
        "details": {
          "function_name": "LimitOrphanTxSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "255-269",
          "snippet": "unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CTransaction>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CTransaction> mapOrphanTransactions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CTransaction> mapOrphanTransactions;\n\nunsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CTransaction>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddOrphanTx",
          "args": [
            "tx"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "AddOrphanTx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "210-239",
          "snippet": "bool AddOrphanTx(const CTransaction& tx)\n{\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n\n    size_t nSize = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n\n    if (nSize > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %\"PRIszu\", hash: %s)\\n\", nSize, hash.ToString().substr(0,10).c_str());\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n\n    printf(\"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CTransaction> mapOrphanTransactions;",
            "map<uint256, set<uint256> > mapOrphanTransactionsByPrev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n\nbool AddOrphanTx(const CTransaction& tx)\n{\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n\n    size_t nSize = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n\n    if (nSize > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %\"PRIszu\", hash: %s)\\n\", nSize, hash.ToString().substr(0,10).c_str());\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n\n    printf(\"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EraseOrphanTx",
          "args": [
            "hash"
          ],
          "line": 3539
        },
        "resolved": true,
        "details": {
          "function_name": "EraseOrphanTx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "241-253",
          "snippet": "void static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CTransaction> mapOrphanTransactions;",
            "map<uint256, set<uint256> > mapOrphanTransactionsByPrev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vEraseQueue.push_back",
          "args": [
            "orphanTxHash"
          ],
          "line": 3532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vEraseQueue.push_back",
          "args": [
            "orphanTxHash"
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWorkQueue.push_back",
          "args": [
            "orphanTxHash"
          ],
          "line": 3526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CInv",
          "args": [
            "MSG_TX",
            "orphanTxHash"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "CInv",
          "container": "CInv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "108-122",
          "snippet": "CInv::CInv(const std::string& strType, const uint256& hashIn)\n{\n    unsigned int i;\n    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n    {\n        if (strType == ppszTypeName[i])\n        {\n            type = i;\n            break;\n        }\n    }\n    if (i == ARRAYLEN(ppszTypeName))\n        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n    hash = hashIn;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nstatic const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};\n\nCInv {\n  CInv::CInv(const std::string& strType, const uint256& hashIn)\n  {\n      unsigned int i;\n      for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n      {\n          if (strType == ppszTypeName[i])\n          {\n              type = i;\n              break;\n          }\n      }\n      if (i == ARRAYLEN(ppszTypeName))\n          throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n      hash = hashIn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RelayTransaction",
          "args": [
            "orphanTx",
            "orphanTxHash"
          ],
          "line": 3524
        },
        "resolved": true,
        "details": {
          "function_name": "RelayTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "2004-2010",
          "snippet": "void RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nvoid RelayTransaction(const CTransaction& tx, const uint256& hash)\n{\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss.reserve(10000);\n    ss << tx;\n    RelayTransaction(tx, hash, ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SyncWithWallets",
          "args": [
            "tx",
            "NULL",
            "true"
          ],
          "line": 3523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "orphanTx.AcceptToMemoryPool",
          "args": [
            "txdb",
            "true",
            "&fMissingInputs2"
          ],
          "line": 3520
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptToMemoryPool",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "710-713",
          "snippet": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\n\nCTransaction {\n  bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n  {\n      return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactionsByPrev[hashPrev].begin",
          "args": [],
          "line": 3512
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vEraseQueue.push_back",
          "args": [
            "inv.hash"
          ],
          "line": 3506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWorkQueue.push_back",
          "args": [
            "inv.hash"
          ],
          "line": 3505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SyncWithWallets",
          "args": [
            "tx",
            "NULL",
            "true"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 3480
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vHeaders.push_back",
          "args": [
            "pindex->GetBlockHeader()"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHeader",
          "args": [],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHeader",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1266-1277",
          "snippet": "CBlock GetBlockHeader() const\n    {\n        CBlock block;\n        block.nVersion       = nVersion;\n        if (pprev)\n            block.hashPrevBlock = pprev->GetBlockHash();\n        block.hashMerkleRoot = hashMerkleRoot;\n        block.nTime          = nTime;\n        block.nBits          = nBits;\n        block.nNonce         = nNonce;\n        return block;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  CBlock GetBlockHeader() const\n      {\n          CBlock block;\n          block.nVersion       = nVersion;\n          if (pprev)\n              block.hashPrevBlock = pprev->GetBlockHash();\n          block.hashMerkleRoot = hashMerkleRoot;\n          block.nTime          = nTime;\n          block.nBits          = nBits;\n          block.nNonce         = nNonce;\n          return block;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"getheaders %d to %s\\n\"",
            "(pindex ? pindex->nHeight : -1)",
            "hashStop.ToString().substr(0,20).c_str()"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locator.GetBlockIndex",
          "args": [],
          "line": 3469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkpoint.ProcessSyncCheckpoint",
          "args": [
            "pfrom"
          ],
          "line": 3441
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessSyncCheckpoint",
          "container": "CSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "387-435",
          "snippet": "bool CSyncCheckpoint::ProcessSyncCheckpoint(CNode* pfrom)\n{\n    if (!CheckSignature())\n        return false;\n\n    LOCK(Checkpoints::cs_hashSyncCheckpoint);\n    if (!mapBlockIndex.count(hashCheckpoint))\n    {\n        // We haven't received the checkpoint chain, keep the checkpoint as pending\n        Checkpoints::hashPendingCheckpoint = hashCheckpoint;\n        Checkpoints::checkpointMessagePending = *this;\n        printf(\"ProcessSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashCheckpoint.ToString().c_str());\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, hashCheckpoint);\n            // ask directly as well in case rejected earlier by duplicate\n            // proof-of-stake because getblocks may not get it this time\n            pfrom->AskFor(CInv(MSG_BLOCK, mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint));\n        }\n        return false;\n    }\n\n    if (!Checkpoints::ValidateSyncCheckpoint(hashCheckpoint))\n        return false;\n\n    CTxDB txdb;\n    CBlockIndex* pindexCheckpoint = mapBlockIndex[hashCheckpoint];\n    if (!pindexCheckpoint->IsInMainChain())\n    {\n        // checkpoint chain received but not yet main chain\n        CBlock block;\n        if (!block.ReadFromDisk(pindexCheckpoint))\n            return error(\"ProcessSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        if (!block.SetBestChain(txdb, pindexCheckpoint))\n        {\n            Checkpoints::hashInvalidCheckpoint = hashCheckpoint;\n            return error(\"ProcessSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n    }\n\n    if (!Checkpoints::WriteSyncCheckpoint(hashCheckpoint))\n        return error(\"ProcessSyncCheckpoint(): failed to write sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n    Checkpoints::checkpointMessage = *this;\n    Checkpoints::hashPendingCheckpoint = 0;\n    Checkpoints::checkpointMessagePending.SetNull();\n    printf(\"ProcessSyncCheckpoint: sync-checkpoint at %s\\n\", hashCheckpoint.ToString().c_str());\n    return true;\n}",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nCSyncCheckpoint {\n  bool CSyncCheckpoint::ProcessSyncCheckpoint(CNode* pfrom)\n  {\n      if (!CheckSignature())\n          return false;\n  \n      LOCK(Checkpoints::cs_hashSyncCheckpoint);\n      if (!mapBlockIndex.count(hashCheckpoint))\n      {\n          // We haven't received the checkpoint chain, keep the checkpoint as pending\n          Checkpoints::hashPendingCheckpoint = hashCheckpoint;\n          Checkpoints::checkpointMessagePending = *this;\n          printf(\"ProcessSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashCheckpoint.ToString().c_str());\n          // Ask this guy to fill in what we're missing\n          if (pfrom)\n          {\n              pfrom->PushGetBlocks(pindexBest, hashCheckpoint);\n              // ask directly as well in case rejected earlier by duplicate\n              // proof-of-stake because getblocks may not get it this time\n              pfrom->AskFor(CInv(MSG_BLOCK, mapOrphanBlocks.count(hashCheckpoint)? WantedByOrphan(mapOrphanBlocks[hashCheckpoint]) : hashCheckpoint));\n          }\n          return false;\n      }\n  \n      if (!Checkpoints::ValidateSyncCheckpoint(hashCheckpoint))\n          return false;\n  \n      CTxDB txdb;\n      CBlockIndex* pindexCheckpoint = mapBlockIndex[hashCheckpoint];\n      if (!pindexCheckpoint->IsInMainChain())\n      {\n          // checkpoint chain received but not yet main chain\n          CBlock block;\n          if (!block.ReadFromDisk(pindexCheckpoint))\n              return error(\"ProcessSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n          if (!block.SetBestChain(txdb, pindexCheckpoint))\n          {\n              Checkpoints::hashInvalidCheckpoint = hashCheckpoint;\n              return error(\"ProcessSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n          }\n      }\n  \n      if (!Checkpoints::WriteSyncCheckpoint(hashCheckpoint))\n          return error(\"ProcessSyncCheckpoint(): failed to write sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n      Checkpoints::checkpointMessage = *this;\n      Checkpoints::hashPendingCheckpoint = 0;\n      Checkpoints::checkpointMessagePending.SetNull();\n      printf(\"ProcessSyncCheckpoint: sync-checkpoint at %s\\n\", hashCheckpoint.ToString().c_str());\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  getblocks stopping at limit %d %s\\n\"",
            "pindex->nHeight",
            "pindex->GetBlockHash().ToString().substr(0,20).c_str()"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfrom->PushInventory",
          "args": [
            "CInv(MSG_BLOCK, pindex->GetBlockHash())"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "PushInventory",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "306-313",
          "snippet": "void PushInventory(const CInv& inv)\n    {\n        {\n            LOCK(cs_inventory);\n            if (!setInventoryKnown.count(inv))\n                vInventoryToSend.push_back(inv);\n        }\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushInventory(const CInv& inv)\n      {\n          {\n              LOCK(cs_inventory);\n              if (!setInventoryKnown.count(inv))\n                  vInventoryToSend.push_back(inv);\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetBlockTime",
          "args": [],
          "line": 3421
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  getblocks stopping at %d %s\\n\"",
            "pindex->nHeight",
            "pindex->GetBlockHash().ToString().substr(0,20).c_str()"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 3418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"getblocks %d to %s limit %d\\n\"",
            "(pindex ? pindex->nHeight : -1)",
            "hashStop.ToString().substr(0,20).c_str()",
            "nLimit"
          ],
          "line": 3413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "locator.GetBlockIndex",
          "args": [],
          "line": 3407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Inventory",
          "args": [
            "inv.hash"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "Inventory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "186-190",
          "snippet": "void static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.reserve",
          "args": [
            "1000"
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.lookup",
          "args": [
            "inv.hash"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.exists",
          "args": [
            "inv.hash"
          ],
          "line": 3384
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "mempool.cs"
          ],
          "line": 3383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inv.GetCommand",
          "args": [],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "GetCommand",
          "container": "CMessageHeader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "38-44",
          "snippet": "std::string CMessageHeader::GetCommand() const\n{\n    if (pchCommand[COMMAND_SIZE-1] == 0)\n        return std::string(pchCommand, pchCommand + strlen(pchCommand));\n    else\n        return std::string(pchCommand, pchCommand + COMMAND_SIZE);\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nCMessageHeader {\n  std::string CMessageHeader::GetCommand() const\n  {\n      if (pchCommand[COMMAND_SIZE-1] == 0)\n          return std::string(pchCommand, pchCommand + strlen(pchCommand));\n      else\n          return std::string(pchCommand, pchCommand + COMMAND_SIZE);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapRelay"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inv.IsKnownType",
          "args": [],
          "line": 3370
        },
        "resolved": true,
        "details": {
          "function_name": "IsKnownType",
          "container": "CInv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "129-132",
          "snippet": "bool CInv::IsKnownType() const\n{\n    return (type >= 1 && type < (int)ARRAYLEN(ppszTypeName));\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nstatic const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};\n\nCInv {\n  bool CInv::IsKnownType() const\n  {\n      return (type >= 1 && type < (int)ARRAYLEN(ppszTypeName));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vInv.push_back",
          "args": [
            "CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash())"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [
            "pindexBest",
            "false"
          ],
          "line": 3364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "(*mi).second"
          ],
          "line": 3354
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "303-308",
          "snippet": "bool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(COutPoint prevout)\n  {\n      CTxDB txdb(\"r\");\n      CTxIndex txindex;\n      return ReadFromDisk(txdb, prevout, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"message getdata size() = %\"PRIszu\"\"",
            "vInv.size()"
          ],
          "line": 3334
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->PushGetBlocks",
          "args": [
            "mapBlockIndex[inv.hash]",
            "uint256(0)"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "PushGetBlocks",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "94-103",
          "snippet": "void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n{\n    // Filter out duplicate requests\n    if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n        return;\n    pindexLastGetBlocksBegin = pindexBegin;\n    hashLastGetBlocksEnd = hashEnd;\n\n    PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n  {\n      // Filter out duplicate requests\n      if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n          return;\n      pindexLastGetBlocksBegin = pindexBegin;\n      hashLastGetBlocksEnd = hashEnd;\n  \n      PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint256",
          "args": [
            "0"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "setuint256",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "250-276",
          "snippet": "void setuint256(uint256 n)\n    {\n        unsigned char pch[sizeof(n) + 6];\n        unsigned char* p = pch + 4;\n        bool fLeadingZeroes = true;\n        unsigned char* pbegin = (unsigned char*)&n;\n        unsigned char* psrc = pbegin + sizeof(n);\n        while (psrc != pbegin)\n        {\n            unsigned char c = *(--psrc);\n            if (fLeadingZeroes)\n            {\n                if (c == 0)\n                    continue;\n                if (c & 0x80)\n                    *p++ = 0;\n                fLeadingZeroes = false;\n            }\n            *p++ = c;\n        }\n        unsigned int nSize = p - (pch + 4);\n        pch[0] = (nSize >> 24) & 0xff;\n        pch[1] = (nSize >> 16) & 0xff;\n        pch[2] = (nSize >> 8) & 0xff;\n        pch[3] = (nSize >> 0) & 0xff;\n        BN_mpi2bn(pch, p - pch, this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void setuint256(uint256 n)\n      {\n          unsigned char pch[sizeof(n) + 6];\n          unsigned char* p = pch + 4;\n          bool fLeadingZeroes = true;\n          unsigned char* pbegin = (unsigned char*)&n;\n          unsigned char* psrc = pbegin + sizeof(n);\n          while (psrc != pbegin)\n          {\n              unsigned char c = *(--psrc);\n              if (fLeadingZeroes)\n              {\n                  if (c == 0)\n                      continue;\n                  if (c & 0x80)\n                      *p++ = 0;\n                  fLeadingZeroes = false;\n              }\n              *p++ = c;\n          }\n          unsigned int nSize = p - (pch + 4);\n          pch[0] = (nSize >> 24) & 0xff;\n          pch[1] = (nSize >> 16) & 0xff;\n          pch[2] = (nSize >> 8) & 0xff;\n          pch[3] = (nSize >> 0) & 0xff;\n          BN_mpi2bn(pch, p - pch, this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOrphanRoot",
          "args": [
            "mapOrphanBlocks[inv.hash]"
          ],
          "line": 3311
        },
        "resolved": true,
        "details": {
          "function_name": "GetOrphanRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "959-965",
          "snippet": "uint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CBlock*> mapOrphanBlocks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CBlock*> mapOrphanBlocks;\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->AskFor",
          "args": [
            "inv"
          ],
          "line": 3309
        },
        "resolved": true,
        "details": {
          "function_name": "AskFor",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "315-333",
          "snippet": "void AskFor(const CInv& inv)\n    {\n        // We're using mapAskFor as a priority queue,\n        // the key is the earliest time the request can be sent\n        int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n        if (fDebugNet)\n            printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n\n        // Make sure not to reuse time indexes to keep things in the same order\n        int64_t nNow = (GetTime() - 1) * 1000000;\n        static int64_t nLastTime;\n        ++nLastTime;\n        nNow = std::max(nNow, nLastTime);\n        nLastTime = nNow;\n\n        // Each retry is 2 minutes after the last\n        nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n        mapAskFor.insert(std::make_pair(nRequestTime, inv));\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void AskFor(const CInv& inv)\n      {\n          // We're using mapAskFor as a priority queue,\n          // the key is the earliest time the request can be sent\n          int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n          if (fDebugNet)\n              printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n  \n          // Make sure not to reuse time indexes to keep things in the same order\n          int64_t nNow = (GetTime() - 1) * 1000000;\n          static int64_t nLastTime;\n          ++nLastTime;\n          nNow = std::max(nNow, nLastTime);\n          nLastTime = nNow;\n  \n          // Each retry is 2 minutes after the last\n          nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n          mapAskFor.insert(std::make_pair(nRequestTime, inv));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  got inventory: %s  %s\\n\"",
            "inv.ToString().c_str()",
            "fAlreadyHave ? \"have\" : \"new\""
          ],
          "line": 3306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AlreadyHave",
          "args": [
            "txdb",
            "inv"
          ],
          "line": 3304
        },
        "resolved": true,
        "details": {
          "function_name": "AlreadyHave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "3016-3038",
          "snippet": "bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "map<uint256, CTransaction> mapOrphanTransactions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nmap<uint256, CBlockIndex*> mapBlockIndex;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmap<uint256, CTransaction> mapOrphanTransactions;\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrman.Add",
          "args": [
            "vAddrOk",
            "pfrom->addr",
            "2 * 60 * 60"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vAddrOk.push_back",
          "args": [
            "addr"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "addr"
          ],
          "line": 3263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "hashKey",
            "pnode"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "BEGIN(hashKey)",
            "END(hashKey)"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "END",
          "args": [
            "hashKey"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEGIN",
          "args": [
            "hashKey"
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&nPointer",
            "&pnode",
            "sizeof(nPointer)"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "END",
          "args": [
            "hashRand"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BEGIN",
          "args": [
            "hashRand"
          ],
          "line": 3249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRandHash",
          "args": [],
          "line": 3246
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "193-198",
          "snippet": "uint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nuint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 3241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.IsRoutable",
          "args": [],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsReachable",
          "args": [
            "addr"
          ],
          "line": 3236
        },
        "resolved": true,
        "details": {
          "function_name": "IsReachable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "300-305",
          "snippet": "bool IsReachable(const CNetAddr& addr)\n{\n    LOCK(cs_mapLocalHost);\n    enum Network net = addr.GetNetwork();\n    return vfReachable[net] && !vfLimited[net];\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CCriticalSection cs_mapLocalHost;",
            "static bool vfReachable[NET_MAX] = {};",
            "static bool vfLimited[NET_MAX] = {};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic bool vfReachable[NET_MAX] = {};\nstatic bool vfLimited[NET_MAX] = {};\n\nbool IsReachable(const CNetAddr& addr)\n{\n    LOCK(cs_mapLocalHost);\n    enum Network net = addr.GetNetwork();\n    return vfReachable[net] && !vfLimited[net];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->AddAddressKnown",
          "args": [
            "addr"
          ],
          "line": 3235
        },
        "resolved": true,
        "details": {
          "function_name": "AddAddressKnown",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "283-286",
          "snippet": "void AddAddressKnown(const CAddress& addr)\n    {\n        setAddrKnown.insert(addr);\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void AddAddressKnown(const CAddress& addr)\n      {\n          setAddrKnown.insert(addr);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 3227
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->vRecv.SetVersion",
          "args": [
            "min(pfrom->nVersion, PROTOCOL_VERSION)"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "SetVersion",
          "container": "CAutoFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "1085-1085",
          "snippet": "void SetVersion(int n)       { nVersion = n; }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCAutoFile {\n  void SetVersion(int n)       { nVersion = n; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pfrom->nVersion",
            "PROTOCOL_VERSION"
          ],
          "line": 3207
        },
        "resolved": true,
        "details": {
          "function_name": "TimingResistantEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "569-576",
          "snippet": "bool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::AskForPendingSyncCheckpoint",
          "args": [
            "pfrom"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "AskForPendingSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "296-301",
          "snippet": "void AskForPendingSyncCheckpoint(CNode* pfrom)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (pfrom && hashPendingCheckpoint != 0 && (!mapBlockIndex.count(hashPendingCheckpoint)) && (!mapOrphanBlocks.count(hashPendingCheckpoint)))\n            pfrom->AskFor(CInv(MSG_BLOCK, hashPendingCheckpoint));\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nvoid AskForPendingSyncCheckpoint(CNode* pfrom)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (pfrom && hashPendingCheckpoint != 0 && (!mapBlockIndex.count(hashPendingCheckpoint)) && (!mapOrphanBlocks.count(hashPendingCheckpoint)))\n            pfrom->AskFor(CInv(MSG_BLOCK, hashPendingCheckpoint));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "IsInitialBlockDownload",
          "args": [],
          "line": 3192
        },
        "resolved": true,
        "details": {
          "function_name": "IsInitialBlockDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1220-1233",
          "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nBestHeight = -1;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cPeerBlockCounts.input",
          "args": [
            "pfrom->nStartingHeight"
          ],
          "line": 3189
        },
        "resolved": true,
        "details": {
          "function_name": "input",
          "container": "CMedianFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "596-607",
          "snippet": "void input(T value)\n    {\n        if(vValues.size() == nSize)\n        {\n            vValues.erase(vValues.begin());\n        }\n        vValues.push_back(value);\n\n        vSorted.resize(vValues.size());\n        std::copy(vValues.begin(), vValues.end(), vSorted.begin());\n        std::sort(vSorted.begin(), vSorted.end());\n    }",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nCMedianFilter {\n  void input(T value)\n      {\n          if(vValues.size() == nSize)\n          {\n              vValues.erase(vValues.begin());\n          }\n          vValues.push_back(value);\n  \n          vSorted.resize(vValues.size());\n          std::copy(vValues.begin(), vValues.end(), vSorted.begin());\n          std::sort(vSorted.begin(), vSorted.end());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\"",
            "pfrom->nVersion",
            "pfrom->nStartingHeight",
            "addrMe.ToString().c_str()",
            "addrFrom.ToString().c_str()",
            "pfrom->addr.ToString().c_str()"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "Checkpoints::cs_hashSyncCheckpoint"
          ],
          "line": 3180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapAlerts"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrman.Good",
          "args": [
            "addrFrom"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "Good",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "443-451",
          "snippet": "void Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Good_(addr, nTime);\n            Check();\n        }\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nvoid Good(const CService &addr, int64_t nTime = GetAdjustedTime())\n    {\n        {\n            LOCK(cs);\n            Check();\n            Good_(addr, nTime);\n            Check();\n        }\n    }"
        }
      },
      {
        "call_info": {
          "callee": "addrman.Add",
          "args": [
            "addrFrom",
            "addrFrom"
          ],
          "line": 3154
        },
        "resolved": true,
        "details": {
          "function_name": "Add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/addrman.h",
          "lines": "427-440",
          "snippet": "bool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }",
          "includes": [
            "#include <openssl/rand.h>",
            "#include <vector>",
            "#include <map>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/rand.h>\n#include <vector>\n#include <map>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n\nbool Add(const std::vector<CAddress> &vAddr, const CNetAddr& source, int64_t nTimePenalty = 0)\n    {\n        int nAdd = 0;\n        {\n            LOCK(cs);\n            Check();\n            for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n                nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n            Check();\n        }\n        if (nAdd)\n            printf(\"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString().c_str(), nTried, nNew);\n        return nAdd > 0;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "GetLocalAddress",
          "args": [
            "&pfrom->addr"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "GetLocalAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "131-142",
          "snippet": "CAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
            "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\n\nCAddress GetLocalAddress(const CNetAddr *paddrPeer)\n{\n    CAddress ret(CService(\"0.0.0.0\",0),0);\n    CService addr;\n    if (GetLocal(addr, paddrPeer))\n    {\n        ret = CAddress(addr);\n        ret.nServices = nLocalServices;\n        ret.nTime = GetAdjustedTime();\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddTimeData",
          "args": [
            "pfrom->addr",
            "nTime"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "AddTimeData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1219-1274",
          "snippet": "void AddTimeData(const CNetAddr& ip, int64_t nTime)\n{\n    int64_t nOffsetSample = nTime - GetTime();\n\n    // Ignore duplicates\n    static set<CNetAddr> setKnown;\n    if (!setKnown.insert(ip).second)\n        return;\n\n    // Add data\n    vTimeOffsets.input(nOffsetSample);\n    printf(\"Added time data, samples %d, offset %+\"PRId64\" (%+\"PRId64\" minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n    {\n        int64_t nMedian = vTimeOffsets.median();\n        std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n\n        // Only let other nodes change our time by so much\n        if(abs64(nMedian) < 60 * 60) {\n            nPeersOffset = nMedian;\n        } else {\n            nPeersOffset = INT64_MAX;\n        }\n\n            {\n                // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                bool fMatch = false;\n                BOOST_FOREACH(int64 nOffset, vSorted)\n                    if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                        fMatch = true;\n\n                if(!fMatch && !fPeersWarning) {\n                    fPeersWarning = true;\n                    string strMessage = _(\"Warning: Please check your date and time! Halcyon will not work properly if they are incorrect.\");\n                    strMiscWarning = strMessage;\n                    printf(\"*** %s\\n\", strMessage.c_str());\n                    uiInterface.ThreadSafeMessageBox(strMessage+\" \", string(\"Halcyon\"),\n                      CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION);\n                }\n\n                if(fMatch && fPeersWarning) {\n                    strMiscWarning.clear();\n                    fPeersWarning = false;\n                }\n            }\n\n        if (fDebug) {\n            BOOST_FOREACH(int64 n, vSorted)\n              printf(\"%+\" PRI64d \"  \", n);\n            printf(\"|  \");\n        }\n\n        if(nPeersOffset != INT64_MAX)\n          printf(\"nPeersOffset = %+\" PRI64d \" seconds\\n\", nPeersOffset);\n    }\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool fDebug = false;",
            "string strMiscWarning;",
            "CMedianFilter<int64_t> vTimeOffsets(200,0);",
            "int64 nPeersOffset = INT64_MAX;",
            "bool fPeersWarning = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nbool fDebug = false;\nstring strMiscWarning;\nCMedianFilter<int64_t> vTimeOffsets(200,0);\nint64 nPeersOffset = INT64_MAX;\nbool fPeersWarning = false;\n\nvoid AddTimeData(const CNetAddr& ip, int64_t nTime)\n{\n    int64_t nOffsetSample = nTime - GetTime();\n\n    // Ignore duplicates\n    static set<CNetAddr> setKnown;\n    if (!setKnown.insert(ip).second)\n        return;\n\n    // Add data\n    vTimeOffsets.input(nOffsetSample);\n    printf(\"Added time data, samples %d, offset %+\"PRId64\" (%+\"PRId64\" minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n    {\n        int64_t nMedian = vTimeOffsets.median();\n        std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n\n        // Only let other nodes change our time by so much\n        if(abs64(nMedian) < 60 * 60) {\n            nPeersOffset = nMedian;\n        } else {\n            nPeersOffset = INT64_MAX;\n        }\n\n            {\n                // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                bool fMatch = false;\n                BOOST_FOREACH(int64 nOffset, vSorted)\n                    if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                        fMatch = true;\n\n                if(!fMatch && !fPeersWarning) {\n                    fPeersWarning = true;\n                    string strMessage = _(\"Warning: Please check your date and time! Halcyon will not work properly if they are incorrect.\");\n                    strMiscWarning = strMessage;\n                    printf(\"*** %s\\n\", strMessage.c_str());\n                    uiInterface.ThreadSafeMessageBox(strMessage+\" \", string(\"Halcyon\"),\n                      CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION);\n                }\n\n                if(fMatch && fPeersWarning) {\n                    strMiscWarning.clear();\n                    fPeersWarning = false;\n                }\n            }\n\n        if (fDebug) {\n            BOOST_FOREACH(int64 n, vSorted)\n              printf(\"%+\" PRI64d \"  \", n);\n            printf(\"|  \");\n        }\n\n        if(nPeersOffset != INT64_MAX)\n          printf(\"nPeersOffset = %+\" PRI64d \" seconds\\n\", nPeersOffset);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-synctime\"",
            "true"
          ],
          "line": 3127
        },
        "resolved": true,
        "details": {
          "function_name": "GetBoolArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "569-578",
          "snippet": "bool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nbool GetBoolArg(const std::string& strArg, bool fDefault)\n{\n    if (mapArgs.count(strArg))\n    {\n        if (mapArgs[strArg].empty())\n            return true;\n        return (atoi(mapArgs[strArg]) != 0);\n    }\n    return fDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->PushVersion",
          "args": [],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "PushVersion",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "567-576",
          "snippet": "void CNode::PushVersion()\n{\n    int64 nTime = GetAdjustedTime();\n    CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n    CAddress addrMe = GetLocalAddress(&addr);\n    RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n    printf(\"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n    PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);",
            "CAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);",
            "uint64_t nLocalHostNonce = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nuint64_t nLocalServices = (fClient ? 0 : NODE_NETWORK);\nCAddress addrSeenByPeer(CService(\"0.0.0.0\", 0), nLocalServices);\nuint64_t nLocalHostNonce = 0;\n\nCNode {\n  void CNode::PushVersion()\n  {\n      int64 nTime = GetAdjustedTime();\n      CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n      CAddress addrMe = GetLocalAddress(&addr);\n      RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n      printf(\"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString().c_str(), addrYou.ToString().c_str(), addr.ToString().c_str());\n      PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                  nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"obsolete node %s with client %d, disconnecting\\n\"",
            "pfrom->addr.ToString().c_str()",
            "pfrom->nVersion"
          ],
          "line": 3110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SeenLocal",
          "args": [
            "addrMe"
          ],
          "line": 3095
        },
        "resolved": true,
        "details": {
          "function_name": "SeenLocal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "278-290",
          "snippet": "bool SeenLocal(const CService& addr)\n{\n    {\n        LOCK(cs_mapLocalHost);\n        if (mapLocalHost.count(addr) == 0)\n            return false;\n        mapLocalHost[addr].nScore++;\n    }\n\n    AdvertizeLocal();\n\n    return true;\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static CCriticalSection cs_mapLocalHost;",
            "static map<CNetAddr, LocalServiceInfo> mapLocalHost;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nstatic CCriticalSection cs_mapLocalHost;\nstatic map<CNetAddr, LocalServiceInfo> mapLocalHost;\n\nbool SeenLocal(const CService& addr)\n{\n    {\n        LOCK(cs_mapLocalHost);\n        if (mapLocalHost.count(addr) == 0)\n            return false;\n        mapLocalHost[addr].nScore++;\n    }\n\n    AdvertizeLocal();\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vRecv.empty",
          "args": [],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"partner %s using obsolete version %i; disconnecting\\n\"",
            "pfrom->addr.ToString().c_str()",
            "pfrom->nVersion"
          ],
          "line": 3078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"dropmessagestest DROPPING RECV MESSAGE\\n\""
          ],
          "line": 3056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRand",
          "args": [
            "atoi(mapArgs[\"-dropmessagestest\"])"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "188-191",
          "snippet": "int GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nint GetRandInt(int nMax)\n{\n    return GetRand(nMax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "mapArgs[\"-dropmessagestest\"]"
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "atoi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "292-295",
          "snippet": "inline int atoi(const std::string& str)\n{\n    return atoi(str.c_str());\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int atoi(const std::string& str)\n{\n    return atoi(str.c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"received: %s (%\"PRIszu\" bytes)\\n\"",
            "strCommand.c_str()",
            "vRecv.size()"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strCommand.c_str",
          "args": [],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RandAddSeedPerfmon",
          "args": [],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "RandAddSeedPerfmon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "146-171",
          "snippet": "void RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nvoid RandAddSeedPerfmon()\n{\n    RandAddSeed();\n\n    // This can take up to 2 seconds, so only do it every 10 minutes\n    static int64_t nLastPerfmon;\n    if (GetTime() < nLastPerfmon + 10 * 60)\n        return;\n    nLastPerfmon = GetTime();\n\n#ifdef WIN32\n    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n    // Seed with the entire set of perfmon data\n    unsigned char pdata[250000];\n    memset(pdata, 0, sizeof(pdata));\n    unsigned long nSize = sizeof(pdata);\n    long ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, pdata, &nSize);\n    RegCloseKey(HKEY_PERFORMANCE_DATA);\n    if (ret == ERROR_SUCCESS)\n    {\n        RAND_add(pdata, nSize, nSize/100.0);\n        memset(pdata, 0, nSize);\n        printf(\"RandAddSeed() %lu bytes\\n\", nSize);\n    }\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nuint nStakeMinAge = 60 * 60 * 12;\nint nBestHeight = -1;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nCMedianFilter<int> cPeerBlockCounts(5, 0);\nmap<uint256, CBlock*> mapOrphanBlocks;\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\nextern map<uint256, CAlert> mapAlerts;\nextern CCriticalSection cs_mapAlerts;\n\nbool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n{\n    static map<CService, CPubKey> mapReuseKey;\n    RandAddSeedPerfmon();\n    if (fDebug)\n        printf(\"received: %s (%\"PRIszu\" bytes)\\n\", strCommand.c_str(), vRecv.size());\n    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n    {\n        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n        return true;\n    }\n\n    if (strCommand == \"version\")\n    {\n        // Each connection can only send one version message\n        if (pfrom->nVersion != 0)\n        {\n            pfrom->Misbehaving(1);\n            return false;\n        }\n\n        int64_t nTime;\n        CAddress addrMe;\n        CAddress addrFrom;\n        uint64_t nNonce = 1;\n        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n        if (pfrom->nVersion < MIN_PROTO_VERSION)\n        {\n            // Since February 20, 2012, the protocol is initiated at version 209,\n            // and earlier versions are no longer supported\n            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n            pfrom->fDisconnect = true;\n            return false;\n        }\n\n        if (pfrom->nVersion == 10300)\n            pfrom->nVersion = 300;\n        if (!vRecv.empty())\n            vRecv >> addrFrom >> nNonce;\n        if (!vRecv.empty())\n            vRecv >> pfrom->strSubVer;\n        if (!vRecv.empty())\n            vRecv >> pfrom->nStartingHeight;\n\n        if (pfrom->fInbound && addrMe.IsRoutable())\n        {\n            pfrom->addrLocal = addrMe;\n            SeenLocal(addrMe);\n        }\n\n        // Disconnect if we connected to ourself\n        if (nNonce == nLocalHostNonce && nNonce > 1)\n        {\n            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n            pfrom->fDisconnect = true;\n            return true;\n        }\n\n        /* Disconnect all obsolete clients */\n        uint nAdjTime = GetAdjustedTime();\n        if(nAdjTime > nStakeMaxAgeForkTime) {\n            if(pfrom->nVersion < MIN_PROTOCOL_VERSION) {\n                printf(\"obsolete node %s with client %d, disconnecting\\n\",\n                  pfrom->addr.ToString().c_str(), pfrom->nVersion);\n                pfrom->fDisconnect = true;\n                return(true);\n            }\n        }\n\n        // record my external IP reported by peer\n        if (addrFrom.IsRoutable() && addrMe.IsRoutable())\n            addrSeenByPeer = addrMe;\n\n        // Be shy and don't send version until we hear\n        if (pfrom->fInbound)\n            pfrom->PushVersion();\n\n        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n\n        if (GetBoolArg(\"-synctime\", true))\n            AddTimeData(pfrom->addr, nTime);\n\n        // Change version\n        pfrom->PushMessage(\"verack\");\n        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n\n        if (!pfrom->fInbound)\n        {\n            // Advertise our address\n            if (!fNoListen && !IsInitialBlockDownload())\n            {\n                CAddress addr = GetLocalAddress(&pfrom->addr);\n                if (addr.IsRoutable())\n                    pfrom->PushAddress(addr);\n            }\n\n            // Get recent addresses\n            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n            {\n                pfrom->PushMessage(\"getaddr\");\n                pfrom->fGetAddr = true;\n            }\n            addrman.Good(pfrom->addr);\n        } else {\n            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n            {\n                addrman.Add(addrFrom, addrFrom);\n                addrman.Good(addrFrom);\n            }\n        }\n\n        // Ask the first connected node for block updates\n        static int nAskedForBlocks = 0;\n        if (!pfrom->fClient && !pfrom->fOneShot &&\n            (pfrom->nStartingHeight > (nBestHeight - 144)) &&\n            (pfrom->nVersion < NOBLKS_VERSION_START ||\n             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n        {\n            nAskedForBlocks++;\n            pfrom->PushGetBlocks(pindexBest, uint256(0));\n        }\n\n        // Relay alerts\n        {\n            LOCK(cs_mapAlerts);\n            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n                item.second.RelayTo(pfrom);\n        }\n\n        // Relay sync-checkpoint\n        {\n            LOCK(Checkpoints::cs_hashSyncCheckpoint);\n            if (!Checkpoints::checkpointMessage.IsNull())\n                Checkpoints::checkpointMessage.RelayTo(pfrom);\n        }\n\n        pfrom->fSuccessfullyConnected = true;\n\n        printf(\"receive version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString().c_str(), addrFrom.ToString().c_str(), pfrom->addr.ToString().c_str());\n\n        cPeerBlockCounts.input(pfrom->nStartingHeight);\n\n        // ppcoin: ask for pending sync-checkpoint if any\n        if (!IsInitialBlockDownload())\n            Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n    }\n\n\n    else if (pfrom->nVersion == 0)\n    {\n        // Must have a version message before anything else\n        pfrom->Misbehaving(1);\n        return false;\n    }\n\n\n    else if (strCommand == \"verack\")\n    {\n        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n    }\n\n\n    else if (strCommand == \"addr\")\n    {\n        vector<CAddress> vAddr;\n        vRecv >> vAddr;\n\n        // Don't want addr from older versions unless seeding\n        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n            return true;\n        if (vAddr.size() > 1000)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message addr size() = %\"PRIszu\"\", vAddr.size());\n        }\n\n        // Store the new addresses\n        vector<CAddress> vAddrOk;\n        int64_t nNow = GetAdjustedTime();\n        int64_t nSince = nNow - 10 * 60;\n        BOOST_FOREACH(CAddress& addr, vAddr)\n        {\n            if (fShutdown)\n                return true;\n            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n                addr.nTime = nNow - 5 * 24 * 60 * 60;\n            pfrom->AddAddressKnown(addr);\n            bool fReachable = IsReachable(addr);\n            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n            {\n                // Relay to a limited number of other nodes\n                {\n                    LOCK(cs_vNodes);\n                    // Use deterministic randomness to send to the same nodes for 24 hours\n                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n                    static uint256 hashSalt;\n                    if (hashSalt == 0)\n                        hashSalt = GetRandHash();\n                    uint64_t hashAddr = addr.GetHash();\n                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n                    multimap<uint256, CNode*> mapMix;\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                    {\n                        if (pnode->nVersion < CADDR_TIME_VERSION)\n                            continue;\n                        unsigned int nPointer;\n                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n                        uint256 hashKey = hashRand ^ nPointer;\n                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n                        mapMix.insert(make_pair(hashKey, pnode));\n                    }\n                    int nRelayNodes = fReachable ? 2 : 1; // limited relaying of addresses outside our network(s)\n                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n                        ((*mi).second)->PushAddress(addr);\n                }\n            }\n            // Do not store addresses outside our network\n            if (fReachable)\n                vAddrOk.push_back(addr);\n        }\n        addrman.Add(vAddrOk, pfrom->addr, 2 * 60 * 60);\n        if (vAddr.size() < 1000)\n            pfrom->fGetAddr = false;\n        if (pfrom->fOneShot)\n            pfrom->fDisconnect = true;\n    }\n\n    else if (strCommand == \"inv\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message inv size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        // find last block in inv vector\n        unsigned int nLastBlock = (unsigned int)(-1);\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK) {\n                nLastBlock = vInv.size() - 1 - nInv;\n                break;\n            }\n        }\n        CTxDB txdb(\"r\");\n        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n        {\n            const CInv &inv = vInv[nInv];\n\n            if (fShutdown)\n                return true;\n            pfrom->AddInventoryKnown(inv);\n\n            bool fAlreadyHave = AlreadyHave(txdb, inv);\n            if (fDebug)\n                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n\n            if (!fAlreadyHave)\n                pfrom->AskFor(inv);\n            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash)) {\n                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n            } else if (nInv == nLastBlock) {\n                // In case we are on a very long side-chain, it is possible that we already have\n                // the last block in an inv bundle sent in response to getblocks. Try to detect\n                // this situation and push another getblocks to continue.\n                pfrom->PushGetBlocks(mapBlockIndex[inv.hash], uint256(0));\n                if (fDebug)\n                    printf(\"force request: %s\\n\", inv.ToString().c_str());\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getdata\")\n    {\n        vector<CInv> vInv;\n        vRecv >> vInv;\n        if (vInv.size() > MAX_INV_SZ)\n        {\n            pfrom->Misbehaving(20);\n            return error(\"message getdata size() = %\"PRIszu\"\", vInv.size());\n        }\n\n        if (fDebugNet || (vInv.size() != 1))\n            printf(\"received getdata (%\"PRIszu\" invsz)\\n\", vInv.size());\n\n        BOOST_FOREACH(const CInv& inv, vInv)\n        {\n            if (fShutdown)\n                return true;\n            if (fDebugNet || (vInv.size() == 1))\n                printf(\"received getdata for: %s\\n\", inv.ToString().c_str());\n\n            if (inv.type == MSG_BLOCK)\n            {\n                // Send block from disk\n                map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(inv.hash);\n                if (mi != mapBlockIndex.end())\n                {\n                    CBlock block;\n                    block.ReadFromDisk((*mi).second);\n                    pfrom->PushMessage(\"block\", block);\n\n                    // Trigger them to send a getblocks request for the next batch of inventory\n                    if (inv.hash == pfrom->hashContinue)\n                    {\n                        // ppcoin: send latest proof-of-work block to allow the\n                        // download node to accept as orphan (proof-of-stake \n                        // block might be rejected by stake connection check)\n                        vector<CInv> vInv;\n                        vInv.push_back(CInv(MSG_BLOCK, GetLastBlockIndex(pindexBest, false)->GetBlockHash()));\n                        pfrom->PushMessage(\"inv\", vInv);\n                        pfrom->hashContinue = 0;\n                    }\n                }\n            }\n            else if (inv.IsKnownType())\n            {\n                // Send stream from relay memory\n                bool pushed = false;\n                {\n                    LOCK(cs_mapRelay);\n                    map<CInv, CDataStream>::iterator mi = mapRelay.find(inv);\n                    if (mi != mapRelay.end()) {\n                        pfrom->PushMessage(inv.GetCommand(), (*mi).second);\n                        pushed = true;\n                    }\n                }\n                if (!pushed && inv.type == MSG_TX) {\n                    LOCK(mempool.cs);\n                    if (mempool.exists(inv.hash)) {\n                        CTransaction tx = mempool.lookup(inv.hash);\n                        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n                        ss.reserve(1000);\n                        ss << tx;\n                        pfrom->PushMessage(\"tx\", ss);\n                    }\n                }\n            }\n\n            // Track requests for our stuff\n            Inventory(inv.hash);\n        }\n    }\n\n\n    else if (strCommand == \"getblocks\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        // Find the last block the caller has in the main chain\n        CBlockIndex* pindex = locator.GetBlockIndex();\n\n        // Send the rest of the chain\n        if (pindex)\n            pindex = pindex->pnext;\n        int nLimit = 500;\n        printf(\"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str(), nLimit);\n        for (; pindex; pindex = pindex->pnext)\n        {\n            if (pindex->GetBlockHash() == hashStop)\n            {\n                printf(\"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                // ppcoin: tell downloading node about the latest block if it's\n                // without risk being rejected due to stake connection check\n                if (hashStop != hashBestChain && pindex->GetBlockTime() + nStakeMinAge > pindexBest->GetBlockTime())\n                    pfrom->PushInventory(CInv(MSG_BLOCK, hashBestChain));\n                break;\n            }\n            pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n            if (--nLimit <= 0)\n            {\n                // When this block is requested, we'll send an inv that'll make them\n                // getblocks the next batch of inventory.\n                printf(\"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().substr(0,20).c_str());\n                pfrom->hashContinue = pindex->GetBlockHash();\n                break;\n            }\n        }\n    }\n    else if (strCommand == \"checkpoint\")\n    {\n        CSyncCheckpoint checkpoint;\n        vRecv >> checkpoint;\n\n        if (checkpoint.ProcessSyncCheckpoint(pfrom))\n        {\n            // Relay\n            pfrom->hashCheckpointKnown = checkpoint.hashCheckpoint;\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n    }\n\n    else if (strCommand == \"getheaders\")\n    {\n        CBlockLocator locator;\n        uint256 hashStop;\n        vRecv >> locator >> hashStop;\n\n        CBlockIndex* pindex = NULL;\n        if (locator.IsNull())\n        {\n            // If locator is null, return the hashStop block\n            map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashStop);\n            if (mi == mapBlockIndex.end())\n                return true;\n            pindex = (*mi).second;\n        }\n        else\n        {\n            // Find the last block the caller has in the main chain\n            pindex = locator.GetBlockIndex();\n            if (pindex)\n                pindex = pindex->pnext;\n        }\n\n        vector<CBlock> vHeaders;\n        int nLimit = 2000;\n        printf(\"getheaders %d to %s\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString().substr(0,20).c_str());\n        for (; pindex; pindex = pindex->pnext)\n        {\n            vHeaders.push_back(pindex->GetBlockHeader());\n            if (--nLimit <= 0 || pindex->GetBlockHash() == hashStop)\n                break;\n        }\n        pfrom->PushMessage(\"headers\", vHeaders);\n    }\n\n\n    else if (strCommand == \"tx\")\n    {\n        vector<uint256> vWorkQueue;\n        vector<uint256> vEraseQueue;\n        CDataStream vMsg(vRecv);\n        CTxDB txdb(\"r\");\n        CTransaction tx;\n        vRecv >> tx;\n\n        CInv inv(MSG_TX, tx.GetHash());\n        pfrom->AddInventoryKnown(inv);\n\n        bool fMissingInputs = false;\n        if (tx.AcceptToMemoryPool(txdb, true, &fMissingInputs))\n        {\n            SyncWithWallets(tx, NULL, true);\n            RelayTransaction(tx, inv.hash);\n            mapAlreadyAskedFor.erase(inv);\n            vWorkQueue.push_back(inv.hash);\n            vEraseQueue.push_back(inv.hash);\n\n            // Recursively process any orphan transactions that depended on this one\n            for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n            {\n                uint256 hashPrev = vWorkQueue[i];\n                for (set<uint256>::iterator mi = mapOrphanTransactionsByPrev[hashPrev].begin();\n                     mi != mapOrphanTransactionsByPrev[hashPrev].end();\n                     ++mi)\n                {\n                    const uint256& orphanTxHash = *mi;\n                    CTransaction& orphanTx = mapOrphanTransactions[orphanTxHash];\n                    bool fMissingInputs2 = false;\n\n                    if (orphanTx.AcceptToMemoryPool(txdb, true, &fMissingInputs2))\n                    {\n                        printf(\"   accepted orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                        SyncWithWallets(tx, NULL, true);\n                        RelayTransaction(orphanTx, orphanTxHash);\n                        mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanTxHash));\n                        vWorkQueue.push_back(orphanTxHash);\n                        vEraseQueue.push_back(orphanTxHash);\n                    }\n                    else if (!fMissingInputs2)\n                    {\n                        // invalid orphan\n                        vEraseQueue.push_back(orphanTxHash);\n                        printf(\"   removed invalid orphan tx %s\\n\", orphanTxHash.ToString().substr(0,10).c_str());\n                    }\n                }\n            }\n\n            BOOST_FOREACH(uint256 hash, vEraseQueue)\n                EraseOrphanTx(hash);\n        }\n        else if (fMissingInputs)\n        {\n            AddOrphanTx(tx);\n\n            // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n            unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n            if (nEvicted > 0)\n                printf(\"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n        }\n        if (tx.nDoS) pfrom->Misbehaving(tx.nDoS);\n    }\n\n\n    else if (strCommand == \"block\")\n    {\n        CBlock block;\n        vRecv >> block;\n        uint256 hashBlock = block.GetHash();\n\n        printf(\"received block %s\\n\", hashBlock.ToString().substr(0,20).c_str());\n        // block.print();\n\n        CInv inv(MSG_BLOCK, hashBlock);\n        pfrom->AddInventoryKnown(inv);\n\n        if (ProcessBlock(pfrom, &block))\n            mapAlreadyAskedFor.erase(inv);\n        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n    }\n\n\n    else if (strCommand == \"getaddr\")\n    {\n        // Don't return addresses older than nCutOff timestamp\n        int64_t nCutOff = GetTime() - (nNodeLifespan * 24 * 60 * 60);\n        pfrom->vAddrToSend.clear();\n        vector<CAddress> vAddr = addrman.GetAddr();\n        BOOST_FOREACH(const CAddress &addr, vAddr)\n            if(addr.nTime > nCutOff)\n                pfrom->PushAddress(addr);\n    }\n\n\n    else if (strCommand == \"mempool\")\n    {\n        std::vector<uint256> vtxid;\n        mempool.queryHashes(vtxid);\n        vector<CInv> vInv;\n        for (unsigned int i = 0; i < vtxid.size(); i++) {\n            CInv inv(MSG_TX, vtxid[i]);\n            vInv.push_back(inv);\n            if (i == (MAX_INV_SZ - 1))\n                    break;\n        }\n        if (vInv.size() > 0)\n            pfrom->PushMessage(\"inv\", vInv);\n    }\n\n\n    else if (strCommand == \"checkorder\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        if (!GetBoolArg(\"-allowreceivebyip\"))\n        {\n            pfrom->PushMessage(\"reply\", hashReply, (int)2, string(\"\"));\n            return true;\n        }\n\n        CWalletTx order;\n        vRecv >> order;\n\n        /// we have a chance to check the order here\n\n        // Keep giving the same key to the same ip until they use it\n        if (!mapReuseKey.count(pfrom->addr))\n            pwalletMain->GetKeyFromPool(mapReuseKey[pfrom->addr], true);\n\n        // Send back approval of order and pubkey to use\n        CScript scriptPubKey;\n        scriptPubKey << mapReuseKey[pfrom->addr] << OP_CHECKSIG;\n        pfrom->PushMessage(\"reply\", hashReply, (int)0, scriptPubKey);\n    }\n\n\n    else if (strCommand == \"reply\")\n    {\n        uint256 hashReply;\n        vRecv >> hashReply;\n\n        CRequestTracker tracker;\n        {\n            LOCK(pfrom->cs_mapRequests);\n            map<uint256, CRequestTracker>::iterator mi = pfrom->mapRequests.find(hashReply);\n            if (mi != pfrom->mapRequests.end())\n            {\n                tracker = (*mi).second;\n                pfrom->mapRequests.erase(mi);\n            }\n        }\n        if (!tracker.IsNull())\n            tracker.fn(tracker.param1, vRecv);\n    }\n\n\n    else if (strCommand == \"ping\")\n    {\n        if (pfrom->nVersion > BIP0031_VERSION)\n        {\n            uint64_t nonce = 0;\n            vRecv >> nonce;\n            // Echo the message back with the nonce. This allows for two useful features:\n            //\n            // 1) A remote node can quickly check if the connection is operational\n            // 2) Remote nodes can measure the latency of the network thread. If this node\n            //    is overloaded it won't respond to pings quickly and the remote node can\n            //    avoid sending us more work, like chain download requests.\n            //\n            // The nonce stops the remote getting confused between different pings: without\n            // it, if the remote node sends a ping once per second and this node takes 5\n            // seconds to respond to each, the 5th ping the remote sends would appear to\n            // return very quickly.\n            pfrom->PushMessage(\"pong\", nonce);\n        }\n    }\n\n\n    else if (strCommand == \"alert\")\n    {\n        CAlert alert;\n        vRecv >> alert;\n\n        uint256 alertHash = alert.GetHash();\n        if (pfrom->setKnown.count(alertHash) == 0)\n        {\n            if (alert.ProcessAlert())\n            {\n                // Relay\n                pfrom->setKnown.insert(alertHash);\n                {\n                    LOCK(cs_vNodes);\n                    BOOST_FOREACH(CNode* pnode, vNodes)\n                        alert.RelayTo(pnode);\n                }\n            }\n            else {\n                // Small DoS penalty so peers that send us lots of\n                // duplicate/expired/invalid-signature/whatever alerts\n                // eventually get banned.\n                // This isn't a Misbehaving(100) (immediate ban) because the\n                // peer might be an older or different implementation with\n                // a different signature key, etc.\n                pfrom->Misbehaving(10);\n            }\n        }\n    }\n\n\n    else\n    {\n        // Ignore unknown commands for extensibility\n    }\n\n\n    // Update the last seen time for this node's address\n    if (pfrom->fNetworkNode)\n        if (strCommand == \"version\" || strCommand == \"addr\" || strCommand == \"inv\" || strCommand == \"getdata\" || strCommand == \"ping\")\n            AddressCurrentlyConnected(pfrom->addr);\n\n\n    return true;\n}"
  },
  {
    "function_name": "AlreadyHave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "3016-3038",
    "snippet": "bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;",
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "map<uint256, CBlock*> mapOrphanBlocks;",
      "map<uint256, CTransaction> mapOrphanTransactions;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapOrphanBlocks.count",
          "args": [
            "inv.hash"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.ContainsTx",
          "args": [
            "inv.hash"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "ContainsTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "230-234",
          "snippet": "bool CTxDB::ContainsTx(uint256 hash)\n{\n    assert(!fClient);\n    return Exists(make_pair(string(\"tx\"), hash));\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ContainsTx(uint256 hash)\n  {\n      assert(!fClient);\n      return Exists(make_pair(string(\"tx\"), hash));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.exists",
          "args": [
            "inv.hash"
          ],
          "line": 3025
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "mempool.cs"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nmap<uint256, CBlockIndex*> mapBlockIndex;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmap<uint256, CTransaction> mapOrphanTransactions;\n\nbool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n{\n    switch (inv.type)\n    {\n    case MSG_TX:\n        {\n        bool txInMap = false;\n            {\n            LOCK(mempool.cs);\n            txInMap = (mempool.exists(inv.hash));\n            }\n        return txInMap ||\n               mapOrphanTransactions.count(inv.hash) ||\n               txdb.ContainsTx(inv.hash);\n        }\n\n    case MSG_BLOCK:\n        return mapBlockIndex.count(inv.hash) ||\n               mapOrphanBlocks.count(inv.hash);\n    }\n    // Don't know what it is, just say we already got one\n    return true;\n}"
  },
  {
    "function_name": "GetWarnings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2956-3001",
    "snippet": "string GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "extern map<uint256, CAlert> mapAlerts;",
      "extern CCriticalSection cs_mapAlerts;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!\"GetWarnings() : invalid parameter\""
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alert.AppliesToMe",
          "args": [],
          "line": 2985
        },
        "resolved": true,
        "details": {
          "function_name": "AppliesToMe",
          "container": "CAlert",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/alert.cpp",
          "lines": "124-127",
          "snippet": "bool CAlert::AppliesToMe() const\n{\n    return AppliesTo(PROTOCOL_VERSION, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<std::string>()));\n}",
          "includes": [
            "#include \"ui_interface.h\"",
            "#include \"sync.h\"",
            "#include \"net.h\"",
            "#include \"key.h\"",
            "#include \"alert.h\"",
            "#include <map>",
            "#include <boost/foreach.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include <boost/algorithm/string/classification.hpp>",
            "#include <algorithm>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ui_interface.h\"\n#include \"sync.h\"\n#include \"net.h\"\n#include \"key.h\"\n#include \"alert.h\"\n#include <map>\n#include <boost/foreach.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include <boost/algorithm/string/classification.hpp>\n#include <algorithm>\n\nCAlert {\n  bool CAlert::AppliesToMe() const\n  {\n      return AppliesTo(PROTOCOL_VERSION, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<std::string>()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_mapAlerts"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\""
          ],
          "line": 2976
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-testsafemode\""
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nextern map<uint256, CAlert> mapAlerts;\nextern CCriticalSection cs_mapAlerts;\n\nstring GetWarnings(string strFor)\n{\n    int nPriority = 0;\n    string strStatusBar;\n    string strRPC;\n\n    if (GetBoolArg(\"-testsafemode\"))\n        strRPC = \"test\";\n\n    // Misc warnings like out of disk space and clock is wrong\n    if (strMiscWarning != \"\")\n    {\n        nPriority = 1000;\n        strStatusBar = strMiscWarning;\n    }\n\n    // if detected invalid checkpoint enter safe mode\n    if (Checkpoints::hashInvalidCheckpoint != 0)\n    {\n        nPriority = 3000;\n        strStatusBar = strRPC = _(\"WARNING: Invalid checkpoint found! Displayed transactions may not be correct! You may need to upgrade, or notify developers.\");\n    }\n\n    // Alerts\n    {\n        LOCK(cs_mapAlerts);\n        BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n        {\n            const CAlert& alert = item.second;\n            if (alert.AppliesToMe() && alert.nPriority > nPriority)\n            {\n                nPriority = alert.nPriority;\n                strStatusBar = alert.strStatusBar;\n                if (nPriority > 1000)\n                    strRPC = strStatusBar;\n            }\n        }\n    }\n\n    if (strFor == \"statusbar\")\n        return strStatusBar;\n    else if (strFor == \"rpc\")\n        return strRPC;\n    assert(!\"GetWarnings() : invalid parameter\");\n    return \"error\";\n}"
  },
  {
    "function_name": "LoadExternalBlockFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2888-2946",
    "snippet": "bool LoadExternalBlockFile(FILE* fileIn)\n{\n    int64_t nStart = GetTimeMillis();\n\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n    return nLoaded > 0;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CCriticalSection cs_main;",
      "unsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\"",
            "nLoaded",
            "GetTimeMillis() - nStart"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTimeMillis",
          "args": [],
          "line": 2944
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s() : Deserialize or I/O error caught during load\\n\"",
            "__PRETTY_FUNCTION__"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ProcessBlock",
          "args": [
            "NULL",
            "&block"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "ProcessBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2428-2512",
          "snippet": "bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "set<pair<COutPoint, unsigned int> > setStakeSeen;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexBest = NULL;",
            "map<uint256, CBlock*> mapOrphanBlocks;",
            "multimap<uint256, CBlock*> mapOrphanBlocksByPrev;",
            "set<pair<COutPoint, unsigned int> > setStakeSeenOrphan;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "blkdat",
            "nPos",
            "SEEK_SET"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "nFind",
            "pchMessageStart",
            "sizeof(pchMessageStart)"
          ],
          "line": 2912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "pchData",
            "pchMessageStart[0]",
            "nRead+1-sizeof(pchMessageStart)"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "pchData",
            "1",
            "sizeof(pchData)",
            "blkdat"
          ],
          "line": 2903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fseek",
          "args": [
            "blkdat",
            "nPos",
            "SEEK_SET"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdat.good",
          "args": [],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "good",
          "container": "CAutoFile",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "1078-1078",
          "snippet": "bool good() const            { return state == 0; }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCAutoFile {\n  bool good() const            { return state == 0; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_main"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nunsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };\n\nbool LoadExternalBlockFile(FILE* fileIn)\n{\n    int64_t nStart = GetTimeMillis();\n\n    int nLoaded = 0;\n    {\n        LOCK(cs_main);\n        try {\n            CAutoFile blkdat(fileIn, SER_DISK, CLIENT_VERSION);\n            unsigned int nPos = 0;\n            while (nPos != (unsigned int)-1 && blkdat.good() && !fRequestShutdown)\n            {\n                unsigned char pchData[65536];\n                do {\n                    fseek(blkdat, nPos, SEEK_SET);\n                    int nRead = fread(pchData, 1, sizeof(pchData), blkdat);\n                    if (nRead <= 8)\n                    {\n                        nPos = (unsigned int)-1;\n                        break;\n                    }\n                    void* nFind = memchr(pchData, pchMessageStart[0], nRead+1-sizeof(pchMessageStart));\n                    if (nFind)\n                    {\n                        if (memcmp(nFind, pchMessageStart, sizeof(pchMessageStart))==0)\n                        {\n                            nPos += ((unsigned char*)nFind - pchData) + sizeof(pchMessageStart);\n                            break;\n                        }\n                        nPos += ((unsigned char*)nFind - pchData) + 1;\n                    }\n                    else\n                        nPos += sizeof(pchData) - sizeof(pchMessageStart) + 1;\n                } while(!fRequestShutdown);\n                if (nPos == (unsigned int)-1)\n                    break;\n                fseek(blkdat, nPos, SEEK_SET);\n                unsigned int nSize;\n                blkdat >> nSize;\n                if (nSize > 0 && nSize <= MAX_BLOCK_SIZE)\n                {\n                    CBlock block;\n                    blkdat >> block;\n                    if (ProcessBlock(NULL,&block))\n                    {\n                        nLoaded++;\n                        nPos += 4 + nSize;\n                    }\n                }\n            }\n        }\n        catch (std::exception &e) {\n            printf(\"%s() : Deserialize or I/O error caught during load\\n\",\n                   __PRETTY_FUNCTION__);\n        }\n    }\n    printf(\"Loaded %i blocks from external file in %\"PRId64\"ms\\n\", nLoaded, GetTimeMillis() - nStart);\n    return nLoaded > 0;\n}"
  },
  {
    "function_name": "PrintBlockTree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2814-2886",
    "snippet": "void PrintBlockTree()\n{\n    // pre-compute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %08x  %s  mint %7s  tx %\"PRIszu\"\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().c_str(),\n            block.nBits,\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            FormatMoney(pindex->nMint).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main time-chain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "CBlockIndex* pindexGenesisBlock = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vStack.push_back",
          "args": [
            "make_pair(nCol+i, vNext[i])"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "nCol+i",
            "vNext[i]"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vNext.size",
          "args": [],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "vNext[0]",
            "vNext[i]"
          ],
          "line": 2877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintWallets",
          "args": [
            "block"
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "PrintWallets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "179-183",
          "snippet": "void static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%d (%u,%u) %s  %08x  %s  mint %7s  tx %\"PRIszu\"\"",
            "pindex->nHeight",
            "pindex->nFile",
            "pindex->nBlockPos",
            "block.GetHash().ToString().c_str()",
            "block.nBits",
            "DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str()",
            "FormatMoney(pindex->nMint).c_str()",
            "block.vtx.size()"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "pindex->nMint"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 2865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "\"%x %H:%M:%S\"",
            "block.GetBlockTime()"
          ],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "376-383",
          "snippet": "inline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.GetBlockTime",
          "args": [],
          "line": 2865
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.GetHash",
          "args": [],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindex"
          ],
          "line": 2858
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "303-308",
          "snippet": "bool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(COutPoint prevout)\n  {\n      CTxDB txdb(\"r\");\n      CTxIndex txindex;\n      return ReadFromDisk(txdb, prevout, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"| \""
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"|\\n\""
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"| \""
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"|\\\\\\n\""
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"| \""
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vStack.pop_back",
          "args": [],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vStack.back",
          "args": [],
          "line": 2834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vStack.back",
          "args": [],
          "line": 2833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vStack.empty",
          "args": [],
          "line": 2831
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vStack.push_back",
          "args": [
            "make_pair(0, pindexGenesisBlock)"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "0",
            "pindexGenesisBlock"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapNext[pindex->pprev].push_back",
          "args": [
            "pindex"
          ],
          "line": 2821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.begin",
          "args": [],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\n\nvoid PrintBlockTree()\n{\n    // pre-compute tree structure\n    map<CBlockIndex*, vector<CBlockIndex*> > mapNext;\n    for (map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.begin(); mi != mapBlockIndex.end(); ++mi)\n    {\n        CBlockIndex* pindex = (*mi).second;\n        mapNext[pindex->pprev].push_back(pindex);\n        // test\n        //while (rand() % 3 == 0)\n        //    mapNext[pindex->pprev].push_back(pindex);\n    }\n\n    vector<pair<int, CBlockIndex*> > vStack;\n    vStack.push_back(make_pair(0, pindexGenesisBlock));\n\n    int nPrevCol = 0;\n    while (!vStack.empty())\n    {\n        int nCol = vStack.back().first;\n        CBlockIndex* pindex = vStack.back().second;\n        vStack.pop_back();\n\n        // print split or gap\n        if (nCol > nPrevCol)\n        {\n            for (int i = 0; i < nCol-1; i++)\n                printf(\"| \");\n            printf(\"|\\\\\\n\");\n        }\n        else if (nCol < nPrevCol)\n        {\n            for (int i = 0; i < nCol; i++)\n                printf(\"| \");\n            printf(\"|\\n\");\n       }\n        nPrevCol = nCol;\n\n        // print columns\n        for (int i = 0; i < nCol; i++)\n            printf(\"| \");\n\n        // print item\n        CBlock block;\n        block.ReadFromDisk(pindex);\n        printf(\"%d (%u,%u) %s  %08x  %s  mint %7s  tx %\"PRIszu\"\",\n            pindex->nHeight,\n            pindex->nFile,\n            pindex->nBlockPos,\n            block.GetHash().ToString().c_str(),\n            block.nBits,\n            DateTimeStrFormat(\"%x %H:%M:%S\", block.GetBlockTime()).c_str(),\n            FormatMoney(pindex->nMint).c_str(),\n            block.vtx.size());\n\n        PrintWallets(block);\n\n        // put the main time-chain first\n        vector<CBlockIndex*>& vNext = mapNext[pindex];\n        for (unsigned int i = 0; i < vNext.size(); i++)\n        {\n            if (vNext[i]->pnext)\n            {\n                swap(vNext[0], vNext[i]);\n                break;\n            }\n        }\n\n        // iterate children\n        for (unsigned int i = 0; i < vNext.size(); i++)\n            vStack.push_back(make_pair(nCol+i, vNext[i]));\n    }\n}"
  },
  {
    "function_name": "LoadBlockIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2657-2810",
    "snippet": "bool LoadBlockIndex(bool fAllowNew) {\n\n    if(fTestNet) {\n        pchMessageStart[0] = 0xfd;\n        pchMessageStart[1] = 0xf2;\n        pchMessageStart[2] = 0xf0;\n        pchMessageStart[3] = 0xdf;\n\n        bnProofOfStakeLimit = bnProofOfStakeLimitTestNet;\n        bnProofOfWorkLimit  = bnProofOfWorkLimitTestNet;\n\n        /* Positive time weight after 20 minutes */\n        nStakeMinAge = 20 * 60;\n        /* Full time weight at 20 hours (+20 minutes) */\n        nStakeMaxAgeOne = 20 * 60 * 60;\n        nStakeMaxAgeTwo = 20 * 60 * 60;\n        /* Interval of 1 minute between stake modifiers */\n        nModifierInterval = 60;\n        /* Coin base and stake maturity */\n        nCoinbaseMaturity = 10;\n        /* NeoScrypt enabled always */\n        fNeoScrypt = true;\n    }\n\n    //\n    // Init with genesis block\n    //\n    CTxDB txdb(\"cr+\");\n    if(!txdb.LoadBlockIndex())\n        return false;\n\n    // Init with genesis block\n    if(mapBlockIndex.empty()) {\n\n        if(!fAllowNew) return false;\n\n        CTransaction txNew;\n        CBlock block;\n\n        if(!fTestNet) {\n\n            /* The Halcyon livenet genesis block */\n\n            const char* pszTimestamp = \"The ancient Greek myth of Halcyon is a tender story of love and commitment\";\n            txNew.nTime = 1408182502;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1408182502;\n            block.nBits    = bnProofOfWorkLimit.GetCompact();\n            block.nNonce   = 899198;\n\n        } else {\n\n/* The Halcyon testnet genesis block:\n * CBlock(hash=9a9e20c1cc8dc1297fc4842e1b358a576db6c985f6dc4a6b8cf16f36f69aa54d, ver=1, hashPrevBlock=0000000000000000000000000000000000000000000000000000000000000000, hashMerkleRoot=bef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362, nTime=1418677200, nBits=1f00ffff, nNonce=28699, vtx=1, vchBlockSig=)\n *   Coinbase(hash=bef44c6f33, nTime=1418677200, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n *     CTxIn(COutPoint(0000000000, 4294967295), coinbase 00012a4c6d546865207465726d2048616c63796f6e206f726967696e617465732066726f6d2074686520477265656b206d797468206f6620416c63796f6e6520616e64206d65616e7320676f6c64656e206f72206d61726b656420627920706561636520616e642070726f73706572697479)\n *     CTxOut(empty)\n *   vMerkleTree: bef44c6f33 */\n\n            const char* pszTimestamp = \"The term Halcyon originates from the Greek myth of Alcyone and means golden or marked by peace and prosperity\";\n            txNew.nTime = 1418677200;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1418677200;\n            block.nBits    = bnProofOfWorkLimitTestNet.GetCompact();\n            block.nNonce   = 28699;\n\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n\n        if(!fTestNet) assert(block.hashMerkleRoot ==\n          uint256(\"0xb761dad6c210bae0a6c1abeec2d7cb83624e34702d3912acba8bef58a932183b\"));\n        else assert(block.hashMerkleRoot ==\n          uint256(\"0xbef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362\"));\n\n        // If no match on genesis block hash, then generate one\n        if(false && ((fTestNet && (block.GetHash() != hashGenesisBlockTestNet)) ||\n                    (!fTestNet && (block.GetHash() != hashGenesisBlock)))) {\n\n            printf(\"Genesis block mining...\\n\");\n\n            uint profile = 0x0;\n            uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &block.nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) break;\n                if(!(block.nNonce & 0xFFF))\n                  printf(\"nonce %08X: hash = %s (target = %s)\\n\",\n                    block.nNonce, hash.ToString().c_str(),\n                    hashTarget.ToString().c_str());\n                ++block.nNonce;\n                if(!block.nNonce) {\n                    printf(\"nonce limit reached, incrementing time\\n\");\n                    ++block.nTime;\n                }\n            }\n            printf(\"block.nTime = %u \\n\", block.nTime);\n            printf(\"block.nNonce = %u \\n\", block.nNonce);\n            printf(\"block.GetHash = %s\\n\", block.GetHash().ToString().c_str());\n            printf(\"block.GetHashPoW = %s\\n\", block.GetHashPoW().ToString().c_str());\n        }\n\n        block.print();\n        if(!fTestNet) assert(block.GetHash() == hashGenesisBlock);\n        else assert(block.GetHash() == hashGenesisBlockTestNet);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos, 0))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n\n        // ppcoin: initialize synchronized checkpoint\n        if (!Checkpoints::WriteSyncCheckpoint((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)))\n            return error(\"LoadBlockIndex() : failed to init sync checkpoint\");\n    }\n\n    string strPubKey = \"\";\n\n    // if checkpoint master key changed must reset sync-checkpoint\n    if (!txdb.ReadCheckpointPubKey(strPubKey) || strPubKey != CSyncCheckpoint::strMasterPubKey)\n    {\n        // write checkpoint master key to db\n        txdb.TxnBegin();\n        if (!txdb.WriteCheckpointPubKey(CSyncCheckpoint::strMasterPubKey))\n            return error(\"LoadBlockIndex() : failed to write new checkpoint master key to db\");\n        if (!txdb.TxnCommit())\n            return error(\"LoadBlockIndex() : failed to commit new checkpoint master key to db\");\n        if ((!fTestNet) && !Checkpoints::ResetSyncCheckpoint())\n            return error(\"LoadBlockIndex() : failed to reset sync-checkpoint\");\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "uint nStakeMinAge = 60 * 60 * 12;",
      "uint nStakeMaxAgeOne = 4294362496;",
      "uint nStakeMaxAgeTwo = 7 * 24 * 60 * 60;",
      "uint nModifierInterval = 10 * 60;",
      "int nCoinbaseMaturity = 50;",
      "unsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"LoadBlockIndex() : failed to reset sync-checkpoint\""
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::ResetSyncCheckpoint",
          "args": [],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "ResetSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "256-294",
          "snippet": "bool ResetSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        const uint256& hash = mapCheckpoints.rbegin()->second;\n        if (mapBlockIndex.count(hash) && !mapBlockIndex[hash]->IsInMainChain())\n        {\n            // checkpoint block accepted but not yet in main chain\n            printf(\"ResetSyncCheckpoint: SetBestChain to hardened checkpoint %s\\n\", hash.ToString().c_str());\n            CTxDB txdb;\n            CBlock block;\n            if (!block.ReadFromDisk(mapBlockIndex[hash]))\n                return error(\"ResetSyncCheckpoint: ReadFromDisk failed for hardened checkpoint %s\", hash.ToString().c_str());\n            if (!block.SetBestChain(txdb, mapBlockIndex[hash]))\n            {\n                return error(\"ResetSyncCheckpoint: SetBestChain failed for hardened checkpoint %s\", hash.ToString().c_str());\n            }\n        }\n        else if(!mapBlockIndex.count(hash))\n        {\n            // checkpoint block not yet accepted\n            hashPendingCheckpoint = hash;\n            checkpointMessagePending.SetNull();\n            printf(\"ResetSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashPendingCheckpoint.ToString().c_str());\n        }\n\n        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, mapCheckpoints)\n        {\n            const uint256& hash = i.second;\n            if (mapBlockIndex.count(hash) && mapBlockIndex[hash]->IsInMainChain())\n            {\n                if (!WriteSyncCheckpoint(hash))\n                    return error(\"ResetSyncCheckpoint: failed to write sync checkpoint %s\", hash.ToString().c_str());\n                printf(\"ResetSyncCheckpoint: sync-checkpoint reset to %s\\n\", hashSyncCheckpoint.ToString().c_str());\n                return true;\n            }\n        }\n\n        return false;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool ResetSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        const uint256& hash = mapCheckpoints.rbegin()->second;\n        if (mapBlockIndex.count(hash) && !mapBlockIndex[hash]->IsInMainChain())\n        {\n            // checkpoint block accepted but not yet in main chain\n            printf(\"ResetSyncCheckpoint: SetBestChain to hardened checkpoint %s\\n\", hash.ToString().c_str());\n            CTxDB txdb;\n            CBlock block;\n            if (!block.ReadFromDisk(mapBlockIndex[hash]))\n                return error(\"ResetSyncCheckpoint: ReadFromDisk failed for hardened checkpoint %s\", hash.ToString().c_str());\n            if (!block.SetBestChain(txdb, mapBlockIndex[hash]))\n            {\n                return error(\"ResetSyncCheckpoint: SetBestChain failed for hardened checkpoint %s\", hash.ToString().c_str());\n            }\n        }\n        else if(!mapBlockIndex.count(hash))\n        {\n            // checkpoint block not yet accepted\n            hashPendingCheckpoint = hash;\n            checkpointMessagePending.SetNull();\n            printf(\"ResetSyncCheckpoint: pending for sync-checkpoint %s\\n\", hashPendingCheckpoint.ToString().c_str());\n        }\n\n        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, mapCheckpoints)\n        {\n            const uint256& hash = i.second;\n            if (mapBlockIndex.count(hash) && mapBlockIndex[hash]->IsInMainChain())\n            {\n                if (!WriteSyncCheckpoint(hash))\n                    return error(\"ResetSyncCheckpoint: failed to write sync checkpoint %s\", hash.ToString().c_str());\n                printf(\"ResetSyncCheckpoint: sync-checkpoint reset to %s\\n\", hashSyncCheckpoint.ToString().c_str());\n                return true;\n            }\n        }\n\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnCommit",
          "args": [],
          "line": 2803
        },
        "resolved": true,
        "details": {
          "function_name": "TxnCommit",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "282-289",
          "snippet": "bool TxnCommit()\n    {\n        if (!pdb || !activeTxn)\n            return false;\n        int ret = activeTxn->commit(0);\n        activeTxn = NULL;\n        return (ret == 0);\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnCommit()\n      {\n          if (!pdb || !activeTxn)\n              return false;\n          int ret = activeTxn->commit(0);\n          activeTxn = NULL;\n          return (ret == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteCheckpointPubKey",
          "args": [
            "CSyncCheckpoint::strMasterPubKey"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "WriteCheckpointPubKey",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "302-305",
          "snippet": "bool CTxDB::WriteCheckpointPubKey(const string& strPubKey)\n{\n    return Write(string(\"strCheckpointPubKey\"), strPubKey);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteCheckpointPubKey(const string& strPubKey)\n  {\n      return Write(string(\"strCheckpointPubKey\"), strPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnBegin",
          "args": [],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "TxnBegin",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "271-280",
          "snippet": "bool TxnBegin()\n    {\n        if (!pdb || activeTxn)\n            return false;\n        DbTxn* ptxn = bitdb.TxnBegin();\n        if (!ptxn)\n            return false;\n        activeTxn = ptxn;\n        return true;\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnBegin()\n      {\n          if (!pdb || activeTxn)\n              return false;\n          DbTxn* ptxn = bitdb.TxnBegin();\n          if (!ptxn)\n              return false;\n          activeTxn = ptxn;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.ReadCheckpointPubKey",
          "args": [
            "strPubKey"
          ],
          "line": 2797
        },
        "resolved": true,
        "details": {
          "function_name": "ReadCheckpointPubKey",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "297-300",
          "snippet": "bool CTxDB::ReadCheckpointPubKey(string& strPubKey)\n{\n    return Read(string(\"strCheckpointPubKey\"), strPubKey);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadCheckpointPubKey(string& strPubKey)\n  {\n      return Read(string(\"strCheckpointPubKey\"), strPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::WriteSyncCheckpoint",
          "args": [
            "(!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "WriteSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "144-158",
          "snippet": "bool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool WriteSyncCheckpoint(const uint256& hashCheckpoint)\n    {\n        CTxDB txdb;\n        txdb.TxnBegin();\n        if (!txdb.WriteSyncCheckpoint(hashCheckpoint))\n        {\n            txdb.TxnAbort();\n            return error(\"WriteSyncCheckpoint(): failed to write to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n        }\n        if (!txdb.TxnCommit())\n            return error(\"WriteSyncCheckpoint(): failed to commit to db sync checkpoint %s\", hashCheckpoint.ToString().c_str());\n\n        Checkpoints::hashSyncCheckpoint = hashCheckpoint;\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "block.AddToBlockIndex",
          "args": [
            "nFile",
            "nBlockPos",
            "0"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "AddToBlockIndex",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2028-2096",
          "snippet": "bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    pindexNew->phashBlock = &hash;\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n\n    // ppcoin: compute chain trust score\n    pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n\n    // ppcoin: compute stake entropy bit for stake modifier\n    if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n        return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n\n    // ppcoin: record proof-of-stake hash value\n    pindexNew->hashProofOfStake = hashProofOfStake;\n\n    // ppcoin: compute stake modifier\n    uint64_t nStakeModifier = 0;\n    bool fGeneratedStakeModifier = false;\n    if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n        return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n    pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n    pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n    if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n        return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n\n    // Add to mapBlockIndex\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    if (pindexNew->IsProofOfStake())\n        setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n    pindexNew->phashBlock = &((*mi).first);\n\n    // Write to disk block index\n    CTxDB txdb;\n    if (!txdb.TxnBegin())\n        return false;\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->nChainTrust > nBestChainTrust)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    uiInterface.NotifyBlocksChanged();\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "set<pair<COutPoint, unsigned int> > setStakeSeen;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "uint256 nBestChainTrust = 0;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nuint256 nBestChainTrust = 0;\nCBlockIndex* pindexBest = NULL;\n\nCBlock {\n  bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n  {\n      // Check for duplicate\n      uint256 hash = GetHash();\n      if (mapBlockIndex.count(hash))\n          return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n  \n      // Construct new block index object\n      CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n      if (!pindexNew)\n          return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n      pindexNew->phashBlock = &hash;\n      map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n      if (miPrev != mapBlockIndex.end())\n      {\n          pindexNew->pprev = (*miPrev).second;\n          pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n      }\n  \n      // ppcoin: compute chain trust score\n      pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n  \n      // ppcoin: compute stake entropy bit for stake modifier\n      if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n          return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n  \n      // ppcoin: record proof-of-stake hash value\n      pindexNew->hashProofOfStake = hashProofOfStake;\n  \n      // ppcoin: compute stake modifier\n      uint64_t nStakeModifier = 0;\n      bool fGeneratedStakeModifier = false;\n      if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n          return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n      pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n      pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n      if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n          return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n  \n      // Add to mapBlockIndex\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n      if (pindexNew->IsProofOfStake())\n          setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n      pindexNew->phashBlock = &((*mi).first);\n  \n      // Write to disk block index\n      CTxDB txdb;\n      if (!txdb.TxnBegin())\n          return false;\n      txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n      if (!txdb.TxnCommit())\n          return false;\n  \n      // New best\n      if (pindexNew->nChainTrust > nBestChainTrust)\n          if (!SetBestChain(txdb, pindexNew))\n              return false;\n  \n      if (pindexNew == pindexBest)\n      {\n          // Notify UI to display prev block's coinbase if it was ours\n          static uint256 hashPrevBestCoinBase;\n          UpdatedTransaction(hashPrevBestCoinBase);\n          hashPrevBestCoinBase = vtx[0].GetHash();\n      }\n  \n      uiInterface.NotifyBlocksChanged();\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.WriteToDisk",
          "args": [
            "nFile",
            "nBlockPos"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "WriteToDisk",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1071-1095",
          "snippet": "bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n    {\n        // Open history file to append\n        CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n        if (!fileout)\n            return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n\n        // Write index header\n        unsigned int nSize = fileout.GetSerializeSize(*this);\n        fileout << FLATDATA(pchMessageStart) << nSize;\n\n        // Write block\n        long fileOutPos = ftell(fileout);\n        if (fileOutPos < 0)\n            return error(\"CBlock::WriteToDisk() : ftell failed\");\n        nBlockPosRet = fileOutPos;\n        fileout << *this;\n\n        // Flush stdio buffers and commit to disk before returning\n        fflush(fileout);\n        if(!IsInitialBlockDownload() || !((nBestHeight + 1) % 100))\n          FileCommit(fileout);\n\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n      {\n          // Open history file to append\n          CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n          if (!fileout)\n              return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n  \n          // Write index header\n          unsigned int nSize = fileout.GetSerializeSize(*this);\n          fileout << FLATDATA(pchMessageStart) << nSize;\n  \n          // Write block\n          long fileOutPos = ftell(fileout);\n          if (fileOutPos < 0)\n              return error(\"CBlock::WriteToDisk() : ftell failed\");\n          nBlockPosRet = fileOutPos;\n          fileout << *this;\n  \n          // Flush stdio buffers and commit to disk before returning\n          fflush(fileout);\n          if(!IsInitialBlockDownload() || !((nBestHeight + 1) % 100))\n            FileCommit(fileout);\n  \n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "block.GetHash() == hashGenesisBlockTestNet"
          ],
          "line": 2779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.GetHash",
          "args": [],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "block.GetHash() == hashGenesisBlock"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.print",
          "args": [],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "print",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1529-1532",
          "snippet": "void print() const\n    {\n        printf(\"%s\\n\", ToString().c_str());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  void print() const\n      {\n          printf(\"%s\\n\", ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"block.GetHashPoW = %s\\n\"",
            "block.GetHashPoW().ToString().c_str()"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.GetHashPoW",
          "args": [],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"nonce limit reached, incrementing time\\n\""
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"nonce %08X: hash = %s (target = %s)\\n\"",
            "block.nNonce",
            "hash.ToString().c_str()",
            "hashTarget.ToString().c_str()"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashTarget.ToString",
          "args": [],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "neoscrypt",
          "args": [
            "(uchar *) &block.nVersion",
            "(uchar *) &hash",
            "profile"
          ],
          "line": 2759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "block.nBits"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Genesis block mining...\\n\""
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "block.hashMerkleRoot ==\n          uint256(\"0xbef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362\")"
          ],
          "line": 2745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint256",
          "args": [
            "\"0xbef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362\""
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "setuint256",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "250-276",
          "snippet": "void setuint256(uint256 n)\n    {\n        unsigned char pch[sizeof(n) + 6];\n        unsigned char* p = pch + 4;\n        bool fLeadingZeroes = true;\n        unsigned char* pbegin = (unsigned char*)&n;\n        unsigned char* psrc = pbegin + sizeof(n);\n        while (psrc != pbegin)\n        {\n            unsigned char c = *(--psrc);\n            if (fLeadingZeroes)\n            {\n                if (c == 0)\n                    continue;\n                if (c & 0x80)\n                    *p++ = 0;\n                fLeadingZeroes = false;\n            }\n            *p++ = c;\n        }\n        unsigned int nSize = p - (pch + 4);\n        pch[0] = (nSize >> 24) & 0xff;\n        pch[1] = (nSize >> 16) & 0xff;\n        pch[2] = (nSize >> 8) & 0xff;\n        pch[3] = (nSize >> 0) & 0xff;\n        BN_mpi2bn(pch, p - pch, this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void setuint256(uint256 n)\n      {\n          unsigned char pch[sizeof(n) + 6];\n          unsigned char* p = pch + 4;\n          bool fLeadingZeroes = true;\n          unsigned char* pbegin = (unsigned char*)&n;\n          unsigned char* psrc = pbegin + sizeof(n);\n          while (psrc != pbegin)\n          {\n              unsigned char c = *(--psrc);\n              if (fLeadingZeroes)\n              {\n                  if (c == 0)\n                      continue;\n                  if (c & 0x80)\n                      *p++ = 0;\n                  fLeadingZeroes = false;\n              }\n              *p++ = c;\n          }\n          unsigned int nSize = p - (pch + 4);\n          pch[0] = (nSize >> 24) & 0xff;\n          pch[1] = (nSize >> 16) & 0xff;\n          pch[2] = (nSize >> 8) & 0xff;\n          pch[3] = (nSize >> 0) & 0xff;\n          BN_mpi2bn(pch, p - pch, this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "block.hashMerkleRoot ==\n          uint256(\"0xb761dad6c210bae0a6c1abeec2d7cb83624e34702d3912acba8bef58a932183b\")"
          ],
          "line": 2743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bnProofOfWorkLimitTestNet.GetCompact",
          "args": [],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "GetCompact",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "333-344",
          "snippet": "unsigned int GetCompact() const\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        std::vector<unsigned char> vch(nSize);\n        nSize -= 4;\n        BN_bn2mpi(this, &vch[0]);\n        unsigned int nCompact = nSize << 24;\n        if (nSize >= 1) nCompact |= (vch[4] << 16);\n        if (nSize >= 2) nCompact |= (vch[5] << 8);\n        if (nSize >= 3) nCompact |= (vch[6] << 0);\n        return nCompact;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  unsigned int GetCompact() const\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          std::vector<unsigned char> vch(nSize);\n          nSize -= 4;\n          BN_bn2mpi(this, &vch[0]);\n          unsigned int nCompact = nSize << 24;\n          if (nSize >= 1) nCompact |= (vch[4] << 16);\n          if (nSize >= 2) nCompact |= (vch[5] << 8);\n          if (nSize >= 3) nCompact |= (vch[6] << 0);\n          return nCompact;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.BuildMerkleTree",
          "args": [],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "BuildMerkleTree",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1020-1037",
          "snippet": "uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 BuildMerkleTree() const\n      {\n          vMerkleTree.clear();\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              vMerkleTree.push_back(tx.GetHash());\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              for (int i = 0; i < nSize; i += 2)\n              {\n                  int i2 = std::min(i+1, nSize-1);\n                  vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                             BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n              }\n              j += nSize;\n          }\n          return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.vtx.push_back",
          "args": [
            "txNew"
          ],
          "line": 2729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txNew.vout[0].SetEmpty",
          "args": [],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "SetEmpty",
          "container": "CTxOut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "381-385",
          "snippet": "void SetEmpty()\n    {\n        nValue = 0;\n        scriptPubKey.clear();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxOut {\n  void SetEmpty()\n      {\n          nValue = 0;\n          scriptPubKey.clear();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vector<unsigned char>",
          "args": [
            "(const unsigned char*)pszTimestamp",
            "(const unsigned char*)pszTimestamp + strlen(pszTimestamp)"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pszTimestamp"
          ],
          "line": 2727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "CScriptID",
          "container": "CScriptID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "59-59",
          "snippet": "CScriptID() : uint160(0) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCScriptID {\n  CScriptID() : uint160(0) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txNew.vout.resize",
          "args": [
            "1"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.vtx.push_back",
          "args": [
            "txNew"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vector<unsigned char>",
          "args": [
            "(const unsigned char*)pszTimestamp",
            "(const unsigned char*)pszTimestamp + strlen(pszTimestamp)"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pszTimestamp"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.empty",
          "args": [],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.LoadBlockIndex",
          "args": [],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "LoadBlockIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "327-571",
          "snippet": "bool CTxDB::LoadBlockIndex()\n{\n    if (mapBlockIndex.size() > 0) {\n        // Already loaded once in this session. It can happen during migration\n        // from BDB.\n        return true;\n    }\n    // The block index is an in-memory structure that maps hashes to on-disk\n    // locations where the contents of the block can be found. Here, we scan it\n    // out of the DB and into mapBlockIndex.\n    leveldb::Iterator *iterator = pdb->NewIterator(leveldb::ReadOptions());\n    // Seek to start key.\n    CDataStream ssStartKey(SER_DISK, CLIENT_VERSION);\n    ssStartKey << make_pair(string(\"blockindex\"), uint256(0));\n    iterator->Seek(ssStartKey.str());\n    // Now read each entry.\n    while (iterator->Valid())\n    {\n        // Unpack keys and values.\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.write(iterator->key().data(), iterator->key().size());\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.write(iterator->value().data(), iterator->value().size());\n        string strType;\n        ssKey >> strType;\n        // Did we reach the end of the data to read?\n        if (fRequestShutdown || strType != \"blockindex\")\n            break;\n        CDiskBlockIndex diskindex;\n        ssValue >> diskindex;\n\n        uint256 blockHash = diskindex.GetBlockHash();\n\n        // Construct block index object\n        CBlockIndex* pindexNew    = InsertBlockIndex(blockHash);\n        pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n        pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n        pindexNew->nFile          = diskindex.nFile;\n        pindexNew->nBlockPos      = diskindex.nBlockPos;\n        pindexNew->nHeight        = diskindex.nHeight;\n        pindexNew->nMint          = diskindex.nMint;\n        pindexNew->nMoneySupply   = diskindex.nMoneySupply;\n        pindexNew->nFlags         = diskindex.nFlags;\n        pindexNew->nStakeModifier = diskindex.nStakeModifier;\n        pindexNew->prevoutStake   = diskindex.prevoutStake;\n        pindexNew->nStakeTime     = diskindex.nStakeTime;\n        pindexNew->hashProofOfStake = diskindex.hashProofOfStake;\n        pindexNew->nVersion       = diskindex.nVersion;\n        pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n        pindexNew->nTime          = diskindex.nTime;\n        pindexNew->nBits          = diskindex.nBits;\n        pindexNew->nNonce         = diskindex.nNonce;\n\n        // Watch for genesis block\n        if (pindexGenesisBlock == NULL && blockHash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n            pindexGenesisBlock = pindexNew;\n\n        if (!pindexNew->CheckIndex()) {\n            delete iterator;\n            return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n        }\n\n        // NovaCoin: build setStakeSeen\n        if (pindexNew->IsProofOfStake())\n            setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n\n        iterator->Next();\n    }\n    delete iterator;\n\n    if (fRequestShutdown)\n        return true;\n\n    // Calculate nChainTrust\n    vector<pair<int, CBlockIndex*> > vSortedByHeight;\n    vSortedByHeight.reserve(mapBlockIndex.size());\n    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n    {\n        CBlockIndex* pindex = item.second;\n        vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n    }\n    sort(vSortedByHeight.begin(), vSortedByHeight.end());\n    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n    {\n        CBlockIndex* pindex = item.second;\n        pindex->nChainTrust = (pindex->pprev ? pindex->pprev->nChainTrust : 0) + pindex->GetBlockTrust();\n        // NovaCoin: calculate stake modifier checksum\n        pindex->nStakeModifierChecksum = GetStakeModifierChecksum(pindex);\n        if (!CheckStakeModifierCheckpoints(pindex->nHeight, pindex->nStakeModifierChecksum))\n            return error(\"CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindex->nHeight, pindex->nStakeModifier);\n    }\n\n    // Load hashBestChain pointer to end of best chain\n    if (!ReadHashBestChain(hashBestChain))\n    {\n        if (pindexGenesisBlock == NULL)\n            return true;\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n    }\n    if (!mapBlockIndex.count(hashBestChain))\n        return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n    pindexBest = mapBlockIndex[hashBestChain];\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexBest->nChainTrust;\n\n    printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, CBigNum(nBestChainTrust).ToString().c_str(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    // NovaCoin: load hashSyncCheckpoint\n    if (!ReadSyncCheckpoint(Checkpoints::hashSyncCheckpoint))\n        return error(\"CTxDB::LoadBlockIndex() : hashSyncCheckpoint not loaded\");\n    printf(\"LoadBlockIndex(): synchronized checkpoint %s\\n\", Checkpoints::hashSyncCheckpoint.ToString().c_str());\n\n    // Load bnBestInvalidTrust, OK if it doesn't exist\n    CBigNum bnBestInvalidTrust;\n    ReadBestInvalidTrust(bnBestInvalidTrust);\n    nBestInvalidTrust = bnBestInvalidTrust.getuint256();\n\n    // Verify blocks in the best chain\n    int nCheckLevel = GetArg(\"-checklevel\", 1);\n    int nCheckDepth = GetArg( \"-checkblocks\", 500);\n    if (nCheckDepth == 0)\n        nCheckDepth = 1000000000; // suffices until the year 19000\n    if (nCheckDepth > nBestHeight)\n        nCheckDepth = nBestHeight;\n    printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n    CBlockIndex* pindexFork = NULL;\n    map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n    for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n    {\n        if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n            break;\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        // check level 1: verify block validity\n        if((nCheckLevel > 0) && !block.CheckBlock()) {\n            printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n            pindexFork = pindex->pprev;\n        }\n        // check level 2: verify transaction index validity\n        if (nCheckLevel>1)\n        {\n            pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n            mapBlockPos[pos] = pindex;\n            BOOST_FOREACH(const CTransaction &tx, block.vtx)\n            {\n                uint256 hashTx = tx.GetHash();\n                CTxIndex txindex;\n                if (ReadTxIndex(hashTx, txindex))\n                {\n                    // check level 3: checker transaction hashes\n                    if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                    {\n                        // either an error or a duplicate transaction\n                        CTransaction txFound;\n                        if (!txFound.ReadFromDisk(txindex.pos))\n                        {\n                            printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n                            pindexFork = pindex->pprev;\n                        }\n                        else\n                            if (txFound.GetHash() != hashTx) // not a duplicate tx\n                            {\n                                printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n                                pindexFork = pindex->pprev;\n                            }\n                    }\n                    // check level 4: check whether spent txouts were spent within the main chain\n                    unsigned int nOutput = 0;\n                    if (nCheckLevel>3)\n                    {\n                        BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n                        {\n                            if (!txpos.IsNull())\n                            {\n                                pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n                                if (!mapBlockPos.count(posFind))\n                                {\n                                    printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                    pindexFork = pindex->pprev;\n                                }\n                                // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                if (nCheckLevel>5)\n                                {\n                                    CTransaction txSpend;\n                                    if (!txSpend.ReadFromDisk(txpos))\n                                    {\n                                        printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else if (!txSpend.CheckTransaction())\n                                    {\n                                        printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n                                        pindexFork = pindex->pprev;\n                                    }\n                                    else\n                                    {\n                                        bool fFound = false;\n                                        BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n                                            if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n                                                fFound = true;\n                                        if (!fFound)\n                                        {\n                                            printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n                                            pindexFork = pindex->pprev;\n                                        }\n                                    }\n                                }\n                            }\n                            nOutput++;\n                        }\n                    }\n                }\n                // check level 5: check whether all prevouts are marked spent\n                if (nCheckLevel>4)\n                {\n                     BOOST_FOREACH(const CTxIn &txin, tx.vin)\n                     {\n                          CTxIndex txindex;\n                          if (ReadTxIndex(txin.prevout.hash, txindex))\n                              if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n                              {\n                                  printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n                                  pindexFork = pindex->pprev;\n                              }\n                     }\n                }\n            }\n        }\n    }\n    if (pindexFork && !fRequestShutdown)\n    {\n        // Reorg back to the fork\n        printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n        CBlock block;\n        if (!block.ReadFromDisk(pindexFork))\n            return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n        CTxDB txdb;\n        block.SetBestChain(txdb, pindexFork);\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [
            "leveldb::DB *txdb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nleveldb::DB *txdb;\n\nCTxDB {\n  bool CTxDB::LoadBlockIndex()\n  {\n      if (mapBlockIndex.size() > 0) {\n          // Already loaded once in this session. It can happen during migration\n          // from BDB.\n          return true;\n      }\n      // The block index is an in-memory structure that maps hashes to on-disk\n      // locations where the contents of the block can be found. Here, we scan it\n      // out of the DB and into mapBlockIndex.\n      leveldb::Iterator *iterator = pdb->NewIterator(leveldb::ReadOptions());\n      // Seek to start key.\n      CDataStream ssStartKey(SER_DISK, CLIENT_VERSION);\n      ssStartKey << make_pair(string(\"blockindex\"), uint256(0));\n      iterator->Seek(ssStartKey.str());\n      // Now read each entry.\n      while (iterator->Valid())\n      {\n          // Unpack keys and values.\n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.write(iterator->key().data(), iterator->key().size());\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.write(iterator->value().data(), iterator->value().size());\n          string strType;\n          ssKey >> strType;\n          // Did we reach the end of the data to read?\n          if (fRequestShutdown || strType != \"blockindex\")\n              break;\n          CDiskBlockIndex diskindex;\n          ssValue >> diskindex;\n  \n          uint256 blockHash = diskindex.GetBlockHash();\n  \n          // Construct block index object\n          CBlockIndex* pindexNew    = InsertBlockIndex(blockHash);\n          pindexNew->pprev          = InsertBlockIndex(diskindex.hashPrev);\n          pindexNew->pnext          = InsertBlockIndex(diskindex.hashNext);\n          pindexNew->nFile          = diskindex.nFile;\n          pindexNew->nBlockPos      = diskindex.nBlockPos;\n          pindexNew->nHeight        = diskindex.nHeight;\n          pindexNew->nMint          = diskindex.nMint;\n          pindexNew->nMoneySupply   = diskindex.nMoneySupply;\n          pindexNew->nFlags         = diskindex.nFlags;\n          pindexNew->nStakeModifier = diskindex.nStakeModifier;\n          pindexNew->prevoutStake   = diskindex.prevoutStake;\n          pindexNew->nStakeTime     = diskindex.nStakeTime;\n          pindexNew->hashProofOfStake = diskindex.hashProofOfStake;\n          pindexNew->nVersion       = diskindex.nVersion;\n          pindexNew->hashMerkleRoot = diskindex.hashMerkleRoot;\n          pindexNew->nTime          = diskindex.nTime;\n          pindexNew->nBits          = diskindex.nBits;\n          pindexNew->nNonce         = diskindex.nNonce;\n  \n          // Watch for genesis block\n          if (pindexGenesisBlock == NULL && blockHash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n              pindexGenesisBlock = pindexNew;\n  \n          if (!pindexNew->CheckIndex()) {\n              delete iterator;\n              return error(\"LoadBlockIndex() : CheckIndex failed at %d\", pindexNew->nHeight);\n          }\n  \n          // NovaCoin: build setStakeSeen\n          if (pindexNew->IsProofOfStake())\n              setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n  \n          iterator->Next();\n      }\n      delete iterator;\n  \n      if (fRequestShutdown)\n          return true;\n  \n      // Calculate nChainTrust\n      vector<pair<int, CBlockIndex*> > vSortedByHeight;\n      vSortedByHeight.reserve(mapBlockIndex.size());\n      BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n      {\n          CBlockIndex* pindex = item.second;\n          vSortedByHeight.push_back(make_pair(pindex->nHeight, pindex));\n      }\n      sort(vSortedByHeight.begin(), vSortedByHeight.end());\n      BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n      {\n          CBlockIndex* pindex = item.second;\n          pindex->nChainTrust = (pindex->pprev ? pindex->pprev->nChainTrust : 0) + pindex->GetBlockTrust();\n          // NovaCoin: calculate stake modifier checksum\n          pindex->nStakeModifierChecksum = GetStakeModifierChecksum(pindex);\n          if (!CheckStakeModifierCheckpoints(pindex->nHeight, pindex->nStakeModifierChecksum))\n              return error(\"CTxDB::LoadBlockIndex() : Failed stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindex->nHeight, pindex->nStakeModifier);\n      }\n  \n      // Load hashBestChain pointer to end of best chain\n      if (!ReadHashBestChain(hashBestChain))\n      {\n          if (pindexGenesisBlock == NULL)\n              return true;\n          return error(\"CTxDB::LoadBlockIndex() : hashBestChain not loaded\");\n      }\n      if (!mapBlockIndex.count(hashBestChain))\n          return error(\"CTxDB::LoadBlockIndex() : hashBestChain not found in the block index\");\n      pindexBest = mapBlockIndex[hashBestChain];\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexBest->nChainTrust;\n  \n      printf(\"LoadBlockIndex(): hashBestChain=%s  height=%d  trust=%s  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight, CBigNum(nBestChainTrust).ToString().c_str(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      // NovaCoin: load hashSyncCheckpoint\n      if (!ReadSyncCheckpoint(Checkpoints::hashSyncCheckpoint))\n          return error(\"CTxDB::LoadBlockIndex() : hashSyncCheckpoint not loaded\");\n      printf(\"LoadBlockIndex(): synchronized checkpoint %s\\n\", Checkpoints::hashSyncCheckpoint.ToString().c_str());\n  \n      // Load bnBestInvalidTrust, OK if it doesn't exist\n      CBigNum bnBestInvalidTrust;\n      ReadBestInvalidTrust(bnBestInvalidTrust);\n      nBestInvalidTrust = bnBestInvalidTrust.getuint256();\n  \n      // Verify blocks in the best chain\n      int nCheckLevel = GetArg(\"-checklevel\", 1);\n      int nCheckDepth = GetArg( \"-checkblocks\", 500);\n      if (nCheckDepth == 0)\n          nCheckDepth = 1000000000; // suffices until the year 19000\n      if (nCheckDepth > nBestHeight)\n          nCheckDepth = nBestHeight;\n      printf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n      CBlockIndex* pindexFork = NULL;\n      map<pair<unsigned int, unsigned int>, CBlockIndex*> mapBlockPos;\n      for (CBlockIndex* pindex = pindexBest; pindex && pindex->pprev; pindex = pindex->pprev)\n      {\n          if (fRequestShutdown || pindex->nHeight < nBestHeight-nCheckDepth)\n              break;\n          CBlock block;\n          if (!block.ReadFromDisk(pindex))\n              return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n          // check level 1: verify block validity\n          if((nCheckLevel > 0) && !block.CheckBlock()) {\n              printf(\"LoadBlockIndex() : *** found bad block at %d, hash=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str());\n              pindexFork = pindex->pprev;\n          }\n          // check level 2: verify transaction index validity\n          if (nCheckLevel>1)\n          {\n              pair<unsigned int, unsigned int> pos = make_pair(pindex->nFile, pindex->nBlockPos);\n              mapBlockPos[pos] = pindex;\n              BOOST_FOREACH(const CTransaction &tx, block.vtx)\n              {\n                  uint256 hashTx = tx.GetHash();\n                  CTxIndex txindex;\n                  if (ReadTxIndex(hashTx, txindex))\n                  {\n                      // check level 3: checker transaction hashes\n                      if (nCheckLevel>2 || pindex->nFile != txindex.pos.nFile || pindex->nBlockPos != txindex.pos.nBlockPos)\n                      {\n                          // either an error or a duplicate transaction\n                          CTransaction txFound;\n                          if (!txFound.ReadFromDisk(txindex.pos))\n                          {\n                              printf(\"LoadBlockIndex() : *** cannot read mislocated transaction %s\\n\", hashTx.ToString().c_str());\n                              pindexFork = pindex->pprev;\n                          }\n                          else\n                              if (txFound.GetHash() != hashTx) // not a duplicate tx\n                              {\n                                  printf(\"LoadBlockIndex(): *** invalid tx position for %s\\n\", hashTx.ToString().c_str());\n                                  pindexFork = pindex->pprev;\n                              }\n                      }\n                      // check level 4: check whether spent txouts were spent within the main chain\n                      unsigned int nOutput = 0;\n                      if (nCheckLevel>3)\n                      {\n                          BOOST_FOREACH(const CDiskTxPos &txpos, txindex.vSpent)\n                          {\n                              if (!txpos.IsNull())\n                              {\n                                  pair<unsigned int, unsigned int> posFind = make_pair(txpos.nFile, txpos.nBlockPos);\n                                  if (!mapBlockPos.count(posFind))\n                                  {\n                                      printf(\"LoadBlockIndex(): *** found bad spend at %d, hashBlock=%s, hashTx=%s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString().c_str(), hashTx.ToString().c_str());\n                                      pindexFork = pindex->pprev;\n                                  }\n                                  // check level 6: check whether spent txouts were spent by a valid transaction that consume them\n                                  if (nCheckLevel>5)\n                                  {\n                                      CTransaction txSpend;\n                                      if (!txSpend.ReadFromDisk(txpos))\n                                      {\n                                          printf(\"LoadBlockIndex(): *** cannot read spending transaction of %s:%i from disk\\n\", hashTx.ToString().c_str(), nOutput);\n                                          pindexFork = pindex->pprev;\n                                      }\n                                      else if (!txSpend.CheckTransaction())\n                                      {\n                                          printf(\"LoadBlockIndex(): *** spending transaction of %s:%i is invalid\\n\", hashTx.ToString().c_str(), nOutput);\n                                          pindexFork = pindex->pprev;\n                                      }\n                                      else\n                                      {\n                                          bool fFound = false;\n                                          BOOST_FOREACH(const CTxIn &txin, txSpend.vin)\n                                              if (txin.prevout.hash == hashTx && txin.prevout.n == nOutput)\n                                                  fFound = true;\n                                          if (!fFound)\n                                          {\n                                              printf(\"LoadBlockIndex(): *** spending transaction of %s:%i does not spend it\\n\", hashTx.ToString().c_str(), nOutput);\n                                              pindexFork = pindex->pprev;\n                                          }\n                                      }\n                                  }\n                              }\n                              nOutput++;\n                          }\n                      }\n                  }\n                  // check level 5: check whether all prevouts are marked spent\n                  if (nCheckLevel>4)\n                  {\n                       BOOST_FOREACH(const CTxIn &txin, tx.vin)\n                       {\n                            CTxIndex txindex;\n                            if (ReadTxIndex(txin.prevout.hash, txindex))\n                                if (txindex.vSpent.size()-1 < txin.prevout.n || txindex.vSpent[txin.prevout.n].IsNull())\n                                {\n                                    printf(\"LoadBlockIndex(): *** found unspent prevout %s:%i in %s\\n\", txin.prevout.hash.ToString().c_str(), txin.prevout.n, hashTx.ToString().c_str());\n                                    pindexFork = pindex->pprev;\n                                }\n                       }\n                  }\n              }\n          }\n      }\n      if (pindexFork && !fRequestShutdown)\n      {\n          // Reorg back to the fork\n          printf(\"LoadBlockIndex() : *** moving best chain pointer back to block %d\\n\", pindexFork->nHeight);\n          CBlock block;\n          if (!block.ReadFromDisk(pindexFork))\n              return error(\"LoadBlockIndex() : block.ReadFromDisk failed\");\n          CTxDB txdb;\n          block.SetBestChain(txdb, pindexFork);\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nuint nStakeMinAge = 60 * 60 * 12;\nuint nStakeMaxAgeOne = 4294362496;\nuint nStakeMaxAgeTwo = 7 * 24 * 60 * 60;\nuint nModifierInterval = 10 * 60;\nint nCoinbaseMaturity = 50;\nunsigned char pchMessageStart[4] = { 0xa1, 0xa0, 0xa2, 0xa3 };\n\nbool LoadBlockIndex(bool fAllowNew) {\n\n    if(fTestNet) {\n        pchMessageStart[0] = 0xfd;\n        pchMessageStart[1] = 0xf2;\n        pchMessageStart[2] = 0xf0;\n        pchMessageStart[3] = 0xdf;\n\n        bnProofOfStakeLimit = bnProofOfStakeLimitTestNet;\n        bnProofOfWorkLimit  = bnProofOfWorkLimitTestNet;\n\n        /* Positive time weight after 20 minutes */\n        nStakeMinAge = 20 * 60;\n        /* Full time weight at 20 hours (+20 minutes) */\n        nStakeMaxAgeOne = 20 * 60 * 60;\n        nStakeMaxAgeTwo = 20 * 60 * 60;\n        /* Interval of 1 minute between stake modifiers */\n        nModifierInterval = 60;\n        /* Coin base and stake maturity */\n        nCoinbaseMaturity = 10;\n        /* NeoScrypt enabled always */\n        fNeoScrypt = true;\n    }\n\n    //\n    // Init with genesis block\n    //\n    CTxDB txdb(\"cr+\");\n    if(!txdb.LoadBlockIndex())\n        return false;\n\n    // Init with genesis block\n    if(mapBlockIndex.empty()) {\n\n        if(!fAllowNew) return false;\n\n        CTransaction txNew;\n        CBlock block;\n\n        if(!fTestNet) {\n\n            /* The Halcyon livenet genesis block */\n\n            const char* pszTimestamp = \"The ancient Greek myth of Halcyon is a tender story of love and commitment\";\n            txNew.nTime = 1408182502;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1408182502;\n            block.nBits    = bnProofOfWorkLimit.GetCompact();\n            block.nNonce   = 899198;\n\n        } else {\n\n/* The Halcyon testnet genesis block:\n * CBlock(hash=9a9e20c1cc8dc1297fc4842e1b358a576db6c985f6dc4a6b8cf16f36f69aa54d, ver=1, hashPrevBlock=0000000000000000000000000000000000000000000000000000000000000000, hashMerkleRoot=bef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362, nTime=1418677200, nBits=1f00ffff, nNonce=28699, vtx=1, vchBlockSig=)\n *   Coinbase(hash=bef44c6f33, nTime=1418677200, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n *     CTxIn(COutPoint(0000000000, 4294967295), coinbase 00012a4c6d546865207465726d2048616c63796f6e206f726967696e617465732066726f6d2074686520477265656b206d797468206f6620416c63796f6e6520616e64206d65616e7320676f6c64656e206f72206d61726b656420627920706561636520616e642070726f73706572697479)\n *     CTxOut(empty)\n *   vMerkleTree: bef44c6f33 */\n\n            const char* pszTimestamp = \"The term Halcyon originates from the Greek myth of Alcyone and means golden or marked by peace and prosperity\";\n            txNew.nTime = 1418677200;\n            txNew.vin.resize(1);\n            txNew.vout.resize(1);\n            txNew.vin[0].scriptSig = CScript() << 0 << CBigNum(42) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n            txNew.vout[0].SetEmpty();\n            block.vtx.push_back(txNew);\n            block.hashPrevBlock = 0;\n            block.hashMerkleRoot = block.BuildMerkleTree();\n            block.nVersion = 1;\n            block.nTime    = 1418677200;\n            block.nBits    = bnProofOfWorkLimitTestNet.GetCompact();\n            block.nNonce   = 28699;\n\n        }\n\n        //// debug print\n        printf(\"%s\\n\", block.GetHash().ToString().c_str());\n        printf(\"%s\\n\", block.hashMerkleRoot.ToString().c_str());\n\n        if(!fTestNet) assert(block.hashMerkleRoot ==\n          uint256(\"0xb761dad6c210bae0a6c1abeec2d7cb83624e34702d3912acba8bef58a932183b\"));\n        else assert(block.hashMerkleRoot ==\n          uint256(\"0xbef44c6f33468bd8b7f40afd000b78aad8b8956864a5ac109adfa95c64f76362\"));\n\n        // If no match on genesis block hash, then generate one\n        if(false && ((fTestNet && (block.GetHash() != hashGenesisBlockTestNet)) ||\n                    (!fTestNet && (block.GetHash() != hashGenesisBlock)))) {\n\n            printf(\"Genesis block mining...\\n\");\n\n            uint profile = 0x0;\n            uint256 hashTarget = CBigNum().SetCompact(block.nBits).getuint256();\n            uint256 hash;\n\n            while(true) {\n                neoscrypt((uchar *) &block.nVersion, (uchar *) &hash, profile);\n                if(hash <= hashTarget) break;\n                if(!(block.nNonce & 0xFFF))\n                  printf(\"nonce %08X: hash = %s (target = %s)\\n\",\n                    block.nNonce, hash.ToString().c_str(),\n                    hashTarget.ToString().c_str());\n                ++block.nNonce;\n                if(!block.nNonce) {\n                    printf(\"nonce limit reached, incrementing time\\n\");\n                    ++block.nTime;\n                }\n            }\n            printf(\"block.nTime = %u \\n\", block.nTime);\n            printf(\"block.nNonce = %u \\n\", block.nNonce);\n            printf(\"block.GetHash = %s\\n\", block.GetHash().ToString().c_str());\n            printf(\"block.GetHashPoW = %s\\n\", block.GetHashPoW().ToString().c_str());\n        }\n\n        block.print();\n        if(!fTestNet) assert(block.GetHash() == hashGenesisBlock);\n        else assert(block.GetHash() == hashGenesisBlockTestNet);\n\n        // Start new block file\n        unsigned int nFile;\n        unsigned int nBlockPos;\n        if (!block.WriteToDisk(nFile, nBlockPos))\n            return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n        if (!block.AddToBlockIndex(nFile, nBlockPos, 0))\n            return error(\"LoadBlockIndex() : genesis block not accepted\");\n\n        // ppcoin: initialize synchronized checkpoint\n        if (!Checkpoints::WriteSyncCheckpoint((!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet)))\n            return error(\"LoadBlockIndex() : failed to init sync checkpoint\");\n    }\n\n    string strPubKey = \"\";\n\n    // if checkpoint master key changed must reset sync-checkpoint\n    if (!txdb.ReadCheckpointPubKey(strPubKey) || strPubKey != CSyncCheckpoint::strMasterPubKey)\n    {\n        // write checkpoint master key to db\n        txdb.TxnBegin();\n        if (!txdb.WriteCheckpointPubKey(CSyncCheckpoint::strMasterPubKey))\n            return error(\"LoadBlockIndex() : failed to write new checkpoint master key to db\");\n        if (!txdb.TxnCommit())\n            return error(\"LoadBlockIndex() : failed to commit new checkpoint master key to db\");\n        if ((!fTestNet) && !Checkpoints::ResetSyncCheckpoint())\n            return error(\"LoadBlockIndex() : failed to reset sync-checkpoint\");\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "BlockFilePath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2610-2614",
    "snippet": "static filesystem::path BlockFilePath(unsigned int nFile)\n{\n    string strBlockFn = strprintf(\"blk%04u.dat\", nFile);\n    return GetDataDir() / strBlockFn;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"blk%04u.dat\"",
            "nFile"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nstatic filesystem::path BlockFilePath(unsigned int nFile)\n{\n    string strBlockFn = strprintf(\"blk%04u.dat\", nFile);\n    return GetDataDir() / strBlockFn;\n}"
  },
  {
    "function_name": "CheckDiskSpace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2592-2608",
    "snippet": "bool CheckDiskSpace(uint64_t nAdditionalBytes)\n{\n    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low!\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Halcyon\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "StartShutdown",
          "args": [],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "StartShutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/init.cpp",
          "lines": "52-61",
          "snippet": "void StartShutdown()\n{\n#ifdef QT_GUI\n    // ensure we leave the Qt main loop for a clean GUI exit (Shutdown() is called in bitcoin.cpp afterwards)\n    uiInterface.QueueShutdown();\n#else\n    // Without UI, Shutdown() can simply be started in a new thread\n    NewThread(Shutdown, NULL);\n#endif\n}",
          "includes": [
            "#include <signal.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/algorithm/string/predicate.hpp>",
            "#include <boost/interprocess/sync/file_lock.hpp>",
            "#include <boost/filesystem/convenience.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include \"checkpoints.h\"",
            "#include \"ui_interface.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CClientUIInterface uiInterface;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <signal.h>\n#include <openssl/crypto.h>\n#include <boost/algorithm/string/predicate.hpp>\n#include <boost/interprocess/sync/file_lock.hpp>\n#include <boost/filesystem/convenience.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include \"checkpoints.h\"\n#include \"ui_interface.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"txdb.h\"\n\nCClientUIInterface uiInterface;\n\nvoid StartShutdown()\n{\n#ifdef QT_GUI\n    // ensure we leave the Qt main loop for a clean GUI exit (Shutdown() is called in bitcoin.cpp afterwards)\n    uiInterface.QueueShutdown();\n#else\n    // Without UI, Shutdown() can simply be started in a new thread\n    NewThread(Shutdown, NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "uiInterface.ThreadSafeMessageBox",
          "args": [
            "strMessage",
            "\"Halcyon\"",
            "CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "ThreadSafeMessageBox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoin.cpp",
          "lines": "38-56",
          "snippet": "static void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}",
          "includes": [
            "#include <QtPlugin>",
            "#include <QLibraryInfo>",
            "#include <QSplashScreen>",
            "#include <QTranslator>",
            "#include <QLocale>",
            "#include <QTextCodec>",
            "#include <QMessageBox>",
            "#include <QApplication>",
            "#include \"qtipcserver.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"guiconstants.h\"",
            "#include \"guiutil.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static BitcoinGUI *guiref;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <QtPlugin>\n#include <QLibraryInfo>\n#include <QSplashScreen>\n#include <QTranslator>\n#include <QLocale>\n#include <QTextCodec>\n#include <QMessageBox>\n#include <QApplication>\n#include \"qtipcserver.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"guiconstants.h\"\n#include \"guiutil.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"bitcoingui.h\"\n\nstatic BitcoinGUI *guiref;\n\nstatic void ThreadSafeMessageBox(const std::string& message, const std::string& caption, int style)\n{\n    // Message from network thread\n    if(guiref)\n    {\n        bool modal = (style & CClientUIInterface::MODAL);\n        // in case of modal message, use blocking connection to wait for user to click OK\n        QMetaObject::invokeMethod(guiref, \"error\",\n                                   modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n                                   Q_ARG(QString, QString::fromStdString(caption)),\n                                   Q_ARG(QString, QString::fromStdString(message)),\n                                   Q_ARG(bool, modal));\n    }\n    else\n    {\n        printf(\"%s: %s\\n\", caption.c_str(), message.c_str());\n        fprintf(stderr, \"%s: %s\\n\", caption.c_str(), message.c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"*** %s\\n\"",
            "strMessage.c_str()"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strMessage.c_str",
          "args": [],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Warning: Disk space is low!\""
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "filesystem::space",
          "args": [
            "GetDataDir()"
          ],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetDataDir",
          "args": [],
          "line": 2594
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nbool CheckDiskSpace(uint64_t nAdditionalBytes)\n{\n    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low!\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Halcyon\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "CheckBlockSignature",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2565-2590",
    "snippet": "bool CBlock::CheckBlockSignature() const\n{\n    if (IsProofOfWork())\n        return vchBlockSig.empty();\n\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n\n    const CTxOut& txout = vtx[1].vout[1];\n\n    if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        valtype& vchPubKey = vSolutions[0];\n        CKey key;\n        if (!key.SetPubKey(vchPubKey))\n            return false;\n        if (vchBlockSig.empty())\n            return false;\n        return key.Verify(GetHash(), vchBlockSig);\n    }\n\n    return false;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key.Verify",
          "args": [
            "GetHash()",
            "vchBlockSig"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "Verify",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "392-399",
          "snippet": "bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    // -1 = error, 0 = bad sig, 1 = good\n    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      // -1 = error, 0 = bad sig, 1 = good\n      if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n          return false;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchBlockSig.empty",
          "args": [],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetPubKey",
          "args": [
            "vchPubKey"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "SetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "259-272",
          "snippet": "bool CKey::SetPubKey(const CPubKey& vchPubKey)\n{\n    const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n    {\n        fSet = true;\n        if (vchPubKey.vchPubKey.size() == 33)\n            SetCompressedPubKey();\n        return true;\n    }\n    pkey = NULL;\n    Reset();\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPubKey(const CPubKey& vchPubKey)\n  {\n      const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n      if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n      {\n          fSet = true;\n          if (vchPubKey.vchPubKey.size() == 33)\n              SetCompressedPubKey();\n          return true;\n      }\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "txout.scriptPubKey",
            "whichType",
            "vSolutions"
          ],
          "line": 2575
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfWork",
          "args": [],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::CheckBlockSignature() const\n  {\n      if (IsProofOfWork())\n          return vchBlockSig.empty();\n  \n      vector<valtype> vSolutions;\n      txnouttype whichType;\n  \n      const CTxOut& txout = vtx[1].vout[1];\n  \n      if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n          return false;\n  \n      if (whichType == TX_PUBKEY)\n      {\n          valtype& vchPubKey = vSolutions[0];\n          CKey key;\n          if (!key.SetPubKey(vchPubKey))\n              return false;\n          if (vchBlockSig.empty())\n              return false;\n          return key.Verify(GetHash(), vchBlockSig);\n      }\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "SignBlock",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2515-2563",
    "snippet": "bool CBlock::SignBlock(CWallet& wallet, int64_t nFees)\n{\n    // if we are trying to sign\n    //    something except proof-of-stake block template\n    if (!vtx[0].vout[0].IsEmpty())\n        return false;\n\n    // if we are trying to sign\n    //    a complete proof-of-stake block\n    if (IsProofOfStake())\n        return true;\n\n    static int64_t nLastCoinStakeSearchTime = GetAdjustedTime(); // startup timestamp\n\n    CKey key;\n    CTransaction txCoinStake;\n    int64_t nSearchTime = txCoinStake.nTime; // search to current time\n\n    if (nSearchTime > nLastCoinStakeSearchTime)\n    {\n        if (wallet.CreateCoinStake(wallet, nBits, nSearchTime-nLastCoinStakeSearchTime, nFees, txCoinStake, key))\n        {\n            if(txCoinStake.nTime >= max((pindexBest->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1),\n              PastDrift(pindexBest->GetBlockTime()))) {\n\n                // make sure coinstake would meet timestamp protocol\n                //    as it would be the same as the block timestamp\n                vtx[0].nTime = nTime = txCoinStake.nTime;\n                nTime = max(pindexBest->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1, GetMaxTransactionTime());\n                nTime = max(GetBlockTime(), PastDrift(pindexBest->GetBlockTime()));\n\n                // we have to make sure that we have no future timestamps in\n                //    our transactions set\n                for (vector<CTransaction>::iterator it = vtx.begin(); it != vtx.end();)\n                    if (it->nTime > nTime) { it = vtx.erase(it); } else { ++it; }\n\n                vtx.insert(vtx.begin() + 1, txCoinStake);\n                hashMerkleRoot = BuildMerkleTree();\n\n                // append a signature to our block\n                return key.Sign(GetHash(), vchBlockSig);\n            }\n        }\n        nLastCoinStakeSearchInterval = nSearchTime - nLastCoinStakeSearchTime;\n        nLastCoinStakeSearchTime = nSearchTime;\n    }\n\n    return false;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key.Sign",
          "args": [
            "GetHash()",
            "vchBlockSig"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "Sign",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "286-312",
          "snippet": "bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n{\n    vchSig.clear();\n    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n    if (sig == NULL)\n        return false;\n    BN_CTX *ctx = BN_CTX_new();\n    BN_CTX_start(ctx);\n    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n    BIGNUM *order = BN_CTX_get(ctx);\n    BIGNUM *halforder = BN_CTX_get(ctx);\n    EC_GROUP_get_order(group, order, ctx);\n    BN_rshift1(halforder, order);\n    if (BN_cmp(sig->s, halforder) > 0) {\n        // enforce low S values, by negating the value (modulo the order) if above order/2.\n        BN_sub(sig->s, order, sig->s);\n    }\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    unsigned int nSize = ECDSA_size(pkey);\n    vchSig.resize(nSize); // Make sure it is big enough\n    unsigned char *pos = &vchSig[0];\n    nSize = i2d_ECDSA_SIG(sig, &pos);\n    ECDSA_SIG_free(sig);\n    vchSig.resize(nSize); // Shrink to fit actual size\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n  {\n      vchSig.clear();\n      ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n      if (sig == NULL)\n          return false;\n      BN_CTX *ctx = BN_CTX_new();\n      BN_CTX_start(ctx);\n      const EC_GROUP *group = EC_KEY_get0_group(pkey);\n      BIGNUM *order = BN_CTX_get(ctx);\n      BIGNUM *halforder = BN_CTX_get(ctx);\n      EC_GROUP_get_order(group, order, ctx);\n      BN_rshift1(halforder, order);\n      if (BN_cmp(sig->s, halforder) > 0) {\n          // enforce low S values, by negating the value (modulo the order) if above order/2.\n          BN_sub(sig->s, order, sig->s);\n      }\n      BN_CTX_end(ctx);\n      BN_CTX_free(ctx);\n      unsigned int nSize = ECDSA_size(pkey);\n      vchSig.resize(nSize); // Make sure it is big enough\n      unsigned char *pos = &vchSig[0];\n      nSize = i2d_ECDSA_SIG(sig, &pos);\n      ECDSA_SIG_free(sig);\n      vchSig.resize(nSize); // Shrink to fit actual size\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildMerkleTree",
          "args": [],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "BuildMerkleTree",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1020-1037",
          "snippet": "uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 BuildMerkleTree() const\n      {\n          vMerkleTree.clear();\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              vMerkleTree.push_back(tx.GetHash());\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              for (int i = 0; i < nSize; i += 2)\n              {\n                  int i2 = std::min(i+1, nSize-1);\n                  vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                             BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n              }\n              j += nSize;\n          }\n          return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx.insert",
          "args": [
            "vtx.begin() + 1",
            "txCoinStake"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtx.begin",
          "args": [],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx.erase",
          "args": [
            "it"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx.end",
          "args": [],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "GetBlockTime()",
            "PastDrift(pindexBest->GetBlockTime())"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_max_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "433-435",
          "snippet": "void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PastDrift",
          "args": [
            "pindexBest->GetBlockTime()"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "PastDrift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "62-62",
          "snippet": "inline int64_t PastDrift(int64_t nTime)   { return(nTime - 10 * 60); }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\ninline int64_t PastDrift(int64_t nTime)   { return(nTime - 10 * 60); }"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetBlockTime",
          "args": [],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetMaxTransactionTime",
          "args": [],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "GetMaxTransactionTime",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1012-1018",
          "snippet": "int64_t GetMaxTransactionTime() const\n    {\n        int64_t maxTransactionTime = 0;\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            maxTransactionTime = std::max(maxTransactionTime, (int64_t)tx.nTime);\n        return maxTransactionTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  int64_t GetMaxTransactionTime() const\n      {\n          int64_t maxTransactionTime = 0;\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              maxTransactionTime = std::max(maxTransactionTime, (int64_t)tx.nTime);\n          return maxTransactionTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetPastTimeLimit",
          "args": [],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "GetPastTimeLimit",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1301-1304",
          "snippet": "int64_t GetPastTimeLimit() const\n    {\n        return GetMedianTimePast();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetPastTimeLimit() const\n      {\n          return GetMedianTimePast();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetMedianTimePast",
          "args": [],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "GetMedianTimePast",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1308-1320",
          "snippet": "int64_t GetMedianTimePast() const\n    {\n        int64_t pmedian[nMedianTimeSpan];\n        int64_t* pbegin = &pmedian[nMedianTimeSpan];\n        int64_t* pend = &pmedian[nMedianTimeSpan];\n\n        const CBlockIndex* pindex = this;\n        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n            *(--pbegin) = pindex->GetBlockTime();\n\n        std::sort(pbegin, pend);\n        return pbegin[(pend - pbegin)/2];\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetMedianTimePast() const\n      {\n          int64_t pmedian[nMedianTimeSpan];\n          int64_t* pbegin = &pmedian[nMedianTimeSpan];\n          int64_t* pend = &pmedian[nMedianTimeSpan];\n  \n          const CBlockIndex* pindex = this;\n          for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n              *(--pbegin) = pindex->GetBlockTime();\n  \n          std::sort(pbegin, pend);\n          return pbegin[(pend - pbegin)/2];\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "wallet.CreateCoinStake",
          "args": [
            "wallet",
            "nBits",
            "nSearchTime-nLastCoinStakeSearchTime",
            "nFees",
            "txCoinStake",
            "key"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfStake",
          "args": [],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx[0].vout[0].IsEmpty",
          "args": [],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "IsEmpty",
          "container": "CTxOut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "387-390",
          "snippet": "bool IsEmpty() const\n    {\n        return (nValue == 0 && scriptPubKey.empty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxOut {\n  bool IsEmpty() const\n      {\n          return (nValue == 0 && scriptPubKey.empty());\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlockIndex* pindexBest = NULL;\n\nCBlock {\n  bool CBlock::SignBlock(CWallet& wallet, int64_t nFees)\n  {\n      // if we are trying to sign\n      //    something except proof-of-stake block template\n      if (!vtx[0].vout[0].IsEmpty())\n          return false;\n  \n      // if we are trying to sign\n      //    a complete proof-of-stake block\n      if (IsProofOfStake())\n          return true;\n  \n      static int64_t nLastCoinStakeSearchTime = GetAdjustedTime(); // startup timestamp\n  \n      CKey key;\n      CTransaction txCoinStake;\n      int64_t nSearchTime = txCoinStake.nTime; // search to current time\n  \n      if (nSearchTime > nLastCoinStakeSearchTime)\n      {\n          if (wallet.CreateCoinStake(wallet, nBits, nSearchTime-nLastCoinStakeSearchTime, nFees, txCoinStake, key))\n          {\n              if(txCoinStake.nTime >= max((pindexBest->GetMedianTimePast() + BLOCK_LIMITER_TIME + 1),\n                PastDrift(pindexBest->GetBlockTime()))) {\n  \n                  // make sure coinstake would meet timestamp protocol\n                  //    as it would be the same as the block timestamp\n                  vtx[0].nTime = nTime = txCoinStake.nTime;\n                  nTime = max(pindexBest->GetPastTimeLimit() + BLOCK_LIMITER_TIME + 1, GetMaxTransactionTime());\n                  nTime = max(GetBlockTime(), PastDrift(pindexBest->GetBlockTime()));\n  \n                  // we have to make sure that we have no future timestamps in\n                  //    our transactions set\n                  for (vector<CTransaction>::iterator it = vtx.begin(); it != vtx.end();)\n                      if (it->nTime > nTime) { it = vtx.erase(it); } else { ++it; }\n  \n                  vtx.insert(vtx.begin() + 1, txCoinStake);\n                  hashMerkleRoot = BuildMerkleTree();\n  \n                  // append a signature to our block\n                  return key.Sign(GetHash(), vchBlockSig);\n              }\n          }\n          nLastCoinStakeSearchInterval = nSearchTime - nLastCoinStakeSearchTime;\n          nLastCoinStakeSearchTime = nSearchTime;\n      }\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "ProcessBlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2428-2512",
    "snippet": "bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "set<pair<COutPoint, unsigned int> > setStakeSeen;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "CBlockIndex* pindexBest = NULL;",
      "map<uint256, CBlock*> mapOrphanBlocks;",
      "multimap<uint256, CBlock*> mapOrphanBlocksByPrev;",
      "set<pair<COutPoint, unsigned int> > setStakeSeenOrphan;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Checkpoints::SendSyncCheckpoint",
          "args": [
            "Checkpoints::AutoSelectSyncCheckpoint()"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "SendSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "323-352",
          "snippet": "bool SendSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = hashCheckpoint;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        if (CSyncCheckpoint::strMasterPrivKey.empty())\n            return error(\"SendSyncCheckpoint: Checkpoint master key unavailable.\");\n        std::vector<unsigned char> vchPrivKey = ParseHex(CSyncCheckpoint::strMasterPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return error(\"SendSyncCheckpoint: Unable to sign checkpoint, check private key?\");\n\n        if(!checkpoint.ProcessSyncCheckpoint(NULL))\n        {\n            printf(\"WARNING: SendSyncCheckpoint: Failed to process checkpoint.\\n\");\n            return false;\n        }\n\n        // Relay checkpoint\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [
            "std::string CSyncCheckpoint::strMasterPrivKey = \"\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nstd::string CSyncCheckpoint::strMasterPrivKey = \"\";\n\nbool SendSyncCheckpoint(uint256 hashCheckpoint)\n    {\n        CSyncCheckpoint checkpoint;\n        checkpoint.hashCheckpoint = hashCheckpoint;\n        CDataStream sMsg(SER_NETWORK, PROTOCOL_VERSION);\n        sMsg << (CUnsignedSyncCheckpoint)checkpoint;\n        checkpoint.vchMsg = std::vector<unsigned char>(sMsg.begin(), sMsg.end());\n\n        if (CSyncCheckpoint::strMasterPrivKey.empty())\n            return error(\"SendSyncCheckpoint: Checkpoint master key unavailable.\");\n        std::vector<unsigned char> vchPrivKey = ParseHex(CSyncCheckpoint::strMasterPrivKey);\n        CKey key;\n        key.SetPrivKey(CPrivKey(vchPrivKey.begin(), vchPrivKey.end())); // if key is not correct openssl may crash\n        if (!key.Sign(Hash(checkpoint.vchMsg.begin(), checkpoint.vchMsg.end()), checkpoint.vchSig))\n            return error(\"SendSyncCheckpoint: Unable to sign checkpoint, check private key?\");\n\n        if(!checkpoint.ProcessSyncCheckpoint(NULL))\n        {\n            printf(\"WARNING: SendSyncCheckpoint: Failed to process checkpoint.\\n\");\n            return false;\n        }\n\n        // Relay checkpoint\n        {\n            LOCK(cs_vNodes);\n            BOOST_FOREACH(CNode* pnode, vNodes)\n                checkpoint.RelayTo(pnode);\n        }\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::AutoSelectSyncCheckpoint",
          "args": [],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "AutoSelectSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "204-212",
          "snippet": "uint256 AutoSelectSyncCheckpoint() {\n        /* No immediate checkpointing on either PoW or PoS blocks,\n         * select by depth in the main chain rather than block time */\n        const CBlockIndex *pindex = pindexBest;\n        const int nCheckpointDepth = GetArg(\"-checkpointdepth\", CHECKPOINT_DEFAULT_DEPTH);\n        while(pindex->pprev && ((pindex->nHeight + nCheckpointDepth) > pindexBest->nHeight))\n          pindex = pindex->pprev;\n        return(pindex->GetBlockHash());\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nuint256 AutoSelectSyncCheckpoint() {\n        /* No immediate checkpointing on either PoW or PoS blocks,\n         * select by depth in the main chain rather than block time */\n        const CBlockIndex *pindex = pindexBest;\n        const int nCheckpointDepth = GetArg(\"-checkpointdepth\", CHECKPOINT_DEFAULT_DEPTH);\n        while(pindex->pprev && ((pindex->nHeight + nCheckpointDepth) > pindexBest->nHeight))\n          pindex = pindex->pprev;\n        return(pindex->GetBlockHash());\n    }"
        }
      },
      {
        "call_info": {
          "callee": "CSyncCheckpoint::strMasterPrivKey.empty",
          "args": [],
          "line": 2508
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessBlock: ACCEPTED\\n\""
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocksByPrev.erase",
          "args": [
            "hashPrev"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblockOrphan->GetProofOfStake",
          "args": [],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "GetProofOfStake",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1006-1009",
          "snippet": "std::pair<COutPoint, unsigned int> GetProofOfStake() const\n    {\n        return IsProofOfStake()? std::make_pair(vtx[1].vin[0].prevout, vtx[1].nTime) : std::make_pair(COutPoint(), (unsigned int)0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  std::pair<COutPoint, unsigned int> GetProofOfStake() const\n      {\n          return IsProofOfStake()? std::make_pair(vtx[1].vin[0].prevout, vtx[1].nTime) : std::make_pair(COutPoint(), (unsigned int)0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblockOrphan->GetHash",
          "args": [],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vWorkQueue.push_back",
          "args": [
            "pblockOrphan->GetHash()"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pblockOrphan->AcceptBlock",
          "args": [],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptBlock",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2192-2313",
          "snippet": "bool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get prev block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    if(!fTestNet && IsProofOfWork()) {\n      if((nHeight > 20000) && (nHeight < nForkOne))\n        return DoS(100, error(\"AcceptBlock() : reject proof-of-work at height %d\", nHeight));\n    }\n\n    // Check proof-of-work or proof-of-stake\n    if(nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake(), false))\n      return(DoS(100, error(\"AcceptBlock() : incorrect proof-of-%s difficulty\",\n        IsProofOfWork() ? \"work\" : \"stake\")));\n\n    uint nOurTime = (uint)GetAdjustedTime();\n\n    /* Check for time stamp (past limit #1) */\n    if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    if(fTestNet || (!fTestNet && (nHeight > nForkOne))) {\n\n        /* Check for time stamp (future limit) */\n        if(nTime > (nOurTime + 5 * 60))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Basic block limiter */\n        if(nTime <= ((uint)pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Future travel detector for the block limiter */\n        if((nTime > (nOurTime + 120)) &&\n          ((pindexPrev->GetAverageTimePast(5, 40) + BLOCK_LIMITER_TIME) > nOurTime))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    /* Check for time stamp (past limit #2) */\n    if(nTime <= (pindexPrev->nTime - 10 * 60))\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n\n    // Check that the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckHardened(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : rejected by hardened checkpoint lock-in at %d\", nHeight));\n\n    // Verify hash target and signature of coinstake tx\n    uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n    if (IsProofOfStake())\n    {\n        if (!CheckProofOfStake(vtx[1], nBits, hashProofOfStake, targetProofOfStake))\n        {\n            printf(\"WARNING: ProcessBlock(): check proof-of-stake failed for block %s\\n\", hash.ToString().c_str());\n            return false; // do not error here as we expect this during initial block download\n        }\n    }\n\n    bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);\n\n    // Check that the block satisfies synchronized checkpoint\n    if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)\n        return error(\"AcceptBlock() : rejected by synchronized checkpoint\");\n\n    if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)\n        strMiscWarning = _(\"WARNING: syncronized checkpoint violation detected, but skipped!\");\n\n    // Enforce rule that the coinbase starts with serialized block height\n    CScript expect = CScript() << nHeight;\n    if (vtx[0].vin[0].scriptSig.size() < expect.size() ||\n        !std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n        return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n\n    /* Don't accept blocks with bogus version numbers after this point */\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne))) {\n        if(nVersion != 2)\n          return(DoS(100, error(\"AcceptBlock() : incorrect block version %u\", nVersion)));\n    }\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos, hashProofOfStake))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n    if (hashBestChain == hash)\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n    }\n\n    // ppcoin: check pending sync-checkpoint\n    Checkpoints::AcceptPendingSyncCheckpoint();\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nBestHeight = -1;",
            "uint256 hashBestChain = 0;",
            "extern enum Checkpoints::CPMode CheckpointsMode;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nBestHeight = -1;\nuint256 hashBestChain = 0;\nextern enum Checkpoints::CPMode CheckpointsMode;\n\nCBlock {\n  bool CBlock::AcceptBlock()\n  {\n      // Check for duplicate\n      uint256 hash = GetHash();\n      if (mapBlockIndex.count(hash))\n          return error(\"AcceptBlock() : block already in mapBlockIndex\");\n  \n      // Get prev block index\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n      if (mi == mapBlockIndex.end())\n          return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n      CBlockIndex* pindexPrev = (*mi).second;\n      int nHeight = pindexPrev->nHeight+1;\n  \n      if(!fTestNet && IsProofOfWork()) {\n        if((nHeight > 20000) && (nHeight < nForkOne))\n          return DoS(100, error(\"AcceptBlock() : reject proof-of-work at height %d\", nHeight));\n      }\n  \n      // Check proof-of-work or proof-of-stake\n      if(nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake(), false))\n        return(DoS(100, error(\"AcceptBlock() : incorrect proof-of-%s difficulty\",\n          IsProofOfWork() ? \"work\" : \"stake\")));\n  \n      uint nOurTime = (uint)GetAdjustedTime();\n  \n      /* Check for time stamp (past limit #1) */\n      if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n        return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n          hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n      if(fTestNet || (!fTestNet && (nHeight > nForkOne))) {\n  \n          /* Check for time stamp (future limit) */\n          if(nTime > (nOurTime + 5 * 60))\n            return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n              hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n          /* Basic block limiter */\n          if(nTime <= ((uint)pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n            return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n              hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n          /* Future travel detector for the block limiter */\n          if((nTime > (nOurTime + 120)) &&\n            ((pindexPrev->GetAverageTimePast(5, 40) + BLOCK_LIMITER_TIME) > nOurTime))\n            return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n              hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n      }\n  \n      /* Check for time stamp (past limit #2) */\n      if(nTime <= (pindexPrev->nTime - 10 * 60))\n        return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n          hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n      // Check that all transactions are finalized\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n          if (!tx.IsFinal(nHeight, GetBlockTime()))\n              return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n  \n      // Check that the block chain matches the known block chain up to a checkpoint\n      if (!Checkpoints::CheckHardened(nHeight, hash))\n          return DoS(100, error(\"AcceptBlock() : rejected by hardened checkpoint lock-in at %d\", nHeight));\n  \n      // Verify hash target and signature of coinstake tx\n      uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n      if (IsProofOfStake())\n      {\n          if (!CheckProofOfStake(vtx[1], nBits, hashProofOfStake, targetProofOfStake))\n          {\n              printf(\"WARNING: ProcessBlock(): check proof-of-stake failed for block %s\\n\", hash.ToString().c_str());\n              return false; // do not error here as we expect this during initial block download\n          }\n      }\n  \n      bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);\n  \n      // Check that the block satisfies synchronized checkpoint\n      if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)\n          return error(\"AcceptBlock() : rejected by synchronized checkpoint\");\n  \n      if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)\n          strMiscWarning = _(\"WARNING: syncronized checkpoint violation detected, but skipped!\");\n  \n      // Enforce rule that the coinbase starts with serialized block height\n      CScript expect = CScript() << nHeight;\n      if (vtx[0].vin[0].scriptSig.size() < expect.size() ||\n          !std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n          return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n  \n      /* Don't accept blocks with bogus version numbers after this point */\n      if(fTestNet || (!fTestNet && (nHeight >= nForkOne))) {\n          if(nVersion != 2)\n            return(DoS(100, error(\"AcceptBlock() : incorrect block version %u\", nVersion)));\n      }\n  \n      // Write block to history file\n      if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n          return error(\"AcceptBlock() : out of disk space\");\n      unsigned int nFile = -1;\n      unsigned int nBlockPos = 0;\n      if (!WriteToDisk(nFile, nBlockPos))\n          return error(\"AcceptBlock() : WriteToDisk failed\");\n      if (!AddToBlockIndex(nFile, nBlockPos, hashProofOfStake))\n          return error(\"AcceptBlock() : AddToBlockIndex failed\");\n  \n      // Relay inventory, but don't relay old inventory during initial block download\n      int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n      if (hashBestChain == hash)\n      {\n          LOCK(cs_vNodes);\n          BOOST_FOREACH(CNode* pnode, vNodes)\n              if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                  pnode->PushInventory(CInv(MSG_BLOCK, hash));\n      }\n  \n      // ppcoin: check pending sync-checkpoint\n      Checkpoints::AcceptPendingSyncCheckpoint();\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocksByPrev.upper_bound",
          "args": [
            "hashPrev"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocksByPrev.lower_bound",
          "args": [
            "hashPrev"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vWorkQueue.size",
          "args": [],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vWorkQueue.push_back",
          "args": [
            "hash"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ProcessBlock() : AcceptBlock FAILED\""
          ],
          "line": 2483
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->AskFor",
          "args": [
            "CInv(MSG_BLOCK, WantedByOrphan(pblock2))"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "AskFor",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "315-333",
          "snippet": "void AskFor(const CInv& inv)\n    {\n        // We're using mapAskFor as a priority queue,\n        // the key is the earliest time the request can be sent\n        int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n        if (fDebugNet)\n            printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n\n        // Make sure not to reuse time indexes to keep things in the same order\n        int64_t nNow = (GetTime() - 1) * 1000000;\n        static int64_t nLastTime;\n        ++nLastTime;\n        nNow = std::max(nNow, nLastTime);\n        nLastTime = nNow;\n\n        // Each retry is 2 minutes after the last\n        nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n        mapAskFor.insert(std::make_pair(nRequestTime, inv));\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void AskFor(const CInv& inv)\n      {\n          // We're using mapAskFor as a priority queue,\n          // the key is the earliest time the request can be sent\n          int64_t& nRequestTime = mapAlreadyAskedFor[inv];\n          if (fDebugNet)\n              printf(\"askfor %s   %\"PRId64\" (%s)\\n\", inv.ToString().c_str(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n  \n          // Make sure not to reuse time indexes to keep things in the same order\n          int64_t nNow = (GetTime() - 1) * 1000000;\n          static int64_t nLastTime;\n          ++nLastTime;\n          nNow = std::max(nNow, nLastTime);\n          nLastTime = nNow;\n  \n          // Each retry is 2 minutes after the last\n          nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);\n          mapAskFor.insert(std::make_pair(nRequestTime, inv));\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CInv",
          "args": [
            "MSG_BLOCK",
            "WantedByOrphan(pblock2)"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "CInv",
          "container": "CInv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "108-122",
          "snippet": "CInv::CInv(const std::string& strType, const uint256& hashIn)\n{\n    unsigned int i;\n    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n    {\n        if (strType == ppszTypeName[i])\n        {\n            type = i;\n            break;\n        }\n    }\n    if (i == ARRAYLEN(ppszTypeName))\n        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n    hash = hashIn;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nstatic const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};\n\nCInv {\n  CInv::CInv(const std::string& strType, const uint256& hashIn)\n  {\n      unsigned int i;\n      for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n      {\n          if (strType == ppszTypeName[i])\n          {\n              type = i;\n              break;\n          }\n      }\n      if (i == ARRAYLEN(ppszTypeName))\n          throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n      hash = hashIn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WantedByOrphan",
          "args": [
            "pblock2"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "WantedByOrphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "968-974",
          "snippet": "uint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CBlock*> mapOrphanBlocks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CBlock*> mapOrphanBlocks;\n\nuint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInitialBlockDownload",
          "args": [],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "IsInitialBlockDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1220-1233",
          "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nBestHeight = -1;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pfrom->PushGetBlocks",
          "args": [
            "pindexBest",
            "GetOrphanRoot(pblock2)"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "PushGetBlocks",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.cpp",
          "lines": "94-103",
          "snippet": "void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n{\n    // Filter out duplicate requests\n    if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n        return;\n    pindexLastGetBlocksBegin = pindexBegin;\n    hashLastGetBlocksEnd = hashEnd;\n\n    PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n}",
          "includes": [
            "#include <miniupnpc/upnperrors.h>",
            "#include <miniupnpc/upnpcommands.h>",
            "#include <miniupnpc/miniupnpc.h>",
            "#include <miniupnpc/miniwget.h>",
            "#include <string.h>",
            "#include \"ui_interface.h\"",
            "#include \"addrman.h\"",
            "#include \"strlcpy.h\"",
            "#include \"init.h\"",
            "#include \"ntp.h\"",
            "#include \"net.h\"",
            "#include \"db.h\"",
            "#include \"irc.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <miniupnpc/upnperrors.h>\n#include <miniupnpc/upnpcommands.h>\n#include <miniupnpc/miniupnpc.h>\n#include <miniupnpc/miniwget.h>\n#include <string.h>\n#include \"ui_interface.h\"\n#include \"addrman.h\"\n#include \"strlcpy.h\"\n#include \"init.h\"\n#include \"ntp.h\"\n#include \"net.h\"\n#include \"db.h\"\n#include \"irc.h\"\n\nCNode {\n  void CNode::PushGetBlocks(CBlockIndex* pindexBegin, uint256 hashEnd)\n  {\n      // Filter out duplicate requests\n      if (pindexBegin == pindexLastGetBlocksBegin && hashEnd == hashLastGetBlocksEnd)\n          return;\n      pindexLastGetBlocksBegin = pindexBegin;\n      hashLastGetBlocksEnd = hashEnd;\n  \n      PushMessage(\"getblocks\", CBlockLocator(pindexBegin), hashEnd);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOrphanRoot",
          "args": [
            "pblock2"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "GetOrphanRoot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "959-965",
          "snippet": "uint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CBlock*> mapOrphanBlocks;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CBlock*> mapOrphanBlocks;\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocksByPrev.insert",
          "args": [
            "make_pair(pblock2->hashPrevBlock, pblock2)"
          ],
          "line": 2467
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pblock2->hashPrevBlock",
            "pblock2"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "hash",
            "pblock2"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\"",
            "pblock2->GetProofOfStake().first.ToString().c_str()",
            "pblock2->GetProofOfStake().second",
            "hash.ToString().c_str()"
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::WantedByPendingSyncCheckpoint",
          "args": [
            "hash"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "WantedByPendingSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "242-253",
          "snippet": "bool WantedByPendingSyncCheckpoint(uint256 hashBlock)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint == 0)\n            return false;\n        if (hashBlock == hashPendingCheckpoint)\n            return true;\n        if (mapOrphanBlocks.count(hashPendingCheckpoint) \n            && hashBlock == WantedByOrphan(mapOrphanBlocks[hashPendingCheckpoint]))\n            return true;\n        return false;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool WantedByPendingSyncCheckpoint(uint256 hashBlock)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint == 0)\n            return false;\n        if (hashBlock == hashPendingCheckpoint)\n            return true;\n        if (mapOrphanBlocks.count(hashPendingCheckpoint) \n            && hashBlock == WantedByOrphan(mapOrphanBlocks[hashPendingCheckpoint]))\n            return true;\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocksByPrev.count",
          "args": [
            "hash"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock2->IsProofOfStake",
          "args": [],
          "line": 2457
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\"",
            "pblock->hashPrevBlock.ToString().substr(0,20).c_str()"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->hashPrevBlock.ToString",
          "args": [
            "0",
            "20"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::AskForPendingSyncCheckpoint",
          "args": [
            "pfrom"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "AskForPendingSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "296-301",
          "snippet": "void AskForPendingSyncCheckpoint(CNode* pfrom)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (pfrom && hashPendingCheckpoint != 0 && (!mapBlockIndex.count(hashPendingCheckpoint)) && (!mapOrphanBlocks.count(hashPendingCheckpoint)))\n            pfrom->AskFor(CInv(MSG_BLOCK, hashPendingCheckpoint));\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nvoid AskForPendingSyncCheckpoint(CNode* pfrom)\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (pfrom && hashPendingCheckpoint != 0 && (!mapBlockIndex.count(hashPendingCheckpoint)) && (!mapOrphanBlocks.count(hashPendingCheckpoint)))\n            pfrom->AskFor(CInv(MSG_BLOCK, hashPendingCheckpoint));\n    }"
        }
      },
      {
        "call_info": {
          "callee": "pblock->CheckBlock",
          "args": [],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "CheckBlock",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2101-2190",
          "snippet": "bool CBlock::CheckBlock() const {\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    if(IsProofOfWork()) {\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n    }\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n\n    if (IsProofOfStake())\n    {\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n        for (unsigned int i = 2; i < vtx.size(); i++)\n            if (vtx[i].IsCoinStake())\n                return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    return(true);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::CheckBlock() const {\n  \n      // These are checks that are independent of context\n      // that can be verified before saving an orphan block.\n  \n      // Size limits\n      if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CheckBlock() : size limits failed\"));\n  \n      if(IsProofOfWork()) {\n  \n          /* Proof-of-work verification against target */\n          if(!CheckProofOfWork(GetHashPoW(), nBits))\n            return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n  \n          /* Proof-of-work block signature verification */\n          if(!CheckBlockSignature())\n            return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n      }\n  \n      // Check timestamp\n      if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n          return error(\"CheckBlock() : block timestamp too far in the future\");\n  \n      // First transaction must be coinbase, the rest must not be\n      if (vtx.empty() || !vtx[0].IsCoinBase())\n          return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n      for (unsigned int i = 1; i < vtx.size(); i++)\n          if (vtx[i].IsCoinBase())\n              return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n  \n      // Check coinbase timestamp\n      if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n          return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n  \n      if (IsProofOfStake())\n      {\n          // Coinbase output should be empty if proof-of-stake block\n          if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n              return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n  \n          // Second transaction must be coinstake, the rest must not be\n          if (vtx.empty() || !vtx[1].IsCoinStake())\n              return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n          for (unsigned int i = 2; i < vtx.size(); i++)\n              if (vtx[i].IsCoinStake())\n                  return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n  \n          // Check coinstake timestamp\n          if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n              return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n  \n          // NovaCoin: check proof-of-stake block signature\n          if(!CheckBlockSignature())\n              return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n      }\n  \n      // Check transactions\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          if (!tx.CheckTransaction())\n              return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n  \n          // ppcoin: check transaction timestamp\n          if (GetBlockTime() < (int64_t)tx.nTime)\n              return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n      }\n  \n      /* Merkle root verification */\n      if(hashMerkleRoot != BuildMerkleTree())\n        return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n  \n      /* Check for duplicate transactions */\n      set<uint256> uniqueTx;\n      BOOST_FOREACH(const CTransaction& tx, vtx) {\n          uniqueTx.insert(tx.GetHash());\n      }\n      if(uniqueTx.size() != vtx.size())\n        return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n  \n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          nSigOps += tx.GetLegacySigOpCount();\n      }\n      if (nSigOps > MAX_BLOCK_SIGOPS)\n          return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n  \n      return(true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\"",
            "pblock->GetProofOfStake().first.ToString().c_str()",
            "pblock->GetProofOfStake().second",
            "hash.ToString().c_str()"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ProcessBlock() : already have block (orphan) %s\"",
            "hash.ToString().substr(0,20).c_str()"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ProcessBlock() : already have block %d %s\"",
            "mapBlockIndex[hash]->nHeight",
            "hash.ToString().substr(0,20).c_str()"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\nmap<uint256, CBlock*> mapOrphanBlocks;\nmultimap<uint256, CBlock*> mapOrphanBlocksByPrev;\nset<pair<COutPoint, unsigned int> > setStakeSeenOrphan;\n\nbool ProcessBlock(CNode* pfrom, CBlock* pblock)\n{\n    // Check for duplicate\n    uint256 hash = pblock->GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n    if (mapOrphanBlocks.count(hash))\n        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n\n    // ppcoin: check proof-of-stake\n    // Limited duplicity on stake: prevents block flood attack\n    // Duplicate stake allowed only when there is orphan child block\n    if (pblock->IsProofOfStake() && setStakeSeen.count(pblock->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n        return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for block %s\", pblock->GetProofOfStake().first.ToString().c_str(), pblock->GetProofOfStake().second, hash.ToString().c_str());\n\n    // Preliminary checks\n    if (!pblock->CheckBlock())\n        return error(\"ProcessBlock() : CheckBlock FAILED\");\n\n    /* Ask for a pending advanced checkpoint if any */\n    if(pfrom && !IsInitialBlockDownload())\n      Checkpoints::AskForPendingSyncCheckpoint(pfrom);\n\n    // If don't already have its previous block, shunt it off to holding area until we get it\n    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n    {\n        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n        CBlock* pblock2 = new CBlock(*pblock);\n        // ppcoin: check proof-of-stake\n        if (pblock2->IsProofOfStake())\n        {\n            // Limited duplicity on stake: prevents block flood attack\n            // Duplicate stake allowed only when there is orphan child block\n            if (setStakeSeenOrphan.count(pblock2->GetProofOfStake()) && !mapOrphanBlocksByPrev.count(hash) && !Checkpoints::WantedByPendingSyncCheckpoint(hash))\n                return error(\"ProcessBlock() : duplicate proof-of-stake (%s, %d) for orphan block %s\", pblock2->GetProofOfStake().first.ToString().c_str(), pblock2->GetProofOfStake().second, hash.ToString().c_str());\n            else\n                setStakeSeenOrphan.insert(pblock2->GetProofOfStake());\n        }\n        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n\n        // Ask this guy to fill in what we're missing\n        if (pfrom)\n        {\n            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n            // ppcoin: getblocks may not obtain the ancestor block rejected\n            // earlier by duplicate-stake check so we ask for it again directly\n            if (!IsInitialBlockDownload())\n                pfrom->AskFor(CInv(MSG_BLOCK, WantedByOrphan(pblock2)));\n        }\n        return true;\n    }\n\n    // Store to disk\n    if (!pblock->AcceptBlock())\n        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n\n    // Recursively process any orphan blocks that depended on this one\n    vector<uint256> vWorkQueue;\n    vWorkQueue.push_back(hash);\n    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n    {\n        uint256 hashPrev = vWorkQueue[i];\n        for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n             mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n             ++mi)\n        {\n            CBlock* pblockOrphan = (*mi).second;\n            if (pblockOrphan->AcceptBlock())\n                vWorkQueue.push_back(pblockOrphan->GetHash());\n            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n            setStakeSeenOrphan.erase(pblockOrphan->GetProofOfStake());\n            delete pblockOrphan;\n        }\n        mapOrphanBlocksByPrev.erase(hashPrev);\n    }\n\n    printf(\"ProcessBlock: ACCEPTED\\n\");\n\n    // ppcoin: if responsible for sync-checkpoint send it\n    if (pfrom && !CSyncCheckpoint::strMasterPrivKey.empty())\n        Checkpoints::SendSyncCheckpoint(Checkpoints::AutoSelectSyncCheckpoint());\n\n    return true;\n}"
  },
  {
    "function_name": "IsSuperMajority",
    "container": "CBlockIndex",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2416-2426",
    "snippet": "bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired, unsigned int nToCheck)\n{\n    unsigned int nFound = 0;\n    for (unsigned int i = 0; i < nToCheck && nFound < nRequired && pstart != NULL; i++)\n    {\n        if (pstart->nVersion >= minVersion)\n            ++nFound;\n        pstart = pstart->pprev;\n    }\n    return (nFound >= nRequired);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlockIndex {\n  bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, unsigned int nRequired, unsigned int nToCheck)\n  {\n      unsigned int nFound = 0;\n      for (unsigned int i = 0; i < nToCheck && nFound < nRequired && pstart != NULL; i++)\n      {\n          if (pstart->nVersion >= minVersion)\n              ++nFound;\n          pstart = pstart->pprev;\n      }\n      return (nFound >= nRequired);\n  }\n}"
  },
  {
    "function_name": "GetBlockTrust",
    "container": "CBlockIndex",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2317-2414",
    "snippet": "uint256 CBlockIndex::GetBlockTrust() const {\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    if(bnTarget <= 0) return(0);\n\n    /* Old protocol */\n\n    if(!fTestNet && (nHeight < nForkOne))\n      return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n\n    /* New protocol: 80% PoS, 20% PoW */\n\n    uint256 nBlockTrust = 1;\n\n    if(IsProofOfWork()) {\n\n        uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n        uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n\n        /* The minimal PoW trust score prior to correction */\n        if(nPoWTrust < 4) nPoWTrust = 4;\n\n        /* Fixed trust for the first 10 blocks */\n        if((pprev == NULL) || (pprev->nHeight < 10))\n          return(nPoWTrust);\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n\n        if(pindexP1->IsProofOfStake()) {\n            /* 100% trust for PoW following PoS */\n            nBlockTrust = nPoWTrust;\n        } else {\n            if(pindexP2->IsProofOfStake()) {\n                /* 50% trust for PoS->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 1);\n            } else {\n                /* 25% trust for PoW->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 2);\n            }\n        }\n\n    } else {\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n        const CBlockIndex* pindexP3 = pindexP2->pprev;\n\n        /* PoS difficulty is very low and of little use for trust scoring;\n         * use full trust of the previous PoW block as a basis instead */\n        uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n\n        if(pindexP1->IsProofOfWork()) {\n            /* 200% trust for PoS following PoW */\n            if(pindexP2->IsProofOfStake()) {\n                /* PoS->PoW->PoS: 100% to 200% */\n                nBlockTrust = (nPrevTrust << 1);\n            } else {\n                if(pindexP3->IsProofOfStake()) {\n                    /* PoS->PoW->PoW->PoS: 50% to 200% */\n                    nBlockTrust = (nPrevTrust << 2);\n                } else {\n                    /* PoW->PoW->PoW->PoS: 25% to 200% */\n                    nBlockTrust = (nPrevTrust << 3);\n                }\n            }\n        } else {\n            if(pindexP2->IsProofOfWork()) {\n                /* 150% of trust for PoW->PoS->PoS */\n                nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n            } else {\n                if(pindexP3->IsProofOfWork()) {\n                    /* 120% of trust for PoW->PoS->PoS->PoS */\n                    nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                } else {\n                    const CBlockIndex* pindexP4 = pindexP3->pprev;\n                    if(pindexP4->IsProofOfWork()) {\n                        /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                        nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                    } else {\n                        const CBlockIndex* pindexP5 = pindexP4->pprev;\n                        if(pindexP5->IsProofOfWork()) {\n                            /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = (nPrevTrust >> 1);\n                        } else {\n                            /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = nPrevTrust;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    return(nBlockTrust);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pindexP5->IsProofOfWork",
          "args": [],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "nPrevTrust"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindexP3->IsProofOfStake",
          "args": [],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uint256",
          "args": [
            "\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\""
          ],
          "line": 2334
        },
        "resolved": true,
        "details": {
          "function_name": "setuint256",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "250-276",
          "snippet": "void setuint256(uint256 n)\n    {\n        unsigned char pch[sizeof(n) + 6];\n        unsigned char* p = pch + 4;\n        bool fLeadingZeroes = true;\n        unsigned char* pbegin = (unsigned char*)&n;\n        unsigned char* psrc = pbegin + sizeof(n);\n        while (psrc != pbegin)\n        {\n            unsigned char c = *(--psrc);\n            if (fLeadingZeroes)\n            {\n                if (c == 0)\n                    continue;\n                if (c & 0x80)\n                    *p++ = 0;\n                fLeadingZeroes = false;\n            }\n            *p++ = c;\n        }\n        unsigned int nSize = p - (pch + 4);\n        pch[0] = (nSize >> 24) & 0xff;\n        pch[1] = (nSize >> 16) & 0xff;\n        pch[2] = (nSize >> 8) & 0xff;\n        pch[3] = (nSize >> 0) & 0xff;\n        BN_mpi2bn(pch, p - pch, this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  void setuint256(uint256 n)\n      {\n          unsigned char pch[sizeof(n) + 6];\n          unsigned char* p = pch + 4;\n          bool fLeadingZeroes = true;\n          unsigned char* pbegin = (unsigned char*)&n;\n          unsigned char* psrc = pbegin + sizeof(n);\n          while (psrc != pbegin)\n          {\n              unsigned char c = *(--psrc);\n              if (fLeadingZeroes)\n              {\n                  if (c == 0)\n                      continue;\n                  if (c & 0x80)\n                      *p++ = 0;\n                  fLeadingZeroes = false;\n              }\n              *p++ = c;\n          }\n          unsigned int nSize = p - (pch + 4);\n          pch[0] = (nSize >> 24) & 0xff;\n          pch[1] = (nSize >> 16) & 0xff;\n          pch[2] = (nSize >> 8) & 0xff;\n          pch[3] = (nSize >> 0) & 0xff;\n          BN_mpi2bn(pch, p - pch, this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bnTarget.SetCompact",
          "args": [
            "nBits"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlockIndex {\n  uint256 CBlockIndex::GetBlockTrust() const {\n      CBigNum bnTarget;\n      bnTarget.SetCompact(nBits);\n  \n      if(bnTarget <= 0) return(0);\n  \n      /* Old protocol */\n  \n      if(!fTestNet && (nHeight < nForkOne))\n        return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n  \n      /* New protocol: 80% PoS, 20% PoW */\n  \n      uint256 nBlockTrust = 1;\n  \n      if(IsProofOfWork()) {\n  \n          uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n          uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n  \n          /* The minimal PoW trust score prior to correction */\n          if(nPoWTrust < 4) nPoWTrust = 4;\n  \n          /* Fixed trust for the first 10 blocks */\n          if((pprev == NULL) || (pprev->nHeight < 10))\n            return(nPoWTrust);\n  \n          const CBlockIndex* pindexP1 = pprev;\n          const CBlockIndex* pindexP2 = pindexP1->pprev;\n  \n          if(pindexP1->IsProofOfStake()) {\n              /* 100% trust for PoW following PoS */\n              nBlockTrust = nPoWTrust;\n          } else {\n              if(pindexP2->IsProofOfStake()) {\n                  /* 50% trust for PoS->PoW->PoW */\n                  nBlockTrust = (nPoWTrust >> 1);\n              } else {\n                  /* 25% trust for PoW->PoW->PoW */\n                  nBlockTrust = (nPoWTrust >> 2);\n              }\n          }\n  \n      } else {\n  \n          const CBlockIndex* pindexP1 = pprev;\n          const CBlockIndex* pindexP2 = pindexP1->pprev;\n          const CBlockIndex* pindexP3 = pindexP2->pprev;\n  \n          /* PoS difficulty is very low and of little use for trust scoring;\n           * use full trust of the previous PoW block as a basis instead */\n          uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n  \n          if(pindexP1->IsProofOfWork()) {\n              /* 200% trust for PoS following PoW */\n              if(pindexP2->IsProofOfStake()) {\n                  /* PoS->PoW->PoS: 100% to 200% */\n                  nBlockTrust = (nPrevTrust << 1);\n              } else {\n                  if(pindexP3->IsProofOfStake()) {\n                      /* PoS->PoW->PoW->PoS: 50% to 200% */\n                      nBlockTrust = (nPrevTrust << 2);\n                  } else {\n                      /* PoW->PoW->PoW->PoS: 25% to 200% */\n                      nBlockTrust = (nPrevTrust << 3);\n                  }\n              }\n          } else {\n              if(pindexP2->IsProofOfWork()) {\n                  /* 150% of trust for PoW->PoS->PoS */\n                  nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n              } else {\n                  if(pindexP3->IsProofOfWork()) {\n                      /* 120% of trust for PoW->PoS->PoS->PoS */\n                      nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                  } else {\n                      const CBlockIndex* pindexP4 = pindexP3->pprev;\n                      if(pindexP4->IsProofOfWork()) {\n                          /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                          nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                      } else {\n                          const CBlockIndex* pindexP5 = pindexP4->pprev;\n                          if(pindexP5->IsProofOfWork()) {\n                              /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                              nBlockTrust = (nPrevTrust >> 1);\n                          } else {\n                              /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                              nBlockTrust = nPrevTrust;\n                          }\n                      }\n                  }\n              }\n          }\n  \n      }\n  \n      return(nBlockTrust);\n  }\n}"
  },
  {
    "function_name": "AcceptBlock",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2192-2313",
    "snippet": "bool CBlock::AcceptBlock()\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AcceptBlock() : block already in mapBlockIndex\");\n\n    // Get prev block index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n    if (mi == mapBlockIndex.end())\n        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n    CBlockIndex* pindexPrev = (*mi).second;\n    int nHeight = pindexPrev->nHeight+1;\n\n    if(!fTestNet && IsProofOfWork()) {\n      if((nHeight > 20000) && (nHeight < nForkOne))\n        return DoS(100, error(\"AcceptBlock() : reject proof-of-work at height %d\", nHeight));\n    }\n\n    // Check proof-of-work or proof-of-stake\n    if(nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake(), false))\n      return(DoS(100, error(\"AcceptBlock() : incorrect proof-of-%s difficulty\",\n        IsProofOfWork() ? \"work\" : \"stake\")));\n\n    uint nOurTime = (uint)GetAdjustedTime();\n\n    /* Check for time stamp (past limit #1) */\n    if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    if(fTestNet || (!fTestNet && (nHeight > nForkOne))) {\n\n        /* Check for time stamp (future limit) */\n        if(nTime > (nOurTime + 5 * 60))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Basic block limiter */\n        if(nTime <= ((uint)pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n        /* Future travel detector for the block limiter */\n        if((nTime > (nOurTime + 120)) &&\n          ((pindexPrev->GetAverageTimePast(5, 40) + BLOCK_LIMITER_TIME) > nOurTime))\n          return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n            hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    }\n\n    /* Check for time stamp (past limit #2) */\n    if(nTime <= (pindexPrev->nTime - 10 * 60))\n      return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n        hash.ToString().substr(0,20).c_str(), nHeight)));\n\n    // Check that all transactions are finalized\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n        if (!tx.IsFinal(nHeight, GetBlockTime()))\n            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n\n    // Check that the block chain matches the known block chain up to a checkpoint\n    if (!Checkpoints::CheckHardened(nHeight, hash))\n        return DoS(100, error(\"AcceptBlock() : rejected by hardened checkpoint lock-in at %d\", nHeight));\n\n    // Verify hash target and signature of coinstake tx\n    uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n    if (IsProofOfStake())\n    {\n        if (!CheckProofOfStake(vtx[1], nBits, hashProofOfStake, targetProofOfStake))\n        {\n            printf(\"WARNING: ProcessBlock(): check proof-of-stake failed for block %s\\n\", hash.ToString().c_str());\n            return false; // do not error here as we expect this during initial block download\n        }\n    }\n\n    bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);\n\n    // Check that the block satisfies synchronized checkpoint\n    if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)\n        return error(\"AcceptBlock() : rejected by synchronized checkpoint\");\n\n    if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)\n        strMiscWarning = _(\"WARNING: syncronized checkpoint violation detected, but skipped!\");\n\n    // Enforce rule that the coinbase starts with serialized block height\n    CScript expect = CScript() << nHeight;\n    if (vtx[0].vin[0].scriptSig.size() < expect.size() ||\n        !std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n        return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n\n    /* Don't accept blocks with bogus version numbers after this point */\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne))) {\n        if(nVersion != 2)\n          return(DoS(100, error(\"AcceptBlock() : incorrect block version %u\", nVersion)));\n    }\n\n    // Write block to history file\n    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n        return error(\"AcceptBlock() : out of disk space\");\n    unsigned int nFile = -1;\n    unsigned int nBlockPos = 0;\n    if (!WriteToDisk(nFile, nBlockPos))\n        return error(\"AcceptBlock() : WriteToDisk failed\");\n    if (!AddToBlockIndex(nFile, nBlockPos, hashProofOfStake))\n        return error(\"AcceptBlock() : AddToBlockIndex failed\");\n\n    // Relay inventory, but don't relay old inventory during initial block download\n    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n    if (hashBestChain == hash)\n    {\n        LOCK(cs_vNodes);\n        BOOST_FOREACH(CNode* pnode, vNodes)\n            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n    }\n\n    // ppcoin: check pending sync-checkpoint\n    Checkpoints::AcceptPendingSyncCheckpoint();\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "int nBestHeight = -1;",
      "uint256 hashBestChain = 0;",
      "extern enum Checkpoints::CPMode CheckpointsMode;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Checkpoints::AcceptPendingSyncCheckpoint",
          "args": [],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptPendingSyncCheckpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "160-201",
          "snippet": "bool AcceptPendingSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint != 0 && mapBlockIndex.count(hashPendingCheckpoint))\n        {\n            if (!ValidateSyncCheckpoint(hashPendingCheckpoint))\n            {\n                hashPendingCheckpoint = 0;\n                checkpointMessagePending.SetNull();\n                return false;\n            }\n\n            CTxDB txdb;\n            CBlockIndex* pindexCheckpoint = mapBlockIndex[hashPendingCheckpoint];\n            if (!pindexCheckpoint->IsInMainChain())\n            {\n                CBlock block;\n                if (!block.ReadFromDisk(pindexCheckpoint))\n                    return error(\"AcceptPendingSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                if (!block.SetBestChain(txdb, pindexCheckpoint))\n                {\n                    hashInvalidCheckpoint = hashPendingCheckpoint;\n                    return error(\"AcceptPendingSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                }\n            }\n\n            if (!WriteSyncCheckpoint(hashPendingCheckpoint))\n                return error(\"AcceptPendingSyncCheckpoint(): failed to write sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n            hashPendingCheckpoint = 0;\n            checkpointMessage = checkpointMessagePending;\n            checkpointMessagePending.SetNull();\n            printf(\"AcceptPendingSyncCheckpoint : sync-checkpoint at %s\\n\", hashSyncCheckpoint.ToString().c_str());\n            // relay the checkpoint\n            if (!checkpointMessage.IsNull())\n            {\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    checkpointMessage.RelayTo(pnode);\n            }\n            return true;\n        }\n        return false;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool AcceptPendingSyncCheckpoint()\n    {\n        LOCK(cs_hashSyncCheckpoint);\n        if (hashPendingCheckpoint != 0 && mapBlockIndex.count(hashPendingCheckpoint))\n        {\n            if (!ValidateSyncCheckpoint(hashPendingCheckpoint))\n            {\n                hashPendingCheckpoint = 0;\n                checkpointMessagePending.SetNull();\n                return false;\n            }\n\n            CTxDB txdb;\n            CBlockIndex* pindexCheckpoint = mapBlockIndex[hashPendingCheckpoint];\n            if (!pindexCheckpoint->IsInMainChain())\n            {\n                CBlock block;\n                if (!block.ReadFromDisk(pindexCheckpoint))\n                    return error(\"AcceptPendingSyncCheckpoint: ReadFromDisk failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                if (!block.SetBestChain(txdb, pindexCheckpoint))\n                {\n                    hashInvalidCheckpoint = hashPendingCheckpoint;\n                    return error(\"AcceptPendingSyncCheckpoint: SetBestChain failed for sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n                }\n            }\n\n            if (!WriteSyncCheckpoint(hashPendingCheckpoint))\n                return error(\"AcceptPendingSyncCheckpoint(): failed to write sync checkpoint %s\", hashPendingCheckpoint.ToString().c_str());\n            hashPendingCheckpoint = 0;\n            checkpointMessage = checkpointMessagePending;\n            checkpointMessagePending.SetNull();\n            printf(\"AcceptPendingSyncCheckpoint : sync-checkpoint at %s\\n\", hashSyncCheckpoint.ToString().c_str());\n            // relay the checkpoint\n            if (!checkpointMessage.IsNull())\n            {\n                BOOST_FOREACH(CNode* pnode, vNodes)\n                    checkpointMessage.RelayTo(pnode);\n            }\n            return true;\n        }\n        return false;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "pnode->PushInventory",
          "args": [
            "CInv(MSG_BLOCK, hash)"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "PushInventory",
          "container": "CNode",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "306-313",
          "snippet": "void PushInventory(const CInv& inv)\n    {\n        {\n            LOCK(cs_inventory);\n            if (!setInventoryKnown.count(inv))\n                vInventoryToSend.push_back(inv);\n        }\n    }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\nCNode {\n  void PushInventory(const CInv& inv)\n      {\n          {\n              LOCK(cs_inventory);\n              if (!setInventoryKnown.count(inv))\n                  vInventoryToSend.push_back(inv);\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CInv",
          "args": [
            "MSG_BLOCK",
            "hash"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "CInv",
          "container": "CInv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/protocol.cpp",
          "lines": "108-122",
          "snippet": "CInv::CInv(const std::string& strType, const uint256& hashIn)\n{\n    unsigned int i;\n    for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n    {\n        if (strType == ppszTypeName[i])\n        {\n            type = i;\n            break;\n        }\n    }\n    if (i == ARRAYLEN(ppszTypeName))\n        throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n    hash = hashIn;\n}",
          "includes": [
            "# include <arpa/inet.h>",
            "#include \"netbase.h\"",
            "#include \"util.h\"",
            "#include \"protocol.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <arpa/inet.h>\n#include \"netbase.h\"\n#include \"util.h\"\n#include \"protocol.h\"\n\nstatic const char* ppszTypeName[] =\n{\n    \"ERROR\",\n    \"tx\",\n    \"block\",\n};\n\nCInv {\n  CInv::CInv(const std::string& strType, const uint256& hashIn)\n  {\n      unsigned int i;\n      for (i = 1; i < ARRAYLEN(ppszTypeName); i++)\n      {\n          if (strType == ppszTypeName[i])\n          {\n              type = i;\n              break;\n          }\n      }\n      if (i == ARRAYLEN(ppszTypeName))\n          throw std::out_of_range(strprintf(\"CInv::CInv(string, uint256) : unknown type '%s'\", strType.c_str()));\n      hash = hashIn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_vNodes"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Checkpoints::GetTotalBlocksEstimate",
          "args": [],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "GetTotalBlocksEstimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "61-66",
          "snippet": "int GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nint GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AcceptBlock() : AddToBlockIndex failed\""
          ],
          "line": 2297
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AddToBlockIndex",
          "args": [
            "nFile",
            "nBlockPos",
            "hashProofOfStake"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "AddToBlockIndex",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2028-2096",
          "snippet": "bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    pindexNew->phashBlock = &hash;\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n\n    // ppcoin: compute chain trust score\n    pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n\n    // ppcoin: compute stake entropy bit for stake modifier\n    if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n        return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n\n    // ppcoin: record proof-of-stake hash value\n    pindexNew->hashProofOfStake = hashProofOfStake;\n\n    // ppcoin: compute stake modifier\n    uint64_t nStakeModifier = 0;\n    bool fGeneratedStakeModifier = false;\n    if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n        return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n    pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n    pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n    if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n        return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n\n    // Add to mapBlockIndex\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    if (pindexNew->IsProofOfStake())\n        setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n    pindexNew->phashBlock = &((*mi).first);\n\n    // Write to disk block index\n    CTxDB txdb;\n    if (!txdb.TxnBegin())\n        return false;\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->nChainTrust > nBestChainTrust)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    uiInterface.NotifyBlocksChanged();\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "set<pair<COutPoint, unsigned int> > setStakeSeen;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "uint256 nBestChainTrust = 0;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nuint256 nBestChainTrust = 0;\nCBlockIndex* pindexBest = NULL;\n\nCBlock {\n  bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n  {\n      // Check for duplicate\n      uint256 hash = GetHash();\n      if (mapBlockIndex.count(hash))\n          return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n  \n      // Construct new block index object\n      CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n      if (!pindexNew)\n          return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n      pindexNew->phashBlock = &hash;\n      map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n      if (miPrev != mapBlockIndex.end())\n      {\n          pindexNew->pprev = (*miPrev).second;\n          pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n      }\n  \n      // ppcoin: compute chain trust score\n      pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n  \n      // ppcoin: compute stake entropy bit for stake modifier\n      if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n          return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n  \n      // ppcoin: record proof-of-stake hash value\n      pindexNew->hashProofOfStake = hashProofOfStake;\n  \n      // ppcoin: compute stake modifier\n      uint64_t nStakeModifier = 0;\n      bool fGeneratedStakeModifier = false;\n      if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n          return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n      pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n      pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n      if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n          return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n  \n      // Add to mapBlockIndex\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n      if (pindexNew->IsProofOfStake())\n          setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n      pindexNew->phashBlock = &((*mi).first);\n  \n      // Write to disk block index\n      CTxDB txdb;\n      if (!txdb.TxnBegin())\n          return false;\n      txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n      if (!txdb.TxnCommit())\n          return false;\n  \n      // New best\n      if (pindexNew->nChainTrust > nBestChainTrust)\n          if (!SetBestChain(txdb, pindexNew))\n              return false;\n  \n      if (pindexNew == pindexBest)\n      {\n          // Notify UI to display prev block's coinbase if it was ours\n          static uint256 hashPrevBestCoinBase;\n          UpdatedTransaction(hashPrevBestCoinBase);\n          hashPrevBestCoinBase = vtx[0].GetHash();\n      }\n  \n      uiInterface.NotifyBlocksChanged();\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteToDisk",
          "args": [
            "nFile",
            "nBlockPos"
          ],
          "line": 2294
        },
        "resolved": true,
        "details": {
          "function_name": "WriteToDisk",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1071-1095",
          "snippet": "bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n    {\n        // Open history file to append\n        CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n        if (!fileout)\n            return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n\n        // Write index header\n        unsigned int nSize = fileout.GetSerializeSize(*this);\n        fileout << FLATDATA(pchMessageStart) << nSize;\n\n        // Write block\n        long fileOutPos = ftell(fileout);\n        if (fileOutPos < 0)\n            return error(\"CBlock::WriteToDisk() : ftell failed\");\n        nBlockPosRet = fileOutPos;\n        fileout << *this;\n\n        // Flush stdio buffers and commit to disk before returning\n        fflush(fileout);\n        if(!IsInitialBlockDownload() || !((nBestHeight + 1) % 100))\n          FileCommit(fileout);\n\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool WriteToDisk(unsigned int& nFileRet, unsigned int& nBlockPosRet)\n      {\n          // Open history file to append\n          CAutoFile fileout = CAutoFile(AppendBlockFile(nFileRet), SER_DISK, CLIENT_VERSION);\n          if (!fileout)\n              return error(\"CBlock::WriteToDisk() : AppendBlockFile failed\");\n  \n          // Write index header\n          unsigned int nSize = fileout.GetSerializeSize(*this);\n          fileout << FLATDATA(pchMessageStart) << nSize;\n  \n          // Write block\n          long fileOutPos = ftell(fileout);\n          if (fileOutPos < 0)\n              return error(\"CBlock::WriteToDisk() : ftell failed\");\n          nBlockPosRet = fileOutPos;\n          fileout << *this;\n  \n          // Flush stdio buffers and commit to disk before returning\n          fflush(fileout);\n          if(!IsInitialBlockDownload() || !((nBestHeight + 1) % 100))\n            FileCommit(fileout);\n  \n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckDiskSpace",
          "args": [
            "::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "CheckDiskSpace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2592-2608",
          "snippet": "bool CheckDiskSpace(uint64_t nAdditionalBytes)\n{\n    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low!\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Halcyon\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nbool CheckDiskSpace(uint64_t nAdditionalBytes)\n{\n    uint64_t nFreeBytesAvailable = filesystem::space(GetDataDir()).available;\n\n    // Check for nMinDiskSpace bytes (currently 50MB)\n    if (nFreeBytesAvailable < nMinDiskSpace + nAdditionalBytes)\n    {\n        fShutdown = true;\n        string strMessage = _(\"Warning: Disk space is low!\");\n        strMiscWarning = strMessage;\n        printf(\"*** %s\\n\", strMessage.c_str());\n        uiInterface.ThreadSafeMessageBox(strMessage, \"Halcyon\", CClientUIInterface::OK | CClientUIInterface::ICON_EXCLAMATION | CClientUIInterface::MODAL);\n        StartShutdown();\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "::GetSerializeSize",
          "args": [
            "*this",
            "SER_DISK",
            "CLIENT_VERSION"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "632-638",
          "snippet": "unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nunsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoS",
          "args": [
            "100",
            "error(\"AcceptBlock() : incorrect block version %u\", nVersion)"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "DoS",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "865-865",
          "snippet": "bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AcceptBlock() : incorrect block version %u\"",
            "nVersion"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::equal",
          "args": [
            "expect.begin()",
            "expect.end()",
            "vtx[0].vin[0].scriptSig.begin()"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtx[0].vin[0].scriptSig.begin",
          "args": [],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expect.end",
          "args": [],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "expect.size",
          "args": [],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "CScriptID",
          "container": "CScriptID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "59-59",
          "snippet": "CScriptID() : uint160(0) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCScriptID {\n  CScriptID() : uint160(0) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::CheckSync",
          "args": [
            "hash",
            "pindexPrev"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "CheckSync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "215-240",
          "snippet": "bool CheckSync(const uint256& hashBlock, const CBlockIndex* pindexPrev)\n    {\n        if (fTestNet) return true; // Testnet has no checkpoints\n        int nHeight = pindexPrev->nHeight + 1;\n\n        LOCK(cs_hashSyncCheckpoint);\n        // sync-checkpoint should always be accepted block\n        assert(mapBlockIndex.count(hashSyncCheckpoint));\n        const CBlockIndex* pindexSync = mapBlockIndex[hashSyncCheckpoint];\n\n        if (nHeight > pindexSync->nHeight)\n        {\n            // trace back to same height as sync-checkpoint\n            const CBlockIndex* pindex = pindexPrev;\n            while (pindex->nHeight > pindexSync->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"CheckSync: pprev null - block index structure failure\");\n            if (pindex->nHeight < pindexSync->nHeight || pindex->GetBlockHash() != hashSyncCheckpoint)\n                return false; // only descendant of sync-checkpoint can pass check\n        }\n        if (nHeight == pindexSync->nHeight && hashBlock != hashSyncCheckpoint)\n            return false; // same height with sync-checkpoint\n        if (nHeight < pindexSync->nHeight && !mapBlockIndex.count(hashBlock))\n            return false; // lower height than sync-checkpoint\n        return true;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool CheckSync(const uint256& hashBlock, const CBlockIndex* pindexPrev)\n    {\n        if (fTestNet) return true; // Testnet has no checkpoints\n        int nHeight = pindexPrev->nHeight + 1;\n\n        LOCK(cs_hashSyncCheckpoint);\n        // sync-checkpoint should always be accepted block\n        assert(mapBlockIndex.count(hashSyncCheckpoint));\n        const CBlockIndex* pindexSync = mapBlockIndex[hashSyncCheckpoint];\n\n        if (nHeight > pindexSync->nHeight)\n        {\n            // trace back to same height as sync-checkpoint\n            const CBlockIndex* pindex = pindexPrev;\n            while (pindex->nHeight > pindexSync->nHeight)\n                if (!(pindex = pindex->pprev))\n                    return error(\"CheckSync: pprev null - block index structure failure\");\n            if (pindex->nHeight < pindexSync->nHeight || pindex->GetBlockHash() != hashSyncCheckpoint)\n                return false; // only descendant of sync-checkpoint can pass check\n        }\n        if (nHeight == pindexSync->nHeight && hashBlock != hashSyncCheckpoint)\n            return false; // same height with sync-checkpoint\n        if (nHeight < pindexSync->nHeight && !mapBlockIndex.count(hashBlock))\n            return false; // lower height than sync-checkpoint\n        return true;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"WARNING: ProcessBlock(): check proof-of-stake failed for block %s\\n\"",
            "hash.ToString().c_str()"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckProofOfStake",
          "args": [
            "vtx[1]",
            "nBits",
            "hashProofOfStake",
            "targetProofOfStake"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "CheckProofOfStake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "342-370",
          "snippet": "bool CheckProofOfStake(const CTransaction& tx, unsigned int nBits, uint256& hashProofOfStake, uint256& targetProofOfStake)\n{\n    if (!tx.IsCoinStake())\n        return error(\"CheckProofOfStake() : called on non-coinstake %s\", tx.GetHash().ToString().c_str());\n\n    // Kernel (input 0) must match the stake hash target per coin age (nBits)\n    const CTxIn& txin = tx.vin[0];\n\n    // First try finding the previous transaction in database\n    CTxDB txdb(\"r\");\n    CTransaction txPrev;\n    CTxIndex txindex;\n    if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: read txPrev failed\"));  // previous transaction not in main chain, may occur during initial download\n\n    // Verify signature\n    if (!VerifySignature(txPrev, tx, 0, 0))\n        return tx.DoS(100, error(\"CheckProofOfStake() : VerifySignature failed on coinstake %s\", tx.GetHash().ToString().c_str()));\n\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n        return fDebug? error(\"CheckProofOfStake() : read block failed\") : false; // unable to read block of previous transaction\n\n    if (!CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, txPrev, txin.prevout, tx.nTime, hashProofOfStake, targetProofOfStake, fDebug))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\", tx.GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str())); // may occur during initial download or if behind on block chain sync\n\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool CheckProofOfStake(const CTransaction& tx, unsigned int nBits, uint256& hashProofOfStake, uint256& targetProofOfStake)\n{\n    if (!tx.IsCoinStake())\n        return error(\"CheckProofOfStake() : called on non-coinstake %s\", tx.GetHash().ToString().c_str());\n\n    // Kernel (input 0) must match the stake hash target per coin age (nBits)\n    const CTxIn& txin = tx.vin[0];\n\n    // First try finding the previous transaction in database\n    CTxDB txdb(\"r\");\n    CTransaction txPrev;\n    CTxIndex txindex;\n    if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: read txPrev failed\"));  // previous transaction not in main chain, may occur during initial download\n\n    // Verify signature\n    if (!VerifySignature(txPrev, tx, 0, 0))\n        return tx.DoS(100, error(\"CheckProofOfStake() : VerifySignature failed on coinstake %s\", tx.GetHash().ToString().c_str()));\n\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n        return fDebug? error(\"CheckProofOfStake() : read block failed\") : false; // unable to read block of previous transaction\n\n    if (!CheckStakeKernelHash(nBits, block, txindex.pos.nTxPos - txindex.pos.nBlockPos, txPrev, txin.prevout, tx.nTime, hashProofOfStake, targetProofOfStake, fDebug))\n        return tx.DoS(1, error(\"CheckProofOfStake() : INFO: check kernel failed on coinstake %s, hashProof=%s\", tx.GetHash().ToString().c_str(), hashProofOfStake.ToString().c_str())); // may occur during initial download or if behind on block chain sync\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfStake",
          "args": [],
          "line": 2259
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::CheckHardened",
          "args": [
            "nHeight",
            "hash"
          ],
          "line": 2254
        },
        "resolved": true,
        "details": {
          "function_name": "CheckHardened",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "52-59",
          "snippet": "bool CheckHardened(int nHeight, const uint256& hash)\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n        if (i == checkpoints.end()) return true;\n        return hash == i->second;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nbool CheckHardened(int nHeight, const uint256& hash)\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        MapCheckpoints::const_iterator i = checkpoints.find(nHeight);\n        if (i == checkpoints.end()) return true;\n        return hash == i->second;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsFinal",
          "args": [
            "nHeight",
            "GetBlockTime()"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBlockTime",
          "args": [],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AcceptBlock() : block %s height %d has a time stamp too far in the past\"",
            "hash.ToString().substr(0,20).c_str()",
            "nHeight"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [
            "0",
            "20"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexPrev->GetAverageTimePast",
          "args": [
            "5",
            "40"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "GetAverageTimePast",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1335-1369",
          "snippet": "uint GetAverageTimePast(uint nAvgTimeSpan, uint nMinDelay) const {\n        uint avg[nAvgTimeSpan], nTempTime, i;\n        uint64 nAvgAccum;\n        const CBlockIndex* pindex = this;\n\n        /* Keep it fail safe */\n        if(!nAvgTimeSpan) return(0);\n\n        /* Initialise the elements to zero */\n        for(i = 0; i < nAvgTimeSpan; i++)\n          avg[i] = 0;\n\n        /* Fill with the time stamps */\n        for(i = nAvgTimeSpan; i && pindex; i--, pindex = pindex->pprev)\n          avg[i - 1] = pindex->nTime;\n\n        /* Not enough input blocks */\n        if(!avg[0]) return(0);\n\n        /* Time travel aware accumulator */\n        nTempTime = avg[0];\n        for(i = 1, nAvgAccum = nTempTime; i < nAvgTimeSpan; i++) { \n            /* Update the accumulator either with an actual or minimal\n             * delay supplied to prevent extremely fast blocks */\n            if(avg[i] < (nTempTime + nMinDelay))\n              nTempTime += nMinDelay;\n            else\n              nTempTime  = avg[i];\n            nAvgAccum += nTempTime;\n        }\n\n        nTempTime = (uint)(nAvgAccum / (uint64)nAvgTimeSpan);\n\n        return(nTempTime);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  uint GetAverageTimePast(uint nAvgTimeSpan, uint nMinDelay) const {\n          uint avg[nAvgTimeSpan], nTempTime, i;\n          uint64 nAvgAccum;\n          const CBlockIndex* pindex = this;\n  \n          /* Keep it fail safe */\n          if(!nAvgTimeSpan) return(0);\n  \n          /* Initialise the elements to zero */\n          for(i = 0; i < nAvgTimeSpan; i++)\n            avg[i] = 0;\n  \n          /* Fill with the time stamps */\n          for(i = nAvgTimeSpan; i && pindex; i--, pindex = pindex->pprev)\n            avg[i - 1] = pindex->nTime;\n  \n          /* Not enough input blocks */\n          if(!avg[0]) return(0);\n  \n          /* Time travel aware accumulator */\n          nTempTime = avg[0];\n          for(i = 1, nAvgAccum = nTempTime; i < nAvgTimeSpan; i++) { \n              /* Update the accumulator either with an actual or minimal\n               * delay supplied to prevent extremely fast blocks */\n              if(avg[i] < (nTempTime + nMinDelay))\n                nTempTime += nMinDelay;\n              else\n                nTempTime  = avg[i];\n              nAvgAccum += nTempTime;\n          }\n  \n          nTempTime = (uint)(nAvgAccum / (uint64)nAvgTimeSpan);\n  \n          return(nTempTime);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexPrev->GetMedianTimePast",
          "args": [],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "GetMedianTimePast",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1308-1320",
          "snippet": "int64_t GetMedianTimePast() const\n    {\n        int64_t pmedian[nMedianTimeSpan];\n        int64_t* pbegin = &pmedian[nMedianTimeSpan];\n        int64_t* pend = &pmedian[nMedianTimeSpan];\n\n        const CBlockIndex* pindex = this;\n        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n            *(--pbegin) = pindex->GetBlockTime();\n\n        std::sort(pbegin, pend);\n        return pbegin[(pend - pbegin)/2];\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetMedianTimePast() const\n      {\n          int64_t pmedian[nMedianTimeSpan];\n          int64_t* pbegin = &pmedian[nMedianTimeSpan];\n          int64_t* pend = &pmedian[nMedianTimeSpan];\n  \n          const CBlockIndex* pindex = this;\n          for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n              *(--pbegin) = pindex->GetBlockTime();\n  \n          std::sort(pbegin, pend);\n          return pbegin[(pend - pbegin)/2];\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfWork",
          "args": [],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetNextTargetRequired",
          "args": [
            "pindexPrev",
            "IsProofOfStake()",
            "false"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "GetNextTargetRequired",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1039-1195",
          "snippet": "uint GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake,\n  bool fPrettyPrint) {\n    CBigNum bnTargetLimit, bnNew;\n\n    /* Separate range limits */\n    if(fTestNet) {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimitTestNet;\n        else bnTargetLimit = bnProofOfWorkLimitTestNet;\n    } else {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimit;\n        else bnTargetLimit = bnProofOfWorkLimit;\n    }\n\n    /* The genesis block */\n    if(pindexLast == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);\n    /* The 1st block */\n    if(pindexPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);\n    /* The 2nd block */\n    if(pindexPrevPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    /* The next block */\n    int nHeight = pindexLast->nHeight + 1;\n\n    if(!fTestNet && (nHeight < nForkOne)) {\n\n        /* Legacy every block retargets of the PPC style */\n\n        int64 nTargetTimespan = 20 * 60;\n        int64 nTargetSpacing = 2 * nBaseTargetSpacing;\n        int64 nInterval, nActualSpacing;\n\n        nActualSpacing = (int64)pindexPrev->nTime - (int64)pindexPrevPrev->nTime;\n        if(nActualSpacing < 0)\n          nActualSpacing = nTargetSpacing;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: pindexLast = %d, pindexPrev = %d, pindexPrevPrev = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexPrevPrev->nHeight);\n            printf(\"RETARGET time stamps: pindexLast = %u, pindexPrev = %u, pindexPrevPrev = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexPrevPrev->nTime);\n        }\n\n        nInterval = nTargetTimespan / nTargetSpacing;\n\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);\n        bnNew /= ((nInterval + 1) * nTargetSpacing);\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nTargetSpacing = %\"PRI64d\", \"\n            \"nInterval = %\"PRI64d\"\\n\", nTargetTimespan, nTargetSpacing, nInterval);\n\n    } else {\n\n        if(!fTestNet) {\n            /* The hard fork to NeoScrypt */\n            if(!fNeoScrypt) fNeoScrypt = true;\n            /* PoW difficulty reset after the switch */\n            if(!fProofOfStake && (pindexPrev->nHeight < nForkOne))\n              return(bnNeoScryptSwitch.GetCompact());\n        }\n\n        /* Orbitcoin Super Shield (OSS);\n         * retargets every block using two averaging windows of 5 and 20 blocks,\n         * 0.25 damping and +1% to -2% limiting */\n\n        int64 nIntervalShort = 5, nIntervalLong = 20, nTargetSpacing, nTargetTimespan,\n              nActualTimespan, nActualTimespanShort, nActualTimespanLong, nActualTimespanAvg,\n              nActualTimespanMax, nActualTimespanMin;\n        uint i;\n\n        if(fProofOfStake)\n          nTargetSpacing = 5 * nBaseTargetSpacing;\n        else\n          nTargetSpacing = 20 * nBaseTargetSpacing;\n\n        nTargetTimespan = nTargetSpacing * nIntervalLong;\n\n        /* The short averaging window */\n        const CBlockIndex* pindexShort = pindexPrev;\n        for(i = 0; i < nIntervalShort; i++) {\n            if(pindexShort->pprev)\n              pindexShort = GetLastBlockIndex(pindexShort->pprev, fProofOfStake);\n            else\n              return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanShort = (int64)pindexPrev->nTime - (int64)pindexShort->nTime;\n\n        /* The long averaging window */\n        const CBlockIndex* pindexLong = pindexShort;\n        for(i = 0; i < (nIntervalLong - nIntervalShort); i++) {\n           if(pindexLong->pprev)\n             pindexLong = GetLastBlockIndex(pindexLong->pprev, fProofOfStake);\n           else\n             return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanLong = (int64)pindexPrev->nTime - (int64)pindexLong->nTime;\n\n        /* Time warp protection */\n        nActualTimespanShort = max(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 3 / 4));\n        nActualTimespanShort = min(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 4 / 3));\n        nActualTimespanLong  = max(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 3 / 4));\n        nActualTimespanLong  = min(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 4 / 3));\n\n        /* The average of both windows */\n        nActualTimespanAvg = (nActualTimespanShort * (nIntervalLong / nIntervalShort) + nActualTimespanLong) / 2;\n\n        /* 0.25 damping */\n        nActualTimespan = nActualTimespanAvg + 3 * nTargetTimespan;\n        nActualTimespan /= 4;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: Last = %d, Prev = %d, Short = %d, Long = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexShort->nHeight, pindexLong->nHeight);\n            printf(\"RETARGET time stamps: Last = %u, Prev = %u, Short = %u, Long = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexShort->nTime, pindexLong->nTime);\n            printf(\"RETARGET windows: short = %\"PRI64d\" (%\"PRI64d\"), long = %\"PRI64d\", \"\n              \"average = %\"PRI64d\", damped = %\"PRI64d\"\\n\",\n              nActualTimespanShort, nActualTimespanShort * (nIntervalLong / nIntervalShort),\n              nActualTimespanLong, nActualTimespanAvg, nActualTimespan);\n        }\n\n        /* Difficulty limiters */\n        nActualTimespanMax = nTargetTimespan * 102 / 100;\n        nActualTimespanMin = nTargetTimespan * 100 / 101;\n        if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n        if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n        /* Retarget */\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= nActualTimespan;\n        bnNew /= nTargetTimespan;\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nActualTimespan = %\"PRI64d\", \"\n            \"nTargetTimespan / nActualTimespan = %.4f\\n\",\n            nTargetTimespan, nActualTimespan, (float)nTargetTimespan / (float)nActualTimespan);\n\n    }\n\n    if(fPrettyPrint) {\n        printf(\"Before: %08x  %s\\n\", pindexPrev->nBits,\n          CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str());\n        printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n    }\n\n    return(bnNew.GetCompact());\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const uint nBaseTargetSpacing = 30;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nconst uint nBaseTargetSpacing = 30;\n\nuint GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake,\n  bool fPrettyPrint) {\n    CBigNum bnTargetLimit, bnNew;\n\n    /* Separate range limits */\n    if(fTestNet) {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimitTestNet;\n        else bnTargetLimit = bnProofOfWorkLimitTestNet;\n    } else {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimit;\n        else bnTargetLimit = bnProofOfWorkLimit;\n    }\n\n    /* The genesis block */\n    if(pindexLast == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);\n    /* The 1st block */\n    if(pindexPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);\n    /* The 2nd block */\n    if(pindexPrevPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    /* The next block */\n    int nHeight = pindexLast->nHeight + 1;\n\n    if(!fTestNet && (nHeight < nForkOne)) {\n\n        /* Legacy every block retargets of the PPC style */\n\n        int64 nTargetTimespan = 20 * 60;\n        int64 nTargetSpacing = 2 * nBaseTargetSpacing;\n        int64 nInterval, nActualSpacing;\n\n        nActualSpacing = (int64)pindexPrev->nTime - (int64)pindexPrevPrev->nTime;\n        if(nActualSpacing < 0)\n          nActualSpacing = nTargetSpacing;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: pindexLast = %d, pindexPrev = %d, pindexPrevPrev = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexPrevPrev->nHeight);\n            printf(\"RETARGET time stamps: pindexLast = %u, pindexPrev = %u, pindexPrevPrev = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexPrevPrev->nTime);\n        }\n\n        nInterval = nTargetTimespan / nTargetSpacing;\n\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);\n        bnNew /= ((nInterval + 1) * nTargetSpacing);\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nTargetSpacing = %\"PRI64d\", \"\n            \"nInterval = %\"PRI64d\"\\n\", nTargetTimespan, nTargetSpacing, nInterval);\n\n    } else {\n\n        if(!fTestNet) {\n            /* The hard fork to NeoScrypt */\n            if(!fNeoScrypt) fNeoScrypt = true;\n            /* PoW difficulty reset after the switch */\n            if(!fProofOfStake && (pindexPrev->nHeight < nForkOne))\n              return(bnNeoScryptSwitch.GetCompact());\n        }\n\n        /* Orbitcoin Super Shield (OSS);\n         * retargets every block using two averaging windows of 5 and 20 blocks,\n         * 0.25 damping and +1% to -2% limiting */\n\n        int64 nIntervalShort = 5, nIntervalLong = 20, nTargetSpacing, nTargetTimespan,\n              nActualTimespan, nActualTimespanShort, nActualTimespanLong, nActualTimespanAvg,\n              nActualTimespanMax, nActualTimespanMin;\n        uint i;\n\n        if(fProofOfStake)\n          nTargetSpacing = 5 * nBaseTargetSpacing;\n        else\n          nTargetSpacing = 20 * nBaseTargetSpacing;\n\n        nTargetTimespan = nTargetSpacing * nIntervalLong;\n\n        /* The short averaging window */\n        const CBlockIndex* pindexShort = pindexPrev;\n        for(i = 0; i < nIntervalShort; i++) {\n            if(pindexShort->pprev)\n              pindexShort = GetLastBlockIndex(pindexShort->pprev, fProofOfStake);\n            else\n              return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanShort = (int64)pindexPrev->nTime - (int64)pindexShort->nTime;\n\n        /* The long averaging window */\n        const CBlockIndex* pindexLong = pindexShort;\n        for(i = 0; i < (nIntervalLong - nIntervalShort); i++) {\n           if(pindexLong->pprev)\n             pindexLong = GetLastBlockIndex(pindexLong->pprev, fProofOfStake);\n           else\n             return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanLong = (int64)pindexPrev->nTime - (int64)pindexLong->nTime;\n\n        /* Time warp protection */\n        nActualTimespanShort = max(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 3 / 4));\n        nActualTimespanShort = min(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 4 / 3));\n        nActualTimespanLong  = max(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 3 / 4));\n        nActualTimespanLong  = min(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 4 / 3));\n\n        /* The average of both windows */\n        nActualTimespanAvg = (nActualTimespanShort * (nIntervalLong / nIntervalShort) + nActualTimespanLong) / 2;\n\n        /* 0.25 damping */\n        nActualTimespan = nActualTimespanAvg + 3 * nTargetTimespan;\n        nActualTimespan /= 4;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: Last = %d, Prev = %d, Short = %d, Long = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexShort->nHeight, pindexLong->nHeight);\n            printf(\"RETARGET time stamps: Last = %u, Prev = %u, Short = %u, Long = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexShort->nTime, pindexLong->nTime);\n            printf(\"RETARGET windows: short = %\"PRI64d\" (%\"PRI64d\"), long = %\"PRI64d\", \"\n              \"average = %\"PRI64d\", damped = %\"PRI64d\"\\n\",\n              nActualTimespanShort, nActualTimespanShort * (nIntervalLong / nIntervalShort),\n              nActualTimespanLong, nActualTimespanAvg, nActualTimespan);\n        }\n\n        /* Difficulty limiters */\n        nActualTimespanMax = nTargetTimespan * 102 / 100;\n        nActualTimespanMin = nTargetTimespan * 100 / 101;\n        if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n        if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n        /* Retarget */\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= nActualTimespan;\n        bnNew /= nTargetTimespan;\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nActualTimespan = %\"PRI64d\", \"\n            \"nTargetTimespan / nActualTimespan = %.4f\\n\",\n            nTargetTimespan, nActualTimespan, (float)nTargetTimespan / (float)nActualTimespan);\n\n    }\n\n    if(fPrettyPrint) {\n        printf(\"Before: %08x  %s\\n\", pindexPrev->nBits,\n          CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str());\n        printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n    }\n\n    return(bnNew.GetCompact());\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.find",
          "args": [
            "hashPrevBlock"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hash"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nBestHeight = -1;\nuint256 hashBestChain = 0;\nextern enum Checkpoints::CPMode CheckpointsMode;\n\nCBlock {\n  bool CBlock::AcceptBlock()\n  {\n      // Check for duplicate\n      uint256 hash = GetHash();\n      if (mapBlockIndex.count(hash))\n          return error(\"AcceptBlock() : block already in mapBlockIndex\");\n  \n      // Get prev block index\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n      if (mi == mapBlockIndex.end())\n          return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n      CBlockIndex* pindexPrev = (*mi).second;\n      int nHeight = pindexPrev->nHeight+1;\n  \n      if(!fTestNet && IsProofOfWork()) {\n        if((nHeight > 20000) && (nHeight < nForkOne))\n          return DoS(100, error(\"AcceptBlock() : reject proof-of-work at height %d\", nHeight));\n      }\n  \n      // Check proof-of-work or proof-of-stake\n      if(nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake(), false))\n        return(DoS(100, error(\"AcceptBlock() : incorrect proof-of-%s difficulty\",\n          IsProofOfWork() ? \"work\" : \"stake\")));\n  \n      uint nOurTime = (uint)GetAdjustedTime();\n  \n      /* Check for time stamp (past limit #1) */\n      if(nTime <= (uint)pindexPrev->GetMedianTimePast())\n        return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp behind the median\",\n          hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n      if(fTestNet || (!fTestNet && (nHeight > nForkOne))) {\n  \n          /* Check for time stamp (future limit) */\n          if(nTime > (nOurTime + 5 * 60))\n            return(DoS(5, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the future\",\n              hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n          /* Basic block limiter */\n          if(nTime <= ((uint)pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))\n            return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the block limiter\",\n              hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n          /* Future travel detector for the block limiter */\n          if((nTime > (nOurTime + 120)) &&\n            ((pindexPrev->GetAverageTimePast(5, 40) + BLOCK_LIMITER_TIME) > nOurTime))\n            return(DoS(5, error(\"AcceptBlock() : block %s height %d rejected by the future travel detector\",\n              hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n      }\n  \n      /* Check for time stamp (past limit #2) */\n      if(nTime <= (pindexPrev->nTime - 10 * 60))\n        return(DoS(20, error(\"AcceptBlock() : block %s height %d has a time stamp too far in the past\",\n          hash.ToString().substr(0,20).c_str(), nHeight)));\n  \n      // Check that all transactions are finalized\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n          if (!tx.IsFinal(nHeight, GetBlockTime()))\n              return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n  \n      // Check that the block chain matches the known block chain up to a checkpoint\n      if (!Checkpoints::CheckHardened(nHeight, hash))\n          return DoS(100, error(\"AcceptBlock() : rejected by hardened checkpoint lock-in at %d\", nHeight));\n  \n      // Verify hash target and signature of coinstake tx\n      uint256 hashProofOfStake = 0, targetProofOfStake = 0;\n      if (IsProofOfStake())\n      {\n          if (!CheckProofOfStake(vtx[1], nBits, hashProofOfStake, targetProofOfStake))\n          {\n              printf(\"WARNING: ProcessBlock(): check proof-of-stake failed for block %s\\n\", hash.ToString().c_str());\n              return false; // do not error here as we expect this during initial block download\n          }\n      }\n  \n      bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);\n  \n      // Check that the block satisfies synchronized checkpoint\n      if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)\n          return error(\"AcceptBlock() : rejected by synchronized checkpoint\");\n  \n      if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)\n          strMiscWarning = _(\"WARNING: syncronized checkpoint violation detected, but skipped!\");\n  \n      // Enforce rule that the coinbase starts with serialized block height\n      CScript expect = CScript() << nHeight;\n      if (vtx[0].vin[0].scriptSig.size() < expect.size() ||\n          !std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))\n          return DoS(100, error(\"AcceptBlock() : block height mismatch in coinbase\"));\n  \n      /* Don't accept blocks with bogus version numbers after this point */\n      if(fTestNet || (!fTestNet && (nHeight >= nForkOne))) {\n          if(nVersion != 2)\n            return(DoS(100, error(\"AcceptBlock() : incorrect block version %u\", nVersion)));\n      }\n  \n      // Write block to history file\n      if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n          return error(\"AcceptBlock() : out of disk space\");\n      unsigned int nFile = -1;\n      unsigned int nBlockPos = 0;\n      if (!WriteToDisk(nFile, nBlockPos))\n          return error(\"AcceptBlock() : WriteToDisk failed\");\n      if (!AddToBlockIndex(nFile, nBlockPos, hashProofOfStake))\n          return error(\"AcceptBlock() : AddToBlockIndex failed\");\n  \n      // Relay inventory, but don't relay old inventory during initial block download\n      int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n      if (hashBestChain == hash)\n      {\n          LOCK(cs_vNodes);\n          BOOST_FOREACH(CNode* pnode, vNodes)\n              if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n                  pnode->PushInventory(CInv(MSG_BLOCK, hash));\n      }\n  \n      // ppcoin: check pending sync-checkpoint\n      Checkpoints::AcceptPendingSyncCheckpoint();\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "CheckBlock",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2101-2190",
    "snippet": "bool CBlock::CheckBlock() const {\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    if(IsProofOfWork()) {\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n    }\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n\n    if (IsProofOfStake())\n    {\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n        for (unsigned int i = 2; i < vtx.size(); i++)\n            if (vtx[i].IsCoinStake())\n                return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    return(true);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoS",
          "args": [
            "100",
            "error(\"CheckBlock() : out-of-bounds SigOpCount\")"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "DoS",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "865-865",
          "snippet": "bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckBlock() : out-of-bounds SigOpCount\""
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetLegacySigOpCount",
          "args": [],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "GetLegacySigOpCount",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "405-418",
          "snippet": "unsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  unsigned int\n  CTransaction::GetLegacySigOpCount() const\n  {\n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          nSigOps += txin.scriptSig.GetSigOpCount(false);\n      }\n      BOOST_FOREACH(const CTxOut& txout, vout)\n      {\n          nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n      }\n      return nSigOps;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx.size",
          "args": [],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uniqueTx.insert",
          "args": [
            "tx.GetHash()"
          ],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 2176
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildMerkleTree",
          "args": [],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "BuildMerkleTree",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1020-1037",
          "snippet": "uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 BuildMerkleTree() const\n      {\n          vMerkleTree.clear();\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              vMerkleTree.push_back(tx.GetHash());\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              for (int i = 0; i < nSize; i += 2)\n              {\n                  int i2 = std::min(i+1, nSize-1);\n                  vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                             BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n              }\n              j += nSize;\n          }\n          return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockTime",
          "args": [],
          "line": 2165
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.CheckTransaction",
          "args": [],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "CheckTransaction",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "478-527",
          "snippet": "bool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::CheckTransaction() const\n  {\n      // Basic checks that don't depend on any context\n      if (vin.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n      if (vout.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n      // Size limits\n      if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n  \n      // Check for negative or overflow output values\n      int64_t nValueOut = 0;\n      for (unsigned int i = 0; i < vout.size(); i++)\n      {\n          const CTxOut& txout = vout[i];\n          if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n          if (txout.nValue < 0)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n          if (txout.nValue > MAX_MONEY)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n          nValueOut += txout.nValue;\n          if (!MoneyRange(nValueOut))\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n      }\n  \n      // Check for duplicate inputs\n      set<COutPoint> vInOutPoints;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          if (vInOutPoints.count(txin.prevout))\n              return false;\n          vInOutPoints.insert(txin.prevout);\n      }\n  \n      if (IsCoinBase())\n      {\n          if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n      }\n      else\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (txin.prevout.IsNull())\n                  return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckBlockSignature",
          "args": [],
          "line": 2154
        },
        "resolved": true,
        "details": {
          "function_name": "CheckBlockSignature",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2565-2590",
          "snippet": "bool CBlock::CheckBlockSignature() const\n{\n    if (IsProofOfWork())\n        return vchBlockSig.empty();\n\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n\n    const CTxOut& txout = vtx[1].vout[1];\n\n    if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        valtype& vchPubKey = vSolutions[0];\n        CKey key;\n        if (!key.SetPubKey(vchPubKey))\n            return false;\n        if (vchBlockSig.empty())\n            return false;\n        return key.Verify(GetHash(), vchBlockSig);\n    }\n\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::CheckBlockSignature() const\n  {\n      if (IsProofOfWork())\n          return vchBlockSig.empty();\n  \n      vector<valtype> vSolutions;\n      txnouttype whichType;\n  \n      const CTxOut& txout = vtx[1].vout[1];\n  \n      if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n          return false;\n  \n      if (whichType == TX_PUBKEY)\n      {\n          valtype& vchPubKey = vSolutions[0];\n          CKey key;\n          if (!key.SetPubKey(vchPubKey))\n              return false;\n          if (vchBlockSig.empty())\n              return false;\n          return key.Verify(GetHash(), vchBlockSig);\n      }\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\"",
            "GetBlockTime()",
            "vtx[1].nTime"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckCoinStakeTimestamp",
          "args": [
            "GetBlockTime()",
            "(int64_t)vtx[1].nTime"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "CheckCoinStakeTimestamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "373-377",
          "snippet": "bool CheckCoinStakeTimestamp(int64_t nTimeBlock, int64_t nTimeTx)\n{\n    // v0.3 protocol\n    return (nTimeBlock == nTimeTx);\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool CheckCoinStakeTimestamp(int64_t nTimeBlock, int64_t nTimeTx)\n{\n    // v0.3 protocol\n    return (nTimeBlock == nTimeTx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx[i].IsCoinStake",
          "args": [],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx.empty",
          "args": [],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx[0].vout[0].IsEmpty",
          "args": [],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "IsEmpty",
          "container": "CTxOut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "387-390",
          "snippet": "bool IsEmpty() const\n    {\n        return (nValue == 0 && scriptPubKey.empty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxOut {\n  bool IsEmpty() const\n      {\n          return (nValue == 0 && scriptPubKey.empty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfStake",
          "args": [],
          "line": 2136
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "FutureDrift",
          "args": [
            "(int64_t)vtx[0].nTime"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "FutureDrift",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "64-64",
          "snippet": "inline int64_t FutureDrift(int64_t nTime) { return(nTime + 10 * 60); }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\ninline int64_t FutureDrift(int64_t nTime) { return(nTime + 10 * 60); }"
        }
      },
      {
        "call_info": {
          "callee": "vtx[i].IsCoinBase",
          "args": [],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckProofOfWork",
          "args": [
            "GetHashPoW()",
            "nBits"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "CheckProofOfWork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1198-1212",
          "snippet": "bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHashPoW",
          "args": [],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfWork",
          "args": [],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::GetSerializeSize",
          "args": [
            "*this",
            "SER_NETWORK",
            "PROTOCOL_VERSION"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "632-638",
          "snippet": "unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nunsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::CheckBlock() const {\n  \n      // These are checks that are independent of context\n      // that can be verified before saving an orphan block.\n  \n      // Size limits\n      if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CheckBlock() : size limits failed\"));\n  \n      if(IsProofOfWork()) {\n  \n          /* Proof-of-work verification against target */\n          if(!CheckProofOfWork(GetHashPoW(), nBits))\n            return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n  \n          /* Proof-of-work block signature verification */\n          if(!CheckBlockSignature())\n            return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n      }\n  \n      // Check timestamp\n      if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n          return error(\"CheckBlock() : block timestamp too far in the future\");\n  \n      // First transaction must be coinbase, the rest must not be\n      if (vtx.empty() || !vtx[0].IsCoinBase())\n          return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n      for (unsigned int i = 1; i < vtx.size(); i++)\n          if (vtx[i].IsCoinBase())\n              return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n  \n      // Check coinbase timestamp\n      if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n          return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n  \n      if (IsProofOfStake())\n      {\n          // Coinbase output should be empty if proof-of-stake block\n          if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n              return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n  \n          // Second transaction must be coinstake, the rest must not be\n          if (vtx.empty() || !vtx[1].IsCoinStake())\n              return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n          for (unsigned int i = 2; i < vtx.size(); i++)\n              if (vtx[i].IsCoinStake())\n                  return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n  \n          // Check coinstake timestamp\n          if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n              return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n  \n          // NovaCoin: check proof-of-stake block signature\n          if(!CheckBlockSignature())\n              return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n      }\n  \n      // Check transactions\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          if (!tx.CheckTransaction())\n              return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n  \n          // ppcoin: check transaction timestamp\n          if (GetBlockTime() < (int64_t)tx.nTime)\n              return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n      }\n  \n      /* Merkle root verification */\n      if(hashMerkleRoot != BuildMerkleTree())\n        return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n  \n      /* Check for duplicate transactions */\n      set<uint256> uniqueTx;\n      BOOST_FOREACH(const CTransaction& tx, vtx) {\n          uniqueTx.insert(tx.GetHash());\n      }\n      if(uniqueTx.size() != vtx.size())\n        return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n  \n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          nSigOps += tx.GetLegacySigOpCount();\n      }\n      if (nSigOps > MAX_BLOCK_SIGOPS)\n          return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n  \n      return(true);\n  }\n}"
  },
  {
    "function_name": "AddToBlockIndex",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2028-2096",
    "snippet": "bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n{\n    // Check for duplicate\n    uint256 hash = GetHash();\n    if (mapBlockIndex.count(hash))\n        return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n\n    // Construct new block index object\n    CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n    if (!pindexNew)\n        return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n    pindexNew->phashBlock = &hash;\n    map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n    if (miPrev != mapBlockIndex.end())\n    {\n        pindexNew->pprev = (*miPrev).second;\n        pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n    }\n\n    // ppcoin: compute chain trust score\n    pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n\n    // ppcoin: compute stake entropy bit for stake modifier\n    if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n        return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n\n    // ppcoin: record proof-of-stake hash value\n    pindexNew->hashProofOfStake = hashProofOfStake;\n\n    // ppcoin: compute stake modifier\n    uint64_t nStakeModifier = 0;\n    bool fGeneratedStakeModifier = false;\n    if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n        return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n    pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n    pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n    if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n        return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n\n    // Add to mapBlockIndex\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n    if (pindexNew->IsProofOfStake())\n        setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n    pindexNew->phashBlock = &((*mi).first);\n\n    // Write to disk block index\n    CTxDB txdb;\n    if (!txdb.TxnBegin())\n        return false;\n    txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n    if (!txdb.TxnCommit())\n        return false;\n\n    // New best\n    if (pindexNew->nChainTrust > nBestChainTrust)\n        if (!SetBestChain(txdb, pindexNew))\n            return false;\n\n    if (pindexNew == pindexBest)\n    {\n        // Notify UI to display prev block's coinbase if it was ours\n        static uint256 hashPrevBestCoinBase;\n        UpdatedTransaction(hashPrevBestCoinBase);\n        hashPrevBestCoinBase = vtx[0].GetHash();\n    }\n\n    uiInterface.NotifyBlocksChanged();\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "set<pair<COutPoint, unsigned int> > setStakeSeen;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "uint256 nBestChainTrust = 0;",
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "uiInterface.NotifyBlocksChanged",
          "args": [],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtx[0].GetHash",
          "args": [],
          "line": 2091
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "UpdatedTransaction",
          "args": [
            "hashPrevBestCoinBase"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "UpdatedTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "172-176",
          "snippet": "void static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetBestChain",
          "args": [
            "txdb",
            "pindexNew"
          ],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChain",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1854-1953",
          "snippet": "bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexGenesisBlock = NULL;",
            "int nBestHeight = -1;",
            "uint256 nBestChainTrust = 0;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;",
            "int64_t nTimeBestReceived = 0;",
            "static CBlockIndex* pblockindexFBBHLast;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nuint256 nBestChainTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\nstatic CBlockIndex* pblockindexFBBHLast;\n\nCBlock {\n  bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      if (!txdb.TxnBegin())\n          return error(\"SetBestChain() : TxnBegin failed\");\n  \n      if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n      {\n          txdb.WriteHashBestChain(hash);\n          if (!txdb.TxnCommit())\n              return error(\"SetBestChain() : TxnCommit failed\");\n          pindexGenesisBlock = pindexNew;\n      }\n      else if (hashPrevBlock == hashBestChain)\n      {\n          if (!SetBestChainInner(txdb, pindexNew))\n              return error(\"SetBestChain() : SetBestChainInner failed\");\n      }\n      else\n      {\n          // the first block in the new chain that will cause it to become the new best chain\n          CBlockIndex *pindexIntermediate = pindexNew;\n  \n          // list of blocks that need to be connected afterwards\n          std::vector<CBlockIndex*> vpindexSecondary;\n  \n          // Reorganize is costly in terms of db load, as it works in a single db transaction.\n          // Try to limit how much needs to be done inside\n          while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n          {\n              vpindexSecondary.push_back(pindexIntermediate);\n              pindexIntermediate = pindexIntermediate->pprev;\n          }\n  \n          if (!vpindexSecondary.empty())\n              printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n  \n          // Switch to new best branch\n          if (!Reorganize(txdb, pindexIntermediate))\n          {\n              txdb.TxnAbort();\n              InvalidChainFound(pindexNew);\n              return error(\"SetBestChain() : Reorganize failed\");\n          }\n  \n          // Connect further blocks\n          BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n          {\n              CBlock block;\n              if (!block.ReadFromDisk(pindex))\n              {\n                  printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                  break;\n              }\n              if (!txdb.TxnBegin()) {\n                  printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                  break;\n              }\n              // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n              if (!block.SetBestChainInner(txdb, pindex))\n                  break;\n          }\n      }\n  \n      // Update best block in wallet (so we can detect restored wallets)\n      bool fIsInitialDownload = IsInitialBlockDownload();\n      if (!fIsInitialDownload)\n      {\n          const CBlockLocator locator(pindexNew);\n          ::SetBestChain(locator);\n      }\n  \n      // New best block\n      hashBestChain = hash;\n      pindexBest = pindexNew;\n      pblockindexFBBHLast = NULL;\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexNew->nChainTrust;\n      nTimeBestReceived = GetTime();\n      nTransactionsUpdated++;\n  \n      uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n  \n      printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n        CBigNum(nBestChainTrust).ToString().c_str(),\n        nBestBlockTrust.Get64(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      std::string strCmd = GetArg(\"-blocknotify\", \"\");\n  \n      if (!fIsInitialDownload && !strCmd.empty())\n      {\n          boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n          boost::thread t(runCommand, strCmd); // thread runs free\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnCommit",
          "args": [],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "TxnCommit",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "282-289",
          "snippet": "bool TxnCommit()\n    {\n        if (!pdb || !activeTxn)\n            return false;\n        int ret = activeTxn->commit(0);\n        activeTxn = NULL;\n        return (ret == 0);\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnCommit()\n      {\n          if (!pdb || !activeTxn)\n              return false;\n          int ret = activeTxn->commit(0);\n          activeTxn = NULL;\n          return (ret == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteBlockIndex",
          "args": [
            "CDiskBlockIndex(pindexNew)"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "WriteBlockIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "262-265",
          "snippet": "bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n{\n    return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n  {\n      return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CDiskBlockIndex",
          "args": [
            "pindexNew"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "if",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1482-1487",
          "snippet": "else if (fRead)\n        {\n            const_cast<CDiskBlockIndex*>(this)->prevoutStake.SetNull();\n            const_cast<CDiskBlockIndex*>(this)->nStakeTime = 0;\n            const_cast<CDiskBlockIndex*>(this)->hashProofOfStake = 0;\n        }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  else if (fRead)\n          {\n              const_cast<CDiskBlockIndex*>(this)->prevoutStake.SetNull();\n              const_cast<CDiskBlockIndex*>(this)->nStakeTime = 0;\n              const_cast<CDiskBlockIndex*>(this)->hashProofOfStake = 0;\n          }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnBegin",
          "args": [],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "TxnBegin",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "271-280",
          "snippet": "bool TxnBegin()\n    {\n        if (!pdb || activeTxn)\n            return false;\n        DbTxn* ptxn = bitdb.TxnBegin();\n        if (!ptxn)\n            return false;\n        activeTxn = ptxn;\n        return true;\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnBegin()\n      {\n          if (!pdb || activeTxn)\n              return false;\n          DbTxn* ptxn = bitdb.TxnBegin();\n          if (!ptxn)\n              return false;\n          activeTxn = ptxn;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setStakeSeen.insert",
          "args": [
            "make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime)"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "pindexNew->prevoutStake",
            "pindexNew->nStakeTime"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindexNew->IsProofOfStake",
          "args": [],
          "line": 2069
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "hash",
            "pindexNew"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64",
            "pindexNew->nHeight",
            "nStakeModifier"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckStakeModifierCheckpoints",
          "args": [
            "pindexNew->nHeight",
            "pindexNew->nStakeModifierChecksum"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "CheckStakeModifierCheckpoints",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "394-401",
          "snippet": "bool CheckStakeModifierCheckpoints(int nHeight, unsigned int nStakeModifierChecksum)\n{\n    MapModifierCheckpoints& checkpoints = (fTestNet ? mapStakeModifierCheckpointsTestNet : mapStakeModifierCheckpoints);\n\n    if (checkpoints.count(nHeight))\n        return nStakeModifierChecksum == checkpoints[nHeight];\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "static std::map<int, unsigned int> mapStakeModifierCheckpoints =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;",
            "static std::map<int, unsigned int> mapStakeModifierCheckpointsTestNet =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nstatic std::map<int, unsigned int> mapStakeModifierCheckpoints =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;\nstatic std::map<int, unsigned int> mapStakeModifierCheckpointsTestNet =\n    boost::assign::map_list_of\n        ( 0, 0x0e00670bu )\n    ;\n\nbool CheckStakeModifierCheckpoints(int nHeight, unsigned int nStakeModifierChecksum)\n{\n    MapModifierCheckpoints& checkpoints = (fTestNet ? mapStakeModifierCheckpointsTestNet : mapStakeModifierCheckpoints);\n\n    if (checkpoints.count(nHeight))\n        return nStakeModifierChecksum == checkpoints[nHeight];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetStakeModifierChecksum",
          "args": [
            "pindexNew"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeModifierChecksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "380-391",
          "snippet": "unsigned int GetStakeModifierChecksum(const CBlockIndex* pindex)\n{\n    assert (pindex->pprev || pindex->GetBlockHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n    // Hash previous checksum with flags, hashProofOfStake and nStakeModifier\n    CDataStream ss(SER_GETHASH, 0);\n    if (pindex->pprev)\n        ss << pindex->pprev->nStakeModifierChecksum;\n    ss << pindex->nFlags << pindex->hashProofOfStake << pindex->nStakeModifier;\n    uint256 hashChecksum = Hash(ss.begin(), ss.end());\n    hashChecksum >>= (256 - 32);\n    return hashChecksum.Get64();\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nunsigned int GetStakeModifierChecksum(const CBlockIndex* pindex)\n{\n    assert (pindex->pprev || pindex->GetBlockHash() == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet));\n    // Hash previous checksum with flags, hashProofOfStake and nStakeModifier\n    CDataStream ss(SER_GETHASH, 0);\n    if (pindex->pprev)\n        ss << pindex->pprev->nStakeModifierChecksum;\n    ss << pindex->nFlags << pindex->hashProofOfStake << pindex->nStakeModifier;\n    uint256 hashChecksum = Hash(ss.begin(), ss.end());\n    hashChecksum >>= (256 - 32);\n    return hashChecksum.Get64();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexNew->SetStakeModifier",
          "args": [
            "nStakeModifier",
            "fGeneratedStakeModifier"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "SetStakeModifier",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1412-1417",
          "snippet": "void SetStakeModifier(uint64_t nModifier, bool fGeneratedStakeModifier)\n    {\n        nStakeModifier = nModifier;\n        if (fGeneratedStakeModifier)\n            nFlags |= BLOCK_STAKE_MODIFIER;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  void SetStakeModifier(uint64_t nModifier, bool fGeneratedStakeModifier)\n      {\n          nStakeModifier = nModifier;\n          if (fGeneratedStakeModifier)\n              nFlags |= BLOCK_STAKE_MODIFIER;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AddToBlockIndex() : ComputeNextStakeModifier() failed\""
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ComputeNextStakeModifier",
          "args": [
            "pindexNew->pprev",
            "nStakeModifier",
            "fGeneratedStakeModifier"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "ComputeNextStakeModifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/kernel.cpp",
          "lines": "138-223",
          "snippet": "bool ComputeNextStakeModifier(const CBlockIndex* pindexPrev, uint64_t& nStakeModifier, bool& fGeneratedStakeModifier)\n{\n    nStakeModifier = 0;\n    fGeneratedStakeModifier = false;\n    if (!pindexPrev)\n    {\n        fGeneratedStakeModifier = true;\n        return true;  // genesis block's modifier is 0\n    }\n    // First find current stake modifier and its generation block time\n    // if it's not old enough, return the same stake modifier\n    int64_t nModifierTime = 0;\n    if (!GetLastStakeModifier(pindexPrev, nStakeModifier, nModifierTime))\n        return error(\"ComputeNextStakeModifier: unable to get last modifier\");\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: prev modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifier, DateTimeStrFormat(nModifierTime).c_str());\n    }\n    if (nModifierTime / nModifierInterval >= pindexPrev->GetBlockTime() / nModifierInterval)\n        return true;\n\n    // Sort candidate blocks by timestamp\n    vector<pair<int64_t, uint256> > vSortedByTimestamp;\n    vSortedByTimestamp.reserve(64 * nModifierInterval / 2 * nBaseTargetSpacing);\n    int64_t nSelectionInterval = GetStakeModifierSelectionInterval();\n    int64_t nSelectionIntervalStart = (pindexPrev->GetBlockTime() / nModifierInterval) * nModifierInterval - nSelectionInterval;\n    const CBlockIndex* pindex = pindexPrev;\n    while (pindex && pindex->GetBlockTime() >= nSelectionIntervalStart)\n    {\n        vSortedByTimestamp.push_back(make_pair(pindex->GetBlockTime(), pindex->GetBlockHash()));\n        pindex = pindex->pprev;\n    }\n    int nHeightFirstCandidate = pindex ? (pindex->nHeight + 1) : 0;\n    reverse(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n    sort(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n\n    // Select 64 blocks from candidate blocks to generate stake modifier\n    uint64_t nStakeModifierNew = 0;\n    int64_t nSelectionIntervalStop = nSelectionIntervalStart;\n    map<uint256, const CBlockIndex*> mapSelectedBlocks;\n    for (int nRound=0; nRound<min(64, (int)vSortedByTimestamp.size()); nRound++)\n    {\n        // add an interval section to the current selection round\n        nSelectionIntervalStop += GetStakeModifierSelectionIntervalSection(nRound);\n        // select a block from the candidates of current round\n        if (!SelectBlockFromCandidates(vSortedByTimestamp, mapSelectedBlocks, nSelectionIntervalStop, nStakeModifier, &pindex))\n            return error(\"ComputeNextStakeModifier: unable to select block at round %d\", nRound);\n        // write the entropy bit of the selected block\n        nStakeModifierNew |= (((uint64_t)pindex->GetStakeEntropyBit()) << nRound);\n        // add the selected block from candidates to selected list\n        mapSelectedBlocks.insert(make_pair(pindex->GetBlockHash(), pindex));\n        if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n            printf(\"ComputeNextStakeModifier: selected round %d stop=%s height=%d bit=%d\\n\", nRound, DateTimeStrFormat(nSelectionIntervalStop).c_str(), pindex->nHeight, pindex->GetStakeEntropyBit());\n    }\n\n    // Print selection map for visualization of the selected blocks\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n    {\n        string strSelectionMap = \"\";\n        // '-' indicates proof-of-work blocks not selected\n        strSelectionMap.insert(0, pindexPrev->nHeight - nHeightFirstCandidate + 1, '-');\n        pindex = pindexPrev;\n        while (pindex && pindex->nHeight >= nHeightFirstCandidate)\n        {\n            // '=' indicates proof-of-stake blocks not selected\n            if (pindex->IsProofOfStake())\n                strSelectionMap.replace(pindex->nHeight - nHeightFirstCandidate, 1, \"=\");\n            pindex = pindex->pprev;\n        }\n        BOOST_FOREACH(const PAIRTYPE(uint256, const CBlockIndex*)& item, mapSelectedBlocks)\n        {\n            // 'S' indicates selected proof-of-stake blocks\n            // 'W' indicates selected proof-of-work blocks\n            strSelectionMap.replace(item.second->nHeight - nHeightFirstCandidate, 1, item.second->IsProofOfStake()? \"S\" : \"W\");\n        }\n        printf(\"ComputeNextStakeModifier: selection height [%d, %d] map %s\\n\", nHeightFirstCandidate, pindexPrev->nHeight, strSelectionMap.c_str());\n    }\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: new modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifierNew, DateTimeStrFormat(pindexPrev->GetBlockTime()).c_str());\n    }\n\n    nStakeModifier = nStakeModifierNew;\n    fGeneratedStakeModifier = true;\n    return true;\n}",
          "includes": [
            "#include \"txdb.h\"",
            "#include \"kernel.h\"",
            "#include <boost/assign/list_of.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"txdb.h\"\n#include \"kernel.h\"\n#include <boost/assign/list_of.hpp>\n\nbool ComputeNextStakeModifier(const CBlockIndex* pindexPrev, uint64_t& nStakeModifier, bool& fGeneratedStakeModifier)\n{\n    nStakeModifier = 0;\n    fGeneratedStakeModifier = false;\n    if (!pindexPrev)\n    {\n        fGeneratedStakeModifier = true;\n        return true;  // genesis block's modifier is 0\n    }\n    // First find current stake modifier and its generation block time\n    // if it's not old enough, return the same stake modifier\n    int64_t nModifierTime = 0;\n    if (!GetLastStakeModifier(pindexPrev, nStakeModifier, nModifierTime))\n        return error(\"ComputeNextStakeModifier: unable to get last modifier\");\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: prev modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifier, DateTimeStrFormat(nModifierTime).c_str());\n    }\n    if (nModifierTime / nModifierInterval >= pindexPrev->GetBlockTime() / nModifierInterval)\n        return true;\n\n    // Sort candidate blocks by timestamp\n    vector<pair<int64_t, uint256> > vSortedByTimestamp;\n    vSortedByTimestamp.reserve(64 * nModifierInterval / 2 * nBaseTargetSpacing);\n    int64_t nSelectionInterval = GetStakeModifierSelectionInterval();\n    int64_t nSelectionIntervalStart = (pindexPrev->GetBlockTime() / nModifierInterval) * nModifierInterval - nSelectionInterval;\n    const CBlockIndex* pindex = pindexPrev;\n    while (pindex && pindex->GetBlockTime() >= nSelectionIntervalStart)\n    {\n        vSortedByTimestamp.push_back(make_pair(pindex->GetBlockTime(), pindex->GetBlockHash()));\n        pindex = pindex->pprev;\n    }\n    int nHeightFirstCandidate = pindex ? (pindex->nHeight + 1) : 0;\n    reverse(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n    sort(vSortedByTimestamp.begin(), vSortedByTimestamp.end());\n\n    // Select 64 blocks from candidate blocks to generate stake modifier\n    uint64_t nStakeModifierNew = 0;\n    int64_t nSelectionIntervalStop = nSelectionIntervalStart;\n    map<uint256, const CBlockIndex*> mapSelectedBlocks;\n    for (int nRound=0; nRound<min(64, (int)vSortedByTimestamp.size()); nRound++)\n    {\n        // add an interval section to the current selection round\n        nSelectionIntervalStop += GetStakeModifierSelectionIntervalSection(nRound);\n        // select a block from the candidates of current round\n        if (!SelectBlockFromCandidates(vSortedByTimestamp, mapSelectedBlocks, nSelectionIntervalStop, nStakeModifier, &pindex))\n            return error(\"ComputeNextStakeModifier: unable to select block at round %d\", nRound);\n        // write the entropy bit of the selected block\n        nStakeModifierNew |= (((uint64_t)pindex->GetStakeEntropyBit()) << nRound);\n        // add the selected block from candidates to selected list\n        mapSelectedBlocks.insert(make_pair(pindex->GetBlockHash(), pindex));\n        if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n            printf(\"ComputeNextStakeModifier: selected round %d stop=%s height=%d bit=%d\\n\", nRound, DateTimeStrFormat(nSelectionIntervalStop).c_str(), pindex->nHeight, pindex->GetStakeEntropyBit());\n    }\n\n    // Print selection map for visualization of the selected blocks\n    if (fDebug && GetBoolArg(\"-printstakemodifier\"))\n    {\n        string strSelectionMap = \"\";\n        // '-' indicates proof-of-work blocks not selected\n        strSelectionMap.insert(0, pindexPrev->nHeight - nHeightFirstCandidate + 1, '-');\n        pindex = pindexPrev;\n        while (pindex && pindex->nHeight >= nHeightFirstCandidate)\n        {\n            // '=' indicates proof-of-stake blocks not selected\n            if (pindex->IsProofOfStake())\n                strSelectionMap.replace(pindex->nHeight - nHeightFirstCandidate, 1, \"=\");\n            pindex = pindex->pprev;\n        }\n        BOOST_FOREACH(const PAIRTYPE(uint256, const CBlockIndex*)& item, mapSelectedBlocks)\n        {\n            // 'S' indicates selected proof-of-stake blocks\n            // 'W' indicates selected proof-of-work blocks\n            strSelectionMap.replace(item.second->nHeight - nHeightFirstCandidate, 1, item.second->IsProofOfStake()? \"S\" : \"W\");\n        }\n        printf(\"ComputeNextStakeModifier: selection height [%d, %d] map %s\\n\", nHeightFirstCandidate, pindexPrev->nHeight, strSelectionMap.c_str());\n    }\n    if (fDebug)\n    {\n        printf(\"ComputeNextStakeModifier: new modifier=0x%016\"PRIx64\" time=%s\\n\", nStakeModifierNew, DateTimeStrFormat(pindexPrev->GetBlockTime()).c_str());\n    }\n\n    nStakeModifier = nStakeModifierNew;\n    fGeneratedStakeModifier = true;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexNew->SetStakeEntropyBit",
          "args": [
            "GetStakeEntropyBit()"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "SetStakeEntropyBit",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1399-1405",
          "snippet": "bool SetStakeEntropyBit(unsigned int nEntropyBit)\n    {\n        if (nEntropyBit > 1)\n            return false;\n        nFlags |= (nEntropyBit? BLOCK_STAKE_ENTROPY : 0);\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool SetStakeEntropyBit(unsigned int nEntropyBit)\n      {\n          if (nEntropyBit > 1)\n              return false;\n          nFlags |= (nEntropyBit? BLOCK_STAKE_ENTROPY : 0);\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetStakeEntropyBit",
          "args": [],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "GetStakeEntropyBit",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1394-1397",
          "snippet": "unsigned int GetStakeEntropyBit() const\n    {\n        return ((nFlags & BLOCK_STAKE_ENTROPY) >> 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  unsigned int GetStakeEntropyBit() const\n      {\n          return ((nFlags & BLOCK_STAKE_ENTROPY) >> 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexNew->GetBlockTrust",
          "args": [],
          "line": 2048
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTrust",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2317-2414",
          "snippet": "uint256 CBlockIndex::GetBlockTrust() const {\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    if(bnTarget <= 0) return(0);\n\n    /* Old protocol */\n\n    if(!fTestNet && (nHeight < nForkOne))\n      return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n\n    /* New protocol: 80% PoS, 20% PoW */\n\n    uint256 nBlockTrust = 1;\n\n    if(IsProofOfWork()) {\n\n        uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n        uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n\n        /* The minimal PoW trust score prior to correction */\n        if(nPoWTrust < 4) nPoWTrust = 4;\n\n        /* Fixed trust for the first 10 blocks */\n        if((pprev == NULL) || (pprev->nHeight < 10))\n          return(nPoWTrust);\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n\n        if(pindexP1->IsProofOfStake()) {\n            /* 100% trust for PoW following PoS */\n            nBlockTrust = nPoWTrust;\n        } else {\n            if(pindexP2->IsProofOfStake()) {\n                /* 50% trust for PoS->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 1);\n            } else {\n                /* 25% trust for PoW->PoW->PoW */\n                nBlockTrust = (nPoWTrust >> 2);\n            }\n        }\n\n    } else {\n\n        const CBlockIndex* pindexP1 = pprev;\n        const CBlockIndex* pindexP2 = pindexP1->pprev;\n        const CBlockIndex* pindexP3 = pindexP2->pprev;\n\n        /* PoS difficulty is very low and of little use for trust scoring;\n         * use full trust of the previous PoW block as a basis instead */\n        uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n\n        if(pindexP1->IsProofOfWork()) {\n            /* 200% trust for PoS following PoW */\n            if(pindexP2->IsProofOfStake()) {\n                /* PoS->PoW->PoS: 100% to 200% */\n                nBlockTrust = (nPrevTrust << 1);\n            } else {\n                if(pindexP3->IsProofOfStake()) {\n                    /* PoS->PoW->PoW->PoS: 50% to 200% */\n                    nBlockTrust = (nPrevTrust << 2);\n                } else {\n                    /* PoW->PoW->PoW->PoS: 25% to 200% */\n                    nBlockTrust = (nPrevTrust << 3);\n                }\n            }\n        } else {\n            if(pindexP2->IsProofOfWork()) {\n                /* 150% of trust for PoW->PoS->PoS */\n                nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n            } else {\n                if(pindexP3->IsProofOfWork()) {\n                    /* 120% of trust for PoW->PoS->PoS->PoS */\n                    nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                } else {\n                    const CBlockIndex* pindexP4 = pindexP3->pprev;\n                    if(pindexP4->IsProofOfWork()) {\n                        /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                        nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                    } else {\n                        const CBlockIndex* pindexP5 = pindexP4->pprev;\n                        if(pindexP5->IsProofOfWork()) {\n                            /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = (nPrevTrust >> 1);\n                        } else {\n                            /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                            nBlockTrust = nPrevTrust;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    return(nBlockTrust);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlockIndex {\n  uint256 CBlockIndex::GetBlockTrust() const {\n      CBigNum bnTarget;\n      bnTarget.SetCompact(nBits);\n  \n      if(bnTarget <= 0) return(0);\n  \n      /* Old protocol */\n  \n      if(!fTestNet && (nHeight < nForkOne))\n        return(((CBigNum(1) << 256) / (bnTarget + 1)).getuint256());\n  \n      /* New protocol: 80% PoS, 20% PoW */\n  \n      uint256 nBlockTrust = 1;\n  \n      if(IsProofOfWork()) {\n  \n          uint256 nPoWBase  = uint256(\"0x00000000FFFF0000000000000000000000000000000000000000000000000000\");\n          uint256 nPoWTrust = (CBigNum(nPoWBase) / (bnTarget + 1)).getuint256();\n  \n          /* The minimal PoW trust score prior to correction */\n          if(nPoWTrust < 4) nPoWTrust = 4;\n  \n          /* Fixed trust for the first 10 blocks */\n          if((pprev == NULL) || (pprev->nHeight < 10))\n            return(nPoWTrust);\n  \n          const CBlockIndex* pindexP1 = pprev;\n          const CBlockIndex* pindexP2 = pindexP1->pprev;\n  \n          if(pindexP1->IsProofOfStake()) {\n              /* 100% trust for PoW following PoS */\n              nBlockTrust = nPoWTrust;\n          } else {\n              if(pindexP2->IsProofOfStake()) {\n                  /* 50% trust for PoS->PoW->PoW */\n                  nBlockTrust = (nPoWTrust >> 1);\n              } else {\n                  /* 25% trust for PoW->PoW->PoW */\n                  nBlockTrust = (nPoWTrust >> 2);\n              }\n          }\n  \n      } else {\n  \n          const CBlockIndex* pindexP1 = pprev;\n          const CBlockIndex* pindexP2 = pindexP1->pprev;\n          const CBlockIndex* pindexP3 = pindexP2->pprev;\n  \n          /* PoS difficulty is very low and of little use for trust scoring;\n           * use full trust of the previous PoW block as a basis instead */\n          uint256 nPrevTrust = pindexP1->nChainTrust - pindexP2->nChainTrust;\n  \n          if(pindexP1->IsProofOfWork()) {\n              /* 200% trust for PoS following PoW */\n              if(pindexP2->IsProofOfStake()) {\n                  /* PoS->PoW->PoS: 100% to 200% */\n                  nBlockTrust = (nPrevTrust << 1);\n              } else {\n                  if(pindexP3->IsProofOfStake()) {\n                      /* PoS->PoW->PoW->PoS: 50% to 200% */\n                      nBlockTrust = (nPrevTrust << 2);\n                  } else {\n                      /* PoW->PoW->PoW->PoS: 25% to 200% */\n                      nBlockTrust = (nPrevTrust << 3);\n                  }\n              }\n          } else {\n              if(pindexP2->IsProofOfWork()) {\n                  /* 150% of trust for PoW->PoS->PoS */\n                  nBlockTrust = (CBigNum(nPrevTrust) * 3 / 4).getuint256();\n              } else {\n                  if(pindexP3->IsProofOfWork()) {\n                      /* 120% of trust for PoW->PoS->PoS->PoS */\n                      nBlockTrust = (CBigNum(nPrevTrust) * 4 / 5).getuint256();\n                  } else {\n                      const CBlockIndex* pindexP4 = pindexP3->pprev;\n                      if(pindexP4->IsProofOfWork()) {\n                          /* 100% of trust for PoW->PoS->PoS->PoS->PoS */\n                          nBlockTrust = (CBigNum(nPrevTrust) * 5 / 6).getuint256();\n                      } else {\n                          const CBlockIndex* pindexP5 = pindexP4->pprev;\n                          if(pindexP5->IsProofOfWork()) {\n                              /* 50% of trust for PoW->PoS->PoS->PoS->PoS->PoS */\n                              nBlockTrust = (nPrevTrust >> 1);\n                          } else {\n                              /* 50% of trust for PoS->PoS->PoS->PoS->PoS->PoS */\n                              nBlockTrust = nPrevTrust;\n                          }\n                      }\n                  }\n              }\n          }\n  \n      }\n  \n      return(nBlockTrust);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.find",
          "args": [
            "hashPrevBlock"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"AddToBlockIndex() : %s already exists\"",
            "hash.ToString().substr(0,20).c_str()"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [
            "0",
            "20"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.count",
          "args": [
            "hash"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nset<pair<COutPoint, unsigned int> > setStakeSeen;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nuint256 nBestChainTrust = 0;\nCBlockIndex* pindexBest = NULL;\n\nCBlock {\n  bool CBlock::AddToBlockIndex(unsigned int nFile, unsigned int nBlockPos, const uint256& hashProofOfStake)\n  {\n      // Check for duplicate\n      uint256 hash = GetHash();\n      if (mapBlockIndex.count(hash))\n          return error(\"AddToBlockIndex() : %s already exists\", hash.ToString().substr(0,20).c_str());\n  \n      // Construct new block index object\n      CBlockIndex* pindexNew = new CBlockIndex(nFile, nBlockPos, *this);\n      if (!pindexNew)\n          return error(\"AddToBlockIndex() : new CBlockIndex failed\");\n      pindexNew->phashBlock = &hash;\n      map<uint256, CBlockIndex*>::iterator miPrev = mapBlockIndex.find(hashPrevBlock);\n      if (miPrev != mapBlockIndex.end())\n      {\n          pindexNew->pprev = (*miPrev).second;\n          pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n      }\n  \n      // ppcoin: compute chain trust score\n      pindexNew->nChainTrust = (pindexNew->pprev ? pindexNew->pprev->nChainTrust : 0) + pindexNew->GetBlockTrust();\n  \n      // ppcoin: compute stake entropy bit for stake modifier\n      if (!pindexNew->SetStakeEntropyBit(GetStakeEntropyBit()))\n          return error(\"AddToBlockIndex() : SetStakeEntropyBit() failed\");\n  \n      // ppcoin: record proof-of-stake hash value\n      pindexNew->hashProofOfStake = hashProofOfStake;\n  \n      // ppcoin: compute stake modifier\n      uint64_t nStakeModifier = 0;\n      bool fGeneratedStakeModifier = false;\n      if (!ComputeNextStakeModifier(pindexNew->pprev, nStakeModifier, fGeneratedStakeModifier))\n          return error(\"AddToBlockIndex() : ComputeNextStakeModifier() failed\");\n      pindexNew->SetStakeModifier(nStakeModifier, fGeneratedStakeModifier);\n      pindexNew->nStakeModifierChecksum = GetStakeModifierChecksum(pindexNew);\n      if (!CheckStakeModifierCheckpoints(pindexNew->nHeight, pindexNew->nStakeModifierChecksum))\n          return error(\"AddToBlockIndex() : Rejected by stake modifier checkpoint height=%d, modifier=0x%016\"PRIx64, pindexNew->nHeight, nStakeModifier);\n  \n      // Add to mapBlockIndex\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.insert(make_pair(hash, pindexNew)).first;\n      if (pindexNew->IsProofOfStake())\n          setStakeSeen.insert(make_pair(pindexNew->prevoutStake, pindexNew->nStakeTime));\n      pindexNew->phashBlock = &((*mi).first);\n  \n      // Write to disk block index\n      CTxDB txdb;\n      if (!txdb.TxnBegin())\n          return false;\n      txdb.WriteBlockIndex(CDiskBlockIndex(pindexNew));\n      if (!txdb.TxnCommit())\n          return false;\n  \n      // New best\n      if (pindexNew->nChainTrust > nBestChainTrust)\n          if (!SetBestChain(txdb, pindexNew))\n              return false;\n  \n      if (pindexNew == pindexBest)\n      {\n          // Notify UI to display prev block's coinbase if it was ours\n          static uint256 hashPrevBestCoinBase;\n          UpdatedTransaction(hashPrevBestCoinBase);\n          hashPrevBestCoinBase = vtx[0].GetHash();\n      }\n  \n      uiInterface.NotifyBlocksChanged();\n      return true;\n  }\n}"
  },
  {
    "function_name": "GetCoinAge",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "2004-2026",
    "snippet": "bool CBlock::GetCoinAge(uint64_t& nCoinAge) const\n{\n    nCoinAge = 0;\n\n    CTxDB txdb(\"r\");\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        uint64_t nTxCoinAge;\n        if (tx.GetCoinAge(txdb, nTxCoinAge))\n            nCoinAge += nTxCoinAge;\n        else\n            return false;\n    }\n\n    if (nCoinAge == 0) // block coin age minimum 1 coin-day\n        nCoinAge = 1;\n\n    /* Might overflow */\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"block nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"block nCoinAge=%\"PRIu64\"\\n\"",
            "nCoinAge"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinage\""
          ],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetCoinAge",
          "args": [
            "txdb",
            "nTxCoinAge"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "GetCoinAge",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1962-2001",
          "snippet": "bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n{\n    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n    nCoinAge = 0;\n\n    if (IsCoinBase())\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // First try finding the previous transaction in database\n        CTransaction txPrev;\n        CTxIndex txindex;\n        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n            continue;  // previous transaction not in main chain\n        if (nTime < txPrev.nTime)\n            return false;  // Transaction timestamp violation\n\n        // Read block header\n        CBlock block;\n        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n            return false; // unable to read block of previous transaction\n        if (block.GetBlockTime() + nStakeMinAge > nTime)\n            continue; // only count coins meeting min age requirement\n\n        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n\n        if(fDebug && GetBoolArg(\"-printcoinage\"))\n          printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n            nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n    }\n\n    CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n    nCoinAge = bnCoinDay.getuint64();\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint nStakeMinAge = 60 * 60 * 12;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nuint nStakeMinAge = 60 * 60 * 12;\n\nCTransaction {\n  bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n  {\n      CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n      nCoinAge = 0;\n  \n      if (IsCoinBase())\n          return true;\n  \n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          // First try finding the previous transaction in database\n          CTransaction txPrev;\n          CTxIndex txindex;\n          if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n              continue;  // previous transaction not in main chain\n          if (nTime < txPrev.nTime)\n              return false;  // Transaction timestamp violation\n  \n          // Read block header\n          CBlock block;\n          if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n              return false; // unable to read block of previous transaction\n          if (block.GetBlockTime() + nStakeMinAge > nTime)\n              continue; // only count coins meeting min age requirement\n  \n          int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n          bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n  \n          if(fDebug && GetBoolArg(\"-printcoinage\"))\n            printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n              nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n      }\n  \n      CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n      nCoinAge = bnCoinDay.getuint64();\n      if(fDebug && GetBoolArg(\"-printcoinage\"))\n        printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n  \n      return(true);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::GetCoinAge(uint64_t& nCoinAge) const\n  {\n      nCoinAge = 0;\n  \n      CTxDB txdb(\"r\");\n      BOOST_FOREACH(const CTransaction& tx, vtx)\n      {\n          uint64_t nTxCoinAge;\n          if (tx.GetCoinAge(txdb, nTxCoinAge))\n              nCoinAge += nTxCoinAge;\n          else\n              return false;\n      }\n  \n      if (nCoinAge == 0) // block coin age minimum 1 coin-day\n          nCoinAge = 1;\n  \n      /* Might overflow */\n      if(fDebug && GetBoolArg(\"-printcoinage\"))\n        printf(\"block nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n  \n      return(true);\n  }\n}"
  },
  {
    "function_name": "GetCoinAge",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1962-2001",
    "snippet": "bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n{\n    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n    nCoinAge = 0;\n\n    if (IsCoinBase())\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // First try finding the previous transaction in database\n        CTransaction txPrev;\n        CTxIndex txindex;\n        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n            continue;  // previous transaction not in main chain\n        if (nTime < txPrev.nTime)\n            return false;  // Transaction timestamp violation\n\n        // Read block header\n        CBlock block;\n        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n            return false; // unable to read block of previous transaction\n        if (block.GetBlockTime() + nStakeMinAge > nTime)\n            continue; // only count coins meeting min age requirement\n\n        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n\n        if(fDebug && GetBoolArg(\"-printcoinage\"))\n          printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n            nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n    }\n\n    CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n    nCoinAge = bnCoinDay.getuint64();\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint nStakeMinAge = 60 * 60 * 12;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"coin age nCoinAge=%\"PRIu64\"\\n\"",
            "nCoinAge"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinage\""
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bnCoinDay.getuint64",
          "args": [],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "getuint64",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "208-221",
          "snippet": "uint64_t getuint64()\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        if (nSize < 4)\n            return 0;\n        std::vector<unsigned char> vch(nSize);\n        BN_bn2mpi(this, &vch[0]);\n        if (vch.size() > 4)\n            vch[4] &= 0x7f;\n        uint64_t n = 0;\n        for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n            ((unsigned char*)&n)[i] = vch[j];\n        return n;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  uint64_t getuint64()\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          if (nSize < 4)\n              return 0;\n          std::vector<unsigned char> vch(nSize);\n          BN_bn2mpi(this, &vch[0]);\n          if (vch.size() > 4)\n              vch[4] &= 0x7f;\n          uint64_t n = 0;\n          for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n              ((unsigned char*)&n)[i] = vch[j];\n          return n;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\"",
            "nValueIn",
            "nTime - txPrev.nTime",
            "bnCentSecond.getuint64()"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetBoolArg",
          "args": [
            "\"-printcoinage\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "nValueIn"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.GetBlockTime",
          "args": [],
          "line": 1984
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "txindex.pos.nFile",
            "txindex.pos.nBlockPos",
            "false"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n  {\n      SetNull();\n      if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n          return false;\n      if (!ReadFromDisk(txindexRet.pos))\n          return false;\n      if (prevout.n >= vout.size())\n      {\n          SetNull();\n          return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinBase",
          "args": [],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nuint nStakeMinAge = 60 * 60 * 12;\n\nCTransaction {\n  bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n  {\n      CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n      nCoinAge = 0;\n  \n      if (IsCoinBase())\n          return true;\n  \n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          // First try finding the previous transaction in database\n          CTransaction txPrev;\n          CTxIndex txindex;\n          if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n              continue;  // previous transaction not in main chain\n          if (nTime < txPrev.nTime)\n              return false;  // Transaction timestamp violation\n  \n          // Read block header\n          CBlock block;\n          if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n              return false; // unable to read block of previous transaction\n          if (block.GetBlockTime() + nStakeMinAge > nTime)\n              continue; // only count coins meeting min age requirement\n  \n          int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n          bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n  \n          if(fDebug && GetBoolArg(\"-printcoinage\"))\n            printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n              nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n      }\n  \n      CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n      nCoinAge = bnCoinDay.getuint64();\n      if(fDebug && GetBoolArg(\"-printcoinage\"))\n        printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n  \n      return(true);\n  }\n}"
  },
  {
    "function_name": "SetBestChain",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1854-1953",
    "snippet": "bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    uint256 hash = GetHash();\n\n    if (!txdb.TxnBegin())\n        return error(\"SetBestChain() : TxnBegin failed\");\n\n    if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n    {\n        txdb.WriteHashBestChain(hash);\n        if (!txdb.TxnCommit())\n            return error(\"SetBestChain() : TxnCommit failed\");\n        pindexGenesisBlock = pindexNew;\n    }\n    else if (hashPrevBlock == hashBestChain)\n    {\n        if (!SetBestChainInner(txdb, pindexNew))\n            return error(\"SetBestChain() : SetBestChainInner failed\");\n    }\n    else\n    {\n        // the first block in the new chain that will cause it to become the new best chain\n        CBlockIndex *pindexIntermediate = pindexNew;\n\n        // list of blocks that need to be connected afterwards\n        std::vector<CBlockIndex*> vpindexSecondary;\n\n        // Reorganize is costly in terms of db load, as it works in a single db transaction.\n        // Try to limit how much needs to be done inside\n        while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n        {\n            vpindexSecondary.push_back(pindexIntermediate);\n            pindexIntermediate = pindexIntermediate->pprev;\n        }\n\n        if (!vpindexSecondary.empty())\n            printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n\n        // Switch to new best branch\n        if (!Reorganize(txdb, pindexIntermediate))\n        {\n            txdb.TxnAbort();\n            InvalidChainFound(pindexNew);\n            return error(\"SetBestChain() : Reorganize failed\");\n        }\n\n        // Connect further blocks\n        BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n        {\n            CBlock block;\n            if (!block.ReadFromDisk(pindex))\n            {\n                printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                break;\n            }\n            if (!txdb.TxnBegin()) {\n                printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                break;\n            }\n            // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n            if (!block.SetBestChainInner(txdb, pindex))\n                break;\n        }\n    }\n\n    // Update best block in wallet (so we can detect restored wallets)\n    bool fIsInitialDownload = IsInitialBlockDownload();\n    if (!fIsInitialDownload)\n    {\n        const CBlockLocator locator(pindexNew);\n        ::SetBestChain(locator);\n    }\n\n    // New best block\n    hashBestChain = hash;\n    pindexBest = pindexNew;\n    pblockindexFBBHLast = NULL;\n    nBestHeight = pindexBest->nHeight;\n    nBestChainTrust = pindexNew->nChainTrust;\n    nTimeBestReceived = GetTime();\n    nTransactionsUpdated++;\n\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(nBestChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n\n    std::string strCmd = GetArg(\"-blocknotify\", \"\");\n\n    if (!fIsInitialDownload && !strCmd.empty())\n    {\n        boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n        boost::thread t(runCommand, strCmd); // thread runs free\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nTransactionsUpdated = 0;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "CBlockIndex* pindexGenesisBlock = NULL;",
      "int nBestHeight = -1;",
      "uint256 nBestChainTrust = 0;",
      "uint256 hashBestChain = 0;",
      "CBlockIndex* pindexBest = NULL;",
      "int64_t nTimeBestReceived = 0;",
      "static CBlockIndex* pblockindexFBBHLast;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "boost::replace_all",
          "args": [
            "strCmd",
            "\"%s\"",
            "hashBestChain.GetHex()"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hashBestChain.GetHex",
          "args": [],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "GetHex",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "402-405",
          "snippet": "std::string GetHex() const\n    {\n        return ToString(16);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  std::string GetHex() const\n      {\n          return ToString(16);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strCmd.empty",
          "args": [],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-blocknotify\"",
            "\"\""
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\"",
            "hashBestChain.ToString().substr(0,20).c_str()",
            "nBestHeight",
            "CBigNum(nBestChainTrust).ToString().c_str()",
            "nBestBlockTrust.Get64()",
            "DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str()"
          ],
          "line": 1938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "\"%x %H:%M:%S\"",
            "pindexBest->GetBlockTime()"
          ],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "376-383",
          "snippet": "inline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetBlockTime",
          "args": [],
          "line": 1942
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nBestBlockTrust.Get64",
          "args": [],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "Get64",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "359-362",
          "snippet": "uint64_t Get64(int n=0) const\n    {\n        return pn[2*n] | (uint64_t)pn[2*n+1] << 32;\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  uint64_t Get64(int n=0) const\n      {\n          return pn[2*n] | (uint64_t)pn[2*n+1] << 32;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "nBestChainTrust"
          ],
          "line": 1940
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBestChain.ToString",
          "args": [],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBestChain.ToString",
          "args": [
            "0",
            "20"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "::SetBestChain",
          "args": [
            "locator"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "165-169",
          "snippet": "void static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInitialBlockDownload",
          "args": [],
          "line": 1920
        },
        "resolved": true,
        "details": {
          "function_name": "IsInitialBlockDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1220-1233",
          "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int nBestHeight = -1;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.SetBestChainInner",
          "args": [
            "txdb",
            "pindex"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChainInner",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1830-1852",
          "snippet": "bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n{\n    uint256 hash = GetHash();\n\n    // Adding to current best branch\n    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n    {\n        txdb.TxnAbort();\n        InvalidChainFound(pindexNew);\n        return false;\n    }\n    if (!txdb.TxnCommit())\n        return error(\"SetBestChain() : TxnCommit failed\");\n\n    // Add to current best branch\n    pindexNew->pprev->pnext = pindexNew;\n\n    // Delete redundant memory transactions\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        mempool.remove(tx);\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      // Adding to current best branch\n      if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n      {\n          txdb.TxnAbort();\n          InvalidChainFound(pindexNew);\n          return false;\n      }\n      if (!txdb.TxnCommit())\n          return error(\"SetBestChain() : TxnCommit failed\");\n  \n      // Add to current best branch\n      pindexNew->pprev->pnext = pindexNew;\n  \n      // Delete redundant memory transactions\n      BOOST_FOREACH(CTransaction& tx, vtx)\n          mempool.remove(tx);\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SetBestChain() : TxnBegin 2 failed\\n\""
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txdb.TxnBegin",
          "args": [],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "TxnBegin",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "271-280",
          "snippet": "bool TxnBegin()\n    {\n        if (!pdb || activeTxn)\n            return false;\n        DbTxn* ptxn = bitdb.TxnBegin();\n        if (!ptxn)\n            return false;\n        activeTxn = ptxn;\n        return true;\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnBegin()\n      {\n          if (!pdb || activeTxn)\n              return false;\n          DbTxn* ptxn = bitdb.TxnBegin();\n          if (!ptxn)\n              return false;\n          activeTxn = ptxn;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SetBestChain() : ReadFromDisk failed\\n\""
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindex"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "303-308",
          "snippet": "bool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(COutPoint prevout)\n  {\n      CTxDB txdb(\"r\");\n      CTxIndex txindex;\n      return ReadFromDisk(txdb, prevout, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SetBestChain() : Reorganize failed\""
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidChainFound",
          "args": [
            "pindexNew"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidChainFound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1235-1256",
          "snippet": "void static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nBestHeight = -1;",
            "uint256 nBestInvalidTrust = 0;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nBestHeight = -1;\nuint256 nBestInvalidTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnAbort",
          "args": [],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "TxnAbort",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "168-173",
          "snippet": "bool TxnAbort()\n    {\n        delete activeBatch;\n        activeBatch = NULL;\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool TxnAbort()\n      {\n          delete activeBatch;\n          activeBatch = NULL;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Reorganize",
          "args": [
            "txdb",
            "pindexIntermediate"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "Reorganize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1730-1826",
          "snippet": "bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBlockIndex* pindexBest = NULL;\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Postponing %\"PRIszu\" reconnects\\n\"",
            "vpindexSecondary.size()"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vpindexSecondary.size",
          "args": [],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vpindexSecondary.push_back",
          "args": [
            "pindexIntermediate"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txdb.TxnCommit",
          "args": [],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "TxnCommit",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "282-289",
          "snippet": "bool TxnCommit()\n    {\n        if (!pdb || !activeTxn)\n            return false;\n        int ret = activeTxn->commit(0);\n        activeTxn = NULL;\n        return (ret == 0);\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnCommit()\n      {\n          if (!pdb || !activeTxn)\n              return false;\n          int ret = activeTxn->commit(0);\n          activeTxn = NULL;\n          return (ret == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteHashBestChain",
          "args": [
            "hash"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "WriteHashBestChain",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "272-275",
          "snippet": "bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n{\n    return Write(string(\"hashBestChain\"), hashBestChain);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n  {\n      return Write(string(\"hashBestChain\"), hashBestChain);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexGenesisBlock = NULL;\nint nBestHeight = -1;\nuint256 nBestChainTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\nint64_t nTimeBestReceived = 0;\nstatic CBlockIndex* pblockindexFBBHLast;\n\nCBlock {\n  bool CBlock::SetBestChain(CTxDB& txdb, CBlockIndex* pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      if (!txdb.TxnBegin())\n          return error(\"SetBestChain() : TxnBegin failed\");\n  \n      if (pindexGenesisBlock == NULL && hash == (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet))\n      {\n          txdb.WriteHashBestChain(hash);\n          if (!txdb.TxnCommit())\n              return error(\"SetBestChain() : TxnCommit failed\");\n          pindexGenesisBlock = pindexNew;\n      }\n      else if (hashPrevBlock == hashBestChain)\n      {\n          if (!SetBestChainInner(txdb, pindexNew))\n              return error(\"SetBestChain() : SetBestChainInner failed\");\n      }\n      else\n      {\n          // the first block in the new chain that will cause it to become the new best chain\n          CBlockIndex *pindexIntermediate = pindexNew;\n  \n          // list of blocks that need to be connected afterwards\n          std::vector<CBlockIndex*> vpindexSecondary;\n  \n          // Reorganize is costly in terms of db load, as it works in a single db transaction.\n          // Try to limit how much needs to be done inside\n          while (pindexIntermediate->pprev && pindexIntermediate->pprev->nChainTrust > pindexBest->nChainTrust)\n          {\n              vpindexSecondary.push_back(pindexIntermediate);\n              pindexIntermediate = pindexIntermediate->pprev;\n          }\n  \n          if (!vpindexSecondary.empty())\n              printf(\"Postponing %\"PRIszu\" reconnects\\n\", vpindexSecondary.size());\n  \n          // Switch to new best branch\n          if (!Reorganize(txdb, pindexIntermediate))\n          {\n              txdb.TxnAbort();\n              InvalidChainFound(pindexNew);\n              return error(\"SetBestChain() : Reorganize failed\");\n          }\n  \n          // Connect further blocks\n          BOOST_REVERSE_FOREACH(CBlockIndex *pindex, vpindexSecondary)\n          {\n              CBlock block;\n              if (!block.ReadFromDisk(pindex))\n              {\n                  printf(\"SetBestChain() : ReadFromDisk failed\\n\");\n                  break;\n              }\n              if (!txdb.TxnBegin()) {\n                  printf(\"SetBestChain() : TxnBegin 2 failed\\n\");\n                  break;\n              }\n              // errors now are not fatal, we still did a reorganisation to a new chain in a valid way\n              if (!block.SetBestChainInner(txdb, pindex))\n                  break;\n          }\n      }\n  \n      // Update best block in wallet (so we can detect restored wallets)\n      bool fIsInitialDownload = IsInitialBlockDownload();\n      if (!fIsInitialDownload)\n      {\n          const CBlockLocator locator(pindexNew);\n          ::SetBestChain(locator);\n      }\n  \n      // New best block\n      hashBestChain = hash;\n      pindexBest = pindexNew;\n      pblockindexFBBHLast = NULL;\n      nBestHeight = pindexBest->nHeight;\n      nBestChainTrust = pindexNew->nChainTrust;\n      nTimeBestReceived = GetTime();\n      nTransactionsUpdated++;\n  \n      uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n  \n      printf(\"SetBestChain: new best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n        hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n        CBigNum(nBestChainTrust).ToString().c_str(),\n        nBestBlockTrust.Get64(),\n        DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n  \n      std::string strCmd = GetArg(\"-blocknotify\", \"\");\n  \n      if (!fIsInitialDownload && !strCmd.empty())\n      {\n          boost::replace_all(strCmd, \"%s\", hashBestChain.GetHex());\n          boost::thread t(runCommand, strCmd); // thread runs free\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "SetBestChainInner",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1830-1852",
    "snippet": "bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n{\n    uint256 hash = GetHash();\n\n    // Adding to current best branch\n    if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n    {\n        txdb.TxnAbort();\n        InvalidChainFound(pindexNew);\n        return false;\n    }\n    if (!txdb.TxnCommit())\n        return error(\"SetBestChain() : TxnCommit failed\");\n\n    // Add to current best branch\n    pindexNew->pprev->pnext = pindexNew;\n\n    // Delete redundant memory transactions\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        mempool.remove(tx);\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool.remove",
          "args": [
            "tx"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SetBestChain() : TxnCommit failed\""
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnCommit",
          "args": [],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "TxnCommit",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "282-289",
          "snippet": "bool TxnCommit()\n    {\n        if (!pdb || !activeTxn)\n            return false;\n        int ret = activeTxn->commit(0);\n        activeTxn = NULL;\n        return (ret == 0);\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnCommit()\n      {\n          if (!pdb || !activeTxn)\n              return false;\n          int ret = activeTxn->commit(0);\n          activeTxn = NULL;\n          return (ret == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "InvalidChainFound",
          "args": [
            "pindexNew"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "InvalidChainFound",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1235-1256",
          "snippet": "void static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nBestHeight = -1;",
            "uint256 nBestInvalidTrust = 0;",
            "uint256 hashBestChain = 0;",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nBestHeight = -1;\nuint256 nBestInvalidTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnAbort",
          "args": [],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "TxnAbort",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "168-173",
          "snippet": "bool TxnAbort()\n    {\n        delete activeBatch;\n        activeBatch = NULL;\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool TxnAbort()\n      {\n          delete activeBatch;\n          activeBatch = NULL;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteHashBestChain",
          "args": [
            "hash"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "WriteHashBestChain",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "272-275",
          "snippet": "bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n{\n    return Write(string(\"hashBestChain\"), hashBestChain);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n  {\n      return Write(string(\"hashBestChain\"), hashBestChain);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConnectBlock",
          "args": [
            "txdb",
            "pindexNew"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "ConnectBlock",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1600-1728",
          "snippet": "bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n\n    /* One more merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(error(\"ConnectBlock() : merkle root verification failed\"));\n\n    //// issue here: it doesn't know the version\n    uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n      - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64_t nFees = 0;\n    int64_t nValueIn = 0;\n    int64_t nValueOut = 0;\n    int64_t nStakeReward = 0;\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        uint256 hashTx = tx.GetHash();\n\n        // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n        // unless those are already completely spent.\n        // If such overwrites are allowed, coinbases and transactions depending upon those\n        // can be duplicated to remove the ability to spend the first instance -- even after\n        // being sent to another address.\n        // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n        // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n        // already refuses previously-known transaction ids entirely.\n        // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n        // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n        // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n        // initial block download.\n        CTxIndex txindexOld;\n        if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n            BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                if (pos.IsNull())\n                    return false;\n        }\n\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n\n        MapPrevTx mapInputs;\n        if (tx.IsCoinBase())\n            nValueOut += tx.GetValueOut();\n        else\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            // Add in sigops done by pay-to-script-hash inputs;\n            // this is to prevent a \"rogue miner\" from creating\n            // an incredibly-expensive-to-validate block.\n            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nSigOps > MAX_BLOCK_SIGOPS)\n                return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n            int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n            int64_t nTxValueOut = tx.GetValueOut();\n            nValueIn += nTxValueIn;\n            nValueOut += nTxValueOut;\n            if (!tx.IsCoinStake())\n                nFees += nTxValueIn - nTxValueOut;\n            if (tx.IsCoinStake())\n                nStakeReward = nTxValueOut - nTxValueIn;\n\n            if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                return false;\n        }\n\n        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    if (IsProofOfWork())\n    {\n        int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n        // Check coinbase reward\n        if (vtx[0].GetValueOut() > nReward)\n            return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                   vtx[0].GetValueOut(),\n                   nReward));\n    }\n    if (IsProofOfStake())\n    {\n        // ppcoin: coin stake tx earns reward instead of paying fee\n        uint64_t nCoinAge;\n        if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n            return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n\n        int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n\n        if (nStakeReward > nCalculatedStakeReward)\n            return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n    }\n\n    // ppcoin: track money supply and mint amount info\n    pindex->nMint = nValueOut - nValueIn + nFees;\n    pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n    if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n        return error(\"Connect() : WriteBlockIndex for pindex failed\");\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n  \n      /* One more merkle root verification */\n      if(hashMerkleRoot != BuildMerkleTree())\n        return(error(\"ConnectBlock() : merkle root verification failed\"));\n  \n      //// issue here: it doesn't know the version\n      uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n        - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n  \n      map<uint256, CTxIndex> mapQueuedChanges;\n      int64_t nFees = 0;\n      int64_t nValueIn = 0;\n      int64_t nValueOut = 0;\n      int64_t nStakeReward = 0;\n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(CTransaction& tx, vtx)\n      {\n          uint256 hashTx = tx.GetHash();\n  \n          // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n          // unless those are already completely spent.\n          // If such overwrites are allowed, coinbases and transactions depending upon those\n          // can be duplicated to remove the ability to spend the first instance -- even after\n          // being sent to another address.\n          // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n          // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n          // already refuses previously-known transaction ids entirely.\n          // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n          // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n          // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n          // initial block download.\n          CTxIndex txindexOld;\n          if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n              BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                  if (pos.IsNull())\n                      return false;\n          }\n  \n          nSigOps += tx.GetLegacySigOpCount();\n          if (nSigOps > MAX_BLOCK_SIGOPS)\n              return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n  \n          CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n          nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n  \n          MapPrevTx mapInputs;\n          if (tx.IsCoinBase())\n              nValueOut += tx.GetValueOut();\n          else\n          {\n              bool fInvalid;\n              if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                  return false;\n  \n              // Add in sigops done by pay-to-script-hash inputs;\n              // this is to prevent a \"rogue miner\" from creating\n              // an incredibly-expensive-to-validate block.\n              nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n              if (nSigOps > MAX_BLOCK_SIGOPS)\n                  return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n  \n              int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n              int64_t nTxValueOut = tx.GetValueOut();\n              nValueIn += nTxValueIn;\n              nValueOut += nTxValueOut;\n              if (!tx.IsCoinStake())\n                  nFees += nTxValueIn - nTxValueOut;\n              if (tx.IsCoinStake())\n                  nStakeReward = nTxValueOut - nTxValueIn;\n  \n              if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                  return false;\n          }\n  \n          mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n      }\n  \n      if (IsProofOfWork())\n      {\n          int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n          // Check coinbase reward\n          if (vtx[0].GetValueOut() > nReward)\n              return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                     vtx[0].GetValueOut(),\n                     nReward));\n      }\n      if (IsProofOfStake())\n      {\n          // ppcoin: coin stake tx earns reward instead of paying fee\n          uint64_t nCoinAge;\n          if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n              return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n  \n          int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n  \n          if (nStakeReward > nCalculatedStakeReward)\n              return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n      }\n  \n      // ppcoin: track money supply and mint amount info\n      pindex->nMint = nValueOut - nValueIn + nFees;\n      pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n      if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n          return error(\"Connect() : WriteBlockIndex for pindex failed\");\n  \n      // Write queued txindex changes\n      for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n      {\n          if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n              return error(\"ConnectBlock() : UpdateTxIndex failed\");\n      }\n  \n      // Update block index on disk without changing it in memory.\n      // The memory index structure will be changed after the db commits.\n      if (pindex->pprev)\n      {\n          CDiskBlockIndex blockindexPrev(pindex->pprev);\n          blockindexPrev.hashNext = pindex->GetBlockHash();\n          if (!txdb.WriteBlockIndex(blockindexPrev))\n              return error(\"ConnectBlock() : WriteBlockIndex failed\");\n      }\n  \n      // Watch for transactions paying to me\n      BOOST_FOREACH(CTransaction& tx, vtx)\n          SyncWithWallets(tx, this, true);\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::SetBestChainInner(CTxDB& txdb, CBlockIndex *pindexNew)\n  {\n      uint256 hash = GetHash();\n  \n      // Adding to current best branch\n      if (!ConnectBlock(txdb, pindexNew) || !txdb.WriteHashBestChain(hash))\n      {\n          txdb.TxnAbort();\n          InvalidChainFound(pindexNew);\n          return false;\n      }\n      if (!txdb.TxnCommit())\n          return error(\"SetBestChain() : TxnCommit failed\");\n  \n      // Add to current best branch\n      pindexNew->pprev->pnext = pindexNew;\n  \n      // Delete redundant memory transactions\n      BOOST_FOREACH(CTransaction& tx, vtx)\n          mempool.remove(tx);\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "Reorganize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1730-1826",
    "snippet": "bool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;",
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"REORGANIZE: done\\n\""
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.removeConflicts",
          "args": [
            "tx"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "removeConflicts",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "753-766",
          "snippet": "bool CTxMemPool::removeConflicts(const CTransaction &tx)\n{\n    // Remove transactions which depend on inputs of tx, recursively\n    LOCK(cs);\n    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n        if (it != mapNextTx.end()) {\n            const CTransaction &txConflict = *it->second.ptx;\n            if (txConflict != tx)\n                remove(txConflict, true);\n        }\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool {\n  bool CTxMemPool::removeConflicts(const CTransaction &tx)\n  {\n      // Remove transactions which depend on inputs of tx, recursively\n      LOCK(cs);\n      BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n          std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n          if (it != mapNextTx.end()) {\n              const CTransaction &txConflict = *it->second.ptx;\n              if (txConflict != tx)\n                  remove(txConflict, true);\n          }\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.remove",
          "args": [
            "tx"
          ],
          "line": 1819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.AcceptToMemoryPool",
          "args": [
            "txdb",
            "false"
          ],
          "line": 1815
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptToMemoryPool",
          "container": "CMerkleTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "825-837",
          "snippet": "bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCMerkleTx {\n  bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n  {\n      if (fClient)\n      {\n          if (!IsInMainChain() && !ClientConnectInputs())\n              return false;\n          return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n      }\n      else\n      {\n          return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Reorganize() : TxnCommit failed\""
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.TxnCommit",
          "args": [],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "TxnCommit",
          "container": "CDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/db.h",
          "lines": "282-289",
          "snippet": "bool TxnCommit()\n    {\n        if (!pdb || !activeTxn)\n            return false;\n        int ret = activeTxn->commit(0);\n        activeTxn = NULL;\n        return (ret == 0);\n    }",
          "includes": [
            "#include <db_cxx.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <db_cxx.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCDB {\n  bool TxnCommit()\n      {\n          if (!pdb || !activeTxn)\n              return false;\n          int ret = activeTxn->commit(0);\n          activeTxn = NULL;\n          return (ret == 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteHashBestChain",
          "args": [
            "pindexNew->GetBlockHash()"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "WriteHashBestChain",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "272-275",
          "snippet": "bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n{\n    return Write(string(\"hashBestChain\"), hashBestChain);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteHashBestChain(uint256 hashBestChain)\n  {\n      return Write(string(\"hashBestChain\"), hashBestChain);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexNew->GetBlockHash",
          "args": [],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vDelete.push_back",
          "args": [
            "tx"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Reorganize() : ConnectBlock %s failed\"",
            "pindex->GetBlockHash().ToString().substr(0,20).c_str()"
          ],
          "line": 1789
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 1789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.ConnectBlock",
          "args": [
            "txdb",
            "pindex"
          ],
          "line": 1786
        },
        "resolved": true,
        "details": {
          "function_name": "ConnectBlock",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1600-1728",
          "snippet": "bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n\n    /* One more merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(error(\"ConnectBlock() : merkle root verification failed\"));\n\n    //// issue here: it doesn't know the version\n    uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n      - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64_t nFees = 0;\n    int64_t nValueIn = 0;\n    int64_t nValueOut = 0;\n    int64_t nStakeReward = 0;\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        uint256 hashTx = tx.GetHash();\n\n        // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n        // unless those are already completely spent.\n        // If such overwrites are allowed, coinbases and transactions depending upon those\n        // can be duplicated to remove the ability to spend the first instance -- even after\n        // being sent to another address.\n        // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n        // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n        // already refuses previously-known transaction ids entirely.\n        // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n        // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n        // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n        // initial block download.\n        CTxIndex txindexOld;\n        if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n            BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                if (pos.IsNull())\n                    return false;\n        }\n\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n\n        MapPrevTx mapInputs;\n        if (tx.IsCoinBase())\n            nValueOut += tx.GetValueOut();\n        else\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            // Add in sigops done by pay-to-script-hash inputs;\n            // this is to prevent a \"rogue miner\" from creating\n            // an incredibly-expensive-to-validate block.\n            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nSigOps > MAX_BLOCK_SIGOPS)\n                return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n            int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n            int64_t nTxValueOut = tx.GetValueOut();\n            nValueIn += nTxValueIn;\n            nValueOut += nTxValueOut;\n            if (!tx.IsCoinStake())\n                nFees += nTxValueIn - nTxValueOut;\n            if (tx.IsCoinStake())\n                nStakeReward = nTxValueOut - nTxValueIn;\n\n            if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                return false;\n        }\n\n        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    if (IsProofOfWork())\n    {\n        int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n        // Check coinbase reward\n        if (vtx[0].GetValueOut() > nReward)\n            return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                   vtx[0].GetValueOut(),\n                   nReward));\n    }\n    if (IsProofOfStake())\n    {\n        // ppcoin: coin stake tx earns reward instead of paying fee\n        uint64_t nCoinAge;\n        if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n            return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n\n        int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n\n        if (nStakeReward > nCalculatedStakeReward)\n            return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n    }\n\n    // ppcoin: track money supply and mint amount info\n    pindex->nMint = nValueOut - nValueIn + nFees;\n    pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n    if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n        return error(\"Connect() : WriteBlockIndex for pindex failed\");\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n  \n      /* One more merkle root verification */\n      if(hashMerkleRoot != BuildMerkleTree())\n        return(error(\"ConnectBlock() : merkle root verification failed\"));\n  \n      //// issue here: it doesn't know the version\n      uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n        - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n  \n      map<uint256, CTxIndex> mapQueuedChanges;\n      int64_t nFees = 0;\n      int64_t nValueIn = 0;\n      int64_t nValueOut = 0;\n      int64_t nStakeReward = 0;\n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(CTransaction& tx, vtx)\n      {\n          uint256 hashTx = tx.GetHash();\n  \n          // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n          // unless those are already completely spent.\n          // If such overwrites are allowed, coinbases and transactions depending upon those\n          // can be duplicated to remove the ability to spend the first instance -- even after\n          // being sent to another address.\n          // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n          // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n          // already refuses previously-known transaction ids entirely.\n          // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n          // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n          // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n          // initial block download.\n          CTxIndex txindexOld;\n          if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n              BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                  if (pos.IsNull())\n                      return false;\n          }\n  \n          nSigOps += tx.GetLegacySigOpCount();\n          if (nSigOps > MAX_BLOCK_SIGOPS)\n              return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n  \n          CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n          nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n  \n          MapPrevTx mapInputs;\n          if (tx.IsCoinBase())\n              nValueOut += tx.GetValueOut();\n          else\n          {\n              bool fInvalid;\n              if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                  return false;\n  \n              // Add in sigops done by pay-to-script-hash inputs;\n              // this is to prevent a \"rogue miner\" from creating\n              // an incredibly-expensive-to-validate block.\n              nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n              if (nSigOps > MAX_BLOCK_SIGOPS)\n                  return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n  \n              int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n              int64_t nTxValueOut = tx.GetValueOut();\n              nValueIn += nTxValueIn;\n              nValueOut += nTxValueOut;\n              if (!tx.IsCoinStake())\n                  nFees += nTxValueIn - nTxValueOut;\n              if (tx.IsCoinStake())\n                  nStakeReward = nTxValueOut - nTxValueIn;\n  \n              if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                  return false;\n          }\n  \n          mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n      }\n  \n      if (IsProofOfWork())\n      {\n          int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n          // Check coinbase reward\n          if (vtx[0].GetValueOut() > nReward)\n              return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                     vtx[0].GetValueOut(),\n                     nReward));\n      }\n      if (IsProofOfStake())\n      {\n          // ppcoin: coin stake tx earns reward instead of paying fee\n          uint64_t nCoinAge;\n          if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n              return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n  \n          int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n  \n          if (nStakeReward > nCalculatedStakeReward)\n              return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n      }\n  \n      // ppcoin: track money supply and mint amount info\n      pindex->nMint = nValueOut - nValueIn + nFees;\n      pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n      if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n          return error(\"Connect() : WriteBlockIndex for pindex failed\");\n  \n      // Write queued txindex changes\n      for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n      {\n          if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n              return error(\"ConnectBlock() : UpdateTxIndex failed\");\n      }\n  \n      // Update block index on disk without changing it in memory.\n      // The memory index structure will be changed after the db commits.\n      if (pindex->pprev)\n      {\n          CDiskBlockIndex blockindexPrev(pindex->pprev);\n          blockindexPrev.hashNext = pindex->GetBlockHash();\n          if (!txdb.WriteBlockIndex(blockindexPrev))\n              return error(\"ConnectBlock() : WriteBlockIndex failed\");\n      }\n  \n      // Watch for transactions paying to me\n      BOOST_FOREACH(CTransaction& tx, vtx)\n          SyncWithWallets(tx, this, true);\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pindex"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "303-308",
          "snippet": "bool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(COutPoint prevout)\n  {\n      CTxDB txdb(\"r\");\n      CTxIndex txindex;\n      return ReadFromDisk(txdb, prevout, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vConnect.size",
          "args": [],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vResurrect.push_back",
          "args": [
            "tx"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinBase",
          "args": [],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 1770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block.DisconnectBlock",
          "args": [
            "txdb",
            "pindex"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "DisconnectBlock",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1575-1597",
          "snippet": "bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // ppcoin: clean up wallet after disconnecting coinstake\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, false, false);\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n  {\n      // Disconnect in reverse order\n      for (int i = vtx.size()-1; i >= 0; i--)\n          if (!vtx[i].DisconnectInputs(txdb))\n              return false;\n  \n      // Update block index on disk without changing it in memory.\n      // The memory index structure will be changed after the db commits.\n      if (pindex->pprev)\n      {\n          CDiskBlockIndex blockindexPrev(pindex->pprev);\n          blockindexPrev.hashNext = 0;\n          if (!txdb.WriteBlockIndex(blockindexPrev))\n              return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n      }\n  \n      // ppcoin: clean up wallet after disconnecting coinstake\n      BOOST_FOREACH(CTransaction& tx, vtx)\n          SyncWithWallets(tx, this, false, false);\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\"",
            "vConnect.size()",
            "pfork->GetBlockHash().ToString().substr(0,20).c_str()",
            "pindexNew->GetBlockHash().ToString().substr(0,20).c_str()"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindexNew->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfork->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\"",
            "vDisconnect.size()",
            "pfork->GetBlockHash().ToString().substr(0,20).c_str()",
            "pindexBest->GetBlockHash().ToString().substr(0,20).c_str()"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindexBest->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfork->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reverse",
          "args": [
            "vConnect.begin()",
            "vConnect.end()"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vConnect.end",
          "args": [],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vConnect.begin",
          "args": [],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vConnect.push_back",
          "args": [
            "pindex"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vDisconnect.push_back",
          "args": [
            "pindex"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"REORGANIZE\\n\""
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBlockIndex* pindexBest = NULL;\n\nbool static Reorganize(CTxDB& txdb, CBlockIndex* pindexNew)\n{\n    printf(\"REORGANIZE\\n\");\n\n    // Find the fork\n    CBlockIndex* pfork = pindexBest;\n    CBlockIndex* plonger = pindexNew;\n    while (pfork != plonger)\n    {\n        while (plonger->nHeight > pfork->nHeight)\n            if (!(plonger = plonger->pprev))\n                return error(\"Reorganize() : plonger->pprev is null\");\n        if (pfork == plonger)\n            break;\n        if (!(pfork = pfork->pprev))\n            return error(\"Reorganize() : pfork->pprev is null\");\n    }\n\n    // List of what to disconnect\n    vector<CBlockIndex*> vDisconnect;\n    for (CBlockIndex* pindex = pindexBest; pindex != pfork; pindex = pindex->pprev)\n        vDisconnect.push_back(pindex);\n\n    // List of what to connect\n    vector<CBlockIndex*> vConnect;\n    for (CBlockIndex* pindex = pindexNew; pindex != pfork; pindex = pindex->pprev)\n        vConnect.push_back(pindex);\n    reverse(vConnect.begin(), vConnect.end());\n\n    printf(\"REORGANIZE: Disconnect %\"PRIszu\" blocks; %s..%s\\n\", vDisconnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexBest->GetBlockHash().ToString().substr(0,20).c_str());\n    printf(\"REORGANIZE: Connect %\"PRIszu\" blocks; %s..%s\\n\", vConnect.size(), pfork->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->GetBlockHash().ToString().substr(0,20).c_str());\n\n    // Disconnect shorter branch\n    vector<CTransaction> vResurrect;\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n    {\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for disconnect failed\");\n        if (!block.DisconnectBlock(txdb, pindex))\n            return error(\"Reorganize() : DisconnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n\n        // Queue memory transactions to resurrect\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n                vResurrect.push_back(tx);\n    }\n\n    // Connect longer branch\n    vector<CTransaction> vDelete;\n    for (unsigned int i = 0; i < vConnect.size(); i++)\n    {\n        CBlockIndex* pindex = vConnect[i];\n        CBlock block;\n        if (!block.ReadFromDisk(pindex))\n            return error(\"Reorganize() : ReadFromDisk for connect failed\");\n        if (!block.ConnectBlock(txdb, pindex))\n        {\n            // Invalid block\n            return error(\"Reorganize() : ConnectBlock %s failed\", pindex->GetBlockHash().ToString().substr(0,20).c_str());\n        }\n\n        // Queue memory transactions to delete\n        BOOST_FOREACH(const CTransaction& tx, block.vtx)\n            vDelete.push_back(tx);\n    }\n    if (!txdb.WriteHashBestChain(pindexNew->GetBlockHash()))\n        return error(\"Reorganize() : WriteHashBestChain failed\");\n\n    // Make sure it's successfully written to disk before changing memory structure\n    if (!txdb.TxnCommit())\n        return error(\"Reorganize() : TxnCommit failed\");\n\n    // Disconnect shorter branch\n    BOOST_FOREACH(CBlockIndex* pindex, vDisconnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction& tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;\n}"
  },
  {
    "function_name": "ConnectBlock",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1600-1728",
    "snippet": "bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n\n    /* One more merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(error(\"ConnectBlock() : merkle root verification failed\"));\n\n    //// issue here: it doesn't know the version\n    uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n      - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n\n    map<uint256, CTxIndex> mapQueuedChanges;\n    int64_t nFees = 0;\n    int64_t nValueIn = 0;\n    int64_t nValueOut = 0;\n    int64_t nStakeReward = 0;\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(CTransaction& tx, vtx)\n    {\n        uint256 hashTx = tx.GetHash();\n\n        // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n        // unless those are already completely spent.\n        // If such overwrites are allowed, coinbases and transactions depending upon those\n        // can be duplicated to remove the ability to spend the first instance -- even after\n        // being sent to another address.\n        // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n        // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n        // already refuses previously-known transaction ids entirely.\n        // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n        // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n        // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n        // initial block download.\n        CTxIndex txindexOld;\n        if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n            BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                if (pos.IsNull())\n                    return false;\n        }\n\n        nSigOps += tx.GetLegacySigOpCount();\n        if (nSigOps > MAX_BLOCK_SIGOPS)\n            return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n        CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n        nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n\n        MapPrevTx mapInputs;\n        if (tx.IsCoinBase())\n            nValueOut += tx.GetValueOut();\n        else\n        {\n            bool fInvalid;\n            if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                return false;\n\n            // Add in sigops done by pay-to-script-hash inputs;\n            // this is to prevent a \"rogue miner\" from creating\n            // an incredibly-expensive-to-validate block.\n            nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n            if (nSigOps > MAX_BLOCK_SIGOPS)\n                return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n\n            int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n            int64_t nTxValueOut = tx.GetValueOut();\n            nValueIn += nTxValueIn;\n            nValueOut += nTxValueOut;\n            if (!tx.IsCoinStake())\n                nFees += nTxValueIn - nTxValueOut;\n            if (tx.IsCoinStake())\n                nStakeReward = nTxValueOut - nTxValueIn;\n\n            if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                return false;\n        }\n\n        mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n    }\n\n    if (IsProofOfWork())\n    {\n        int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n        // Check coinbase reward\n        if (vtx[0].GetValueOut() > nReward)\n            return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                   vtx[0].GetValueOut(),\n                   nReward));\n    }\n    if (IsProofOfStake())\n    {\n        // ppcoin: coin stake tx earns reward instead of paying fee\n        uint64_t nCoinAge;\n        if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n            return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n\n        int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n\n        if (nStakeReward > nCalculatedStakeReward)\n            return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n    }\n\n    // ppcoin: track money supply and mint amount info\n    pindex->nMint = nValueOut - nValueIn + nFees;\n    pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n    if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n        return error(\"Connect() : WriteBlockIndex for pindex failed\");\n\n    // Write queued txindex changes\n    for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n    {\n        if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n            return error(\"ConnectBlock() : UpdateTxIndex failed\");\n    }\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = pindex->GetBlockHash();\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"ConnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // Watch for transactions paying to me\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, true);\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SyncWithWallets",
          "args": [
            "tx",
            "this",
            "true"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ConnectBlock() : WriteBlockIndex failed\""
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteBlockIndex",
          "args": [
            "blockindexPrev"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "WriteBlockIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "262-265",
          "snippet": "bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n{\n    return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n  {\n      return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.UpdateTxIndex",
          "args": [
            "(*mi).first",
            "(*mi).second"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "206-210",
          "snippet": "bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n{\n    assert(!fClient);\n    return Write(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n  {\n      assert(!fClient);\n      return Write(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapQueuedChanges.end",
          "args": [],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapQueuedChanges.begin",
          "args": [],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CDiskBlockIndex",
          "args": [
            "pindex"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "if",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1482-1487",
          "snippet": "else if (fRead)\n        {\n            const_cast<CDiskBlockIndex*>(this)->prevoutStake.SetNull();\n            const_cast<CDiskBlockIndex*>(this)->nStakeTime = 0;\n            const_cast<CDiskBlockIndex*>(this)->hashProofOfStake = 0;\n        }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  else if (fRead)\n          {\n              const_cast<CDiskBlockIndex*>(this)->prevoutStake.SetNull();\n              const_cast<CDiskBlockIndex*>(this)->nStakeTime = 0;\n              const_cast<CDiskBlockIndex*>(this)->hashProofOfStake = 0;\n          }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoS",
          "args": [
            "100",
            "error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward)"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "DoS",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "865-865",
          "snippet": "bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\"",
            "nStakeReward",
            "nCalculatedStakeReward"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetProofOfStakeReward",
          "args": [
            "pindex->nHeight",
            "nCoinAge",
            "nFees"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "GetProofOfStakeReward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1005-1029",
          "snippet": "int64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ConnectBlock() : %s unable to get coin age for coinstake\"",
            "vtx[1].GetHash().ToString().substr(0,10).c_str()"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx[1].GetHash",
          "args": [],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx[1].GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtx[1].GetCoinAge",
          "args": [
            "txdb",
            "nCoinAge"
          ],
          "line": 1691
        },
        "resolved": true,
        "details": {
          "function_name": "GetCoinAge",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1962-2001",
          "snippet": "bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n{\n    CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n    nCoinAge = 0;\n\n    if (IsCoinBase())\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // First try finding the previous transaction in database\n        CTransaction txPrev;\n        CTxIndex txindex;\n        if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n            continue;  // previous transaction not in main chain\n        if (nTime < txPrev.nTime)\n            return false;  // Transaction timestamp violation\n\n        // Read block header\n        CBlock block;\n        if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n            return false; // unable to read block of previous transaction\n        if (block.GetBlockTime() + nStakeMinAge > nTime)\n            continue; // only count coins meeting min age requirement\n\n        int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n        bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n\n        if(fDebug && GetBoolArg(\"-printcoinage\"))\n          printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n            nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n    }\n\n    CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n    nCoinAge = bnCoinDay.getuint64();\n    if(fDebug && GetBoolArg(\"-printcoinage\"))\n      printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n\n    return(true);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint nStakeMinAge = 60 * 60 * 12;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nuint nStakeMinAge = 60 * 60 * 12;\n\nCTransaction {\n  bool CTransaction::GetCoinAge(CTxDB& txdb, uint64_t& nCoinAge) const\n  {\n      CBigNum bnCentSecond = 0;  // coin age in the unit of cent-seconds\n      nCoinAge = 0;\n  \n      if (IsCoinBase())\n          return true;\n  \n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          // First try finding the previous transaction in database\n          CTransaction txPrev;\n          CTxIndex txindex;\n          if (!txPrev.ReadFromDisk(txdb, txin.prevout, txindex))\n              continue;  // previous transaction not in main chain\n          if (nTime < txPrev.nTime)\n              return false;  // Transaction timestamp violation\n  \n          // Read block header\n          CBlock block;\n          if (!block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n              return false; // unable to read block of previous transaction\n          if (block.GetBlockTime() + nStakeMinAge > nTime)\n              continue; // only count coins meeting min age requirement\n  \n          int64_t nValueIn = txPrev.vout[txin.prevout.n].nValue;\n          bnCentSecond += CBigNum(nValueIn) * (nTime-txPrev.nTime) / CENT;\n  \n          if(fDebug && GetBoolArg(\"-printcoinage\"))\n            printf(\"coin age nValueIn=%\"PRId64\" nTimeDiff=%d nCentSecond=%\"PRIu64\"\\n\",\n              nValueIn, nTime - txPrev.nTime, bnCentSecond.getuint64());\n      }\n  \n      CBigNum bnCoinDay = bnCentSecond * CENT / (24 * 60 * 60);\n      nCoinAge = bnCoinDay.getuint64();\n      if(fDebug && GetBoolArg(\"-printcoinage\"))\n        printf(\"coin age nCoinAge=%\"PRIu64\"\\n\", nCoinAge);\n  \n      return(true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfStake",
          "args": [],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfStake",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1384-1387",
          "snippet": "bool IsProofOfStake() const\n    {\n        return (nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfStake() const\n      {\n          return (nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx[0].GetValueOut",
          "args": [],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueOut",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "577-587",
          "snippet": "int64_t GetValueOut() const\n    {\n        int64_t nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  int64_t GetValueOut() const\n      {\n          int64_t nValueOut = 0;\n          BOOST_FOREACH(const CTxOut& txout, vout)\n          {\n              nValueOut += txout.nValue;\n              if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                  throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n          }\n          return nValueOut;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetProofOfWorkReward",
          "args": [
            "pindex->nHeight",
            "nFees"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "GetProofOfWorkReward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "976-1003",
          "snippet": "int64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsProofOfWork",
          "args": [],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "IsProofOfWork",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1379-1382",
          "snippet": "bool IsProofOfWork() const\n    {\n        return !(nFlags & BLOCK_PROOF_OF_STAKE);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsProofOfWork() const\n      {\n          return !(nFlags & BLOCK_PROOF_OF_STAKE);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CTxIndex",
          "args": [
            "posThisTx",
            "tx.vout.size()"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "CTxIndex",
          "container": "CTxIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "790-794",
          "snippet": "CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n    {\n        pos = posIn;\n        vSpent.resize(nOutputs);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxIndex {\n  CTxIndex(const CDiskTxPos& posIn, unsigned int nOutputs)\n      {\n          pos = posIn;\n          vSpent.resize(nOutputs);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.vout.size",
          "args": [],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.ConnectInputs",
          "args": [
            "txdb",
            "mapInputs",
            "mapQueuedChanges",
            "posThisTx",
            "pindex",
            "true",
            "false"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetValueIn",
          "args": [
            "mapInputs"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetP2SHSigOpCount",
          "args": [
            "mapInputs"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.FetchInputs",
          "args": [
            "txdb",
            "mapQueuedChanges",
            "true",
            "false",
            "mapInputs",
            "fInvalid"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "FetchInputs",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1310-1523",
          "snippet": "bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n indexes are valid:\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nCoinbaseMaturity = 50;",
            "int nBestHeight = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nCoinbaseMaturity = 50;\nint nBestHeight = -1;\n\nCTransaction {\n  bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                                 bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n  {\n      // FetchInputs can return false either because we just haven't seen some inputs\n      // (in which case the transaction should be stored as an orphan)\n      // or because the transaction is malformed (in which case the transaction should\n      // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n      fInvalid = false;\n  \n      if (IsCoinBase())\n          return true; // Coinbase transactions have no inputs to fetch.\n  \n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          COutPoint prevout = vin[i].prevout;\n          if (inputsRet.count(prevout.hash))\n              continue; // Got it already\n  \n          // Read txindex\n          CTxIndex& txindex = inputsRet[prevout.hash].first;\n          bool fFound = true;\n          if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n          {\n              // Get txindex from current proposed changes\n              txindex = mapTestPool.find(prevout.hash)->second;\n          }\n          else\n          {\n              // Read txindex from txdb\n              fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n          }\n          if (!fFound && (fBlock || fMiner))\n              return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n  \n          // Read txPrev\n          CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n          {\n              // Get prev tx from single transactions in memory\n              {\n                  LOCK(mempool.cs);\n                  if (!mempool.exists(prevout.hash))\n                      return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                  txPrev = mempool.lookup(prevout.hash);\n              }\n              if (!fFound)\n                  txindex.vSpent.resize(txPrev.vout.size());\n          }\n          else\n          {\n              // Get prev tx from disk\n              if (!txPrev.ReadFromDisk(txindex.pos))\n                  return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n          }\n      }\n  \n      // Make sure all prevout.n indexes are valid:\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const COutPoint prevout = vin[i].prevout;\n          assert(inputsRet.count(prevout.hash) != 0);\n          const CTxIndex& txindex = inputsRet[prevout.hash].first;\n          const CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n          {\n              // Revisit this if/when transaction replacement is implemented and allows\n              // adding inputs:\n              fInvalid = true;\n              return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n          }\n      }\n  \n      return true;\n  }\n  \n  const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n  {\n      MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n      if (mi == inputs.end())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n  \n      const CTransaction& txPrev = (mi->second).second;\n      if (input.prevout.n >= txPrev.vout.size())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n  \n      return txPrev.vout[input.prevout.n];\n  }\n  \n  int64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      int64_t nResult = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          nResult += GetOutputFor(vin[i], inputs).nValue;\n      }\n      return nResult;\n  \n  }\n  \n  unsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      unsigned int nSigOps = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n          if (prevout.scriptPubKey.IsPayToScriptHash())\n              nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n      }\n      return nSigOps;\n  }\n  \n  bool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n      const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n  {\n      // Take over previous transactions' spent pointers\n      // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n      // fMiner is true when called from the internal bitcoin miner\n      // ... both are false when called from CTransaction::AcceptToMemoryPool\n      if (!IsCoinBase())\n      {\n          int64_t nValueIn = 0;\n          int64_t nFees = 0;\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                  return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n  \n              // If prev is coinbase or coinstake, check that it's matured\n              if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                  for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                      if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                          return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n  \n              // ppcoin: check transaction timestamp\n              if (txPrev.nTime > nTime)\n                  return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n  \n              // Check for negative or overflow input values\n              nValueIn += txPrev.vout[prevout.n].nValue;\n              if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                  return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n  \n          }\n          // The first loop above does all the inexpensive checks.\n          // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n          // Helps prevent CPU exhaustion attacks.\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              // Check for conflicts (double-spend)\n              // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n              // for an attacker to attempt to split the network.\n              if (!txindex.vSpent[prevout.n].IsNull())\n                  return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n  \n              // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n              // before the last blockchain checkpoint. This is safe because block merkle hashes are\n              // still computed and checked, and any change will be caught at the next checkpoint.\n              if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n              {\n                  // Verify signature\n                  if (!VerifySignature(txPrev, *this, i, 0))\n                  {\n                      return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                  }\n              }\n  \n              // Mark outpoints as spent\n              txindex.vSpent[prevout.n] = posThisTx;\n  \n              // Write back\n              if (fBlock || fMiner)\n              {\n                  mapTestPool[prevout.hash] = txindex;\n              }\n          }\n  \n          if (!IsCoinStake())\n          {\n              if (nValueIn < GetValueOut())\n                  return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // Tally transaction fees\n              int64_t nTxFee = nValueIn - GetValueOut();\n              if (nTxFee < 0)\n                  return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // enforce transaction fees for every block\n              if (nTxFee < GetMinFee())\n                  return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n  \n              nFees += nTxFee;\n              if (!MoneyRange(nFees))\n                  return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n          }\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinBase",
          "args": [],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::GetSerializeSize",
          "args": [
            "tx",
            "SER_DISK",
            "CLIENT_VERSION"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "632-638",
          "snippet": "unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nunsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetLegacySigOpCount",
          "args": [],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "GetLegacySigOpCount",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "405-418",
          "snippet": "unsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  unsigned int\n  CTransaction::GetLegacySigOpCount() const\n  {\n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          nSigOps += txin.scriptSig.GetSigOpCount(false);\n      }\n      BOOST_FOREACH(const CTxOut& txout, vout)\n      {\n          nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n      }\n      return nSigOps;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pos.IsNull",
          "args": [],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "IsNull",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1585-1588",
          "snippet": "bool IsNull()\n    {\n        return vHave.empty();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  bool IsNull()\n      {\n          return vHave.empty();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BOOST_FOREACH",
          "args": [
            "CDiskTxPos &pos",
            "txindexOld.vSpent"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txdb.ReadTxIndex",
          "args": [
            "hashTx",
            "txindexOld"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "ReadTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "199-204",
          "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetSizeOfCompactSize",
          "args": [
            "vtx.size()"
          ],
          "line": 1608
        },
        "resolved": true,
        "details": {
          "function_name": "GetSizeOfCompactSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "171-177",
          "snippet": "inline unsigned int GetSizeOfCompactSize(uint64_t nSize)\n{\n    if (nSize < 253)             return sizeof(unsigned char);\n    else if (nSize <= std::numeric_limits<unsigned short>::max()) return sizeof(unsigned char) + sizeof(unsigned short);\n    else if (nSize <= std::numeric_limits<unsigned int>::max())  return sizeof(unsigned char) + sizeof(unsigned int);\n    else                         return sizeof(unsigned char) + sizeof(uint64_t);\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\ninline unsigned int GetSizeOfCompactSize(uint64_t nSize)\n{\n    if (nSize < 253)             return sizeof(unsigned char);\n    else if (nSize <= std::numeric_limits<unsigned short>::max()) return sizeof(unsigned char) + sizeof(unsigned short);\n    else if (nSize <= std::numeric_limits<unsigned int>::max())  return sizeof(unsigned char) + sizeof(unsigned int);\n    else                         return sizeof(unsigned char) + sizeof(uint64_t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBlock",
          "args": [],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "CheckBlockSignature",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "2565-2590",
          "snippet": "bool CBlock::CheckBlockSignature() const\n{\n    if (IsProofOfWork())\n        return vchBlockSig.empty();\n\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n\n    const CTxOut& txout = vtx[1].vout[1];\n\n    if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        valtype& vchPubKey = vSolutions[0];\n        CKey key;\n        if (!key.SetPubKey(vchPubKey))\n            return false;\n        if (vchBlockSig.empty())\n            return false;\n        return key.Verify(GetHash(), vchBlockSig);\n    }\n\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::CheckBlockSignature() const\n  {\n      if (IsProofOfWork())\n          return vchBlockSig.empty();\n  \n      vector<valtype> vSolutions;\n      txnouttype whichType;\n  \n      const CTxOut& txout = vtx[1].vout[1];\n  \n      if (!Solver(txout.scriptPubKey, whichType, vSolutions))\n          return false;\n  \n      if (whichType == TX_PUBKEY)\n      {\n          valtype& vchPubKey = vSolutions[0];\n          CKey key;\n          if (!key.SetPubKey(vchPubKey))\n              return false;\n          if (vchBlockSig.empty())\n              return false;\n          return key.Verify(GetHash(), vchBlockSig);\n      }\n  \n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BuildMerkleTree",
          "args": [],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "BuildMerkleTree",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1020-1037",
          "snippet": "uint256 BuildMerkleTree() const\n    {\n        vMerkleTree.clear();\n        BOOST_FOREACH(const CTransaction& tx, vtx)\n            vMerkleTree.push_back(tx.GetHash());\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            for (int i = 0; i < nSize; i += 2)\n            {\n                int i2 = std::min(i+1, nSize-1);\n                vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                           BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n            }\n            j += nSize;\n        }\n        return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 BuildMerkleTree() const\n      {\n          vMerkleTree.clear();\n          BOOST_FOREACH(const CTransaction& tx, vtx)\n              vMerkleTree.push_back(tx.GetHash());\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              for (int i = 0; i < nSize; i += 2)\n              {\n                  int i2 = std::min(i+1, nSize-1);\n                  vMerkleTree.push_back(Hash(BEGIN(vMerkleTree[j+i]),  END(vMerkleTree[j+i]),\n                                             BEGIN(vMerkleTree[j+i2]), END(vMerkleTree[j+i2])));\n              }\n              j += nSize;\n          }\n          return (vMerkleTree.empty() ? 0 : vMerkleTree.back());\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCBlock {\n  bool CBlock::ConnectBlock(CTxDB& txdb, CBlockIndex* pindex) {\n  \n      /* One more merkle root verification */\n      if(hashMerkleRoot != BuildMerkleTree())\n        return(error(\"ConnectBlock() : merkle root verification failed\"));\n  \n      //// issue here: it doesn't know the version\n      uint nTxPos = pindex->nBlockPos + ::GetSerializeSize(CBlock(), SER_DISK, CLIENT_VERSION)\n        - (2 * GetSizeOfCompactSize(0)) + GetSizeOfCompactSize(vtx.size());\n  \n      map<uint256, CTxIndex> mapQueuedChanges;\n      int64_t nFees = 0;\n      int64_t nValueIn = 0;\n      int64_t nValueOut = 0;\n      int64_t nStakeReward = 0;\n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(CTransaction& tx, vtx)\n      {\n          uint256 hashTx = tx.GetHash();\n  \n          // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n          // unless those are already completely spent.\n          // If such overwrites are allowed, coinbases and transactions depending upon those\n          // can be duplicated to remove the ability to spend the first instance -- even after\n          // being sent to another address.\n          // See BIP30 and http://r6.ca/blog/20120206T005236Z.html for more information.\n          // This logic is not necessary for memory pool transactions, as AcceptToMemoryPool\n          // already refuses previously-known transaction ids entirely.\n          // This rule was originally applied all blocks whose timestamp was after March 15, 2012, 0:00 UTC.\n          // Now that the whole chain is irreversibly beyond that time it is applied to all blocks except the\n          // two in the chain that violate it. This prevents exploiting the issue against nodes in their\n          // initial block download.\n          CTxIndex txindexOld;\n          if (txdb.ReadTxIndex(hashTx, txindexOld)) {\n              BOOST_FOREACH(CDiskTxPos &pos, txindexOld.vSpent)\n                  if (pos.IsNull())\n                      return false;\n          }\n  \n          nSigOps += tx.GetLegacySigOpCount();\n          if (nSigOps > MAX_BLOCK_SIGOPS)\n              return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n  \n          CDiskTxPos posThisTx(pindex->nFile, pindex->nBlockPos, nTxPos);\n          nTxPos += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n  \n          MapPrevTx mapInputs;\n          if (tx.IsCoinBase())\n              nValueOut += tx.GetValueOut();\n          else\n          {\n              bool fInvalid;\n              if (!tx.FetchInputs(txdb, mapQueuedChanges, true, false, mapInputs, fInvalid))\n                  return false;\n  \n              // Add in sigops done by pay-to-script-hash inputs;\n              // this is to prevent a \"rogue miner\" from creating\n              // an incredibly-expensive-to-validate block.\n              nSigOps += tx.GetP2SHSigOpCount(mapInputs);\n              if (nSigOps > MAX_BLOCK_SIGOPS)\n                  return DoS(100, error(\"ConnectBlock() : too many sigops\"));\n  \n              int64_t nTxValueIn = tx.GetValueIn(mapInputs);\n              int64_t nTxValueOut = tx.GetValueOut();\n              nValueIn += nTxValueIn;\n              nValueOut += nTxValueOut;\n              if (!tx.IsCoinStake())\n                  nFees += nTxValueIn - nTxValueOut;\n              if (tx.IsCoinStake())\n                  nStakeReward = nTxValueOut - nTxValueIn;\n  \n              if (!tx.ConnectInputs(txdb, mapInputs, mapQueuedChanges, posThisTx, pindex, true, false))\n                  return false;\n          }\n  \n          mapQueuedChanges[hashTx] = CTxIndex(posThisTx, tx.vout.size());\n      }\n  \n      if (IsProofOfWork())\n      {\n          int64_t nReward = GetProofOfWorkReward(pindex->nHeight, nFees);\n          // Check coinbase reward\n          if (vtx[0].GetValueOut() > nReward)\n              return DoS(50, error(\"ConnectBlock() : coinbase reward exceeded (actual=%\"PRId64\" vs calculated=%\"PRId64\")\",\n                     vtx[0].GetValueOut(),\n                     nReward));\n      }\n      if (IsProofOfStake())\n      {\n          // ppcoin: coin stake tx earns reward instead of paying fee\n          uint64_t nCoinAge;\n          if (!vtx[1].GetCoinAge(txdb, nCoinAge))\n              return error(\"ConnectBlock() : %s unable to get coin age for coinstake\", vtx[1].GetHash().ToString().substr(0,10).c_str());\n  \n          int64_t nCalculatedStakeReward = GetProofOfStakeReward(pindex->nHeight, nCoinAge, nFees);\n  \n          if (nStakeReward > nCalculatedStakeReward)\n              return DoS(100, error(\"ConnectBlock() : coinstake pays too much(actual=%\"PRId64\" vs calculated=%\"PRId64\")\", nStakeReward, nCalculatedStakeReward));\n      }\n  \n      // ppcoin: track money supply and mint amount info\n      pindex->nMint = nValueOut - nValueIn + nFees;\n      pindex->nMoneySupply = (pindex->pprev? pindex->pprev->nMoneySupply : 0) + nValueOut - nValueIn;\n      if (!txdb.WriteBlockIndex(CDiskBlockIndex(pindex)))\n          return error(\"Connect() : WriteBlockIndex for pindex failed\");\n  \n      // Write queued txindex changes\n      for (map<uint256, CTxIndex>::iterator mi = mapQueuedChanges.begin(); mi != mapQueuedChanges.end(); ++mi)\n      {\n          if (!txdb.UpdateTxIndex((*mi).first, (*mi).second))\n              return error(\"ConnectBlock() : UpdateTxIndex failed\");\n      }\n  \n      // Update block index on disk without changing it in memory.\n      // The memory index structure will be changed after the db commits.\n      if (pindex->pprev)\n      {\n          CDiskBlockIndex blockindexPrev(pindex->pprev);\n          blockindexPrev.hashNext = pindex->GetBlockHash();\n          if (!txdb.WriteBlockIndex(blockindexPrev))\n              return error(\"ConnectBlock() : WriteBlockIndex failed\");\n      }\n  \n      // Watch for transactions paying to me\n      BOOST_FOREACH(CTransaction& tx, vtx)\n          SyncWithWallets(tx, this, true);\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "DisconnectBlock",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1575-1597",
    "snippet": "bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n{\n    // Disconnect in reverse order\n    for (int i = vtx.size()-1; i >= 0; i--)\n        if (!vtx[i].DisconnectInputs(txdb))\n            return false;\n\n    // Update block index on disk without changing it in memory.\n    // The memory index structure will be changed after the db commits.\n    if (pindex->pprev)\n    {\n        CDiskBlockIndex blockindexPrev(pindex->pprev);\n        blockindexPrev.hashNext = 0;\n        if (!txdb.WriteBlockIndex(blockindexPrev))\n            return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n    }\n\n    // ppcoin: clean up wallet after disconnecting coinstake\n    BOOST_FOREACH(CTransaction& tx, vtx)\n        SyncWithWallets(tx, this, false, false);\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SyncWithWallets",
          "args": [
            "tx",
            "this",
            "false",
            "false"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "SyncWithWallets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "146-162",
          "snippet": "void SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fConnect)\n{\n    if (!fConnect)\n    {\n        // ppcoin: wallets need to refund inputs when disconnecting coinstake\n        if (tx.IsCoinStake())\n        {\n            BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n                if (pwallet->IsFromMe(tx))\n                    pwallet->DisableTransaction(tx);\n        }\n        return;\n    }\n\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fConnect)\n{\n    if (!fConnect)\n    {\n        // ppcoin: wallets need to refund inputs when disconnecting coinstake\n        if (tx.IsCoinStake())\n        {\n            BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n                if (pwallet->IsFromMe(tx))\n                    pwallet->DisableTransaction(tx);\n        }\n        return;\n    }\n\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"DisconnectBlock() : WriteBlockIndex failed\""
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.WriteBlockIndex",
          "args": [
            "blockindexPrev"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "WriteBlockIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "262-265",
          "snippet": "bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n{\n    return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::WriteBlockIndex(const CDiskBlockIndex& blockindex)\n  {\n      return Write(make_pair(string(\"blockindex\"), blockindex.GetBlockHash()), blockindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx[i].DisconnectInputs",
          "args": [
            "txdb"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "DisconnectInputs",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1274-1307",
          "snippet": "bool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anyway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::DisconnectInputs(CTxDB& txdb)\n  {\n      // Relinquish previous transactions' spent pointers\n      if (!IsCoinBase())\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n          {\n              COutPoint prevout = txin.prevout;\n  \n              // Get prev txindex from disk\n              CTxIndex txindex;\n              if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                  return error(\"DisconnectInputs() : ReadTxIndex failed\");\n  \n              if (prevout.n >= txindex.vSpent.size())\n                  return error(\"DisconnectInputs() : prevout.n out of range\");\n  \n              // Mark outpoint as not spent\n              txindex.vSpent[prevout.n].SetNull();\n  \n              // Write back\n              if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                  return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n          }\n      }\n  \n      // Remove transaction from index\n      // This can fail if a duplicate of this transaction was in a chain that got\n      // reorganized away. This is only possible if this transaction was completely\n      // spent, so erasing it would be a no-op anyway.\n      txdb.EraseTxIndex(*this);\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtx.size",
          "args": [],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::DisconnectBlock(CTxDB& txdb, CBlockIndex* pindex)\n  {\n      // Disconnect in reverse order\n      for (int i = vtx.size()-1; i >= 0; i--)\n          if (!vtx[i].DisconnectInputs(txdb))\n              return false;\n  \n      // Update block index on disk without changing it in memory.\n      // The memory index structure will be changed after the db commits.\n      if (pindex->pprev)\n      {\n          CDiskBlockIndex blockindexPrev(pindex->pprev);\n          blockindexPrev.hashNext = 0;\n          if (!txdb.WriteBlockIndex(blockindexPrev))\n              return error(\"DisconnectBlock() : WriteBlockIndex failed\");\n      }\n  \n      // ppcoin: clean up wallet after disconnecting coinstake\n      BOOST_FOREACH(CTransaction& tx, vtx)\n          SyncWithWallets(tx, this, false, false);\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "ClientConnectInputs",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1526-1570",
    "snippet": "bool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    {\n        LOCK(mempool.cs);\n        int64_t nValueIn = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mempool.exists(prevout.hash))\n                return false;\n            CTransaction& txPrev = mempool.lookup(prevout.hash);\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            ///// this is redundant with the mempool.mapNextTx stuff,\n            ///// not sure which I want to get rid of\n            ///// this has to go away now that posNext is gone\n            // // Check for conflicts\n            // if (!txPrev.vout[prevout.n].posNext.IsNull())\n            //     return error(\"ConnectInputs() : prev tx already used\");\n            //\n            // // Flag outpoints as used\n            // txPrev.vout[prevout.n].posNext = posThisTx;\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetValueOut",
          "args": [],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueOut",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "577-587",
          "snippet": "int64_t GetValueOut() const\n    {\n        int64_t nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  int64_t GetValueOut() const\n      {\n          int64_t nValueOut = 0;\n          BOOST_FOREACH(const CTxOut& txout, vout)\n          {\n              nValueOut += txout.nValue;\n              if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                  throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n          }\n          return nValueOut;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ClientConnectInputs() : txin values out of range\""
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MoneyRange",
          "args": [
            "nValueIn"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "MoneyRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "48-48",
          "snippet": "inline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\ninline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }"
        }
      },
      {
        "call_info": {
          "callee": "VerifySignature",
          "args": [
            "txPrev",
            "*this",
            "i",
            "0"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "VerifySignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1766-1778",
          "snippet": "bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}"
        }
      },
      {
        "call_info": {
          "callee": "txPrev.vout.size",
          "args": [],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.lookup",
          "args": [
            "prevout.hash"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.exists",
          "args": [
            "prevout.hash"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "mempool.cs"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsCoinBase",
          "args": [],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\n\nCTransaction {\n  bool CTransaction::ClientConnectInputs()\n  {\n      if (IsCoinBase())\n          return false;\n  \n      // Take over previous transactions' spent pointers\n      {\n          LOCK(mempool.cs);\n          int64_t nValueIn = 0;\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              // Get prev tx from single transactions in memory\n              COutPoint prevout = vin[i].prevout;\n              if (!mempool.exists(prevout.hash))\n                  return false;\n              CTransaction& txPrev = mempool.lookup(prevout.hash);\n  \n              if (prevout.n >= txPrev.vout.size())\n                  return false;\n  \n              // Verify signature\n              if (!VerifySignature(txPrev, *this, i, 0))\n                  return error(\"ConnectInputs() : VerifySignature failed\");\n  \n              ///// this is redundant with the mempool.mapNextTx stuff,\n              ///// not sure which I want to get rid of\n              ///// this has to go away now that posNext is gone\n              // // Check for conflicts\n              // if (!txPrev.vout[prevout.n].posNext.IsNull())\n              //     return error(\"ConnectInputs() : prev tx already used\");\n              //\n              // // Flag outpoints as used\n              // txPrev.vout[prevout.n].posNext = posThisTx;\n  \n              nValueIn += txPrev.vout[prevout.n].nValue;\n  \n              if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                  return error(\"ClientConnectInputs() : txin values out of range\");\n          }\n          if (GetValueOut() > nValueIn)\n              return false;\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "FetchInputs",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1310-1523",
    "snippet": "bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n indexes are valid:\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "int nCoinbaseMaturity = 50;",
      "int nBestHeight = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoS",
          "args": [
            "100",
            "error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"))"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "DoS",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "865-865",
          "snippet": "bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))return DoS(100",
            "error(\"ConnectInputs() : nFees out of range\")"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ConnectInputs() : nFees out of range\""
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": ";\n\n            nFees += nTxFee;\n            if",
          "args": [
            "!MoneyRange(nFees)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MoneyRange",
          "args": [
            "nFees"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "MoneyRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "48-48",
          "snippet": "inline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\ninline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ConnectInputs() : %s not paying required fee=%s, paid=%s\"",
            "GetHash().ToString().substr(0,10).c_str()",
            "FormatMoney(GetMinFee()).c_str()",
            "FormatMoney(nTxFee).c_str()"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "nTxFee"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FormatMoney",
          "args": [
            "GetMinFee()"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMinFee",
          "args": [],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n            // enforce transaction fees for every block\n            if",
          "args": [
            "nTxFee < GetMinFee()"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetMinFee",
          "args": [],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n        int64_t nFees = 0;\n        for",
          "args": [
            "unsigned int i = 0;i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)return DoS(100",
            "error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str())"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n            if",
          "args": [
            "nTxFee < 0"
          ],
          "line": 1438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetValueOut",
          "args": [],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueOut",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "577-587",
          "snippet": "int64_t GetValueOut() const\n    {\n        int64_t nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  int64_t GetValueOut() const\n      {\n          int64_t nValueOut = 0;\n          BOOST_FOREACH(const CTxOut& txout, vout)\n          {\n              nValueOut += txout.nValue;\n              if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                  throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n          }\n          return nValueOut;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "for",
          "args": [
            "unsigned int i = 0;i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())return DoS(100",
            "error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str())"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "formatTxAmount",
          "container": "TransactionTableModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "424-435",
          "snippet": "QString TransactionTableModel::formatTxAmount(const TransactionRecord *wtx, bool showUnconfirmed) const\n{\n    QString str = BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), wtx->credit + wtx->debit);\n    if(showUnconfirmed)\n    {\n        if(!wtx->status.countsForBalance)\n        {\n            str = QString(\"[\") + str + QString(\"]\");\n        }\n    }\n    return QString(str);\n}",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTableModel {\n  QString TransactionTableModel::formatTxAmount(const TransactionRecord *wtx, bool showUnconfirmed) const\n  {\n      QString str = BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), wtx->credit + wtx->debit);\n      if(showUnconfirmed)\n      {\n          if(!wtx->status.countsForBalance)\n          {\n              str = QString(\"[\") + str + QString(\"]\");\n          }\n      }\n      return QString(str);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n            if",
          "args": [
            "nValueIn < GetValueOut()"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n            }\n        }\n\n        if",
          "args": [
            "!IsCoinStake()"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsCoinStake",
          "args": [],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": ";\n\n            // Write back\n            if",
          "args": [
            "fBlock || fMiner"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n                // Verify signature\n                if",
          "args": [
            "!VerifySignature(txPrev, *this, i, 0)"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VerifySignature",
          "args": [
            "txPrev",
            "*this",
            "i",
            "0"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "VerifySignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1766-1778",
          "snippet": "bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}"
        }
      },
      {
        "call_info": {
          "callee": ";\n\n            // Skip ECDSA signature verification when connecting blocks",
          "args": [
            "!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate()))"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Checkpoints::GetTotalBlocksEstimate",
          "args": [],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "GetTotalBlocksEstimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "61-66",
          "snippet": "int GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nint GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ConnectInputs() : %s prev tx already used at %s\"",
            "GetHash().ToString().substr(0,10).c_str()",
            "txindex.vSpent[prevout.n].ToString().c_str()"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "error",
          "container": "BitcoinGUI",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/bitcoingui.cpp",
          "lines": "627-636",
          "snippet": "void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n{\n    // Report errors from network/worker thread\n    if(modal)\n    {\n        QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n    } else {\n        notificator->notify(Notificator::Critical, title, message);\n    }\n}",
          "includes": [
            "#include <iostream>",
            "#include <QStyle>",
            "#include <QUrl>",
            "#include <QDragEnterEvent>",
            "#include <QTimer>",
            "#include <QDesktopServices>",
            "#include <QFileDialog>",
            "#include <QMovie>",
            "#include <QDateTime>",
            "#include <QStackedWidget>",
            "#include <QProgressBar>",
            "#include <QMimeData>",
            "#include <QMessageBox>",
            "#include <QLocale>",
            "#include <QPushButton>",
            "#include <QLineEdit>",
            "#include <QLabel>",
            "#include <QStatusBar>",
            "#include <QToolBar>",
            "#include <QVBoxLayout>",
            "#include <QTabWidget>",
            "#include <QIcon>",
            "#include <QMenu>",
            "#include <QMenuBar>",
            "#include <QMainWindow>",
            "#include <QApplication>",
            "#include \"macdockiconhandler.h\"",
            "#include \"blockexplorer.h\"",
            "#include \"wallet.h\"",
            "#include \"rpcconsole.h\"",
            "#include \"guiutil.h\"",
            "#include \"notificator.h\"",
            "#include \"askpassphrasedialog.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"overviewpage.h\"",
            "#include \"transactionview.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"transactiondescdialog.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"editaddressdialog.h\"",
            "#include \"walletmodel.h\"",
            "#include \"clientmodel.h\"",
            "#include \"aboutdialog.h\"",
            "#include \"optionsdialog.h\"",
            "#include \"signverifymessagedialog.h\"",
            "#include \"sendcoinsdialog.h\"",
            "#include \"addressbookpage.h\"",
            "#include \"transactiontablemodel.h\"",
            "#include \"bitcoingui.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iostream>\n#include <QStyle>\n#include <QUrl>\n#include <QDragEnterEvent>\n#include <QTimer>\n#include <QDesktopServices>\n#include <QFileDialog>\n#include <QMovie>\n#include <QDateTime>\n#include <QStackedWidget>\n#include <QProgressBar>\n#include <QMimeData>\n#include <QMessageBox>\n#include <QLocale>\n#include <QPushButton>\n#include <QLineEdit>\n#include <QLabel>\n#include <QStatusBar>\n#include <QToolBar>\n#include <QVBoxLayout>\n#include <QTabWidget>\n#include <QIcon>\n#include <QMenu>\n#include <QMenuBar>\n#include <QMainWindow>\n#include <QApplication>\n#include \"macdockiconhandler.h\"\n#include \"blockexplorer.h\"\n#include \"wallet.h\"\n#include \"rpcconsole.h\"\n#include \"guiutil.h\"\n#include \"notificator.h\"\n#include \"askpassphrasedialog.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"overviewpage.h\"\n#include \"transactionview.h\"\n#include \"addresstablemodel.h\"\n#include \"transactiondescdialog.h\"\n#include \"optionsmodel.h\"\n#include \"editaddressdialog.h\"\n#include \"walletmodel.h\"\n#include \"clientmodel.h\"\n#include \"aboutdialog.h\"\n#include \"optionsdialog.h\"\n#include \"signverifymessagedialog.h\"\n#include \"sendcoinsdialog.h\"\n#include \"addressbookpage.h\"\n#include \"transactiontablemodel.h\"\n#include \"bitcoingui.h\"\n\nBitcoinGUI {\n  void BitcoinGUI::error(const QString &title, const QString &message, bool modal)\n  {\n      // Report errors from network/worker thread\n      if(modal)\n      {\n          QMessageBox::critical(this, title, message, QMessageBox::Ok, QMessageBox::Ok);\n      } else {\n          notificator->notify(Notificator::Critical, title, message);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txindex.vSpent[prevout.n].ToString",
          "args": [],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n            // Check for conflicts",
          "args": [
            "!txindex.vSpent[prevout.n].IsNull()"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txindex.vSpent[prevout.n].IsNull",
          "args": [],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "IsNull",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1585-1588",
          "snippet": "bool IsNull()\n    {\n        return vHave.empty();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  bool IsNull()\n      {\n          return vHave.empty();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "inputs.count(prevout.hash) > 0"
          ],
          "line": 1470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputs.count",
          "args": [
            "prevout.hash"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vin.size",
          "args": [],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DoS",
          "args": [
            "!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn)"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DoS",
          "args": [
            "100",
            "error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)return DoS(100",
            "error(\"ConnectInputs() : transaction timestamp earlier than input transaction\")"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n            // ppcoin: check transaction timestamp\n            if",
          "args": [
            "txPrev.nTime > nTime"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txPrev.IsCoinBase",
          "args": [],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "if",
          "args": [
            "pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "if",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1482-1487",
          "snippet": "else if (fRead)\n        {\n            const_cast<CDiskBlockIndex*>(this)->prevoutStake.SetNull();\n            const_cast<CDiskBlockIndex*>(this)->nStakeTime = 0;\n            const_cast<CDiskBlockIndex*>(this)->hashProofOfStake = 0;\n        }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  else if (fRead)\n          {\n              const_cast<CDiskBlockIndex*>(this)->prevoutStake.SetNull();\n              const_cast<CDiskBlockIndex*>(this)->nStakeTime = 0;\n              const_cast<CDiskBlockIndex*>(this)->hashProofOfStake = 0;\n          }\n}"
        }
      },
      {
        "call_info": {
          "callee": "for",
          "args": [
            "const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity;pindex = pindex->pprev"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "formatTooltip",
          "container": "TransactionTableModel",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/transactiontablemodel.cpp",
          "lines": "473-482",
          "snippet": "QString TransactionTableModel::formatTooltip(const TransactionRecord *rec) const\n{\n    QString tooltip = formatTxStatus(rec) + QString(\"\\n\") + formatTxType(rec);\n    if(rec->type==TransactionRecord::RecvFromOther || rec->type==TransactionRecord::SendToOther ||\n       rec->type==TransactionRecord::SendToAddress || rec->type==TransactionRecord::RecvWithAddress)\n    {\n        tooltip += QString(\" \") + formatTxToAddress(rec, true);\n    }\n    return tooltip;\n}",
          "includes": [
            "#include <QtAlgorithms>",
            "#include <QDateTime>",
            "#include <QIcon>",
            "#include <QTimer>",
            "#include <QColor>",
            "#include <QList>",
            "#include <QLocale>",
            "#include \"ui_interface.h\"",
            "#include \"wallet.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"addresstablemodel.h\"",
            "#include \"optionsmodel.h\"",
            "#include \"walletmodel.h\"",
            "#include \"transactiondesc.h\"",
            "#include \"guiconstants.h\"",
            "#include \"transactionrecord.h\"",
            "#include \"guiutil.h\"",
            "#include \"transactiontablemodel.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <QtAlgorithms>\n#include <QDateTime>\n#include <QIcon>\n#include <QTimer>\n#include <QColor>\n#include <QList>\n#include <QLocale>\n#include \"ui_interface.h\"\n#include \"wallet.h\"\n#include \"bitcoinunits.h\"\n#include \"addresstablemodel.h\"\n#include \"optionsmodel.h\"\n#include \"walletmodel.h\"\n#include \"transactiondesc.h\"\n#include \"guiconstants.h\"\n#include \"transactionrecord.h\"\n#include \"guiutil.h\"\n#include \"transactiontablemodel.h\"\n\nTransactionTableModel {\n  QString TransactionTableModel::formatTooltip(const TransactionRecord *rec) const\n  {\n      QString tooltip = formatTxStatus(rec) + QString(\"\\n\") + formatTxType(rec);\n      if(rec->type==TransactionRecord::RecvFromOther || rec->type==TransactionRecord::SendToOther ||\n         rec->type==TransactionRecord::SendToAddress || rec->type==TransactionRecord::RecvWithAddress)\n      {\n          tooltip += QString(\" \") + formatTxToAddress(rec, true);\n      }\n      return tooltip;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s\", GetHash",
          "args": [
            "txPrev.IsCoinBase() || txPrev.IsCoinStake()"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\n            if",
          "args": [
            "prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size()"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "inputs.count(prevout.hash) > 0"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if",
          "args": [
            "!IsCoinBase()"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTransaction::ConnectInputs",
          "args": [
            "CTxDB& txdb",
            "MapPrevTxinputs",
            "map<uint256, CTxIndex>& mapTestPool",
            "constCDiskTxPos& posThisTx",
            "constCBlockIndex* pindexBlock",
            "boolfBlock",
            "boolfMiner"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prevout.scriptPubKey.GetSigOpCount",
          "args": [
            "vin[i].scriptSig"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "GetSigOpCount",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1926-1948",
          "snippet": "unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n{\n    if (!IsPayToScriptHash())\n        return GetSigOpCount(true);\n\n    // This is a pay-to-script-hash scriptPubKey;\n    // get the last item that the scriptSig\n    // pushes onto the stack:\n    const_iterator pc = scriptSig.begin();\n    vector<unsigned char> data;\n    while (pc < scriptSig.end())\n    {\n        opcodetype opcode;\n        if (!scriptSig.GetOp(pc, opcode, data))\n            return 0;\n        if (opcode > OP_16)\n            return 0;\n    }\n\n    /// ... and return its opcount:\n    CScript subscript(data.begin(), data.end());\n    return subscript.GetSigOpCount(true);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n  {\n      if (!IsPayToScriptHash())\n          return GetSigOpCount(true);\n  \n      // This is a pay-to-script-hash scriptPubKey;\n      // get the last item that the scriptSig\n      // pushes onto the stack:\n      const_iterator pc = scriptSig.begin();\n      vector<unsigned char> data;\n      while (pc < scriptSig.end())\n      {\n          opcodetype opcode;\n          if (!scriptSig.GetOp(pc, opcode, data))\n              return 0;\n          if (opcode > OP_16)\n              return 0;\n      }\n  \n      /// ... and return its opcount:\n      CScript subscript(data.begin(), data.end());\n      return subscript.GetSigOpCount(true);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": ";\n        if",
          "args": [
            "prevout.scriptPubKey.IsPayToScriptHash()"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prevout.scriptPubKey.IsPayToScriptHash",
          "args": [],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "IsPayToScriptHash",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1950-1957",
          "snippet": "bool CScript::IsPayToScriptHash() const\n{\n    // Extra-fast test for pay-to-script-hash CScripts:\n    return (this->size() == 23 &&\n            this->at(0) == OP_HASH160 &&\n            this->at(1) == 0x14 &&\n            this->at(22) == OP_EQUAL);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::IsPayToScriptHash() const\n  {\n      // Extra-fast test for pay-to-script-hash CScripts:\n      return (this->size() == 23 &&\n              this->at(0) == OP_HASH160 &&\n              this->at(1) == 0x14 &&\n              this->at(22) == OP_EQUAL);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOutputFor",
          "args": [
            "vin[i]",
            "inputs"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTransaction::GetP2SHSigOpCount",
          "args": [
            "constMapPrevTx& inputs"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetOutputFor",
          "args": [
            "vin[i]",
            "inputs"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTransaction::GetValueIn",
          "args": [
            "constMapPrevTx& inputs"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::runtime_error",
          "args": [
            "\"CTransaction::GetOutputFor() : prevout.n out of range\""
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    if",
          "args": [
            "input.prevout.n >= txPrev.vout.size()"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::runtime_error",
          "args": [
            "\"CTransaction::GetOutputFor() : prevout.hash not found\""
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n    if",
          "args": [
            "mi == inputs.end()"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inputs.end",
          "args": [],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "inputs.find",
          "args": [
            "input.prevout.hash"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CTransaction::GetOutputFor",
          "args": [
            "constCTxIn& input",
            "constMapPrevTx& inputs"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "inputsRet.count(prevout.hash) != 0"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prevout.hash.ToString",
          "args": [
            "0",
            "10"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txPrev.ReadFromDisk",
          "args": [
            "txindex.pos"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "303-308",
          "snippet": "bool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(COutPoint prevout)\n  {\n      CTxDB txdb(\"r\");\n      CTxIndex txindex;\n      return ReadFromDisk(txdb, prevout, txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txindex.vSpent.resize",
          "args": [
            "txPrev.vout.size()"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.lookup",
          "args": [
            "prevout.hash"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.exists",
          "args": [
            "prevout.hash"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "mempool.cs"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CDiskTxPos",
          "args": [
            "1",
            "1",
            "1"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "CDiskTxPos",
          "container": "CDiskTxPos",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "164-169",
          "snippet": "CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n    {\n        nFile = nFileIn;\n        nBlockPos = nBlockPosIn;\n        nTxPos = nTxPosIn;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskTxPos {\n  CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n      {\n          nFile = nFileIn;\n          nBlockPos = nBlockPosIn;\n          nTxPos = nTxPosIn;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [
            "0",
            "10"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txdb.ReadTxIndex",
          "args": [
            "prevout.hash",
            "txindex"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ReadTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "199-204",
          "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nCoinbaseMaturity = 50;\nint nBestHeight = -1;\n\nCTransaction {\n  bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                                 bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n  {\n      // FetchInputs can return false either because we just haven't seen some inputs\n      // (in which case the transaction should be stored as an orphan)\n      // or because the transaction is malformed (in which case the transaction should\n      // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n      fInvalid = false;\n  \n      if (IsCoinBase())\n          return true; // Coinbase transactions have no inputs to fetch.\n  \n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          COutPoint prevout = vin[i].prevout;\n          if (inputsRet.count(prevout.hash))\n              continue; // Got it already\n  \n          // Read txindex\n          CTxIndex& txindex = inputsRet[prevout.hash].first;\n          bool fFound = true;\n          if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n          {\n              // Get txindex from current proposed changes\n              txindex = mapTestPool.find(prevout.hash)->second;\n          }\n          else\n          {\n              // Read txindex from txdb\n              fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n          }\n          if (!fFound && (fBlock || fMiner))\n              return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n  \n          // Read txPrev\n          CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n          {\n              // Get prev tx from single transactions in memory\n              {\n                  LOCK(mempool.cs);\n                  if (!mempool.exists(prevout.hash))\n                      return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                  txPrev = mempool.lookup(prevout.hash);\n              }\n              if (!fFound)\n                  txindex.vSpent.resize(txPrev.vout.size());\n          }\n          else\n          {\n              // Get prev tx from disk\n              if (!txPrev.ReadFromDisk(txindex.pos))\n                  return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n          }\n      }\n  \n      // Make sure all prevout.n indexes are valid:\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const COutPoint prevout = vin[i].prevout;\n          assert(inputsRet.count(prevout.hash) != 0);\n          const CTxIndex& txindex = inputsRet[prevout.hash].first;\n          const CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n          {\n              // Revisit this if/when transaction replacement is implemented and allows\n              // adding inputs:\n              fInvalid = true;\n              return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n          }\n      }\n  \n      return true;\n  }\n  \n  const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n  {\n      MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n      if (mi == inputs.end())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n  \n      const CTransaction& txPrev = (mi->second).second;\n      if (input.prevout.n >= txPrev.vout.size())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n  \n      return txPrev.vout[input.prevout.n];\n  }\n  \n  int64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      int64_t nResult = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          nResult += GetOutputFor(vin[i], inputs).nValue;\n      }\n      return nResult;\n  \n  }\n  \n  unsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      unsigned int nSigOps = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n          if (prevout.scriptPubKey.IsPayToScriptHash())\n              nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n      }\n      return nSigOps;\n  }\n  \n  bool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n      const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n  {\n      // Take over previous transactions' spent pointers\n      // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n      // fMiner is true when called from the internal bitcoin miner\n      // ... both are false when called from CTransaction::AcceptToMemoryPool\n      if (!IsCoinBase())\n      {\n          int64_t nValueIn = 0;\n          int64_t nFees = 0;\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                  return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n  \n              // If prev is coinbase or coinstake, check that it's matured\n              if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                  for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                      if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                          return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n  \n              // ppcoin: check transaction timestamp\n              if (txPrev.nTime > nTime)\n                  return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n  \n              // Check for negative or overflow input values\n              nValueIn += txPrev.vout[prevout.n].nValue;\n              if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                  return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n  \n          }\n          // The first loop above does all the inexpensive checks.\n          // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n          // Helps prevent CPU exhaustion attacks.\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              // Check for conflicts (double-spend)\n              // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n              // for an attacker to attempt to split the network.\n              if (!txindex.vSpent[prevout.n].IsNull())\n                  return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n  \n              // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n              // before the last blockchain checkpoint. This is safe because block merkle hashes are\n              // still computed and checked, and any change will be caught at the next checkpoint.\n              if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n              {\n                  // Verify signature\n                  if (!VerifySignature(txPrev, *this, i, 0))\n                  {\n                      return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                  }\n              }\n  \n              // Mark outpoints as spent\n              txindex.vSpent[prevout.n] = posThisTx;\n  \n              // Write back\n              if (fBlock || fMiner)\n              {\n                  mapTestPool[prevout.hash] = txindex;\n              }\n          }\n  \n          if (!IsCoinStake())\n          {\n              if (nValueIn < GetValueOut())\n                  return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // Tally transaction fees\n              int64_t nTxFee = nValueIn - GetValueOut();\n              if (nTxFee < 0)\n                  return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // enforce transaction fees for every block\n              if (nTxFee < GetMinFee())\n                  return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n  \n              nFees += nTxFee;\n              if (!MoneyRange(nFees))\n                  return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n          }\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "DisconnectInputs",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1274-1307",
    "snippet": "bool CTransaction::DisconnectInputs(CTxDB& txdb)\n{\n    // Relinquish previous transactions' spent pointers\n    if (!IsCoinBase())\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n        {\n            COutPoint prevout = txin.prevout;\n\n            // Get prev txindex from disk\n            CTxIndex txindex;\n            if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : ReadTxIndex failed\");\n\n            if (prevout.n >= txindex.vSpent.size())\n                return error(\"DisconnectInputs() : prevout.n out of range\");\n\n            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anyway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "txdb.EraseTxIndex",
          "args": [
            "*this"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "EraseTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "222-228",
          "snippet": "bool CTxDB::EraseTxIndex(const CTransaction& tx)\n{\n    assert(!fClient);\n    uint256 hash = tx.GetHash();\n\n    return Erase(make_pair(string(\"tx\"), hash));\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::EraseTxIndex(const CTransaction& tx)\n  {\n      assert(!fClient);\n      uint256 hash = tx.GetHash();\n  \n      return Erase(make_pair(string(\"tx\"), hash));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"DisconnectInputs() : UpdateTxIndex failed\""
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.UpdateTxIndex",
          "args": [
            "prevout.hash",
            "txindex"
          ],
          "line": 1295
        },
        "resolved": true,
        "details": {
          "function_name": "UpdateTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "206-210",
          "snippet": "bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n{\n    assert(!fClient);\n    return Write(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::UpdateTxIndex(uint256 hash, const CTxIndex& txindex)\n  {\n      assert(!fClient);\n      return Write(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txindex.vSpent[prevout.n].SetNull",
          "args": [],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1580-1583",
          "snippet": "void SetNull()\n    {\n        vHave.clear();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  void SetNull()\n      {\n          vHave.clear();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txindex.vSpent.size",
          "args": [],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.ReadTxIndex",
          "args": [
            "prevout.hash",
            "txindex"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "ReadTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "199-204",
          "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinBase",
          "args": [],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::DisconnectInputs(CTxDB& txdb)\n  {\n      // Relinquish previous transactions' spent pointers\n      if (!IsCoinBase())\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n          {\n              COutPoint prevout = txin.prevout;\n  \n              // Get prev txindex from disk\n              CTxIndex txindex;\n              if (!txdb.ReadTxIndex(prevout.hash, txindex))\n                  return error(\"DisconnectInputs() : ReadTxIndex failed\");\n  \n              if (prevout.n >= txindex.vSpent.size())\n                  return error(\"DisconnectInputs() : prevout.n out of range\");\n  \n              // Mark outpoint as not spent\n              txindex.vSpent[prevout.n].SetNull();\n  \n              // Write back\n              if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                  return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n          }\n      }\n  \n      // Remove transaction from index\n      // This can fail if a duplicate of this transaction was in a chain that got\n      // reorganized away. This is only possible if this transaction was completely\n      // spent, so erasing it would be a no-op anyway.\n      txdb.EraseTxIndex(*this);\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "UpdateTime",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1259-1262",
    "snippet": "void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n{\n    nTime = max(GetBlockTime(), GetAdjustedTime());\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "GetBlockTime()",
            "GetAdjustedTime()"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_max_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "433-435",
          "snippet": "void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetAdjustedTime",
          "args": [],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "GetAdjustedTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "1201-1214",
          "snippet": "int64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern int64 nNtpOffset;",
            "int64 nPeersOffset = INT64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nextern int64 nNtpOffset;\nint64 nPeersOffset = INT64_MAX;\n\nint64_t GetAdjustedTime() {\n\n    int64 nTime = GetTime();\n\n     /* If the NTP and system time are within half an hour, follow the former */\n    if(abs64(nNtpOffset) < 30 * 60)\n      return(nTime + nNtpOffset);\n\n     /* If the median peer time and system time are within 1 hour, follow the former */\n    if(abs64(nPeersOffset) < 60 * 60)\n      return(nTime + nPeersOffset);\n\n     return(nTime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetBlockTime",
          "args": [],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  void CBlock::UpdateTime(const CBlockIndex* pindexPrev)\n  {\n      nTime = max(GetBlockTime(), GetAdjustedTime());\n  }\n}"
  },
  {
    "function_name": "InvalidChainFound",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1235-1256",
    "snippet": "void static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "int nBestHeight = -1;",
      "uint256 nBestInvalidTrust = 0;",
      "uint256 hashBestChain = 0;",
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\"",
            "hashBestChain.ToString().substr(0,20).c_str()",
            "nBestHeight",
            "CBigNum(pindexBest->nChainTrust).ToString().c_str()",
            "nBestBlockTrust.Get64()",
            "DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str()"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [
            "\"%x %H:%M:%S\"",
            "pindexBest->GetBlockTime()"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "DateTimeStrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "376-383",
          "snippet": "inline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline std::string DateTimeStrFormat(const char* pszFormat, int64_t nTime)\n{\n    time_t n = nTime;\n    struct tm* ptmTime = gmtime(&n);\n    char pszTime[200];\n    strftime(pszTime, sizeof(pszTime), pszFormat, ptmTime);\n    return pszTime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetBlockTime",
          "args": [],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "nBestBlockTrust.Get64",
          "args": [],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "Get64",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "359-362",
          "snippet": "uint64_t Get64(int n=0) const\n    {\n        return pn[2*n] | (uint64_t)pn[2*n+1] << 32;\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  uint64_t Get64(int n=0) const\n      {\n          return pn[2*n] | (uint64_t)pn[2*n+1] << 32;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "pindexBest->nChainTrust"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBestChain.ToString",
          "args": [],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashBestChain.ToString",
          "args": [
            "0",
            "20"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\"",
            "pindexNew->GetBlockHash().ToString().substr(0,20).c_str()",
            "pindexNew->nHeight",
            "CBigNum(pindexNew->nChainTrust).ToString().c_str()",
            "nBestInvalidBlockTrust.Get64()",
            "DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str()"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DateTimeStrFormat",
          "args": [],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pindexNew->GetBlockHash",
          "args": [],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexNew->GetBlockHash",
          "args": [
            "0",
            "20"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uiInterface.NotifyBlocksChanged",
          "args": [],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTxDB",
          "args": [
            "CBigNum(nBestInvalidTrust)"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "WriteVersion",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "181-184",
          "snippet": "bool WriteVersion(int nVersion)\n    {\n        return Write(std::string(\"version\"), nVersion);\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool WriteVersion(int nVersion)\n      {\n          return Write(std::string(\"version\"), nVersion);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CTxDB",
          "args": [],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "TxnAbort",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "168-173",
          "snippet": "bool TxnAbort()\n    {\n        delete activeBatch;\n        activeBatch = NULL;\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool TxnAbort()\n      {\n          delete activeBatch;\n          activeBatch = NULL;\n          return true;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nBestHeight = -1;\nuint256 nBestInvalidTrust = 0;\nuint256 hashBestChain = 0;\nCBlockIndex* pindexBest = NULL;\n\nvoid static InvalidChainFound(CBlockIndex* pindexNew)\n{\n    if (pindexNew->nChainTrust > nBestInvalidTrust)\n    {\n        nBestInvalidTrust = pindexNew->nChainTrust;\n        CTxDB().WriteBestInvalidTrust(CBigNum(nBestInvalidTrust));\n        uiInterface.NotifyBlocksChanged();\n    }\n\n    uint256 nBestInvalidBlockTrust = pindexNew->nChainTrust - pindexNew->pprev->nChainTrust;\n    uint256 nBestBlockTrust = pindexBest->nHeight != 0 ? (pindexBest->nChainTrust - pindexBest->pprev->nChainTrust) : pindexBest->nChainTrust;\n\n    printf(\"InvalidChainFound: invalid block=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      pindexNew->GetBlockHash().ToString().substr(0,20).c_str(), pindexNew->nHeight,\n      CBigNum(pindexNew->nChainTrust).ToString().c_str(), nBestInvalidBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexNew->GetBlockTime()).c_str());\n    printf(\"InvalidChainFound:  current best=%s  height=%d  trust=%s  blocktrust=%\"PRId64\"  date=%s\\n\",\n      hashBestChain.ToString().substr(0,20).c_str(), nBestHeight,\n      CBigNum(pindexBest->nChainTrust).ToString().c_str(),\n      nBestBlockTrust.Get64(),\n      DateTimeStrFormat(\"%x %H:%M:%S\", pindexBest->GetBlockTime()).c_str());\n}"
  },
  {
    "function_name": "IsInitialBlockDownload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1220-1233",
    "snippet": "bool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nBestHeight = -1;",
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindexBest->GetBlockTime",
          "args": [],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockTime",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1284-1287",
          "snippet": "int64_t GetBlockTime() const\n    {\n        return (int64_t)nTime;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  int64_t GetBlockTime() const\n      {\n          return (int64_t)nTime;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Checkpoints::GetTotalBlocksEstimate",
          "args": [],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "GetTotalBlocksEstimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "61-66",
          "snippet": "int GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nint GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nBestHeight = -1;\nCBlockIndex* pindexBest = NULL;\n\nbool IsInitialBlockDownload()\n{\n    if (pindexBest == NULL || nBestHeight < Checkpoints::GetTotalBlocksEstimate())\n        return true;\n    static int64_t nLastUpdate;\n    static CBlockIndex* pindexLastBest;\n    if (pindexBest != pindexLastBest)\n    {\n        pindexLastBest = pindexBest;\n        nLastUpdate = GetTime();\n    }\n    return(((GetTime() - nLastUpdate) < 10) &&\n      (pindexBest->GetBlockTime() < (GetTime() - 4 * 60 * 60)));\n}"
  },
  {
    "function_name": "GetNumBlocksOfPeers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1215-1218",
    "snippet": "int GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CMedianFilter<int> cPeerBlockCounts(5, 0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::max",
          "args": [
            "cPeerBlockCounts.median()",
            "Checkpoints::GetTotalBlocksEstimate()"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Checkpoints::GetTotalBlocksEstimate",
          "args": [],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "GetTotalBlocksEstimate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.cpp",
          "lines": "61-66",
          "snippet": "int GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }",
          "includes": [
            "#include \"uint256.h\"",
            "#include \"main.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include <boost/foreach.hpp>",
            "#include <boost/assign/list_of.hpp> // for 'map_list_of()'"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"uint256.h\"\n#include \"main.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include <boost/foreach.hpp>\n#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n\nint GetTotalBlocksEstimate()\n    {\n        MapCheckpoints& checkpoints = (fTestNet ? mapCheckpointsTestnet : mapCheckpoints);\n\n        return checkpoints.rbegin()->first;\n    }"
        }
      },
      {
        "call_info": {
          "callee": "cPeerBlockCounts.median",
          "args": [],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "median",
          "container": "CMedianFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "609-621",
          "snippet": "T median() const\n    {\n        int size = vSorted.size();\n        assert(size>0);\n        if(size & 1) // Odd number of elements\n        {\n            return vSorted[size/2];\n        }\n        else // Even number of elements\n        {\n            return (vSorted[size/2-1] + vSorted[size/2]) / 2;\n        }\n    }",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nCMedianFilter {\n  T median() const\n      {\n          int size = vSorted.size();\n          assert(size>0);\n          if(size & 1) // Odd number of elements\n          {\n              return vSorted[size/2];\n          }\n          else // Even number of elements\n          {\n              return (vSorted[size/2-1] + vSorted[size/2]) / 2;\n          }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCMedianFilter<int> cPeerBlockCounts(5, 0);\n\nint GetNumBlocksOfPeers()\n{\n    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n}"
  },
  {
    "function_name": "CheckProofOfWork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1198-1212",
    "snippet": "bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CheckProofOfWork() : hash doesn't match nBits\""
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bnTarget.getuint256",
          "args": [],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "getuint256",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "278-291",
          "snippet": "uint256 getuint256() const\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        if (nSize < 4)\n            return 0;\n        std::vector<unsigned char> vch(nSize);\n        BN_bn2mpi(this, &vch[0]);\n        if (vch.size() > 4)\n            vch[4] &= 0x7f;\n        uint256 n = 0;\n        for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n            ((unsigned char*)&n)[i] = vch[j];\n        return n;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  uint256 getuint256() const\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          if (nSize < 4)\n              return 0;\n          std::vector<unsigned char> vch(nSize);\n          BN_bn2mpi(this, &vch[0]);\n          if (vch.size() > 4)\n              vch[4] &= 0x7f;\n          uint256 n = 0;\n          for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n              ((unsigned char*)&n)[i] = vch[j];\n          return n;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "bnTarget.SetCompact",
          "args": [
            "nBits"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool CheckProofOfWork(uint256 hash, unsigned int nBits)\n{\n    CBigNum bnTarget;\n    bnTarget.SetCompact(nBits);\n\n    // Check range\n    if (bnTarget <= 0 || bnTarget > bnProofOfWorkLimit)\n        return error(\"CheckProofOfWork() : nBits below minimum work\");\n\n    // Check proof of work matches claimed amount\n    if (hash > bnTarget.getuint256())\n        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n\n    return true;\n}"
  },
  {
    "function_name": "GetNextTargetRequired",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1039-1195",
    "snippet": "uint GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake,\n  bool fPrettyPrint) {\n    CBigNum bnTargetLimit, bnNew;\n\n    /* Separate range limits */\n    if(fTestNet) {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimitTestNet;\n        else bnTargetLimit = bnProofOfWorkLimitTestNet;\n    } else {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimit;\n        else bnTargetLimit = bnProofOfWorkLimit;\n    }\n\n    /* The genesis block */\n    if(pindexLast == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);\n    /* The 1st block */\n    if(pindexPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);\n    /* The 2nd block */\n    if(pindexPrevPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    /* The next block */\n    int nHeight = pindexLast->nHeight + 1;\n\n    if(!fTestNet && (nHeight < nForkOne)) {\n\n        /* Legacy every block retargets of the PPC style */\n\n        int64 nTargetTimespan = 20 * 60;\n        int64 nTargetSpacing = 2 * nBaseTargetSpacing;\n        int64 nInterval, nActualSpacing;\n\n        nActualSpacing = (int64)pindexPrev->nTime - (int64)pindexPrevPrev->nTime;\n        if(nActualSpacing < 0)\n          nActualSpacing = nTargetSpacing;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: pindexLast = %d, pindexPrev = %d, pindexPrevPrev = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexPrevPrev->nHeight);\n            printf(\"RETARGET time stamps: pindexLast = %u, pindexPrev = %u, pindexPrevPrev = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexPrevPrev->nTime);\n        }\n\n        nInterval = nTargetTimespan / nTargetSpacing;\n\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);\n        bnNew /= ((nInterval + 1) * nTargetSpacing);\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nTargetSpacing = %\"PRI64d\", \"\n            \"nInterval = %\"PRI64d\"\\n\", nTargetTimespan, nTargetSpacing, nInterval);\n\n    } else {\n\n        if(!fTestNet) {\n            /* The hard fork to NeoScrypt */\n            if(!fNeoScrypt) fNeoScrypt = true;\n            /* PoW difficulty reset after the switch */\n            if(!fProofOfStake && (pindexPrev->nHeight < nForkOne))\n              return(bnNeoScryptSwitch.GetCompact());\n        }\n\n        /* Orbitcoin Super Shield (OSS);\n         * retargets every block using two averaging windows of 5 and 20 blocks,\n         * 0.25 damping and +1% to -2% limiting */\n\n        int64 nIntervalShort = 5, nIntervalLong = 20, nTargetSpacing, nTargetTimespan,\n              nActualTimespan, nActualTimespanShort, nActualTimespanLong, nActualTimespanAvg,\n              nActualTimespanMax, nActualTimespanMin;\n        uint i;\n\n        if(fProofOfStake)\n          nTargetSpacing = 5 * nBaseTargetSpacing;\n        else\n          nTargetSpacing = 20 * nBaseTargetSpacing;\n\n        nTargetTimespan = nTargetSpacing * nIntervalLong;\n\n        /* The short averaging window */\n        const CBlockIndex* pindexShort = pindexPrev;\n        for(i = 0; i < nIntervalShort; i++) {\n            if(pindexShort->pprev)\n              pindexShort = GetLastBlockIndex(pindexShort->pprev, fProofOfStake);\n            else\n              return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanShort = (int64)pindexPrev->nTime - (int64)pindexShort->nTime;\n\n        /* The long averaging window */\n        const CBlockIndex* pindexLong = pindexShort;\n        for(i = 0; i < (nIntervalLong - nIntervalShort); i++) {\n           if(pindexLong->pprev)\n             pindexLong = GetLastBlockIndex(pindexLong->pprev, fProofOfStake);\n           else\n             return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanLong = (int64)pindexPrev->nTime - (int64)pindexLong->nTime;\n\n        /* Time warp protection */\n        nActualTimespanShort = max(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 3 / 4));\n        nActualTimespanShort = min(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 4 / 3));\n        nActualTimespanLong  = max(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 3 / 4));\n        nActualTimespanLong  = min(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 4 / 3));\n\n        /* The average of both windows */\n        nActualTimespanAvg = (nActualTimespanShort * (nIntervalLong / nIntervalShort) + nActualTimespanLong) / 2;\n\n        /* 0.25 damping */\n        nActualTimespan = nActualTimespanAvg + 3 * nTargetTimespan;\n        nActualTimespan /= 4;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: Last = %d, Prev = %d, Short = %d, Long = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexShort->nHeight, pindexLong->nHeight);\n            printf(\"RETARGET time stamps: Last = %u, Prev = %u, Short = %u, Long = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexShort->nTime, pindexLong->nTime);\n            printf(\"RETARGET windows: short = %\"PRI64d\" (%\"PRI64d\"), long = %\"PRI64d\", \"\n              \"average = %\"PRI64d\", damped = %\"PRI64d\"\\n\",\n              nActualTimespanShort, nActualTimespanShort * (nIntervalLong / nIntervalShort),\n              nActualTimespanLong, nActualTimespanAvg, nActualTimespan);\n        }\n\n        /* Difficulty limiters */\n        nActualTimespanMax = nTargetTimespan * 102 / 100;\n        nActualTimespanMin = nTargetTimespan * 100 / 101;\n        if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n        if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n        /* Retarget */\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= nActualTimespan;\n        bnNew /= nTargetTimespan;\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nActualTimespan = %\"PRI64d\", \"\n            \"nTargetTimespan / nActualTimespan = %.4f\\n\",\n            nTargetTimespan, nActualTimespan, (float)nTargetTimespan / (float)nActualTimespan);\n\n    }\n\n    if(fPrettyPrint) {\n        printf(\"Before: %08x  %s\\n\", pindexPrev->nBits,\n          CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str());\n        printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n    }\n\n    return(bnNew.GetCompact());\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const uint nBaseTargetSpacing = 30;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bnNew.GetCompact",
          "args": [],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "GetCompact",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "333-344",
          "snippet": "unsigned int GetCompact() const\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        std::vector<unsigned char> vch(nSize);\n        nSize -= 4;\n        BN_bn2mpi(this, &vch[0]);\n        unsigned int nCompact = nSize << 24;\n        if (nSize >= 1) nCompact |= (vch[4] << 16);\n        if (nSize >= 2) nCompact |= (vch[5] << 8);\n        if (nSize >= 3) nCompact |= (vch[6] << 0);\n        return nCompact;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  unsigned int GetCompact() const\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          std::vector<unsigned char> vch(nSize);\n          nSize -= 4;\n          BN_bn2mpi(this, &vch[0]);\n          unsigned int nCompact = nSize << 24;\n          if (nSize >= 1) nCompact |= (vch[4] << 16);\n          if (nSize >= 2) nCompact |= (vch[5] << 8);\n          if (nSize >= 3) nCompact |= (vch[6] << 0);\n          return nCompact;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"After:  %08x  %s\\n\"",
            "bnNew.GetCompact()",
            "bnNew.getuint256().ToString().c_str()"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bnNew.getuint256",
          "args": [],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "getuint256",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "278-291",
          "snippet": "uint256 getuint256() const\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        if (nSize < 4)\n            return 0;\n        std::vector<unsigned char> vch(nSize);\n        BN_bn2mpi(this, &vch[0]);\n        if (vch.size() > 4)\n            vch[4] &= 0x7f;\n        uint256 n = 0;\n        for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n            ((unsigned char*)&n)[i] = vch[j];\n        return n;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  uint256 getuint256() const\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          if (nSize < 4)\n              return 0;\n          std::vector<unsigned char> vch(nSize);\n          BN_bn2mpi(this, &vch[0]);\n          if (vch.size() > 4)\n              vch[4] &= 0x7f;\n          uint256 n = 0;\n          for (unsigned int i = 0, j = vch.size()-1; i < sizeof(n) && j >= 4; i++, j--)\n              ((unsigned char*)&n)[i] = vch[j];\n          return n;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Before: %08x  %s\\n\"",
            "pindexPrev->nBits",
            "CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str()"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "pindexPrev->nBits"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET nTargetTimespan = %\"PRI64d\", nActualTimespan = %\"PRI64d\", \"\n            \"nTargetTimespan / nActualTimespan = %.4f\\n\"",
            "nTargetTimespan",
            "nActualTimespan",
            "(float)nTargetTimespan / (float)nActualTimespan"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bnNew.SetCompact",
          "args": [
            "pindexPrev->nBits"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET windows: short = %\"PRI64d\" (%\"PRI64d\"), long = %\"PRI64d\", \"\n              \"average = %\"PRI64d\", damped = %\"PRI64d\"\\n\"",
            "nActualTimespanShort",
            "nActualTimespanShort * (nIntervalLong / nIntervalShort)",
            "nActualTimespanLong",
            "nActualTimespanAvg",
            "nActualTimespan"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET time stamps: Last = %u, Prev = %u, Short = %u, Long = %u\\n\"",
            "pindexLast->nTime",
            "pindexPrev->nTime",
            "pindexShort->nTime",
            "pindexLong->nTime"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"heights: Last = %d, Prev = %d, Short = %d, Long = %d\\n\"",
            "pindexLast->nHeight",
            "pindexPrev->nHeight",
            "pindexShort->nHeight",
            "pindexLong->nHeight"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET PoW \""
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET PoS \""
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "nActualTimespanLong",
            "(nTargetSpacing * nIntervalLong  * 4 / 3)"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "TimingResistantEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "569-576",
          "snippet": "bool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nActualTimespanLong",
            "(nTargetSpacing * nIntervalLong  * 3 / 4)"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_max_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "433-435",
          "snippet": "void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [
            "pindexLong->pprev",
            "fProofOfStake"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [
            "pindexShort->pprev",
            "fProofOfStake"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET nTargetTimespan = %\"PRI64d\", nTargetSpacing = %\"PRI64d\", \"\n            \"nInterval = %\"PRI64d\"\\n\"",
            "nTargetTimespan",
            "nTargetSpacing",
            "nInterval"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bnNew.SetCompact",
          "args": [
            "pindexPrev->nBits"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET time stamps: pindexLast = %u, pindexPrev = %u, pindexPrevPrev = %u\\n\"",
            "pindexLast->nTime",
            "pindexPrev->nTime",
            "pindexPrevPrev->nTime"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"heights: pindexLast = %d, pindexPrev = %d, pindexPrevPrev = %d\\n\"",
            "pindexLast->nHeight",
            "pindexPrev->nHeight",
            "pindexPrevPrev->nHeight"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET PoW \""
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"RETARGET PoS \""
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [
            "pindexPrev->pprev",
            "fProofOfStake"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetLastBlockIndex",
          "args": [
            "pindexLast",
            "fProofOfStake"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nconst uint nBaseTargetSpacing = 30;\n\nuint GetNextTargetRequired(const CBlockIndex* pindexLast, bool fProofOfStake,\n  bool fPrettyPrint) {\n    CBigNum bnTargetLimit, bnNew;\n\n    /* Separate range limits */\n    if(fTestNet) {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimitTestNet;\n        else bnTargetLimit = bnProofOfWorkLimitTestNet;\n    } else {\n        if(fProofOfStake) bnTargetLimit = bnProofOfStakeLimit;\n        else bnTargetLimit = bnProofOfWorkLimit;\n    }\n\n    /* The genesis block */\n    if(pindexLast == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrev = GetLastBlockIndex(pindexLast, fProofOfStake);\n    /* The 1st block */\n    if(pindexPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    const CBlockIndex* pindexPrevPrev = GetLastBlockIndex(pindexPrev->pprev, fProofOfStake);\n    /* The 2nd block */\n    if(pindexPrevPrev->pprev == NULL) return(bnTargetLimit.GetCompact());\n    /* The next block */\n    int nHeight = pindexLast->nHeight + 1;\n\n    if(!fTestNet && (nHeight < nForkOne)) {\n\n        /* Legacy every block retargets of the PPC style */\n\n        int64 nTargetTimespan = 20 * 60;\n        int64 nTargetSpacing = 2 * nBaseTargetSpacing;\n        int64 nInterval, nActualSpacing;\n\n        nActualSpacing = (int64)pindexPrev->nTime - (int64)pindexPrevPrev->nTime;\n        if(nActualSpacing < 0)\n          nActualSpacing = nTargetSpacing;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: pindexLast = %d, pindexPrev = %d, pindexPrevPrev = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexPrevPrev->nHeight);\n            printf(\"RETARGET time stamps: pindexLast = %u, pindexPrev = %u, pindexPrevPrev = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexPrevPrev->nTime);\n        }\n\n        nInterval = nTargetTimespan / nTargetSpacing;\n\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= ((nInterval - 1) * nTargetSpacing + nActualSpacing + nActualSpacing);\n        bnNew /= ((nInterval + 1) * nTargetSpacing);\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nTargetSpacing = %\"PRI64d\", \"\n            \"nInterval = %\"PRI64d\"\\n\", nTargetTimespan, nTargetSpacing, nInterval);\n\n    } else {\n\n        if(!fTestNet) {\n            /* The hard fork to NeoScrypt */\n            if(!fNeoScrypt) fNeoScrypt = true;\n            /* PoW difficulty reset after the switch */\n            if(!fProofOfStake && (pindexPrev->nHeight < nForkOne))\n              return(bnNeoScryptSwitch.GetCompact());\n        }\n\n        /* Orbitcoin Super Shield (OSS);\n         * retargets every block using two averaging windows of 5 and 20 blocks,\n         * 0.25 damping and +1% to -2% limiting */\n\n        int64 nIntervalShort = 5, nIntervalLong = 20, nTargetSpacing, nTargetTimespan,\n              nActualTimespan, nActualTimespanShort, nActualTimespanLong, nActualTimespanAvg,\n              nActualTimespanMax, nActualTimespanMin;\n        uint i;\n\n        if(fProofOfStake)\n          nTargetSpacing = 5 * nBaseTargetSpacing;\n        else\n          nTargetSpacing = 20 * nBaseTargetSpacing;\n\n        nTargetTimespan = nTargetSpacing * nIntervalLong;\n\n        /* The short averaging window */\n        const CBlockIndex* pindexShort = pindexPrev;\n        for(i = 0; i < nIntervalShort; i++) {\n            if(pindexShort->pprev)\n              pindexShort = GetLastBlockIndex(pindexShort->pprev, fProofOfStake);\n            else\n              return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanShort = (int64)pindexPrev->nTime - (int64)pindexShort->nTime;\n\n        /* The long averaging window */\n        const CBlockIndex* pindexLong = pindexShort;\n        for(i = 0; i < (nIntervalLong - nIntervalShort); i++) {\n           if(pindexLong->pprev)\n             pindexLong = GetLastBlockIndex(pindexLong->pprev, fProofOfStake);\n           else\n             return(bnTargetLimit.GetCompact());\n        }\n        nActualTimespanLong = (int64)pindexPrev->nTime - (int64)pindexLong->nTime;\n\n        /* Time warp protection */\n        nActualTimespanShort = max(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 3 / 4));\n        nActualTimespanShort = min(nActualTimespanShort, (nTargetSpacing * nIntervalShort * 4 / 3));\n        nActualTimespanLong  = max(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 3 / 4));\n        nActualTimespanLong  = min(nActualTimespanLong,  (nTargetSpacing * nIntervalLong  * 4 / 3));\n\n        /* The average of both windows */\n        nActualTimespanAvg = (nActualTimespanShort * (nIntervalLong / nIntervalShort) + nActualTimespanLong) / 2;\n\n        /* 0.25 damping */\n        nActualTimespan = nActualTimespanAvg + 3 * nTargetTimespan;\n        nActualTimespan /= 4;\n\n        if(fPrettyPrint) {\n            fProofOfStake? printf(\"RETARGET PoS \") : printf(\"RETARGET PoW \");\n            printf(\"heights: Last = %d, Prev = %d, Short = %d, Long = %d\\n\",\n              pindexLast->nHeight, pindexPrev->nHeight, pindexShort->nHeight, pindexLong->nHeight);\n            printf(\"RETARGET time stamps: Last = %u, Prev = %u, Short = %u, Long = %u\\n\",\n              pindexLast->nTime, pindexPrev->nTime, pindexShort->nTime, pindexLong->nTime);\n            printf(\"RETARGET windows: short = %\"PRI64d\" (%\"PRI64d\"), long = %\"PRI64d\", \"\n              \"average = %\"PRI64d\", damped = %\"PRI64d\"\\n\",\n              nActualTimespanShort, nActualTimespanShort * (nIntervalLong / nIntervalShort),\n              nActualTimespanLong, nActualTimespanAvg, nActualTimespan);\n        }\n\n        /* Difficulty limiters */\n        nActualTimespanMax = nTargetTimespan * 102 / 100;\n        nActualTimespanMin = nTargetTimespan * 100 / 101;\n        if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;\n        if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;\n\n        /* Retarget */\n        bnNew.SetCompact(pindexPrev->nBits);\n        bnNew *= nActualTimespan;\n        bnNew /= nTargetTimespan;\n\n        if((bnNew <= 0) || (bnNew > bnTargetLimit))\n          bnNew = bnTargetLimit;\n\n        if(fPrettyPrint)\n          printf(\"RETARGET nTargetTimespan = %\"PRI64d\", nActualTimespan = %\"PRI64d\", \"\n            \"nTargetTimespan / nActualTimespan = %.4f\\n\",\n            nTargetTimespan, nActualTimespan, (float)nTargetTimespan / (float)nActualTimespan);\n\n    }\n\n    if(fPrettyPrint) {\n        printf(\"Before: %08x  %s\\n\", pindexPrev->nBits,\n          CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str());\n        printf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());\n    }\n\n    return(bnNew.GetCompact());\n}"
  },
  {
    "function_name": "GetProofOfStakeReward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "1005-1029",
    "snippet": "int64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfStakeReward(int64_t nHeight, int64_t nCoinAge, int64_t nFees) {\n    int64_t nRewardCoinYear = 9 * CENT;\n    int64_t nSubsidy;\n\n    if(fTestNet) {\n        nRewardCoinYear   = 300 * CENT;\n    } else {\n        if(nHeight >= nForkOne)\n          nRewardCoinYear = 300 * CENT;\n        if(nHeight >= (nForkOne + 130000))\n          nRewardCoinYear = 200 * CENT;\n        if(nHeight >= (nForkOne + 260000))\n          nRewardCoinYear = 100 * CENT;\n    }\n\n    if(!fTestNet && (nHeight < nStakeRewardFork))\n      nSubsidy = (nCoinAge * nRewardCoinYear) / (365 * COIN);\n    else\n      nSubsidy = (nCoinAge / 365) * (nRewardCoinYear / COIN);\n\n    if(fTestNet || (!fTestNet && (nHeight >= nForkOne)))\n      if(nSubsidy > 5 * COIN) nSubsidy = 5 * COIN;\n\n    return(nSubsidy + nFees);\n}"
  },
  {
    "function_name": "GetProofOfWorkReward",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "976-1003",
    "snippet": "int64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint64_t GetProofOfWorkReward(int64_t nHeight, int64_t nFees) {\n    int64_t nSubsidy = 5 * COIN;\n\n    if(fTestNet) {\n        if(nHeight <= 2000)           nSubsidy = 300 * COIN;\n    } else {\n        if(nHeight <= 20000) {\n            if(nHeight <= 2000)       nSubsidy = 300 * COIN;\n            else if(nHeight <= 4000)  nSubsidy = 250 * COIN;\n            else if(nHeight <= 5000)  nSubsidy = 200 * COIN;\n            else if(nHeight <= 6400)  nSubsidy = 150 * COIN;\n            else if(nHeight <= 6800)  nSubsidy = 100 * COIN;\n            else if(nHeight <= 7800)  nSubsidy = 50  * COIN;\n            else if(nHeight <= 9000)  nSubsidy = 20  * COIN;\n            else if(nHeight <= 10000) nSubsidy = 100 * COIN;\n            else if(nHeight <= 12000) nSubsidy = 80  * COIN;\n            else if(nHeight <= 15000) nSubsidy = 60  * COIN;\n            else if(nHeight <= 16000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 17000) nSubsidy = 40  * COIN;\n            else if(nHeight <= 18000) nSubsidy = 50  * COIN;\n            else if(nHeight <= 19000) nSubsidy = 30  * COIN;\n            else if(nHeight <= 19500) nSubsidy = 20  * COIN;\n            else if(nHeight <= 20000) nSubsidy = 100 * COIN;\n        }\n    }\n\n    return(nSubsidy + nFees);\n}"
  },
  {
    "function_name": "WantedByOrphan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "968-974",
    "snippet": "uint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "map<uint256, CBlock*> mapOrphanBlocks;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapOrphanBlocks.count",
          "args": [
            "pblockOrphan->hashPrevBlock"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CBlock*> mapOrphanBlocks;\n\nuint256 WantedByOrphan(const CBlock* pblockOrphan)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblockOrphan->hashPrevBlock))\n        pblockOrphan = mapOrphanBlocks[pblockOrphan->hashPrevBlock];\n    return pblockOrphan->hashPrevBlock;\n}"
  },
  {
    "function_name": "GetOrphanRoot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "959-965",
    "snippet": "uint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "map<uint256, CBlock*> mapOrphanBlocks;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pblock->GetHash",
          "args": [],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanBlocks.count",
          "args": [
            "pblock->hashPrevBlock"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CBlock*> mapOrphanBlocks;\n\nuint256 static GetOrphanRoot(const CBlock* pblock)\n{\n    // Work back to the first block in the orphan chain\n    while (mapOrphanBlocks.count(pblock->hashPrevBlock))\n        pblock = mapOrphanBlocks[pblock->hashPrevBlock];\n    return pblock->GetHash();\n}"
  },
  {
    "function_name": "ReadFromDisk",
    "container": "CBlock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "945-957",
    "snippet": "bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CBlock::ReadFromDisk() : GetHash() doesn't match index\""
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHash",
          "args": [],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHash",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1644-1658",
          "snippet": "uint256 GetBlockHash()\n    {\n        // Find the first block the caller has in the main chain\n        BOOST_FOREACH(const uint256& hash, vHave)\n        {\n            std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n            if (mi != mapBlockIndex.end())\n            {\n                CBlockIndex* pindex = (*mi).second;\n                if (pindex->IsInMainChain())\n                    return hash;\n            }\n        }\n        return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  uint256 GetBlockHash()\n      {\n          // Find the first block the caller has in the main chain\n          BOOST_FOREACH(const uint256& hash, vHave)\n          {\n              std::map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hash);\n              if (mi != mapBlockIndex.end())\n              {\n                  CBlockIndex* pindex = (*mi).second;\n                  if (pindex->IsInMainChain())\n                      return hash;\n              }\n          }\n          return (!fTestNet ? hashGenesisBlock : hashGenesisBlockTestNet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadFromDisk",
          "args": [
            "pindex->nFile",
            "pindex->nBlockPos",
            "fReadTransactions"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n  {\n      SetNull();\n      if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n          return false;\n      if (!ReadFromDisk(txindexRet.pos))\n          return false;\n      if (prevout.n >= vout.size())\n      {\n          SetNull();\n          return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->GetBlockHeader",
          "args": [],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "GetBlockHeader",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1266-1277",
          "snippet": "CBlock GetBlockHeader() const\n    {\n        CBlock block;\n        block.nVersion       = nVersion;\n        if (pprev)\n            block.hashPrevBlock = pprev->GetBlockHash();\n        block.hashMerkleRoot = hashMerkleRoot;\n        block.nTime          = nTime;\n        block.nBits          = nBits;\n        block.nNonce         = nNonce;\n        return block;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  CBlock GetBlockHeader() const\n      {\n          CBlock block;\n          block.nVersion       = nVersion;\n          if (pprev)\n              block.hashPrevBlock = pprev->GetBlockHash();\n          block.hashMerkleRoot = hashMerkleRoot;\n          block.nTime          = nTime;\n          block.nBits          = nBits;\n          block.nNonce         = nNonce;\n          return block;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n  {\n      if (!fReadTransactions)\n      {\n          *this = pindex->GetBlockHeader();\n          return true;\n      }\n      if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n          return false;\n      if (GetHash() != pindex->GetBlockHash())\n          return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n      return true;\n  }\n}"
  },
  {
    "function_name": "GetTransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "890-913",
    "snippet": "bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CCriticalSection cs_main;",
      "CTxMemPool mempool;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block.GetHash",
          "args": [],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "txindex.pos.nFile",
            "txindex.pos.nBlockPos",
            "false"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n  {\n      SetNull();\n      if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n          return false;\n      if (!ReadFromDisk(txindexRet.pos))\n          return false;\n      if (prevout.n >= vout.size())\n      {\n          SetNull();\n          return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "COutPoint",
          "args": [
            "hash",
            "0"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "COutPoint",
          "container": "COutPoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "227-227",
          "snippet": "COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCOutPoint {\n  COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.lookup",
          "args": [
            "hash"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mempool.exists",
          "args": [
            "hash"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "mempool.cs"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_main"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_main;\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock)\n{\n    {\n        LOCK(cs_main);\n        {\n            LOCK(mempool.cs);\n            if (mempool.exists(hash))\n            {\n                tx = mempool.lookup(hash);\n                return true;\n            }\n        }\n        CTxDB txdb(\"r\");\n        CTxIndex txindex;\n        if (tx.ReadFromDisk(txdb, COutPoint(hash, 0), txindex))\n        {\n            CBlock block;\n            if (block.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos, false))\n                hashBlock = block.GetHash();\n            return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "function_name": "GetDepthInMainChain",
    "container": "CTxIndex",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "873-887",
    "snippet": "int CTxIndex::GetDepthInMainChain() const\n{\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n        return 0;\n    // Find the block in the index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n    return 1 + nBestHeight - pindex->nHeight;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "int nBestHeight = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pindex->IsInMainChain",
          "args": [],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.find",
          "args": [
            "block.GetHash()"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.GetHash",
          "args": [],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "block.ReadFromDisk",
          "args": [
            "pos.nFile",
            "pos.nBlockPos",
            "false"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n  {\n      SetNull();\n      if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n          return false;\n      if (!ReadFromDisk(txindexRet.pos))\n          return false;\n      if (prevout.n >= vout.size())\n      {\n          SetNull();\n          return false;\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nBestHeight = -1;\n\nCTxIndex {\n  int CTxIndex::GetDepthInMainChain() const\n  {\n      // Read block header\n      CBlock block;\n      if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n          return 0;\n      // Find the block in the index\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n      if (mi == mapBlockIndex.end())\n          return 0;\n      CBlockIndex* pindex = (*mi).second;\n      if (!pindex || !pindex->IsInMainChain())\n          return 0;\n      return 1 + nBestHeight - pindex->nHeight;\n  }\n}"
  },
  {
    "function_name": "AcceptWalletTransaction",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "867-871",
    "snippet": "bool CWalletTx::AcceptWalletTransaction()\n{\n    CTxDB txdb(\"r\");\n    return AcceptWalletTransaction(txdb);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AcceptWalletTransaction",
          "args": [
            "txdb"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCWalletTx {\n  bool CWalletTx::AcceptWalletTransaction()\n  {\n      CTxDB txdb(\"r\");\n      return AcceptWalletTransaction(txdb);\n  }\n}"
  },
  {
    "function_name": "AcceptWalletTransaction",
    "container": "CWalletTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "847-865",
    "snippet": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n\n    {\n        LOCK(mempool.cs);\n        // Add previous supporting transactions first\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "AcceptToMemoryPool",
          "args": [
            "txdb",
            "fCheckInputs"
          ],
          "line": 862
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptToMemoryPool",
          "container": "CMerkleTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "825-837",
          "snippet": "bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCMerkleTx {\n  bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n  {\n      if (fClient)\n      {\n          if (!IsInMainChain() && !ClientConnectInputs())\n              return false;\n          return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n      }\n      else\n      {\n          return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.ContainsTx",
          "args": [
            "hash"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "ContainsTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "230-234",
          "snippet": "bool CTxDB::ContainsTx(uint256 hash)\n{\n    assert(!fClient);\n    return Exists(make_pair(string(\"tx\"), hash));\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ContainsTx(uint256 hash)\n  {\n      assert(!fClient);\n      return Exists(make_pair(string(\"tx\"), hash));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.exists",
          "args": [
            "hash"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinBase",
          "args": [],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "mempool.cs"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCWalletTx {\n  bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n  {\n  \n      {\n          LOCK(mempool.cs);\n          // Add previous supporting transactions first\n          BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n          {\n              if (!(tx.IsCoinBase() || tx.IsCoinStake()))\n              {\n                  uint256 hash = tx.GetHash();\n                  if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                      tx.AcceptToMemoryPool(txdb, fCheckInputs);\n              }\n          }\n          return AcceptToMemoryPool(txdb, fCheckInputs);\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "AcceptToMemoryPool",
    "container": "CMerkleTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "839-843",
    "snippet": "bool CMerkleTx::AcceptToMemoryPool()\n{\n    CTxDB txdb(\"r\");\n    return AcceptToMemoryPool(txdb);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AcceptToMemoryPool",
          "args": [
            "txdb"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCMerkleTx {\n  bool CMerkleTx::AcceptToMemoryPool()\n  {\n      CTxDB txdb(\"r\");\n      return AcceptToMemoryPool(txdb);\n  }\n}"
  },
  {
    "function_name": "AcceptToMemoryPool",
    "container": "CMerkleTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "825-837",
    "snippet": "bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CTransaction::AcceptToMemoryPool",
          "args": [
            "txdb",
            "fCheckInputs"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "AcceptToMemoryPool",
          "container": "CMerkleTx",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "825-837",
          "snippet": "bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n{\n    if (fClient)\n    {\n        if (!IsInMainChain() && !ClientConnectInputs())\n            return false;\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    else\n    {\n        return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ClientConnectInputs",
          "args": [],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "ClientConnectInputs",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1526-1570",
          "snippet": "bool CTransaction::ClientConnectInputs()\n{\n    if (IsCoinBase())\n        return false;\n\n    // Take over previous transactions' spent pointers\n    {\n        LOCK(mempool.cs);\n        int64_t nValueIn = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            // Get prev tx from single transactions in memory\n            COutPoint prevout = vin[i].prevout;\n            if (!mempool.exists(prevout.hash))\n                return false;\n            CTransaction& txPrev = mempool.lookup(prevout.hash);\n\n            if (prevout.n >= txPrev.vout.size())\n                return false;\n\n            // Verify signature\n            if (!VerifySignature(txPrev, *this, i, 0))\n                return error(\"ConnectInputs() : VerifySignature failed\");\n\n            ///// this is redundant with the mempool.mapNextTx stuff,\n            ///// not sure which I want to get rid of\n            ///// this has to go away now that posNext is gone\n            // // Check for conflicts\n            // if (!txPrev.vout[prevout.n].posNext.IsNull())\n            //     return error(\"ConnectInputs() : prev tx already used\");\n            //\n            // // Flag outpoints as used\n            // txPrev.vout[prevout.n].posNext = posThisTx;\n\n            nValueIn += txPrev.vout[prevout.n].nValue;\n\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return error(\"ClientConnectInputs() : txin values out of range\");\n        }\n        if (GetValueOut() > nValueIn)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\n\nCTransaction {\n  bool CTransaction::ClientConnectInputs()\n  {\n      if (IsCoinBase())\n          return false;\n  \n      // Take over previous transactions' spent pointers\n      {\n          LOCK(mempool.cs);\n          int64_t nValueIn = 0;\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              // Get prev tx from single transactions in memory\n              COutPoint prevout = vin[i].prevout;\n              if (!mempool.exists(prevout.hash))\n                  return false;\n              CTransaction& txPrev = mempool.lookup(prevout.hash);\n  \n              if (prevout.n >= txPrev.vout.size())\n                  return false;\n  \n              // Verify signature\n              if (!VerifySignature(txPrev, *this, i, 0))\n                  return error(\"ConnectInputs() : VerifySignature failed\");\n  \n              ///// this is redundant with the mempool.mapNextTx stuff,\n              ///// not sure which I want to get rid of\n              ///// this has to go away now that posNext is gone\n              // // Check for conflicts\n              // if (!txPrev.vout[prevout.n].posNext.IsNull())\n              //     return error(\"ConnectInputs() : prev tx already used\");\n              //\n              // // Flag outpoints as used\n              // txPrev.vout[prevout.n].posNext = posThisTx;\n  \n              nValueIn += txPrev.vout[prevout.n].nValue;\n  \n              if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                  return error(\"ClientConnectInputs() : txin values out of range\");\n          }\n          if (GetValueOut() > nValueIn)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsInMainChain",
          "args": [],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCMerkleTx {\n  bool CMerkleTx::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs)\n  {\n      if (fClient)\n      {\n          if (!IsInMainChain() && !ClientConnectInputs())\n              return false;\n          return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n      }\n      else\n      {\n          return CTransaction::AcceptToMemoryPool(txdb, fCheckInputs);\n      }\n  }\n}"
  },
  {
    "function_name": "GetBlocksToMaturity",
    "container": "CMerkleTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "817-822",
    "snippet": "int CMerkleTx::GetBlocksToMaturity() const\n{\n    if (!(IsCoinBase() || IsCoinStake()))\n        return 0;\n    return max(0, (nCoinbaseMaturity+10) - GetDepthInMainChain());\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int nCoinbaseMaturity = 50;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "0",
            "(nCoinbaseMaturity+10) - GetDepthInMainChain()"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_max_open_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "433-435",
          "snippet": "void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {\n  opt->rep.max_open_files = n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetDepthInMainChain",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "GetDepthInMainChain",
          "container": "CTxIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "873-887",
          "snippet": "int CTxIndex::GetDepthInMainChain() const\n{\n    // Read block header\n    CBlock block;\n    if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n        return 0;\n    // Find the block in the index\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n    return 1 + nBestHeight - pindex->nHeight;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<uint256, CBlockIndex*> mapBlockIndex;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nBestHeight = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nBestHeight = -1;\n\nCTxIndex {\n  int CTxIndex::GetDepthInMainChain() const\n  {\n      // Read block header\n      CBlock block;\n      if (!block.ReadFromDisk(pos.nFile, pos.nBlockPos, false))\n          return 0;\n      // Find the block in the index\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.GetHash());\n      if (mi == mapBlockIndex.end())\n          return 0;\n      CBlockIndex* pindex = (*mi).second;\n      if (!pindex || !pindex->IsInMainChain())\n          return 0;\n      return 1 + nBestHeight - pindex->nHeight;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinStake",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinBase",
          "args": [],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nint nCoinbaseMaturity = 50;\n\nCMerkleTx {\n  int CMerkleTx::GetBlocksToMaturity() const\n  {\n      if (!(IsCoinBase() || IsCoinStake()))\n          return 0;\n      return max(0, (nCoinbaseMaturity+10) - GetDepthInMainChain());\n  }\n}"
  },
  {
    "function_name": "GetDepthInMainChain",
    "container": "CMerkleTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "790-814",
    "snippet": "int CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const {\n    bool fTxMempool = mempool.exists(GetHash());\n\n    if((hashBlock == 0) || (nIndex == -1))\n      return(fTxMempool ? 0 : -1);\n\n    // Find the block it claims to be in\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if(mi == mapBlockIndex.end())\n      return(fTxMempool ? 0 : -1);\n\n    CBlockIndex* pindex = (*mi).second;\n    if(!pindex || !pindex->IsInMainChain())\n      return(fTxMempool ? 0 : -1);\n\n    // Make sure the merkle branch connects to this block\n    if(!fMerkleVerified) {\n        if(CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n          return(fTxMempool ? 0 : -1);\n        fMerkleVerified = true;\n    }\n\n    pindexRet = pindex;\n    return(pindexBest->nHeight - pindex->nHeight + 1);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;",
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CBlock::CheckMerkleBranch",
          "args": [
            "GetHash()",
            "vMerkleBranch",
            "nIndex"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "CheckMerkleBranch",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1055-1068",
          "snippet": "static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex)\n    {\n        if (nIndex == -1)\n            return 0;\n        BOOST_FOREACH(const uint256& otherside, vMerkleBranch)\n        {\n            if (nIndex & 1)\n                hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n            else\n                hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n            nIndex >>= 1;\n        }\n        return hash;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex)\n      {\n          if (nIndex == -1)\n              return 0;\n          BOOST_FOREACH(const uint256& otherside, vMerkleBranch)\n          {\n              if (nIndex & 1)\n                  hash = Hash(BEGIN(otherside), END(otherside), BEGIN(hash), END(hash));\n              else\n                  hash = Hash(BEGIN(hash), END(hash), BEGIN(otherside), END(otherside));\n              nIndex >>= 1;\n          }\n          return hash;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pindex->IsInMainChain",
          "args": [],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.find",
          "args": [
            "hashBlock"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mempool.exists",
          "args": [
            "GetHash()"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "exists",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1697-1700",
          "snippet": "bool exists(uint256 hash)\n    {\n        return (mapTx.count(hash) != 0);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  bool exists(uint256 hash)\n      {\n          return (mapTx.count(hash) != 0);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\n\nCMerkleTx {\n  int CMerkleTx::GetDepthInMainChain(CBlockIndex* &pindexRet) const {\n      bool fTxMempool = mempool.exists(GetHash());\n  \n      if((hashBlock == 0) || (nIndex == -1))\n        return(fTxMempool ? 0 : -1);\n  \n      // Find the block it claims to be in\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n      if(mi == mapBlockIndex.end())\n        return(fTxMempool ? 0 : -1);\n  \n      CBlockIndex* pindex = (*mi).second;\n      if(!pindex || !pindex->IsInMainChain())\n        return(fTxMempool ? 0 : -1);\n  \n      // Make sure the merkle branch connects to this block\n      if(!fMerkleVerified) {\n          if(CBlock::CheckMerkleBranch(GetHash(), vMerkleBranch, nIndex) != pindex->hashMerkleRoot)\n            return(fTxMempool ? 0 : -1);\n          fMerkleVerified = true;\n      }\n  \n      pindexRet = pindex;\n      return(pindexBest->nHeight - pindex->nHeight + 1);\n  }\n}"
  },
  {
    "function_name": "queryHashes",
    "container": "CTxMemPool",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "776-784",
    "snippet": "void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n{\n    vtxid.clear();\n\n    LOCK(cs);\n    vtxid.reserve(mapTx.size());\n    for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n        vtxid.push_back((*mi).first);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vtxid.push_back",
          "args": [
            "(*mi).first"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapTx.end",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapTx.begin",
          "args": [],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vtxid.reserve",
          "args": [
            "mapTx.size()"
          ],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapTx.size",
          "args": [],
          "line": 781
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vtxid.clear",
          "args": [],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCTxMemPool {\n  void CTxMemPool::queryHashes(std::vector<uint256>& vtxid)\n  {\n      vtxid.clear();\n  \n      LOCK(cs);\n      vtxid.reserve(mapTx.size());\n      for (map<uint256, CTransaction>::iterator mi = mapTx.begin(); mi != mapTx.end(); ++mi)\n          vtxid.push_back((*mi).first);\n  }\n}"
  },
  {
    "function_name": "clear",
    "container": "CTxMemPool",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "768-774",
    "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nTransactionsUpdated = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapNextTx.clear",
          "args": [],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
  },
  {
    "function_name": "removeConflicts",
    "container": "CTxMemPool",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "753-766",
    "snippet": "bool CTxMemPool::removeConflicts(const CTransaction &tx)\n{\n    // Remove transactions which depend on inputs of tx, recursively\n    LOCK(cs);\n    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n        if (it != mapNextTx.end()) {\n            const CTransaction &txConflict = *it->second.ptx;\n            if (txConflict != tx)\n                remove(txConflict, true);\n        }\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "txConflict",
            "true"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "729-751",
          "snippet": "bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n{\n    // Remove transaction from memory pool\n    {\n        LOCK(cs);\n        uint256 hash = tx.GetHash();\n        if (mapTx.count(hash))\n        {\n            if (fRecursive) {\n                for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                    if (it != mapNextTx.end())\n                        remove(*it->second.ptx, true);\n                }\n            }\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                mapNextTx.erase(txin.prevout);\n            mapTx.erase(hash);\n            nTransactionsUpdated++;\n        }\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCTxMemPool {\n  bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n  {\n      // Remove transaction from memory pool\n      {\n          LOCK(cs);\n          uint256 hash = tx.GetHash();\n          if (mapTx.count(hash))\n          {\n              if (fRecursive) {\n                  for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                      std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                      if (it != mapNextTx.end())\n                          remove(*it->second.ptx, true);\n                  }\n              }\n              BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                  mapNextTx.erase(txin.prevout);\n              mapTx.erase(hash);\n              nTransactionsUpdated++;\n          }\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapNextTx.end",
          "args": [],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapNextTx.find",
          "args": [
            "txin.prevout"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool {\n  bool CTxMemPool::removeConflicts(const CTransaction &tx)\n  {\n      // Remove transactions which depend on inputs of tx, recursively\n      LOCK(cs);\n      BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n          std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n          if (it != mapNextTx.end()) {\n              const CTransaction &txConflict = *it->second.ptx;\n              if (txConflict != tx)\n                  remove(txConflict, true);\n          }\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "remove",
    "container": "CTxMemPool",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "729-751",
    "snippet": "bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n{\n    // Remove transaction from memory pool\n    {\n        LOCK(cs);\n        uint256 hash = tx.GetHash();\n        if (mapTx.count(hash))\n        {\n            if (fRecursive) {\n                for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                    if (it != mapNextTx.end())\n                        remove(*it->second.ptx, true);\n                }\n            }\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                mapNextTx.erase(txin.prevout);\n            mapTx.erase(hash);\n            nTransactionsUpdated++;\n        }\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nTransactionsUpdated = 0;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapTx.erase",
          "args": [
            "hash"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "*it->second.ptx",
            "true"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "remove",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "729-751",
          "snippet": "bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n{\n    // Remove transaction from memory pool\n    {\n        LOCK(cs);\n        uint256 hash = tx.GetHash();\n        if (mapTx.count(hash))\n        {\n            if (fRecursive) {\n                for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                    std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                    if (it != mapNextTx.end())\n                        remove(*it->second.ptx, true);\n                }\n            }\n            BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                mapNextTx.erase(txin.prevout);\n            mapTx.erase(hash);\n            nTransactionsUpdated++;\n        }\n    }\n    return true;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mapNextTx.end",
          "args": [],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapNextTx.find",
          "args": [
            "COutPoint(hash, i)"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "COutPoint",
          "args": [
            "hash",
            "i"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "COutPoint",
          "container": "COutPoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "227-227",
          "snippet": "COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCOutPoint {\n  COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.vout.size",
          "args": [],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapTx.count",
          "args": [
            "hash"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCTxMemPool {\n  bool CTxMemPool::remove(const CTransaction &tx, bool fRecursive)\n  {\n      // Remove transaction from memory pool\n      {\n          LOCK(cs);\n          uint256 hash = tx.GetHash();\n          if (mapTx.count(hash))\n          {\n              if (fRecursive) {\n                  for (unsigned int i = 0; i < tx.vout.size(); i++) {\n                      std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(COutPoint(hash, i));\n                      if (it != mapNextTx.end())\n                          remove(*it->second.ptx, true);\n                  }\n              }\n              BOOST_FOREACH(const CTxIn& txin, tx.vin)\n                  mapNextTx.erase(txin.prevout);\n              mapTx.erase(hash);\n              nTransactionsUpdated++;\n          }\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "addUnchecked",
    "container": "CTxMemPool",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "715-726",
    "snippet": "bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n{\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call CTxMemPool::accept to properly check the transaction first.\n    {\n        mapTx[hash] = tx;\n        for (unsigned int i = 0; i < tx.vin.size(); i++)\n            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n        nTransactionsUpdated++;\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned int nTransactionsUpdated = 0;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CInPoint",
          "args": [
            "&mapTx[hash]",
            "i"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "CInPoint",
          "container": "CInPoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "212-212",
          "snippet": "CInPoint(CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCInPoint {\n  CInPoint(CTransaction* ptxIn, unsigned int nIn) { ptx = ptxIn; n = nIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.vin.size",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCTxMemPool {\n  bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n  {\n      // Add to memory pool without checking anything.  Don't call this directly,\n      // call CTxMemPool::accept to properly check the transaction first.\n      {\n          mapTx[hash] = tx;\n          for (unsigned int i = 0; i < tx.vin.size(); i++)\n              mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n          nTransactionsUpdated++;\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "AcceptToMemoryPool",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "710-713",
    "snippet": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CTxMemPool mempool;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mempool.accept",
          "args": [
            "txdb",
            "*this",
            "fCheckInputs",
            "pfMissingInputs"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "accept",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "559-708",
          "snippet": "bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                        bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // ppcoin: coinstake is also only valid in a block, not as a loose transaction\n    if (tx.IsCoinStake())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinstake as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64_t)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64_t nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        int64_t txMinFee = tx.GetMinFee(1000, GMF_RELAY, nSize);\n        if (nFees < txMinFee)\n            return error(\"CTxMemPool::accept() : not enough fees %s, %\"PRId64\" < %\"PRId64,\n                         hash.ToString().c_str(),\n                         nFees, txMinFee);\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make others' transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64_t nLastTime;\n            int64_t nNow = GetTime();\n\n            {\n                LOCK(cs);\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                dFreeCount += nSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(txdb, mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "CBlockIndex* pindexBest = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\n\nCTxMemPool {\n  bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                          bool* pfMissingInputs)\n  {\n      if (pfMissingInputs)\n          *pfMissingInputs = false;\n  \n      if (!tx.CheckTransaction())\n          return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n  \n      // Coinbase is only valid in a block, not as a loose transaction\n      if (tx.IsCoinBase())\n          return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n  \n      // ppcoin: coinstake is also only valid in a block, not as a loose transaction\n      if (tx.IsCoinStake())\n          return tx.DoS(100, error(\"CTxMemPool::accept() : coinstake as individual tx\"));\n  \n      // To help v0.1.5 clients who would see it as a negative number\n      if ((int64_t)tx.nLockTime > std::numeric_limits<int>::max())\n          return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n  \n      // Rather not work on nonstandard transactions (unless -testnet)\n      if (!fTestNet && !tx.IsStandard())\n          return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n  \n      // Do we already have it?\n      uint256 hash = tx.GetHash();\n      {\n          LOCK(cs);\n          if (mapTx.count(hash))\n              return false;\n      }\n      if (fCheckInputs)\n          if (txdb.ContainsTx(hash))\n              return false;\n  \n      // Check for conflicts with in-memory transactions\n      CTransaction* ptxOld = NULL;\n      for (unsigned int i = 0; i < tx.vin.size(); i++)\n      {\n          COutPoint outpoint = tx.vin[i].prevout;\n          if (mapNextTx.count(outpoint))\n          {\n              // Disable replacement feature for now\n              return false;\n  \n              // Allow replacing with a newer version of the same transaction\n              if (i != 0)\n                  return false;\n              ptxOld = mapNextTx[outpoint].ptx;\n              if (ptxOld->IsFinal())\n                  return false;\n              if (!tx.IsNewerThan(*ptxOld))\n                  return false;\n              for (unsigned int i = 0; i < tx.vin.size(); i++)\n              {\n                  COutPoint outpoint = tx.vin[i].prevout;\n                  if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                      return false;\n              }\n              break;\n          }\n      }\n  \n      if (fCheckInputs)\n      {\n          MapPrevTx mapInputs;\n          map<uint256, CTxIndex> mapUnused;\n          bool fInvalid = false;\n          if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n          {\n              if (fInvalid)\n                  return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n              if (pfMissingInputs)\n                  *pfMissingInputs = true;\n              return false;\n          }\n  \n          // Check for non-standard pay-to-script-hash in inputs\n          if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n              return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n  \n          // Note: if you modify this code to accept non-standard transactions, then\n          // you should add code here to check that the transaction does a\n          // reasonable number of ECDSA signature verifications.\n  \n          int64_t nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n          unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n  \n          // Don't accept it if it can't get into a block\n          int64_t txMinFee = tx.GetMinFee(1000, GMF_RELAY, nSize);\n          if (nFees < txMinFee)\n              return error(\"CTxMemPool::accept() : not enough fees %s, %\"PRId64\" < %\"PRId64,\n                           hash.ToString().c_str(),\n                           nFees, txMinFee);\n  \n          // Continuously rate-limit free transactions\n          // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n          // be annoying or make others' transactions take longer to confirm.\n          if (nFees < MIN_RELAY_TX_FEE)\n          {\n              static CCriticalSection cs;\n              static double dFreeCount;\n              static int64_t nLastTime;\n              int64_t nNow = GetTime();\n  \n              {\n                  LOCK(cs);\n                  // Use an exponentially decaying ~10-minute window:\n                  dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                  nLastTime = nNow;\n                  // -limitfreerelay unit is thousand-bytes-per-minute\n                  // At default rate it would take over a month to fill 1GB\n                  if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                      return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                  if (fDebug)\n                      printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                  dFreeCount += nSize;\n              }\n          }\n  \n          // Check against previous transactions\n          // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n          if (!tx.ConnectInputs(txdb, mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n          {\n              return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n          }\n      }\n  \n      // Store transaction in memory\n      {\n          LOCK(cs);\n          if (ptxOld)\n          {\n              printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n              remove(*ptxOld);\n          }\n          addUnchecked(hash, tx);\n      }\n  \n      ///// are we sure this is ok when loading transactions or restoring block txes\n      // If updated, erase old tx from wallet\n      if (ptxOld)\n          EraseFromWallets(ptxOld->GetHash());\n  \n      printf(\"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\",\n             hash.ToString().substr(0,10).c_str(),\n             mapTx.size());\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\n\nCTransaction {\n  bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n  {\n      return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n  }\n}"
  },
  {
    "function_name": "accept",
    "container": "CTxMemPool",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "559-708",
    "snippet": "bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                        bool* pfMissingInputs)\n{\n    if (pfMissingInputs)\n        *pfMissingInputs = false;\n\n    if (!tx.CheckTransaction())\n        return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n\n    // Coinbase is only valid in a block, not as a loose transaction\n    if (tx.IsCoinBase())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n\n    // ppcoin: coinstake is also only valid in a block, not as a loose transaction\n    if (tx.IsCoinStake())\n        return tx.DoS(100, error(\"CTxMemPool::accept() : coinstake as individual tx\"));\n\n    // To help v0.1.5 clients who would see it as a negative number\n    if ((int64_t)tx.nLockTime > std::numeric_limits<int>::max())\n        return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n\n    // Rather not work on nonstandard transactions (unless -testnet)\n    if (!fTestNet && !tx.IsStandard())\n        return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n\n    // Do we already have it?\n    uint256 hash = tx.GetHash();\n    {\n        LOCK(cs);\n        if (mapTx.count(hash))\n            return false;\n    }\n    if (fCheckInputs)\n        if (txdb.ContainsTx(hash))\n            return false;\n\n    // Check for conflicts with in-memory transactions\n    CTransaction* ptxOld = NULL;\n    for (unsigned int i = 0; i < tx.vin.size(); i++)\n    {\n        COutPoint outpoint = tx.vin[i].prevout;\n        if (mapNextTx.count(outpoint))\n        {\n            // Disable replacement feature for now\n            return false;\n\n            // Allow replacing with a newer version of the same transaction\n            if (i != 0)\n                return false;\n            ptxOld = mapNextTx[outpoint].ptx;\n            if (ptxOld->IsFinal())\n                return false;\n            if (!tx.IsNewerThan(*ptxOld))\n                return false;\n            for (unsigned int i = 0; i < tx.vin.size(); i++)\n            {\n                COutPoint outpoint = tx.vin[i].prevout;\n                if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                    return false;\n            }\n            break;\n        }\n    }\n\n    if (fCheckInputs)\n    {\n        MapPrevTx mapInputs;\n        map<uint256, CTxIndex> mapUnused;\n        bool fInvalid = false;\n        if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n        {\n            if (fInvalid)\n                return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n            if (pfMissingInputs)\n                *pfMissingInputs = true;\n            return false;\n        }\n\n        // Check for non-standard pay-to-script-hash in inputs\n        if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n            return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n\n        // Note: if you modify this code to accept non-standard transactions, then\n        // you should add code here to check that the transaction does a\n        // reasonable number of ECDSA signature verifications.\n\n        int64_t nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n        unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n\n        // Don't accept it if it can't get into a block\n        int64_t txMinFee = tx.GetMinFee(1000, GMF_RELAY, nSize);\n        if (nFees < txMinFee)\n            return error(\"CTxMemPool::accept() : not enough fees %s, %\"PRId64\" < %\"PRId64,\n                         hash.ToString().c_str(),\n                         nFees, txMinFee);\n\n        // Continuously rate-limit free transactions\n        // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n        // be annoying or make others' transactions take longer to confirm.\n        if (nFees < MIN_RELAY_TX_FEE)\n        {\n            static CCriticalSection cs;\n            static double dFreeCount;\n            static int64_t nLastTime;\n            int64_t nNow = GetTime();\n\n            {\n                LOCK(cs);\n                // Use an exponentially decaying ~10-minute window:\n                dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                nLastTime = nNow;\n                // -limitfreerelay unit is thousand-bytes-per-minute\n                // At default rate it would take over a month to fill 1GB\n                if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                    return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                if (fDebug)\n                    printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                dFreeCount += nSize;\n            }\n        }\n\n        // Check against previous transactions\n        // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n        if (!tx.ConnectInputs(txdb, mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n        {\n            return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Store transaction in memory\n    {\n        LOCK(cs);\n        if (ptxOld)\n        {\n            printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n            remove(*ptxOld);\n        }\n        addUnchecked(hash, tx);\n    }\n\n    ///// are we sure this is ok when loading transactions or restoring block txes\n    // If updated, erase old tx from wallet\n    if (ptxOld)\n        EraseFromWallets(ptxOld->GetHash());\n\n    printf(\"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\",\n           hash.ToString().substr(0,10).c_str(),\n           mapTx.size());\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\"",
            "hash.ToString().substr(0,10).c_str()",
            "mapTx.size()"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapTx.size",
          "args": [],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [
            "0",
            "10"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EraseFromWallets",
          "args": [
            "ptxOld->GetHash()"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "EraseFromWallets",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "139-143",
          "snippet": "void static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptxOld->GetHash",
          "args": [],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addUnchecked",
          "args": [
            "hash",
            "tx"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "addUnchecked",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "715-726",
          "snippet": "bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n{\n    // Add to memory pool without checking anything.  Don't call this directly,\n    // call CTxMemPool::accept to properly check the transaction first.\n    {\n        mapTx[hash] = tx;\n        for (unsigned int i = 0; i < tx.vin.size(); i++)\n            mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n        nTransactionsUpdated++;\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nCTxMemPool {\n  bool CTxMemPool::addUnchecked(const uint256& hash, CTransaction &tx)\n  {\n      // Add to memory pool without checking anything.  Don't call this directly,\n      // call CTxMemPool::accept to properly check the transaction first.\n      {\n          mapTx[hash] = tx;\n          for (unsigned int i = 0; i < tx.vin.size(); i++)\n              mapNextTx[tx.vin[i].prevout] = CInPoint(&mapTx[hash], i);\n          nTransactionsUpdated++;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove",
          "args": [
            "*ptxOld"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "removeConflicts",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "753-766",
          "snippet": "bool CTxMemPool::removeConflicts(const CTransaction &tx)\n{\n    // Remove transactions which depend on inputs of tx, recursively\n    LOCK(cs);\n    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n        std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n        if (it != mapNextTx.end()) {\n            const CTransaction &txConflict = *it->second.ptx;\n            if (txConflict != tx)\n                remove(txConflict, true);\n        }\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool {\n  bool CTxMemPool::removeConflicts(const CTransaction &tx)\n  {\n      // Remove transactions which depend on inputs of tx, recursively\n      LOCK(cs);\n      BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n          std::map<COutPoint, CInPoint>::iterator it = mapNextTx.find(txin.prevout);\n          if (it != mapNextTx.end()) {\n              const CTransaction &txConflict = *it->second.ptx;\n              if (txConflict != tx)\n                  remove(txConflict, true);\n          }\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CTxMemPool::accept() : replacing tx %s with new version\\n\"",
            "ptxOld->GetHash().ToString().c_str()"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CTxMemPool::accept() : ConnectInputs failed %s\"",
            "hash.ToString().substr(0,10).c_str()"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "leveldb_options_set_error_if_exists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "411-414",
          "snippet": "void leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nvoid leveldb_options_set_error_if_exists(\n    leveldb_options_t* opt, unsigned char v) {\n  opt->rep.error_if_exists = v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.ConnectInputs",
          "args": [
            "txdb",
            "mapInputs",
            "mapUnused",
            "CDiskTxPos(1,1,1)",
            "pindexBest",
            "false",
            "false"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CDiskTxPos",
          "args": [
            "1",
            "1",
            "1"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "CDiskTxPos",
          "container": "CDiskTxPos",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "164-169",
          "snippet": "CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n    {\n        nFile = nFileIn;\n        nBlockPos = nBlockPosIn;\n        nTxPos = nTxPosIn;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskTxPos {\n  CDiskTxPos(unsigned int nFileIn, unsigned int nBlockPosIn, unsigned int nTxPosIn)\n      {\n          nFile = nFileIn;\n          nBlockPos = nBlockPosIn;\n          nTxPos = nTxPosIn;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Rate limit dFreeCount: %g => %g\\n\"",
            "dFreeCount",
            "dFreeCount+nSize"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CTxMemPool::accept() : free transaction rejected by rate limiter\""
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsFromMe",
          "args": [
            "tx"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "IsFromMe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "121-127",
          "snippet": "bool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-limitfreerelay\"",
            "15"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pow",
          "args": [
            "1.0 - 1.0/600.0",
            "(double)(nNow - nLastTime)"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "pow_mod",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "467-481",
          "snippet": "CBigNum pow_mod(const CBigNum& e, const CBigNum& m) const {\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if( e < 0){\n            // g^-x = (g^-1)^x\n            CBigNum inv = this->inverse(m);\n            CBigNum posE = e * -1;\n            if (!BN_mod_exp(&ret, &inv, &posE, &m, pctx))\n                throw bignum_error(\"CBigNum::pow_mod: BN_mod_exp failed on negative exponent\");\n        }else\n            if (!BN_mod_exp(&ret, this, &e, &m, pctx))\n                throw bignum_error(\"CBigNum::pow_mod : BN_mod_exp failed\");\n\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum pow_mod(const CBigNum& e, const CBigNum& m) const {\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if( e < 0){\n              // g^-x = (g^-1)^x\n              CBigNum inv = this->inverse(m);\n              CBigNum posE = e * -1;\n              if (!BN_mod_exp(&ret, &inv, &posE, &m, pctx))\n                  throw bignum_error(\"CBigNum::pow_mod: BN_mod_exp failed on negative exponent\");\n          }else\n              if (!BN_mod_exp(&ret, this, &e, &m, pctx))\n                  throw bignum_error(\"CBigNum::pow_mod : BN_mod_exp failed\");\n  \n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetTime",
          "args": [],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "GetTimeMillis",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "370-374",
          "snippet": "inline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline int64_t GetTimeMillis()\n{\n    return (boost::posix_time::ptime(boost::posix_time::microsec_clock::universal_time()) -\n            boost::posix_time::ptime(boost::gregorian::date(1970,1,1))).total_milliseconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CTxMemPool::accept() : not enough fees %s, %\"PRId64\" < %\"PRId64",
            "hash.ToString().c_str()",
            "nFees",
            "txMinFee"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetMinFee",
          "args": [
            "1000",
            "GMF_RELAY",
            "nSize"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "GetMinFee",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "529-556",
          "snippet": "int64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n{\n    // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n    int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n\n    unsigned int nNewBlockSize = nBlockSize + nBytes;\n    int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n\n    // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n    if (nMinFee < nBaseFee)\n    {\n        BOOST_FOREACH(const CTxOut& txout, vout)\n            if (txout.nValue < CENT)\n                nMinFee = nBaseFee;\n    }\n\n    // Raise the price as the block approaches full\n    if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n    {\n        if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n            return MAX_MONEY;\n        nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n    }\n\n    if (!MoneyRange(nMinFee))\n        nMinFee = MAX_MONEY;\n    return nMinFee;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  int64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n  {\n      // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n      int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n  \n      unsigned int nNewBlockSize = nBlockSize + nBytes;\n      int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n  \n      // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n      if (nMinFee < nBaseFee)\n      {\n          BOOST_FOREACH(const CTxOut& txout, vout)\n              if (txout.nValue < CENT)\n                  nMinFee = nBaseFee;\n      }\n  \n      // Raise the price as the block approaches full\n      if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n      {\n          if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n              return MAX_MONEY;\n          nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n      }\n  \n      if (!MoneyRange(nMinFee))\n          nMinFee = MAX_MONEY;\n      return nMinFee;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::GetSerializeSize",
          "args": [
            "tx",
            "SER_NETWORK",
            "PROTOCOL_VERSION"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "632-638",
          "snippet": "unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nunsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetValueOut",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "GetValueOut",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "577-587",
          "snippet": "int64_t GetValueOut() const\n    {\n        int64_t nValueOut = 0;\n        BOOST_FOREACH(const CTxOut& txout, vout)\n        {\n            nValueOut += txout.nValue;\n            if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n        }\n        return nValueOut;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  int64_t GetValueOut() const\n      {\n          int64_t nValueOut = 0;\n          BOOST_FOREACH(const CTxOut& txout, vout)\n          {\n              nValueOut += txout.nValue;\n              if (!MoneyRange(txout.nValue) || !MoneyRange(nValueOut))\n                  throw std::runtime_error(\"CTransaction::GetValueOut() : value out of range\");\n          }\n          return nValueOut;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetValueIn",
          "args": [
            "mapInputs"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.AreInputsStandard",
          "args": [
            "mapInputs"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "AreInputsStandard",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "351-403",
          "snippet": "bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n        if (nArgsExpected < 0)\n            return false;\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n\n            int tmpExpected;\n            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n            if (tmpExpected < 0)\n                return false;\n            nArgsExpected += tmpExpected;\n        }\n\n        if (stack.size() != (unsigned int)nArgsExpected)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n  {\n      if (IsCoinBase())\n          return true; // Coinbases don't use vin normally\n  \n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n  \n          vector<vector<unsigned char> > vSolutions;\n          txnouttype whichType;\n          // get the scriptPubKey corresponding to this input:\n          const CScript& prevScript = prev.scriptPubKey;\n          if (!Solver(prevScript, whichType, vSolutions))\n              return false;\n          int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n          if (nArgsExpected < 0)\n              return false;\n  \n          // Transactions with extra stuff in their scriptSigs are\n          // non-standard. Note that this EvalScript() call will\n          // be quick, because if there are any operations\n          // beside \"push data\" in the scriptSig the\n          // IsStandard() call returns false\n          vector<vector<unsigned char> > stack;\n          if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n              return false;\n  \n          if (whichType == TX_SCRIPTHASH)\n          {\n              if (stack.empty())\n                  return false;\n              CScript subscript(stack.back().begin(), stack.back().end());\n              vector<vector<unsigned char> > vSolutions2;\n              txnouttype whichType2;\n              if (!Solver(subscript, whichType2, vSolutions2))\n                  return false;\n              if (whichType2 == TX_SCRIPTHASH)\n                  return false;\n  \n              int tmpExpected;\n              tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n              if (tmpExpected < 0)\n                  return false;\n              nArgsExpected += tmpExpected;\n          }\n  \n          if (stack.size() != (unsigned int)nArgsExpected)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.FetchInputs",
          "args": [
            "txdb",
            "mapUnused",
            "false",
            "false",
            "mapInputs",
            "fInvalid"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "FetchInputs",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "1310-1523",
          "snippet": "bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                               bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n{\n    // FetchInputs can return false either because we just haven't seen some inputs\n    // (in which case the transaction should be stored as an orphan)\n    // or because the transaction is malformed (in which case the transaction should\n    // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n    fInvalid = false;\n\n    if (IsCoinBase())\n        return true; // Coinbase transactions have no inputs to fetch.\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        COutPoint prevout = vin[i].prevout;\n        if (inputsRet.count(prevout.hash))\n            continue; // Got it already\n\n        // Read txindex\n        CTxIndex& txindex = inputsRet[prevout.hash].first;\n        bool fFound = true;\n        if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n        {\n            // Get txindex from current proposed changes\n            txindex = mapTestPool.find(prevout.hash)->second;\n        }\n        else\n        {\n            // Read txindex from txdb\n            fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n        }\n        if (!fFound && (fBlock || fMiner))\n            return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n\n        // Read txPrev\n        CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n        {\n            // Get prev tx from single transactions in memory\n            {\n                LOCK(mempool.cs);\n                if (!mempool.exists(prevout.hash))\n                    return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                txPrev = mempool.lookup(prevout.hash);\n            }\n            if (!fFound)\n                txindex.vSpent.resize(txPrev.vout.size());\n        }\n        else\n        {\n            // Get prev tx from disk\n            if (!txPrev.ReadFromDisk(txindex.pos))\n                return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n        }\n    }\n\n    // Make sure all prevout.n indexes are valid:\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const COutPoint prevout = vin[i].prevout;\n        assert(inputsRet.count(prevout.hash) != 0);\n        const CTxIndex& txindex = inputsRet[prevout.hash].first;\n        const CTransaction& txPrev = inputsRet[prevout.hash].second;\n        if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n        {\n            // Revisit this if/when transaction replacement is implemented and allows\n            // adding inputs:\n            fInvalid = true;\n            return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n        }\n    }\n\n    return true;\n}\n\nconst CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n{\n    MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n    if (mi == inputs.end())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n\n    const CTransaction& txPrev = (mi->second).second;\n    if (input.prevout.n >= txPrev.vout.size())\n        throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n\n    return txPrev.vout[input.prevout.n];\n}\n\nint64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    int64_t nResult = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        nResult += GetOutputFor(vin[i], inputs).nValue;\n    }\n    return nResult;\n\n}\n\nunsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n{\n    if (IsCoinBase())\n        return 0;\n\n    unsigned int nSigOps = 0;\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n        if (prevout.scriptPubKey.IsPayToScriptHash())\n            nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n    }\n    return nSigOps;\n}\n\nbool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n    const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n{\n    // Take over previous transactions' spent pointers\n    // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n    // fMiner is true when called from the internal bitcoin miner\n    // ... both are false when called from CTransaction::AcceptToMemoryPool\n    if (!IsCoinBase())\n    {\n        int64_t nValueIn = 0;\n        int64_t nFees = 0;\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n\n            // If prev is coinbase or coinstake, check that it's matured\n            if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                    if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                        return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n\n            // ppcoin: check transaction timestamp\n            if (txPrev.nTime > nTime)\n                return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n\n            // Check for negative or overflow input values\n            nValueIn += txPrev.vout[prevout.n].nValue;\n            if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n\n        }\n        // The first loop above does all the inexpensive checks.\n        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n        // Helps prevent CPU exhaustion attacks.\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            COutPoint prevout = vin[i].prevout;\n            assert(inputs.count(prevout.hash) > 0);\n            CTxIndex& txindex = inputs[prevout.hash].first;\n            CTransaction& txPrev = inputs[prevout.hash].second;\n\n            // Check for conflicts (double-spend)\n            // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n            // for an attacker to attempt to split the network.\n            if (!txindex.vSpent[prevout.n].IsNull())\n                return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n\n            // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n            // before the last blockchain checkpoint. This is safe because block merkle hashes are\n            // still computed and checked, and any change will be caught at the next checkpoint.\n            if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n            {\n                // Verify signature\n                if (!VerifySignature(txPrev, *this, i, 0))\n                {\n                    return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                }\n            }\n\n            // Mark outpoints as spent\n            txindex.vSpent[prevout.n] = posThisTx;\n\n            // Write back\n            if (fBlock || fMiner)\n            {\n                mapTestPool[prevout.hash] = txindex;\n            }\n        }\n\n        if (!IsCoinStake())\n        {\n            if (nValueIn < GetValueOut())\n                return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n\n            // Tally transaction fees\n            int64_t nTxFee = nValueIn - GetValueOut();\n            if (nTxFee < 0)\n                return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n\n            // enforce transaction fees for every block\n            if (nTxFee < GetMinFee())\n                return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n\n            nFees += nTxFee;\n            if (!MoneyRange(nFees))\n                return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CTxMemPool mempool;",
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "int nCoinbaseMaturity = 50;",
            "int nBestHeight = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTxMemPool mempool;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nint nCoinbaseMaturity = 50;\nint nBestHeight = -1;\n\nCTransaction {\n  bool CTransaction::FetchInputs(CTxDB& txdb, const map<uint256, CTxIndex>& mapTestPool,\n                                 bool fBlock, bool fMiner, MapPrevTx& inputsRet, bool& fInvalid)\n  {\n      // FetchInputs can return false either because we just haven't seen some inputs\n      // (in which case the transaction should be stored as an orphan)\n      // or because the transaction is malformed (in which case the transaction should\n      // be dropped).  If tx is definitely invalid, fInvalid will be set to true.\n      fInvalid = false;\n  \n      if (IsCoinBase())\n          return true; // Coinbase transactions have no inputs to fetch.\n  \n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          COutPoint prevout = vin[i].prevout;\n          if (inputsRet.count(prevout.hash))\n              continue; // Got it already\n  \n          // Read txindex\n          CTxIndex& txindex = inputsRet[prevout.hash].first;\n          bool fFound = true;\n          if ((fBlock || fMiner) && mapTestPool.count(prevout.hash))\n          {\n              // Get txindex from current proposed changes\n              txindex = mapTestPool.find(prevout.hash)->second;\n          }\n          else\n          {\n              // Read txindex from txdb\n              fFound = txdb.ReadTxIndex(prevout.hash, txindex);\n          }\n          if (!fFound && (fBlock || fMiner))\n              return fMiner ? false : error(\"FetchInputs() : %s prev tx %s index entry not found\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n  \n          // Read txPrev\n          CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (!fFound || txindex.pos == CDiskTxPos(1,1,1))\n          {\n              // Get prev tx from single transactions in memory\n              {\n                  LOCK(mempool.cs);\n                  if (!mempool.exists(prevout.hash))\n                      return error(\"FetchInputs() : %s mempool Tx prev not found %s\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n                  txPrev = mempool.lookup(prevout.hash);\n              }\n              if (!fFound)\n                  txindex.vSpent.resize(txPrev.vout.size());\n          }\n          else\n          {\n              // Get prev tx from disk\n              if (!txPrev.ReadFromDisk(txindex.pos))\n                  return error(\"FetchInputs() : %s ReadFromDisk prev tx %s failed\", GetHash().ToString().substr(0,10).c_str(),  prevout.hash.ToString().substr(0,10).c_str());\n          }\n      }\n  \n      // Make sure all prevout.n indexes are valid:\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const COutPoint prevout = vin[i].prevout;\n          assert(inputsRet.count(prevout.hash) != 0);\n          const CTxIndex& txindex = inputsRet[prevout.hash].first;\n          const CTransaction& txPrev = inputsRet[prevout.hash].second;\n          if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n          {\n              // Revisit this if/when transaction replacement is implemented and allows\n              // adding inputs:\n              fInvalid = true;\n              return DoS(100, error(\"FetchInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n          }\n      }\n  \n      return true;\n  }\n  \n  const CTxOut& CTransaction::GetOutputFor(const CTxIn& input, const MapPrevTx& inputs) const\n  {\n      MapPrevTx::const_iterator mi = inputs.find(input.prevout.hash);\n      if (mi == inputs.end())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.hash not found\");\n  \n      const CTransaction& txPrev = (mi->second).second;\n      if (input.prevout.n >= txPrev.vout.size())\n          throw std::runtime_error(\"CTransaction::GetOutputFor() : prevout.n out of range\");\n  \n      return txPrev.vout[input.prevout.n];\n  }\n  \n  int64_t CTransaction::GetValueIn(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      int64_t nResult = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          nResult += GetOutputFor(vin[i], inputs).nValue;\n      }\n      return nResult;\n  \n  }\n  \n  unsigned int CTransaction::GetP2SHSigOpCount(const MapPrevTx& inputs) const\n  {\n      if (IsCoinBase())\n          return 0;\n  \n      unsigned int nSigOps = 0;\n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const CTxOut& prevout = GetOutputFor(vin[i], inputs);\n          if (prevout.scriptPubKey.IsPayToScriptHash())\n              nSigOps += prevout.scriptPubKey.GetSigOpCount(vin[i].scriptSig);\n      }\n      return nSigOps;\n  }\n  \n  bool CTransaction::ConnectInputs(CTxDB& txdb, MapPrevTx inputs, map<uint256, CTxIndex>& mapTestPool, const CDiskTxPos& posThisTx,\n      const CBlockIndex* pindexBlock, bool fBlock, bool fMiner)\n  {\n      // Take over previous transactions' spent pointers\n      // fBlock is true when this is called from AcceptBlock when a new best-block is added to the blockchain\n      // fMiner is true when called from the internal bitcoin miner\n      // ... both are false when called from CTransaction::AcceptToMemoryPool\n      if (!IsCoinBase())\n      {\n          int64_t nValueIn = 0;\n          int64_t nFees = 0;\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              if (prevout.n >= txPrev.vout.size() || prevout.n >= txindex.vSpent.size())\n                  return DoS(100, error(\"ConnectInputs() : %s prevout.n out of range %d %\"PRIszu\" %\"PRIszu\" prev tx %s\\n%s\", GetHash().ToString().substr(0,10).c_str(), prevout.n, txPrev.vout.size(), txindex.vSpent.size(), prevout.hash.ToString().substr(0,10).c_str(), txPrev.ToString().c_str()));\n  \n              // If prev is coinbase or coinstake, check that it's matured\n              if (txPrev.IsCoinBase() || txPrev.IsCoinStake())\n                  for (const CBlockIndex* pindex = pindexBlock; pindex && pindexBlock->nHeight - pindex->nHeight < nCoinbaseMaturity; pindex = pindex->pprev)\n                      if (pindex->nBlockPos == txindex.pos.nBlockPos && pindex->nFile == txindex.pos.nFile)\n                          return error(\"ConnectInputs() : tried to spend %s at depth %d\", txPrev.IsCoinBase() ? \"coinbase\" : \"coinstake\", pindexBlock->nHeight - pindex->nHeight);\n  \n              // ppcoin: check transaction timestamp\n              if (txPrev.nTime > nTime)\n                  return DoS(100, error(\"ConnectInputs() : transaction timestamp earlier than input transaction\"));\n  \n              // Check for negative or overflow input values\n              nValueIn += txPrev.vout[prevout.n].nValue;\n              if (!MoneyRange(txPrev.vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n                  return DoS(100, error(\"ConnectInputs() : txin values out of range\"));\n  \n          }\n          // The first loop above does all the inexpensive checks.\n          // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n          // Helps prevent CPU exhaustion attacks.\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              COutPoint prevout = vin[i].prevout;\n              assert(inputs.count(prevout.hash) > 0);\n              CTxIndex& txindex = inputs[prevout.hash].first;\n              CTransaction& txPrev = inputs[prevout.hash].second;\n  \n              // Check for conflicts (double-spend)\n              // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n              // for an attacker to attempt to split the network.\n              if (!txindex.vSpent[prevout.n].IsNull())\n                  return fMiner ? false : error(\"ConnectInputs() : %s prev tx already used at %s\", GetHash().ToString().substr(0,10).c_str(), txindex.vSpent[prevout.n].ToString().c_str());\n  \n              // Skip ECDSA signature verification when connecting blocks (fBlock=true)\n              // before the last blockchain checkpoint. This is safe because block merkle hashes are\n              // still computed and checked, and any change will be caught at the next checkpoint.\n              if (!(fBlock && (nBestHeight < Checkpoints::GetTotalBlocksEstimate())))\n              {\n                  // Verify signature\n                  if (!VerifySignature(txPrev, *this, i, 0))\n                  {\n                      return DoS(100,error(\"ConnectInputs() : %s VerifySignature failed\", GetHash().ToString().substr(0,10).c_str()));\n                  }\n              }\n  \n              // Mark outpoints as spent\n              txindex.vSpent[prevout.n] = posThisTx;\n  \n              // Write back\n              if (fBlock || fMiner)\n              {\n                  mapTestPool[prevout.hash] = txindex;\n              }\n          }\n  \n          if (!IsCoinStake())\n          {\n              if (nValueIn < GetValueOut())\n                  return DoS(100, error(\"ConnectInputs() : %s value in < value out\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // Tally transaction fees\n              int64_t nTxFee = nValueIn - GetValueOut();\n              if (nTxFee < 0)\n                  return DoS(100, error(\"ConnectInputs() : %s nTxFee < 0\", GetHash().ToString().substr(0,10).c_str()));\n  \n              // enforce transaction fees for every block\n              if (nTxFee < GetMinFee())\n                  return fBlock? DoS(100, error(\"ConnectInputs() : %s not paying required fee=%s, paid=%s\", GetHash().ToString().substr(0,10).c_str(), FormatMoney(GetMinFee()).c_str(), FormatMoney(nTxFee).c_str())) : false;\n  \n              nFees += nTxFee;\n              if (!MoneyRange(nFees))\n                  return DoS(100, error(\"ConnectInputs() : nFees out of range\"));\n          }\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapNextTx.count",
          "args": [
            "outpoint"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsNewerThan",
          "args": [
            "*ptxOld"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "IsNewerThan",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "508-535",
          "snippet": "bool IsNewerThan(const CTransaction& old) const\n    {\n        if (vin.size() != old.vin.size())\n            return false;\n        for (unsigned int i = 0; i < vin.size(); i++)\n            if (vin[i].prevout != old.vin[i].prevout)\n                return false;\n\n        bool fNewer = false;\n        unsigned int nLowest = std::numeric_limits<unsigned int>::max();\n        for (unsigned int i = 0; i < vin.size(); i++)\n        {\n            if (vin[i].nSequence != old.vin[i].nSequence)\n            {\n                if (vin[i].nSequence <= nLowest)\n                {\n                    fNewer = false;\n                    nLowest = vin[i].nSequence;\n                }\n                if (old.vin[i].nSequence < nLowest)\n                {\n                    fNewer = true;\n                    nLowest = old.vin[i].nSequence;\n                }\n            }\n        }\n        return fNewer;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsNewerThan(const CTransaction& old) const\n      {\n          if (vin.size() != old.vin.size())\n              return false;\n          for (unsigned int i = 0; i < vin.size(); i++)\n              if (vin[i].prevout != old.vin[i].prevout)\n                  return false;\n  \n          bool fNewer = false;\n          unsigned int nLowest = std::numeric_limits<unsigned int>::max();\n          for (unsigned int i = 0; i < vin.size(); i++)\n          {\n              if (vin[i].nSequence != old.vin[i].nSequence)\n              {\n                  if (vin[i].nSequence <= nLowest)\n                  {\n                      fNewer = false;\n                      nLowest = vin[i].nSequence;\n                  }\n                  if (old.vin[i].nSequence < nLowest)\n                  {\n                      fNewer = true;\n                      nLowest = old.vin[i].nSequence;\n                  }\n              }\n          }\n          return fNewer;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptxOld->IsFinal",
          "args": [],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "IsFinal",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "491-506",
          "snippet": "bool IsFinal(int nBlockHeight=0, int64_t nBlockTime=0) const\n    {\n        // Time based nLockTime implemented in 0.1.6\n        if (nLockTime == 0)\n            return true;\n        if (nBlockHeight == 0)\n            nBlockHeight = nBestHeight;\n        if (nBlockTime == 0)\n            nBlockTime = GetAdjustedTime();\n        if ((int64_t)nLockTime < ((int64_t)nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n            return true;\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (!txin.IsFinal())\n                return false;\n        return true;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsFinal(int nBlockHeight=0, int64_t nBlockTime=0) const\n      {\n          // Time based nLockTime implemented in 0.1.6\n          if (nLockTime == 0)\n              return true;\n          if (nBlockHeight == 0)\n              nBlockHeight = nBestHeight;\n          if (nBlockTime == 0)\n              nBlockTime = GetAdjustedTime();\n          if ((int64_t)nLockTime < ((int64_t)nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n              return true;\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (!txin.IsFinal())\n                  return false;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txdb.ContainsTx",
          "args": [
            "hash"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "ContainsTx",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "230-234",
          "snippet": "bool CTxDB::ContainsTx(uint256 hash)\n{\n    assert(!fClient);\n    return Exists(make_pair(string(\"tx\"), hash));\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ContainsTx(uint256 hash)\n  {\n      assert(!fClient);\n      return Exists(make_pair(string(\"tx\"), hash));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.IsStandard",
          "args": [],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "IsStandard",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "310-338",
          "snippet": "bool CTransaction::IsStandard() const\n{\n    if (nVersion > CTransaction::CURRENT_VERSION)\n        return false;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n        if (fEnforceCanonical && !txin.scriptSig.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout) {\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n        if (txout.nValue == 0)\n            return false;\n        if (fEnforceCanonical && !txout.scriptPubKey.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::IsStandard() const\n  {\n      if (nVersion > CTransaction::CURRENT_VERSION)\n          return false;\n  \n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n          // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n          // ~65-byte public keys, plus a few script ops.\n          if (txin.scriptSig.size() > 500)\n              return false;\n          if (!txin.scriptSig.IsPushOnly())\n              return false;\n          if (fEnforceCanonical && !txin.scriptSig.HasCanonicalPushes()) {\n              return false;\n          }\n      }\n      BOOST_FOREACH(const CTxOut& txout, vout) {\n          if (!::IsStandard(txout.scriptPubKey))\n              return false;\n          if (txout.nValue == 0)\n              return false;\n          if (fEnforceCanonical && !txout.scriptPubKey.HasCanonicalPushes()) {\n              return false;\n          }\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::numeric_limits<int>::max",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.DoS",
          "args": [
            "100",
            "error(\"CTxMemPool::accept() : coinstake as individual tx\")"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "DoS",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "865-865",
          "snippet": "bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinBase",
          "args": [],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.CheckTransaction",
          "args": [],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "CheckTransaction",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "478-527",
          "snippet": "bool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::CheckTransaction() const\n  {\n      // Basic checks that don't depend on any context\n      if (vin.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n      if (vout.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n      // Size limits\n      if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n  \n      // Check for negative or overflow output values\n      int64_t nValueOut = 0;\n      for (unsigned int i = 0; i < vout.size(); i++)\n      {\n          const CTxOut& txout = vout[i];\n          if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n          if (txout.nValue < 0)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n          if (txout.nValue > MAX_MONEY)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n          nValueOut += txout.nValue;\n          if (!MoneyRange(nValueOut))\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n      }\n  \n      // Check for duplicate inputs\n      set<COutPoint> vInOutPoints;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          if (vInOutPoints.count(txin.prevout))\n              return false;\n          vInOutPoints.insert(txin.prevout);\n      }\n  \n      if (IsCoinBase())\n      {\n          if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n      }\n      else\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (txin.prevout.IsNull())\n                  return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\n\nCTxMemPool {\n  bool CTxMemPool::accept(CTxDB& txdb, CTransaction &tx, bool fCheckInputs,\n                          bool* pfMissingInputs)\n  {\n      if (pfMissingInputs)\n          *pfMissingInputs = false;\n  \n      if (!tx.CheckTransaction())\n          return error(\"CTxMemPool::accept() : CheckTransaction failed\");\n  \n      // Coinbase is only valid in a block, not as a loose transaction\n      if (tx.IsCoinBase())\n          return tx.DoS(100, error(\"CTxMemPool::accept() : coinbase as individual tx\"));\n  \n      // ppcoin: coinstake is also only valid in a block, not as a loose transaction\n      if (tx.IsCoinStake())\n          return tx.DoS(100, error(\"CTxMemPool::accept() : coinstake as individual tx\"));\n  \n      // To help v0.1.5 clients who would see it as a negative number\n      if ((int64_t)tx.nLockTime > std::numeric_limits<int>::max())\n          return error(\"CTxMemPool::accept() : not accepting nLockTime beyond 2038 yet\");\n  \n      // Rather not work on nonstandard transactions (unless -testnet)\n      if (!fTestNet && !tx.IsStandard())\n          return error(\"CTxMemPool::accept() : nonstandard transaction type\");\n  \n      // Do we already have it?\n      uint256 hash = tx.GetHash();\n      {\n          LOCK(cs);\n          if (mapTx.count(hash))\n              return false;\n      }\n      if (fCheckInputs)\n          if (txdb.ContainsTx(hash))\n              return false;\n  \n      // Check for conflicts with in-memory transactions\n      CTransaction* ptxOld = NULL;\n      for (unsigned int i = 0; i < tx.vin.size(); i++)\n      {\n          COutPoint outpoint = tx.vin[i].prevout;\n          if (mapNextTx.count(outpoint))\n          {\n              // Disable replacement feature for now\n              return false;\n  \n              // Allow replacing with a newer version of the same transaction\n              if (i != 0)\n                  return false;\n              ptxOld = mapNextTx[outpoint].ptx;\n              if (ptxOld->IsFinal())\n                  return false;\n              if (!tx.IsNewerThan(*ptxOld))\n                  return false;\n              for (unsigned int i = 0; i < tx.vin.size(); i++)\n              {\n                  COutPoint outpoint = tx.vin[i].prevout;\n                  if (!mapNextTx.count(outpoint) || mapNextTx[outpoint].ptx != ptxOld)\n                      return false;\n              }\n              break;\n          }\n      }\n  \n      if (fCheckInputs)\n      {\n          MapPrevTx mapInputs;\n          map<uint256, CTxIndex> mapUnused;\n          bool fInvalid = false;\n          if (!tx.FetchInputs(txdb, mapUnused, false, false, mapInputs, fInvalid))\n          {\n              if (fInvalid)\n                  return error(\"CTxMemPool::accept() : FetchInputs found invalid tx %s\", hash.ToString().substr(0,10).c_str());\n              if (pfMissingInputs)\n                  *pfMissingInputs = true;\n              return false;\n          }\n  \n          // Check for non-standard pay-to-script-hash in inputs\n          if (!tx.AreInputsStandard(mapInputs) && !fTestNet)\n              return error(\"CTxMemPool::accept() : nonstandard transaction input\");\n  \n          // Note: if you modify this code to accept non-standard transactions, then\n          // you should add code here to check that the transaction does a\n          // reasonable number of ECDSA signature verifications.\n  \n          int64_t nFees = tx.GetValueIn(mapInputs)-tx.GetValueOut();\n          unsigned int nSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n  \n          // Don't accept it if it can't get into a block\n          int64_t txMinFee = tx.GetMinFee(1000, GMF_RELAY, nSize);\n          if (nFees < txMinFee)\n              return error(\"CTxMemPool::accept() : not enough fees %s, %\"PRId64\" < %\"PRId64,\n                           hash.ToString().c_str(),\n                           nFees, txMinFee);\n  \n          // Continuously rate-limit free transactions\n          // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n          // be annoying or make others' transactions take longer to confirm.\n          if (nFees < MIN_RELAY_TX_FEE)\n          {\n              static CCriticalSection cs;\n              static double dFreeCount;\n              static int64_t nLastTime;\n              int64_t nNow = GetTime();\n  \n              {\n                  LOCK(cs);\n                  // Use an exponentially decaying ~10-minute window:\n                  dFreeCount *= pow(1.0 - 1.0/600.0, (double)(nNow - nLastTime));\n                  nLastTime = nNow;\n                  // -limitfreerelay unit is thousand-bytes-per-minute\n                  // At default rate it would take over a month to fill 1GB\n                  if (dFreeCount > GetArg(\"-limitfreerelay\", 15)*10*1000 && !IsFromMe(tx))\n                      return error(\"CTxMemPool::accept() : free transaction rejected by rate limiter\");\n                  if (fDebug)\n                      printf(\"Rate limit dFreeCount: %g => %g\\n\", dFreeCount, dFreeCount+nSize);\n                  dFreeCount += nSize;\n              }\n          }\n  \n          // Check against previous transactions\n          // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n          if (!tx.ConnectInputs(txdb, mapInputs, mapUnused, CDiskTxPos(1,1,1), pindexBest, false, false))\n          {\n              return error(\"CTxMemPool::accept() : ConnectInputs failed %s\", hash.ToString().substr(0,10).c_str());\n          }\n      }\n  \n      // Store transaction in memory\n      {\n          LOCK(cs);\n          if (ptxOld)\n          {\n              printf(\"CTxMemPool::accept() : replacing tx %s with new version\\n\", ptxOld->GetHash().ToString().c_str());\n              remove(*ptxOld);\n          }\n          addUnchecked(hash, tx);\n      }\n  \n      ///// are we sure this is ok when loading transactions or restoring block txes\n      // If updated, erase old tx from wallet\n      if (ptxOld)\n          EraseFromWallets(ptxOld->GetHash());\n  \n      printf(\"CTxMemPool::accept() : accepted %s (poolsz %\"PRIszu\")\\n\",\n             hash.ToString().substr(0,10).c_str(),\n             mapTx.size());\n      return true;\n  }\n}"
  },
  {
    "function_name": "GetMinFee",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "529-556",
    "snippet": "int64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n{\n    // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n    int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n\n    unsigned int nNewBlockSize = nBlockSize + nBytes;\n    int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n\n    // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n    if (nMinFee < nBaseFee)\n    {\n        BOOST_FOREACH(const CTxOut& txout, vout)\n            if (txout.nValue < CENT)\n                nMinFee = nBaseFee;\n    }\n\n    // Raise the price as the block approaches full\n    if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n    {\n        if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n            return MAX_MONEY;\n        nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n    }\n\n    if (!MoneyRange(nMinFee))\n        nMinFee = MAX_MONEY;\n    return nMinFee;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MoneyRange",
          "args": [
            "nMinFee"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "MoneyRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "48-48",
          "snippet": "inline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\ninline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  int64_t CTransaction::GetMinFee(unsigned int nBlockSize, enum GetMinFee_mode mode, unsigned int nBytes) const\n  {\n      // Base fee is either MIN_TX_FEE or MIN_RELAY_TX_FEE\n      int64_t nBaseFee = (mode == GMF_RELAY) ? MIN_RELAY_TX_FEE : MIN_TX_FEE;\n  \n      unsigned int nNewBlockSize = nBlockSize + nBytes;\n      int64_t nMinFee = (1 + (int64_t)nBytes / 1000) * nBaseFee;\n  \n      // To limit dust spam, require MIN_TX_FEE/MIN_RELAY_TX_FEE if any output is less than 0.01\n      if (nMinFee < nBaseFee)\n      {\n          BOOST_FOREACH(const CTxOut& txout, vout)\n              if (txout.nValue < CENT)\n                  nMinFee = nBaseFee;\n      }\n  \n      // Raise the price as the block approaches full\n      if (nBlockSize != 1 && nNewBlockSize >= MAX_BLOCK_SIZE_GEN/2)\n      {\n          if (nNewBlockSize >= MAX_BLOCK_SIZE_GEN)\n              return MAX_MONEY;\n          nMinFee *= MAX_BLOCK_SIZE_GEN / (MAX_BLOCK_SIZE_GEN - nNewBlockSize);\n      }\n  \n      if (!MoneyRange(nMinFee))\n          nMinFee = MAX_MONEY;\n      return nMinFee;\n  }\n}"
  },
  {
    "function_name": "CheckTransaction",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "478-527",
    "snippet": "bool CTransaction::CheckTransaction() const\n{\n    // Basic checks that don't depend on any context\n    if (vin.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n    if (vout.empty())\n        return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n    // Size limits\n    if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n\n    // Check for negative or overflow output values\n    int64_t nValueOut = 0;\n    for (unsigned int i = 0; i < vout.size(); i++)\n    {\n        const CTxOut& txout = vout[i];\n        if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n        if (txout.nValue < 0)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n        if (txout.nValue > MAX_MONEY)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n        nValueOut += txout.nValue;\n        if (!MoneyRange(nValueOut))\n            return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n    }\n\n    // Check for duplicate inputs\n    set<COutPoint> vInOutPoints;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        if (vInOutPoints.count(txin.prevout))\n            return false;\n        vInOutPoints.insert(txin.prevout);\n    }\n\n    if (IsCoinBase())\n    {\n        if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n            return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n    }\n    else\n    {\n        BOOST_FOREACH(const CTxIn& txin, vin)\n            if (txin.prevout.IsNull())\n                return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoS",
          "args": [
            "10",
            "error(\"CTransaction::CheckTransaction() : prevout is null\")"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "DoS",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "865-865",
          "snippet": "bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  bool DoS(int nDoSIn, bool fIn) const { nDoS += nDoSIn; return fIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"CTransaction::CheckTransaction() : prevout is null\""
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.prevout.IsNull",
          "args": [],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "IsNull",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1585-1588",
          "snippet": "bool IsNull()\n    {\n        return vHave.empty();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  bool IsNull()\n      {\n          return vHave.empty();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vin[0].scriptSig.size",
          "args": [],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinBase",
          "args": [],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vInOutPoints.insert",
          "args": [
            "txin.prevout"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vInOutPoints.count",
          "args": [
            "txin.prevout"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MoneyRange",
          "args": [
            "nValueOut"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "MoneyRange",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "48-48",
          "snippet": "inline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\ninline bool MoneyRange(int64_t nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }"
        }
      },
      {
        "call_info": {
          "callee": "IsCoinStake",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txout.IsEmpty",
          "args": [],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "IsEmpty",
          "container": "CTxOut",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "387-390",
          "snippet": "bool IsEmpty() const\n    {\n        return (nValue == 0 && scriptPubKey.empty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxOut {\n  bool IsEmpty() const\n      {\n          return (nValue == 0 && scriptPubKey.empty());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::GetSerializeSize",
          "args": [
            "*this",
            "SER_NETWORK",
            "PROTOCOL_VERSION"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "632-638",
          "snippet": "unsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nunsigned int GetSerializeSize(const std::set<K, Pred, A>& m, int nType, int nVersion)\n{\n    unsigned int nSize = GetSizeOfCompactSize(m.size());\n    for (typename std::set<K, Pred, A>::const_iterator it = m.begin(); it != m.end(); ++it)\n        nSize += GetSerializeSize((*it), nType, nVersion);\n    return nSize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vout.empty",
          "args": [],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::CheckTransaction() const\n  {\n      // Basic checks that don't depend on any context\n      if (vin.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vin empty\"));\n      if (vout.empty())\n          return DoS(10, error(\"CTransaction::CheckTransaction() : vout empty\"));\n      // Size limits\n      if (::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n          return DoS(100, error(\"CTransaction::CheckTransaction() : size limits failed\"));\n  \n      // Check for negative or overflow output values\n      int64_t nValueOut = 0;\n      for (unsigned int i = 0; i < vout.size(); i++)\n      {\n          const CTxOut& txout = vout[i];\n          if (txout.IsEmpty() && !IsCoinBase() && !IsCoinStake())\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout empty for user transaction\"));\n          if (txout.nValue < 0)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue negative\"));\n          if (txout.nValue > MAX_MONEY)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout.nValue too high\"));\n          nValueOut += txout.nValue;\n          if (!MoneyRange(nValueOut))\n              return DoS(100, error(\"CTransaction::CheckTransaction() : txout total out of range\"));\n      }\n  \n      // Check for duplicate inputs\n      set<COutPoint> vInOutPoints;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          if (vInOutPoints.count(txin.prevout))\n              return false;\n          vInOutPoints.insert(txin.prevout);\n      }\n  \n      if (IsCoinBase())\n      {\n          if (vin[0].scriptSig.size() < 2 || vin[0].scriptSig.size() > 100)\n              return DoS(100, error(\"CTransaction::CheckTransaction() : coinbase script size is invalid\"));\n      }\n      else\n      {\n          BOOST_FOREACH(const CTxIn& txin, vin)\n              if (txin.prevout.IsNull())\n                  return DoS(10, error(\"CTransaction::CheckTransaction() : prevout is null\"));\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "SetMerkleBranch",
    "container": "CMerkleTx",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "421-470",
    "snippet": "int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n{\n    if (fClient)\n    {\n        if (hashBlock == 0)\n            return 0;\n    }\n    else\n    {\n        CBlock blockTmp;\n        if (pblock == NULL)\n        {\n            // Load the block this tx is in\n            CTxIndex txindex;\n            if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                return 0;\n            if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                return 0;\n            pblock = &blockTmp;\n        }\n\n        // Update the tx's hashBlock\n        hashBlock = pblock->GetHash();\n\n        // Locate the transaction\n        for (nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n            if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                break;\n        if (nIndex == (int)pblock->vtx.size())\n        {\n            vMerkleBranch.clear();\n            nIndex = -1;\n            printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n            return 0;\n        }\n\n        // Fill in merkle branch\n        vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n    }\n\n    // Is the tx in a block that's in the main chain\n    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n    if (mi == mapBlockIndex.end())\n        return 0;\n    CBlockIndex* pindex = (*mi).second;\n    if (!pindex || !pindex->IsInMainChain())\n        return 0;\n\n    return pindexBest->nHeight - pindex->nHeight + 1;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "map<uint256, CBlockIndex*> mapBlockIndex;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "CBlockIndex* pindexBest = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pindex->IsInMainChain",
          "args": [],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "IsInMainChain",
          "container": "CBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1291-1294",
          "snippet": "bool IsInMainChain() const\n    {\n        return (pnext || this == pindexBest);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockIndex {\n  bool IsInMainChain() const\n      {\n          return (pnext || this == pindexBest);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.end",
          "args": [],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapBlockIndex.find",
          "args": [
            "hashBlock"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->GetMerkleBranch",
          "args": [
            "nIndex"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "GetMerkleBranch",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1039-1053",
          "snippet": "std::vector<uint256> GetMerkleBranch(int nIndex) const\n    {\n        if (vMerkleTree.empty())\n            BuildMerkleTree();\n        std::vector<uint256> vMerkleBranch;\n        int j = 0;\n        for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n        {\n            int i = std::min(nIndex^1, nSize-1);\n            vMerkleBranch.push_back(vMerkleTree[j+i]);\n            nIndex >>= 1;\n            j += nSize;\n        }\n        return vMerkleBranch;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  std::vector<uint256> GetMerkleBranch(int nIndex) const\n      {\n          if (vMerkleTree.empty())\n              BuildMerkleTree();\n          std::vector<uint256> vMerkleBranch;\n          int j = 0;\n          for (int nSize = vtx.size(); nSize > 1; nSize = (nSize + 1) / 2)\n          {\n              int i = std::min(nIndex^1, nSize-1);\n              vMerkleBranch.push_back(vMerkleTree[j+i]);\n              nIndex >>= 1;\n              j += nSize;\n          }\n          return vMerkleBranch;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vMerkleBranch.clear",
          "args": [],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->vtx.size",
          "args": [],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pblock->GetHash",
          "args": [],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockTmp.ReadFromDisk",
          "args": [
            "txindex.pos.nFile",
            "txindex.pos.nBlockPos"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "945-957",
          "snippet": "bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n{\n    if (!fReadTransactions)\n    {\n        *this = pindex->GetBlockHeader();\n        return true;\n    }\n    if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n        return false;\n    if (GetHash() != pindex->GetBlockHash())\n        return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n    return true;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBlock {\n  bool CBlock::ReadFromDisk(const CBlockIndex* pindex, bool fReadTransactions)\n  {\n      if (!fReadTransactions)\n      {\n          *this = pindex->GetBlockHeader();\n          return true;\n      }\n      if (!ReadFromDisk(pindex->nFile, pindex->nBlockPos, fReadTransactions))\n          return false;\n      if (GetHash() != pindex->GetBlockHash())\n          return error(\"CBlock::ReadFromDisk() : GetHash() doesn't match index\");\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CTxDB",
          "args": [
            "GetHash()",
            "txindex"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "Write",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "101-123",
          "snippet": "bool Write(const K& key, const T& value)\n    {\n        if (fReadOnly)\n            assert(!\"Write called on database in read-only mode\");\n\n        CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n        ssKey.reserve(1000);\n        ssKey << key;\n        CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n        ssValue.reserve(10000);\n        ssValue << value;\n\n        if (activeBatch) {\n            activeBatch->Put(ssKey.str(), ssValue.str());\n            return true;\n        }\n        leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n        if (!status.ok()) {\n            printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n            return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool Write(const K& key, const T& value)\n      {\n          if (fReadOnly)\n              assert(!\"Write called on database in read-only mode\");\n  \n          CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n          ssKey.reserve(1000);\n          ssKey << key;\n          CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n          ssValue.reserve(10000);\n          ssValue << value;\n  \n          if (activeBatch) {\n              activeBatch->Put(ssKey.str(), ssValue.str());\n              return true;\n          }\n          leveldb::Status status = pdb->Put(leveldb::WriteOptions(), ssKey.str(), ssValue.str());\n          if (!status.ok()) {\n              printf(\"LevelDB write failure: %s\\n\", status.ToString().c_str());\n              return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetHash",
          "args": [],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "GetHashPoW",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "936-952",
          "snippet": "uint256 GetHashPoW() const {\n        uint256 hashPoW;\n        uint profile = 0x0;\n\n        /* All these blocks must be v2+ with valid nHeight */\n        int nHeight = GetBlockHeight();\n\n        /* X15 or NeoScrypt */\n        if(!fTestNet && (nHeight < nForkOne)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n        } else {\n            profile |= nNeoScryptOptions;\n            neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n        }\n\n        return(hashPoW);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHashPoW() const {\n          uint256 hashPoW;\n          uint profile = 0x0;\n  \n          /* All these blocks must be v2+ with valid nHeight */\n          int nHeight = GetBlockHeight();\n  \n          /* X15 or NeoScrypt */\n          if(!fTestNet && (nHeight < nForkOne)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashPoW);\n          } else {\n              profile |= nNeoScryptOptions;\n              neoscrypt((uchar *) &nVersion, (uchar *) &hashPoW, profile);\n          }\n  \n          return(hashPoW);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CTxDB",
          "args": [
            "\"r\""
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "WriteVersion",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.h",
          "lines": "181-184",
          "snippet": "bool WriteVersion(int nVersion)\n    {\n        return Write(std::string(\"version\"), nVersion);\n    }",
          "includes": [
            "#include <leveldb/write_batch.h>",
            "#include <leveldb/db.h>",
            "#include <vector>",
            "#include <string>",
            "#include <map>",
            "#include \"main.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <leveldb/write_batch.h>\n#include <leveldb/db.h>\n#include <vector>\n#include <string>\n#include <map>\n#include \"main.h\"\n\nCTxDB {\n  bool WriteVersion(int nVersion)\n      {\n          return Write(std::string(\"version\"), nVersion);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nmap<uint256, CBlockIndex*> mapBlockIndex;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nCBlockIndex* pindexBest = NULL;\n\nCMerkleTx {\n  int CMerkleTx::SetMerkleBranch(const CBlock* pblock)\n  {\n      if (fClient)\n      {\n          if (hashBlock == 0)\n              return 0;\n      }\n      else\n      {\n          CBlock blockTmp;\n          if (pblock == NULL)\n          {\n              // Load the block this tx is in\n              CTxIndex txindex;\n              if (!CTxDB(\"r\").ReadTxIndex(GetHash(), txindex))\n                  return 0;\n              if (!blockTmp.ReadFromDisk(txindex.pos.nFile, txindex.pos.nBlockPos))\n                  return 0;\n              pblock = &blockTmp;\n          }\n  \n          // Update the tx's hashBlock\n          hashBlock = pblock->GetHash();\n  \n          // Locate the transaction\n          for (nIndex = 0; nIndex < (int)pblock->vtx.size(); nIndex++)\n              if (pblock->vtx[nIndex] == *(CTransaction*)this)\n                  break;\n          if (nIndex == (int)pblock->vtx.size())\n          {\n              vMerkleBranch.clear();\n              nIndex = -1;\n              printf(\"ERROR: SetMerkleBranch() : couldn't find tx in block\\n\");\n              return 0;\n          }\n  \n          // Fill in merkle branch\n          vMerkleBranch = pblock->GetMerkleBranch(nIndex);\n      }\n  \n      // Is the tx in a block that's in the main chain\n      map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashBlock);\n      if (mi == mapBlockIndex.end())\n          return 0;\n      CBlockIndex* pindex = (*mi).second;\n      if (!pindex || !pindex->IsInMainChain())\n          return 0;\n  \n      return pindexBest->nHeight - pindex->nHeight + 1;\n  }\n}"
  },
  {
    "function_name": "GetLegacySigOpCount",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "405-418",
    "snippet": "unsigned int\nCTransaction::GetLegacySigOpCount() const\n{\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        nSigOps += txin.scriptSig.GetSigOpCount(false);\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout)\n    {\n        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n    }\n    return nSigOps;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "txout.scriptPubKey.GetSigOpCount",
          "args": [
            "false"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "GetSigOpCount",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1926-1948",
          "snippet": "unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n{\n    if (!IsPayToScriptHash())\n        return GetSigOpCount(true);\n\n    // This is a pay-to-script-hash scriptPubKey;\n    // get the last item that the scriptSig\n    // pushes onto the stack:\n    const_iterator pc = scriptSig.begin();\n    vector<unsigned char> data;\n    while (pc < scriptSig.end())\n    {\n        opcodetype opcode;\n        if (!scriptSig.GetOp(pc, opcode, data))\n            return 0;\n        if (opcode > OP_16)\n            return 0;\n    }\n\n    /// ... and return its opcount:\n    CScript subscript(data.begin(), data.end());\n    return subscript.GetSigOpCount(true);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n  {\n      if (!IsPayToScriptHash())\n          return GetSigOpCount(true);\n  \n      // This is a pay-to-script-hash scriptPubKey;\n      // get the last item that the scriptSig\n      // pushes onto the stack:\n      const_iterator pc = scriptSig.begin();\n      vector<unsigned char> data;\n      while (pc < scriptSig.end())\n      {\n          opcodetype opcode;\n          if (!scriptSig.GetOp(pc, opcode, data))\n              return 0;\n          if (opcode > OP_16)\n              return 0;\n      }\n  \n      /// ... and return its opcount:\n      CScript subscript(data.begin(), data.end());\n      return subscript.GetSigOpCount(true);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  unsigned int\n  CTransaction::GetLegacySigOpCount() const\n  {\n      unsigned int nSigOps = 0;\n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          nSigOps += txin.scriptSig.GetSigOpCount(false);\n      }\n      BOOST_FOREACH(const CTxOut& txout, vout)\n      {\n          nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n      }\n      return nSigOps;\n  }\n}"
  },
  {
    "function_name": "AreInputsStandard",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "351-403",
    "snippet": "bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n{\n    if (IsCoinBase())\n        return true; // Coinbases don't use vin normally\n\n    for (unsigned int i = 0; i < vin.size(); i++)\n    {\n        const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n\n        vector<vector<unsigned char> > vSolutions;\n        txnouttype whichType;\n        // get the scriptPubKey corresponding to this input:\n        const CScript& prevScript = prev.scriptPubKey;\n        if (!Solver(prevScript, whichType, vSolutions))\n            return false;\n        int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n        if (nArgsExpected < 0)\n            return false;\n\n        // Transactions with extra stuff in their scriptSigs are\n        // non-standard. Note that this EvalScript() call will\n        // be quick, because if there are any operations\n        // beside \"push data\" in the scriptSig the\n        // IsStandard() call returns false\n        vector<vector<unsigned char> > stack;\n        if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n            return false;\n\n        if (whichType == TX_SCRIPTHASH)\n        {\n            if (stack.empty())\n                return false;\n            CScript subscript(stack.back().begin(), stack.back().end());\n            vector<vector<unsigned char> > vSolutions2;\n            txnouttype whichType2;\n            if (!Solver(subscript, whichType2, vSolutions2))\n                return false;\n            if (whichType2 == TX_SCRIPTHASH)\n                return false;\n\n            int tmpExpected;\n            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n            if (tmpExpected < 0)\n                return false;\n            nArgsExpected += tmpExpected;\n        }\n\n        if (stack.size() != (unsigned int)nArgsExpected)\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack.size",
          "args": [],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ScriptSigArgsExpected",
          "args": [
            "whichType2",
            "vSolutions2"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "ScriptSigArgsExpected",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1480-1498",
          "snippet": "int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions)\n{\n    switch (t)\n    {\n    case TX_NONSTANDARD:\n        return -1;\n    case TX_PUBKEY:\n        return 1;\n    case TX_PUBKEYHASH:\n        return 2;\n    case TX_MULTISIG:\n        if (vSolutions.size() < 1 || vSolutions[0].size() < 1)\n            return -1;\n        return vSolutions[0][0] + 1;\n    case TX_SCRIPTHASH:\n        return 1; // doesn't include args needed by the script\n    }\n    return -1;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nint ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions)\n{\n    switch (t)\n    {\n    case TX_NONSTANDARD:\n        return -1;\n    case TX_PUBKEY:\n        return 1;\n    case TX_PUBKEYHASH:\n        return 2;\n    case TX_MULTISIG:\n        if (vSolutions.size() < 1 || vSolutions[0].size() < 1)\n            return -1;\n        return vSolutions[0][0] + 1;\n    case TX_SCRIPTHASH:\n        return 1; // doesn't include args needed by the script\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "subscript",
            "whichType2",
            "vSolutions2"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack.back",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.back",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.back",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.back",
          "args": [],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.empty",
          "args": [],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EvalScript",
          "args": [
            "stack",
            "vin[i].scriptSig",
            "*this",
            "i",
            "0"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "EvalScript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "323-1125",
          "snippet": "bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);",
            "static const valtype vchFalse(0);",
            "static const valtype vchTrue(1, 1);",
            "static const CBigNum bnZero(0);",
            "static const CBigNum bnOne(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\nstatic const valtype vchFalse(0);\nstatic const valtype vchTrue(1, 1);\nstatic const CBigNum bnZero(0);\nstatic const CBigNum bnOne(1);\n\nbool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOutputFor",
          "args": [
            "vin[i]",
            "mapInputs"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsCoinBase",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinBase",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "537-540",
          "snippet": "bool IsCoinBase() const\n    {\n        return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinBase() const\n      {\n          return (vin.size() == 1 && vin[0].prevout.IsNull() && vout.size() >= 1);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::AreInputsStandard(const MapPrevTx& mapInputs) const\n  {\n      if (IsCoinBase())\n          return true; // Coinbases don't use vin normally\n  \n      for (unsigned int i = 0; i < vin.size(); i++)\n      {\n          const CTxOut& prev = GetOutputFor(vin[i], mapInputs);\n  \n          vector<vector<unsigned char> > vSolutions;\n          txnouttype whichType;\n          // get the scriptPubKey corresponding to this input:\n          const CScript& prevScript = prev.scriptPubKey;\n          if (!Solver(prevScript, whichType, vSolutions))\n              return false;\n          int nArgsExpected = ScriptSigArgsExpected(whichType, vSolutions);\n          if (nArgsExpected < 0)\n              return false;\n  \n          // Transactions with extra stuff in their scriptSigs are\n          // non-standard. Note that this EvalScript() call will\n          // be quick, because if there are any operations\n          // beside \"push data\" in the scriptSig the\n          // IsStandard() call returns false\n          vector<vector<unsigned char> > stack;\n          if (!EvalScript(stack, vin[i].scriptSig, *this, i, 0))\n              return false;\n  \n          if (whichType == TX_SCRIPTHASH)\n          {\n              if (stack.empty())\n                  return false;\n              CScript subscript(stack.back().begin(), stack.back().end());\n              vector<vector<unsigned char> > vSolutions2;\n              txnouttype whichType2;\n              if (!Solver(subscript, whichType2, vSolutions2))\n                  return false;\n              if (whichType2 == TX_SCRIPTHASH)\n                  return false;\n  \n              int tmpExpected;\n              tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n              if (tmpExpected < 0)\n                  return false;\n              nArgsExpected += tmpExpected;\n          }\n  \n          if (stack.size() != (unsigned int)nArgsExpected)\n              return false;\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "IsStandard",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "310-338",
    "snippet": "bool CTransaction::IsStandard() const\n{\n    if (nVersion > CTransaction::CURRENT_VERSION)\n        return false;\n\n    BOOST_FOREACH(const CTxIn& txin, vin)\n    {\n        // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n        // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n        // ~65-byte public keys, plus a few script ops.\n        if (txin.scriptSig.size() > 500)\n            return false;\n        if (!txin.scriptSig.IsPushOnly())\n            return false;\n        if (fEnforceCanonical && !txin.scriptSig.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    BOOST_FOREACH(const CTxOut& txout, vout) {\n        if (!::IsStandard(txout.scriptPubKey))\n            return false;\n        if (txout.nValue == 0)\n            return false;\n        if (fEnforceCanonical && !txout.scriptPubKey.HasCanonicalPushes()) {\n            return false;\n        }\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "txout.scriptPubKey.HasCanonicalPushes",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "HasCanonicalPushes",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1959-1984",
          "snippet": "bool CScript::HasCanonicalPushes() const\n{\n    const_iterator pc = begin();\n    while (pc < end())\n    {\n        opcodetype opcode;\n        std::vector<unsigned char> data;\n        if (!GetOp(pc, opcode, data))\n            return false;\n        if (opcode > OP_16)\n            continue;\n        if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n            // Could have used an OP_n code, rather than a 1-byte push.\n            return false;\n        if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n            // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n            // Could have used an OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n            // Could have used an OP_PUSHDATA2.\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::HasCanonicalPushes() const\n  {\n      const_iterator pc = begin();\n      while (pc < end())\n      {\n          opcodetype opcode;\n          std::vector<unsigned char> data;\n          if (!GetOp(pc, opcode, data))\n              return false;\n          if (opcode > OP_16)\n              continue;\n          if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n              // Could have used an OP_n code, rather than a 1-byte push.\n              return false;\n          if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n              // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n              // Could have used an OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n              // Could have used an OP_PUSHDATA2.\n              return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "::IsStandard",
          "args": [
            "txout.scriptPubKey"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "IsStandard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1500-1519",
          "snippet": "bool IsStandard(const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_MULTISIG)\n    {\n        unsigned char m = vSolutions.front()[0];\n        unsigned char n = vSolutions.back()[0];\n        // Support up to x-of-3 multisig txns as standard\n        if (n < 1 || n > 3)\n            return false;\n        if (m < 1 || m > n)\n            return false;\n    }\n\n    return whichType != TX_NONSTANDARD;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool IsStandard(const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_MULTISIG)\n    {\n        unsigned char m = vSolutions.front()[0];\n        unsigned char n = vSolutions.back()[0];\n        // Support up to x-of-3 multisig txns as standard\n        if (n < 1 || n > 3)\n            return false;\n        if (m < 1 || m > n)\n            return false;\n    }\n\n    return whichType != TX_NONSTANDARD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.IsPushOnly",
          "args": [],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "IsPushOnly",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "529-541",
          "snippet": "bool IsPushOnly() const\n    {\n        const_iterator pc = begin();\n        while (pc < end())\n        {\n            opcodetype opcode;\n            if (!GetOp(pc, opcode))\n                return false;\n            if (opcode > OP_16)\n                return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool IsPushOnly() const\n      {\n          const_iterator pc = begin();\n          while (pc < end())\n          {\n              opcodetype opcode;\n              if (!GetOp(pc, opcode))\n                  return false;\n              if (opcode > OP_16)\n                  return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.size",
          "args": [],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::IsStandard() const\n  {\n      if (nVersion > CTransaction::CURRENT_VERSION)\n          return false;\n  \n      BOOST_FOREACH(const CTxIn& txin, vin)\n      {\n          // Biggest 'standard' txin is a 3-signature 3-of-3 CHECKMULTISIG\n          // pay-to-script-hash, which is 3 ~80-byte signatures, 3\n          // ~65-byte public keys, plus a few script ops.\n          if (txin.scriptSig.size() > 500)\n              return false;\n          if (!txin.scriptSig.IsPushOnly())\n              return false;\n          if (fEnforceCanonical && !txin.scriptSig.HasCanonicalPushes()) {\n              return false;\n          }\n      }\n      BOOST_FOREACH(const CTxOut& txout, vout) {\n          if (!::IsStandard(txout.scriptPubKey))\n              return false;\n          if (txout.nValue == 0)\n              return false;\n          if (fEnforceCanonical && !txout.scriptPubKey.HasCanonicalPushes()) {\n              return false;\n          }\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "ReadFromDisk",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "303-308",
    "snippet": "bool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadFromDisk",
          "args": [
            "txdb",
            "prevout",
            "txindex"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(COutPoint prevout)\n  {\n      CTxDB txdb(\"r\");\n      CTxIndex txindex;\n      return ReadFromDisk(txdb, prevout, txindex);\n  }\n}"
  },
  {
    "function_name": "ReadFromDisk",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "297-301",
    "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n{\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ReadFromDisk",
          "args": [
            "txdb",
            "prevout",
            "txindex"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "282-295",
          "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout)\n  {\n      CTxIndex txindex;\n      return ReadFromDisk(txdb, prevout, txindex);\n  }\n}"
  },
  {
    "function_name": "ReadFromDisk",
    "container": "CTransaction",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "282-295",
    "snippet": "bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n{\n    SetNull();\n    if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n        return false;\n    if (!ReadFromDisk(txindexRet.pos))\n        return false;\n    if (prevout.n >= vout.size())\n    {\n        SetNull();\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetNull",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CBlockLocator",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1580-1583",
          "snippet": "void SetNull()\n    {\n        vHave.clear();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlockLocator {\n  void SetNull()\n      {\n          vHave.clear();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vout.size",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ReadFromDisk",
          "args": [
            "txindexRet.pos"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ReadFromDisk",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "303-308",
          "snippet": "bool CTransaction::ReadFromDisk(COutPoint prevout)\n{\n    CTxDB txdb(\"r\");\n    CTxIndex txindex;\n    return ReadFromDisk(txdb, prevout, txindex);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "txdb.ReadTxIndex",
          "args": [
            "prevout.hash",
            "txindexRet"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ReadTxIndex",
          "container": "CTxDB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/txdb-leveldb.cpp",
          "lines": "199-204",
          "snippet": "bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n{\n    assert(!fClient);\n    txindex.SetNull();\n    return Read(make_pair(string(\"tx\"), hash), txindex);\n}",
          "includes": [
            "#include \"main.h\"",
            "#include \"util.h\"",
            "#include \"txdb.h\"",
            "#include \"checkpoints.h\"",
            "#include \"kernel.h\"",
            "#include <memenv/memenv.h>",
            "#include <leveldb/filter_policy.h>",
            "#include <leveldb/cache.h>",
            "#include <leveldb/env.h>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/version.hpp>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"main.h\"\n#include \"util.h\"\n#include \"txdb.h\"\n#include \"checkpoints.h\"\n#include \"kernel.h\"\n#include <memenv/memenv.h>\n#include <leveldb/filter_policy.h>\n#include <leveldb/cache.h>\n#include <leveldb/env.h>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/version.hpp>\n#include <map>\n\nCTxDB {\n  bool CTxDB::ReadTxIndex(uint256 hash, CTxIndex& txindex)\n  {\n      assert(!fClient);\n      txindex.SetNull();\n      return Read(make_pair(string(\"tx\"), hash), txindex);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCTransaction {\n  bool CTransaction::ReadFromDisk(CTxDB& txdb, COutPoint prevout, CTxIndex& txindexRet)\n  {\n      SetNull();\n      if (!txdb.ReadTxIndex(prevout.hash, txindexRet))\n          return false;\n      if (!ReadFromDisk(txindexRet.pos))\n          return false;\n      if (prevout.n >= vout.size())\n      {\n          SetNull();\n          return false;\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "LimitOrphanTxSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "255-269",
    "snippet": "unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CTransaction>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "map<uint256, CTransaction> mapOrphanTransactions;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EraseOrphanTx",
          "args": [
            "it->first"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "EraseOrphanTx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "241-253",
          "snippet": "void static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
            "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
            "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
            "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
            "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
            "map<uint256, CTransaction> mapOrphanTransactions;",
            "map<uint256, set<uint256> > mapOrphanTransactionsByPrev;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactions.begin",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactions.end",
          "args": [],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactions.lower_bound",
          "args": [
            "randomhash"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRandHash",
          "args": [],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "193-198",
          "snippet": "uint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nuint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactions.size",
          "args": [],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CTransaction> mapOrphanTransactions;\n\nunsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n{\n    unsigned int nEvicted = 0;\n    while (mapOrphanTransactions.size() > nMaxOrphans)\n    {\n        // Evict a random orphan:\n        uint256 randomhash = GetRandHash();\n        map<uint256, CTransaction>::iterator it = mapOrphanTransactions.lower_bound(randomhash);\n        if (it == mapOrphanTransactions.end())\n            it = mapOrphanTransactions.begin();\n        EraseOrphanTx(it->first);\n        ++nEvicted;\n    }\n    return nEvicted;\n}"
  },
  {
    "function_name": "EraseOrphanTx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "241-253",
    "snippet": "void static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "map<uint256, CTransaction> mapOrphanTransactions;",
      "map<uint256, set<uint256> > mapOrphanTransactionsByPrev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapOrphanTransactions.erase",
          "args": [
            "hash"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactionsByPrev[txin.prevout.hash].empty",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactions.count",
          "args": [
            "hash"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n\nvoid static EraseOrphanTx(uint256 hash)\n{\n    if (!mapOrphanTransactions.count(hash))\n        return;\n    const CTransaction& tx = mapOrphanTransactions[hash];\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        mapOrphanTransactionsByPrev[txin.prevout.hash].erase(hash);\n        if (mapOrphanTransactionsByPrev[txin.prevout.hash].empty())\n            mapOrphanTransactionsByPrev.erase(txin.prevout.hash);\n    }\n    mapOrphanTransactions.erase(hash);\n}"
  },
  {
    "function_name": "AddOrphanTx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "210-239",
    "snippet": "bool AddOrphanTx(const CTransaction& tx)\n{\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n\n    size_t nSize = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n\n    if (nSize > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %\"PRIszu\", hash: %s)\\n\", nSize, hash.ToString().substr(0,10).c_str());\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n\n    printf(\"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);",
      "map<uint256, CTransaction> mapOrphanTransactions;",
      "map<uint256, set<uint256> > mapOrphanTransactionsByPrev;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"stored orphan tx %s (mapsz %\"PRIszu\")\\n\"",
            "hash.ToString().substr(0,10).c_str()",
            "mapOrphanTransactions.size()"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactions.size",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1691-1695",
          "snippet": "unsigned long size()\n    {\n        LOCK(cs);\n        return mapTx.size();\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTxMemPool {\n  unsigned long size()\n      {\n          LOCK(cs);\n          return mapTx.size();\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CDiskBlockIndex",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "1518-1527",
          "snippet": "std::string ToString() const\n    {\n        std::string str = \"CDiskBlockIndex(\";\n        str += CBlockIndex::ToString();\n        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n            GetBlockHash().ToString().c_str(),\n            hashPrev.ToString().c_str(),\n            hashNext.ToString().c_str());\n        return str;\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCDiskBlockIndex {\n  std::string ToString() const\n      {\n          std::string str = \"CDiskBlockIndex(\";\n          str += CBlockIndex::ToString();\n          str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s, hashNext=%s)\",\n              GetBlockHash().ToString().c_str(),\n              hashPrev.ToString().c_str(),\n              hashNext.ToString().c_str());\n          return str;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "hash.ToString",
          "args": [
            "0",
            "10"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "Harness",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table_test.cc",
          "lines": "595-602",
          "snippet": "std::string ToString(const KVMap& data,\n                       const KVMap::const_reverse_iterator& it) {\n    if (it == data.rend()) {\n      return \"END\";\n    } else {\n      return \"'\" + it->first + \"->\" + it->second + \"'\";\n    }\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/random.h\"",
            "#include \"table/format.h\"",
            "#include \"table/block_builder.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include <string>",
            "#include <map>",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/random.h\"\n#include \"table/format.h\"\n#include \"table/block_builder.h\"\n#include \"table/block.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include <string>\n#include <map>\n#include \"leveldb/table.h\"\n\nHarness {\n  std::string ToString(const KVMap& data,\n                         const KVMap::const_reverse_iterator& it) {\n      if (it == data.rend()) {\n        return \"END\";\n      } else {\n        return \"'\" + it->first + \"->\" + it->second + \"'\";\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactionsByPrev[txin.prevout.hash].insert",
          "args": [
            "hash"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ignoring large orphan tx (size: %\"PRIszu\", hash: %s)\\n\"",
            "nSize",
            "hash.ToString().substr(0,10).c_str()"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tx.GetSerializeSize",
          "args": [
            "SER_NETWORK",
            "CTransaction::CURRENT_VERSION"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "GetSerializeSize",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "364-367",
          "snippet": "unsigned int GetSerializeSize(int nType, int nVersion) const\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int GetSerializeSize(int nType, int nVersion) const\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mapOrphanTransactions.count",
          "args": [
            "hash"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.GetHash",
          "args": [],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CBlock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "915-933",
          "snippet": "uint256 GetHash() const {\n        uint256 hashBlock;\n\n        if(!fTestNet && (nTime < 1419062077)) {\n            x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n        } else {\n            /* 80 + 32 bytes, no padding */\n            uchar input[112];\n            /* Copy the block header */\n            neoscrypt_copy(&input[0], &nVersion, 80);\n            /* Copy the merkle root once again */\n            neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n            /* Hash the data;\n             * key is higher and lower 10 bytes of merkle root\n             * with nTime, nBits, nNonce in between */\n            neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n        }\n        return(hashBlock);\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCBlock {\n  uint256 GetHash() const {\n          uint256 hashBlock;\n  \n          if(!fTestNet && (nTime < 1419062077)) {\n              x15hash((uchar *) &nVersion, (uchar *) &hashBlock);\n          } else {\n              /* 80 + 32 bytes, no padding */\n              uchar input[112];\n              /* Copy the block header */\n              neoscrypt_copy(&input[0], &nVersion, 80);\n              /* Copy the merkle root once again */\n              neoscrypt_copy(&input[80], &hashMerkleRoot, 32);\n              /* Hash the data;\n               * key is higher and lower 10 bytes of merkle root\n               * with nTime, nBits, nNonce in between */\n              neoscrypt_blake2s(&input[0], 112, &input[58], 32, &hashBlock, 32);\n          }\n          return(hashBlock);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\nmap<uint256, CTransaction> mapOrphanTransactions;\nmap<uint256, set<uint256> > mapOrphanTransactionsByPrev;\n\nbool AddOrphanTx(const CTransaction& tx)\n{\n    uint256 hash = tx.GetHash();\n    if (mapOrphanTransactions.count(hash))\n        return false;\n\n    // Ignore big transactions, to avoid a\n    // send-big-orphans memory exhaustion attack. If a peer has a legitimate\n    // large transaction with a missing parent then we assume\n    // it will rebroadcast it later, after the parent transaction(s)\n    // have been mined or received.\n    // 10,000 orphans, each of which is at most 5,000 bytes big is\n    // at most 500 megabytes of orphans:\n\n    size_t nSize = tx.GetSerializeSize(SER_NETWORK, CTransaction::CURRENT_VERSION);\n\n    if (nSize > 5000)\n    {\n        printf(\"ignoring large orphan tx (size: %\"PRIszu\", hash: %s)\\n\", nSize, hash.ToString().substr(0,10).c_str());\n        return false;\n    }\n\n    mapOrphanTransactions[hash] = tx;\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n        mapOrphanTransactionsByPrev[txin.prevout.hash].insert(hash);\n\n    printf(\"stored orphan tx %s (mapsz %\"PRIszu\")\\n\", hash.ToString().substr(0,10).c_str(),\n        mapOrphanTransactions.size());\n    return true;\n}"
  },
  {
    "function_name": "ResendWalletTransactions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "193-197",
    "snippet": "void ResendWalletTransactions(bool fForce)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions(fForce);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->ResendWalletTransactions",
          "args": [
            "fForce"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "ResendWalletTransactions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "193-197",
          "snippet": "void ResendWalletTransactions(bool fForce)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions(fForce);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nvoid ResendWalletTransactions(bool fForce)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->ResendWalletTransactions(fForce);\n}"
  },
  {
    "function_name": "Inventory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "186-190",
    "snippet": "void static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->Inventory",
          "args": [
            "hash"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "Inventory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "186-190",
          "snippet": "void static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nvoid static Inventory(const uint256& hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->Inventory(hash);\n}"
  },
  {
    "function_name": "PrintWallets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "179-183",
    "snippet": "void static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->PrintWallet",
          "args": [
            "block"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nvoid static PrintWallets(const CBlock& block)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->PrintWallet(block);\n}"
  },
  {
    "function_name": "UpdatedTransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "172-176",
    "snippet": "void static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->UpdatedTransaction",
          "args": [
            "hashTx"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "UpdatedTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "172-176",
          "snippet": "void static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nvoid static UpdatedTransaction(const uint256& hashTx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->UpdatedTransaction(hashTx);\n}"
  },
  {
    "function_name": "SetBestChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "165-169",
    "snippet": "void static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->SetBestChain",
          "args": [
            "loc"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "SetBestChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "165-169",
          "snippet": "void static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nvoid static SetBestChain(const CBlockLocator& loc)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->SetBestChain(loc);\n}"
  },
  {
    "function_name": "SyncWithWallets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "146-162",
    "snippet": "void SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fConnect)\n{\n    if (!fConnect)\n    {\n        // ppcoin: wallets need to refund inputs when disconnecting coinstake\n        if (tx.IsCoinStake())\n        {\n            BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n                if (pwallet->IsFromMe(tx))\n                    pwallet->DisableTransaction(tx);\n        }\n        return;\n    }\n\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->AddToWalletIfInvolvingMe",
          "args": [
            "tx",
            "pblock",
            "fUpdate"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwallet->DisableTransaction",
          "args": [
            "tx"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwallet->IsFromMe",
          "args": [
            "tx"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "IsFromMe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "121-127",
          "snippet": "bool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "set<CWallet*> setpwalletRegistered;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tx.IsCoinStake",
          "args": [],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "IsCoinStake",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "542-546",
          "snippet": "bool IsCoinStake() const\n    {\n        // ppcoin: the coin stake transaction is marked with the first output empty\n        return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  bool IsCoinStake() const\n      {\n          // ppcoin: the coin stake transaction is marked with the first output empty\n          return (vin.size() > 0 && (!vin[0].prevout.IsNull()) && vout.size() >= 2 && vout[0].IsEmpty());\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nvoid SyncWithWallets(const CTransaction& tx, const CBlock* pblock, bool fUpdate, bool fConnect)\n{\n    if (!fConnect)\n    {\n        // ppcoin: wallets need to refund inputs when disconnecting coinstake\n        if (tx.IsCoinStake())\n        {\n            BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n                if (pwallet->IsFromMe(tx))\n                    pwallet->DisableTransaction(tx);\n        }\n        return;\n    }\n\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n}"
  },
  {
    "function_name": "EraseFromWallets",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "139-143",
    "snippet": "void static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->EraseFromWallet",
          "args": [
            "hash"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "EraseFromWallet",
          "container": "CWallet",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/wallet.cpp",
          "lines": "568-578",
          "snippet": "bool CWallet::EraseFromWallet(uint256 hash)\n{\n    if (!fFileBacked)\n        return false;\n    {\n        LOCK(cs_wallet);\n        if (mapWallet.erase(hash))\n            CWalletDB(strWalletFile).EraseTx(hash);\n    }\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"coincontrol.h\"",
            "#include \"kernel.h\"",
            "#include \"base58.h\"",
            "#include \"ui_interface.h\"",
            "#include \"crypter.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\"",
            "#include \"txdb.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/replace.hpp>\n#include \"coincontrol.h\"\n#include \"kernel.h\"\n#include \"base58.h\"\n#include \"ui_interface.h\"\n#include \"crypter.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n#include \"txdb.h\"\n\nCWallet {\n  bool CWallet::EraseFromWallet(uint256 hash)\n  {\n      if (!fFileBacked)\n          return false;\n      {\n          LOCK(cs_wallet);\n          if (mapWallet.erase(hash))\n              CWalletDB(strWalletFile).EraseTx(hash);\n      }\n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nvoid static EraseFromWallets(uint256 hash)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        pwallet->EraseFromWallet(hash);\n}"
  },
  {
    "function_name": "GetTransaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "130-136",
    "snippet": "bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;",
      "CBigNum bnProofOfWorkLimit(~uint256(0) >> 20);",
      "CBigNum bnProofOfStakeLimit(~uint256(0) >> 20);",
      "const CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);",
      "CBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);",
      "CBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->GetTransaction",
          "args": [
            "hashTx",
            "wtx"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "GetTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "130-136",
          "snippet": "bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\nCBigNum bnProofOfWorkLimit(~uint256(0) >> 20);\nCBigNum bnProofOfStakeLimit(~uint256(0) >> 20);\nconst CBigNum bnNeoScryptSwitch(~uint256(0) >> 30);\nCBigNum bnProofOfWorkLimitTestNet(~uint256(0) >> 16);\nCBigNum bnProofOfStakeLimitTestNet(~uint256(0) >> 16);\n\nbool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->GetTransaction(hashTx,wtx))\n            return true;\n    return false;\n}"
  },
  {
    "function_name": "IsFromMe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "121-127",
    "snippet": "bool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "set<CWallet*> setpwalletRegistered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pwallet->IsFromMe",
          "args": [
            "tx"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "IsFromMe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "121-127",
          "snippet": "bool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nset<CWallet*> setpwalletRegistered;\n\nbool static IsFromMe(CTransaction& tx)\n{\n    BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n        if (pwallet->IsFromMe(tx))\n            return true;\n    return false;\n}"
  },
  {
    "function_name": "UnregisterWallet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "112-118",
    "snippet": "void UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CCriticalSection cs_setpwalletRegistered;",
      "set<CWallet*> setpwalletRegistered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setpwalletRegistered.erase",
          "args": [
            "pwalletIn"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_setpwalletRegistered"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nvoid UnregisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.erase(pwalletIn);\n    }\n}"
  },
  {
    "function_name": "RegisterWallet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
    "lines": "104-110",
    "snippet": "void RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}",
    "includes": [
      "#include <boost/filesystem/fstream.hpp>",
      "#include <boost/filesystem.hpp>",
      "#include <boost/algorithm/string/replace.hpp>",
      "#include \"kernel.h\"",
      "#include \"ui_interface.h\"",
      "#include \"init.h\"",
      "#include \"net.h\"",
      "#include \"txdb.h\"",
      "#include \"db.h\"",
      "#include \"checkpoints.h\"",
      "#include \"alert.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "CCriticalSection cs_setpwalletRegistered;",
      "set<CWallet*> setpwalletRegistered;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setpwalletRegistered.insert",
          "args": [
            "pwalletIn"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_setpwalletRegistered"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nCCriticalSection cs_setpwalletRegistered;\nset<CWallet*> setpwalletRegistered;\n\nvoid RegisterWallet(CWallet* pwalletIn)\n{\n    {\n        LOCK(cs_setpwalletRegistered);\n        setpwalletRegistered.insert(pwalletIn);\n    }\n}"
  }
]