[
  {
    "function_name": "SeekToLast",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "299-304",
    "snippet": "void DBIter::SeekToLast() {\n  direction_ = kReverse;\n  ClearSavedValue();\n  iter_->SeekToLast();\n  FindPrevUserEntry();\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindPrevUserEntry",
          "args": [],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "FindPrevUserEntry",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "232-272",
          "snippet": "void DBIter::FindPrevUserEntry() {\n  assert(direction_ == kReverse);\n\n  ValueType value_type = kTypeDeletion;\n  if (iter_->Valid()) {\n    do {\n      ParsedInternalKey ikey;\n      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n        if ((value_type != kTypeDeletion) &&\n            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {\n          // We encountered a non-deleted value in entries for previous keys,\n          break;\n        }\n        value_type = ikey.type;\n        if (value_type == kTypeDeletion) {\n          saved_key_.clear();\n          ClearSavedValue();\n        } else {\n          Slice raw_value = iter_->value();\n          if (saved_value_.capacity() > raw_value.size() + 1048576) {\n            std::string empty;\n            swap(empty, saved_value_);\n          }\n          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n          saved_value_.assign(raw_value.data(), raw_value.size());\n        }\n      }\n      iter_->Prev();\n    } while (iter_->Valid());\n  }\n\n  if (value_type == kTypeDeletion) {\n    // End\n    valid_ = false;\n    saved_key_.clear();\n    ClearSavedValue();\n    direction_ = kForward;\n  } else {\n    valid_ = true;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::FindPrevUserEntry() {\n    assert(direction_ == kReverse);\n  \n    ValueType value_type = kTypeDeletion;\n    if (iter_->Valid()) {\n      do {\n        ParsedInternalKey ikey;\n        if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n          if ((value_type != kTypeDeletion) &&\n              user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {\n            // We encountered a non-deleted value in entries for previous keys,\n            break;\n          }\n          value_type = ikey.type;\n          if (value_type == kTypeDeletion) {\n            saved_key_.clear();\n            ClearSavedValue();\n          } else {\n            Slice raw_value = iter_->value();\n            if (saved_value_.capacity() > raw_value.size() + 1048576) {\n              std::string empty;\n              swap(empty, saved_value_);\n            }\n            SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n            saved_value_.assign(raw_value.data(), raw_value.size());\n          }\n        }\n        iter_->Prev();\n      } while (iter_->Valid());\n    }\n  \n    if (value_type == kTypeDeletion) {\n      // End\n      valid_ = false;\n      saved_key_.clear();\n      ClearSavedValue();\n      direction_ = kForward;\n    } else {\n      valid_ = true;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->SeekToLast",
          "args": [],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToLast",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "299-304",
          "snippet": "void DBIter::SeekToLast() {\n  direction_ = kReverse;\n  ClearSavedValue();\n  iter_->SeekToLast();\n  FindPrevUserEntry();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ClearSavedValue",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ClearSavedValue",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "97-104",
          "snippet": "inline void ClearSavedValue() {\n    if (saved_value_.capacity() > 1048576) {\n      std::string empty;\n      swap(empty, saved_value_);\n    } else {\n      saved_value_.clear();\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void ClearSavedValue() {\n      if (saved_value_.capacity() > 1048576) {\n        std::string empty;\n        swap(empty, saved_value_);\n      } else {\n        saved_value_.clear();\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToLast() {\n    direction_ = kReverse;\n    ClearSavedValue();\n    iter_->SeekToLast();\n    FindPrevUserEntry();\n  }\n}"
  },
  {
    "function_name": "SeekToFirst",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "288-297",
    "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindNextUserEntry",
          "args": [
            "false",
            "&saved_key_/* temporary storage */"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "FindNextUserEntry",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "173-203",
          "snippet": "void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n  // Loop until we hit an acceptable entry to yield\n  assert(iter_->Valid());\n  assert(direction_ == kForward);\n  do {\n    ParsedInternalKey ikey;\n    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n      switch (ikey.type) {\n        case kTypeDeletion:\n          // Arrange to skip all upcoming entries for this key since\n          // they are hidden by this deletion.\n          SaveKey(ikey.user_key, skip);\n          skipping = true;\n          break;\n        case kTypeValue:\n          if (skipping &&\n              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n            // Entry hidden\n          } else {\n            valid_ = true;\n            saved_key_.clear();\n            return;\n          }\n          break;\n      }\n    }\n    iter_->Next();\n  } while (iter_->Valid());\n  saved_key_.clear();\n  valid_ = false;\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n    // Loop until we hit an acceptable entry to yield\n    assert(iter_->Valid());\n    assert(direction_ == kForward);\n    do {\n      ParsedInternalKey ikey;\n      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n        switch (ikey.type) {\n          case kTypeDeletion:\n            // Arrange to skip all upcoming entries for this key since\n            // they are hidden by this deletion.\n            SaveKey(ikey.user_key, skip);\n            skipping = true;\n            break;\n          case kTypeValue:\n            if (skipping &&\n                user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n              // Entry hidden\n            } else {\n              valid_ = true;\n              saved_key_.clear();\n              return;\n            }\n            break;\n        }\n      }\n      iter_->Next();\n    } while (iter_->Valid());\n    saved_key_.clear();\n    valid_ = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Valid",
          "args": [],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->SeekToFirst",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "ClearSavedValue",
          "args": [],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "ClearSavedValue",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "97-104",
          "snippet": "inline void ClearSavedValue() {\n    if (saved_value_.capacity() > 1048576) {\n      std::string empty;\n      swap(empty, saved_value_);\n    } else {\n      saved_value_.clear();\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void ClearSavedValue() {\n      if (saved_value_.capacity() > 1048576) {\n        std::string empty;\n        swap(empty, saved_value_);\n      } else {\n        saved_value_.clear();\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
  },
  {
    "function_name": "Seek",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "274-286",
    "snippet": "void DBIter::Seek(const Slice& target) {\n  direction_ = kForward;\n  ClearSavedValue();\n  saved_key_.clear();\n  AppendInternalKey(\n      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));\n  iter_->Seek(saved_key_);\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindNextUserEntry",
          "args": [
            "false",
            "&saved_key_/* temporary storage */"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "FindNextUserEntry",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "173-203",
          "snippet": "void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n  // Loop until we hit an acceptable entry to yield\n  assert(iter_->Valid());\n  assert(direction_ == kForward);\n  do {\n    ParsedInternalKey ikey;\n    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n      switch (ikey.type) {\n        case kTypeDeletion:\n          // Arrange to skip all upcoming entries for this key since\n          // they are hidden by this deletion.\n          SaveKey(ikey.user_key, skip);\n          skipping = true;\n          break;\n        case kTypeValue:\n          if (skipping &&\n              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n            // Entry hidden\n          } else {\n            valid_ = true;\n            saved_key_.clear();\n            return;\n          }\n          break;\n      }\n    }\n    iter_->Next();\n  } while (iter_->Valid());\n  saved_key_.clear();\n  valid_ = false;\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n    // Loop until we hit an acceptable entry to yield\n    assert(iter_->Valid());\n    assert(direction_ == kForward);\n    do {\n      ParsedInternalKey ikey;\n      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n        switch (ikey.type) {\n          case kTypeDeletion:\n            // Arrange to skip all upcoming entries for this key since\n            // they are hidden by this deletion.\n            SaveKey(ikey.user_key, skip);\n            skipping = true;\n            break;\n          case kTypeValue:\n            if (skipping &&\n                user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n              // Entry hidden\n            } else {\n              valid_ = true;\n              saved_key_.clear();\n              return;\n            }\n            break;\n        }\n      }\n      iter_->Next();\n    } while (iter_->Valid());\n    saved_key_.clear();\n    valid_ = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Valid",
          "args": [],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Seek",
          "args": [
            "saved_key_"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "Seek",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "274-286",
          "snippet": "void DBIter::Seek(const Slice& target) {\n  direction_ = kForward;\n  ClearSavedValue();\n  saved_key_.clear();\n  AppendInternalKey(\n      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));\n  iter_->Seek(saved_key_);\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "AppendInternalKey",
          "args": [
            "&saved_key_",
            "ParsedInternalKey(target, sequence_, kValueTypeForSeek)"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "AppendInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.cc",
          "lines": "18-21",
          "snippet": "void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {\n  result->append(key.user_key.data(), key.user_key.size());\n  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"port/port.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"port/port.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nvoid AppendInternalKey(std::string* result, const ParsedInternalKey& key) {\n  result->append(key.user_key.data(), key.user_key.size());\n  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParsedInternalKey",
          "args": [
            "target",
            "sequence_",
            "kValueTypeForSeek"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "ParsedInternalKey",
          "container": "ParsedInternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "76-77",
          "snippet": "ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)\n      : user_key(u), sequence(seq), type(t) { }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nParsedInternalKey {\n  ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)\n        : user_key(u), sequence(seq), type(t) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "saved_key_.clear",
          "args": [],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearSavedValue",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ClearSavedValue",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "97-104",
          "snippet": "inline void ClearSavedValue() {\n    if (saved_value_.capacity() > 1048576) {\n      std::string empty;\n      swap(empty, saved_value_);\n    } else {\n      saved_value_.clear();\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void ClearSavedValue() {\n      if (saved_value_.capacity() > 1048576) {\n        std::string empty;\n        swap(empty, saved_value_);\n      } else {\n        saved_value_.clear();\n      }\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Seek(const Slice& target) {\n    direction_ = kForward;\n    ClearSavedValue();\n    saved_key_.clear();\n    AppendInternalKey(\n        &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));\n    iter_->Seek(saved_key_);\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
  },
  {
    "function_name": "FindPrevUserEntry",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "232-272",
    "snippet": "void DBIter::FindPrevUserEntry() {\n  assert(direction_ == kReverse);\n\n  ValueType value_type = kTypeDeletion;\n  if (iter_->Valid()) {\n    do {\n      ParsedInternalKey ikey;\n      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n        if ((value_type != kTypeDeletion) &&\n            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {\n          // We encountered a non-deleted value in entries for previous keys,\n          break;\n        }\n        value_type = ikey.type;\n        if (value_type == kTypeDeletion) {\n          saved_key_.clear();\n          ClearSavedValue();\n        } else {\n          Slice raw_value = iter_->value();\n          if (saved_value_.capacity() > raw_value.size() + 1048576) {\n            std::string empty;\n            swap(empty, saved_value_);\n          }\n          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n          saved_value_.assign(raw_value.data(), raw_value.size());\n        }\n      }\n      iter_->Prev();\n    } while (iter_->Valid());\n  }\n\n  if (value_type == kTypeDeletion) {\n    // End\n    valid_ = false;\n    saved_key_.clear();\n    ClearSavedValue();\n    direction_ = kForward;\n  } else {\n    valid_ = true;\n  }\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ClearSavedValue",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ClearSavedValue",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "97-104",
          "snippet": "inline void ClearSavedValue() {\n    if (saved_value_.capacity() > 1048576) {\n      std::string empty;\n      swap(empty, saved_value_);\n    } else {\n      saved_value_.clear();\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void ClearSavedValue() {\n      if (saved_value_.capacity() > 1048576) {\n        std::string empty;\n        swap(empty, saved_value_);\n      } else {\n        saved_value_.clear();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "saved_key_.clear",
          "args": [],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Valid",
          "args": [],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Prev",
          "args": [],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "Prev",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "205-230",
          "snippet": "void DBIter::Prev() {\n  assert(valid_);\n\n  if (direction_ == kForward) {  // Switch directions?\n    // iter_ is pointing at the current entry.  Scan backwards until\n    // the key changes so we can use the normal reverse scanning code.\n    assert(iter_->Valid());  // Otherwise valid_ would have been false\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    while (true) {\n      iter_->Prev();\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        ClearSavedValue();\n        return;\n      }\n      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n                                    saved_key_) < 0) {\n        break;\n      }\n    }\n    direction_ = kReverse;\n  }\n\n  FindPrevUserEntry();\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Prev() {\n    assert(valid_);\n  \n    if (direction_ == kForward) {  // Switch directions?\n      // iter_ is pointing at the current entry.  Scan backwards until\n      // the key changes so we can use the normal reverse scanning code.\n      assert(iter_->Valid());  // Otherwise valid_ would have been false\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n      while (true) {\n        iter_->Prev();\n        if (!iter_->Valid()) {\n          valid_ = false;\n          saved_key_.clear();\n          ClearSavedValue();\n          return;\n        }\n        if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n                                      saved_key_) < 0) {\n          break;\n        }\n      }\n      direction_ = kReverse;\n    }\n  \n    FindPrevUserEntry();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "saved_value_.assign",
          "args": [
            "raw_value.data()",
            "raw_value.size()"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_value.size",
          "args": [],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_value.data",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SaveKey",
          "args": [
            "ExtractUserKey(iter_->key())",
            "&saved_key_"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "SaveKey",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "93-95",
          "snippet": "inline void SaveKey(const Slice& k, std::string* dst) {\n    dst->assign(k.data(), k.size());\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void SaveKey(const Slice& k, std::string* dst) {\n      dst->assign(k.data(), k.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExtractUserKey",
          "args": [
            "iter_->key()"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractUserKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "98-101",
          "snippet": "inline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->key",
          "args": [],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "empty",
            "saved_value_"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saved_value_.capacity",
          "args": [],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter_->value",
          "args": [],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_comparator_->Compare",
          "args": [
            "ikey.user_key",
            "saved_key_"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseKey",
          "args": [
            "&ikey"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "ParseKey",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "130-144",
          "snippet": "inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n  Slice k = iter_->key();\n  ssize_t n = k.size() + iter_->value().size();\n  bytes_counter_ -= n;\n  while (bytes_counter_ < 0) {\n    bytes_counter_ += RandomPeriod();\n    db_->RecordReadSample(k);\n  }\n  if (!ParseInternalKey(k, ikey)) {\n    status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n    return false;\n  } else {\n    return true;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n    Slice k = iter_->key();\n    ssize_t n = k.size() + iter_->value().size();\n    bytes_counter_ -= n;\n    while (bytes_counter_ < 0) {\n      bytes_counter_ += RandomPeriod();\n      db_->RecordReadSample(k);\n    }\n    if (!ParseInternalKey(k, ikey)) {\n      status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n      return false;\n    } else {\n      return true;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "direction_ == kReverse"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::FindPrevUserEntry() {\n    assert(direction_ == kReverse);\n  \n    ValueType value_type = kTypeDeletion;\n    if (iter_->Valid()) {\n      do {\n        ParsedInternalKey ikey;\n        if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n          if ((value_type != kTypeDeletion) &&\n              user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {\n            // We encountered a non-deleted value in entries for previous keys,\n            break;\n          }\n          value_type = ikey.type;\n          if (value_type == kTypeDeletion) {\n            saved_key_.clear();\n            ClearSavedValue();\n          } else {\n            Slice raw_value = iter_->value();\n            if (saved_value_.capacity() > raw_value.size() + 1048576) {\n              std::string empty;\n              swap(empty, saved_value_);\n            }\n            SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n            saved_value_.assign(raw_value.data(), raw_value.size());\n          }\n        }\n        iter_->Prev();\n      } while (iter_->Valid());\n    }\n  \n    if (value_type == kTypeDeletion) {\n      // End\n      valid_ = false;\n      saved_key_.clear();\n      ClearSavedValue();\n      direction_ = kForward;\n    } else {\n      valid_ = true;\n    }\n  }\n}"
  },
  {
    "function_name": "Prev",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "205-230",
    "snippet": "void DBIter::Prev() {\n  assert(valid_);\n\n  if (direction_ == kForward) {  // Switch directions?\n    // iter_ is pointing at the current entry.  Scan backwards until\n    // the key changes so we can use the normal reverse scanning code.\n    assert(iter_->Valid());  // Otherwise valid_ would have been false\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    while (true) {\n      iter_->Prev();\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        ClearSavedValue();\n        return;\n      }\n      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n                                    saved_key_) < 0) {\n        break;\n      }\n    }\n    direction_ = kReverse;\n  }\n\n  FindPrevUserEntry();\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindPrevUserEntry",
          "args": [],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "FindPrevUserEntry",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "232-272",
          "snippet": "void DBIter::FindPrevUserEntry() {\n  assert(direction_ == kReverse);\n\n  ValueType value_type = kTypeDeletion;\n  if (iter_->Valid()) {\n    do {\n      ParsedInternalKey ikey;\n      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n        if ((value_type != kTypeDeletion) &&\n            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {\n          // We encountered a non-deleted value in entries for previous keys,\n          break;\n        }\n        value_type = ikey.type;\n        if (value_type == kTypeDeletion) {\n          saved_key_.clear();\n          ClearSavedValue();\n        } else {\n          Slice raw_value = iter_->value();\n          if (saved_value_.capacity() > raw_value.size() + 1048576) {\n            std::string empty;\n            swap(empty, saved_value_);\n          }\n          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n          saved_value_.assign(raw_value.data(), raw_value.size());\n        }\n      }\n      iter_->Prev();\n    } while (iter_->Valid());\n  }\n\n  if (value_type == kTypeDeletion) {\n    // End\n    valid_ = false;\n    saved_key_.clear();\n    ClearSavedValue();\n    direction_ = kForward;\n  } else {\n    valid_ = true;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::FindPrevUserEntry() {\n    assert(direction_ == kReverse);\n  \n    ValueType value_type = kTypeDeletion;\n    if (iter_->Valid()) {\n      do {\n        ParsedInternalKey ikey;\n        if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n          if ((value_type != kTypeDeletion) &&\n              user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {\n            // We encountered a non-deleted value in entries for previous keys,\n            break;\n          }\n          value_type = ikey.type;\n          if (value_type == kTypeDeletion) {\n            saved_key_.clear();\n            ClearSavedValue();\n          } else {\n            Slice raw_value = iter_->value();\n            if (saved_value_.capacity() > raw_value.size() + 1048576) {\n              std::string empty;\n              swap(empty, saved_value_);\n            }\n            SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n            saved_value_.assign(raw_value.data(), raw_value.size());\n          }\n        }\n        iter_->Prev();\n      } while (iter_->Valid());\n    }\n  \n    if (value_type == kTypeDeletion) {\n      // End\n      valid_ = false;\n      saved_key_.clear();\n      ClearSavedValue();\n      direction_ = kForward;\n    } else {\n      valid_ = true;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_comparator_->Compare",
          "args": [
            "ExtractUserKey(iter_->key())",
            "saved_key_"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExtractUserKey",
          "args": [
            "iter_->key()"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractUserKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "98-101",
          "snippet": "inline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->key",
          "args": [],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearSavedValue",
          "args": [],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "ClearSavedValue",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "97-104",
          "snippet": "inline void ClearSavedValue() {\n    if (saved_value_.capacity() > 1048576) {\n      std::string empty;\n      swap(empty, saved_value_);\n    } else {\n      saved_value_.clear();\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void ClearSavedValue() {\n      if (saved_value_.capacity() > 1048576) {\n        std::string empty;\n        swap(empty, saved_value_);\n      } else {\n        saved_value_.clear();\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "saved_key_.clear",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Valid",
          "args": [],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Prev",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "Prev",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "205-230",
          "snippet": "void DBIter::Prev() {\n  assert(valid_);\n\n  if (direction_ == kForward) {  // Switch directions?\n    // iter_ is pointing at the current entry.  Scan backwards until\n    // the key changes so we can use the normal reverse scanning code.\n    assert(iter_->Valid());  // Otherwise valid_ would have been false\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    while (true) {\n      iter_->Prev();\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        ClearSavedValue();\n        return;\n      }\n      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n                                    saved_key_) < 0) {\n        break;\n      }\n    }\n    direction_ = kReverse;\n  }\n\n  FindPrevUserEntry();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "SaveKey",
          "args": [
            "ExtractUserKey(iter_->key())",
            "&saved_key_"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "SaveKey",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "93-95",
          "snippet": "inline void SaveKey(const Slice& k, std::string* dst) {\n    dst->assign(k.data(), k.size());\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void SaveKey(const Slice& k, std::string* dst) {\n      dst->assign(k.data(), k.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iter_->Valid()"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "valid_"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Prev() {\n    assert(valid_);\n  \n    if (direction_ == kForward) {  // Switch directions?\n      // iter_ is pointing at the current entry.  Scan backwards until\n      // the key changes so we can use the normal reverse scanning code.\n      assert(iter_->Valid());  // Otherwise valid_ would have been false\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n      while (true) {\n        iter_->Prev();\n        if (!iter_->Valid()) {\n          valid_ = false;\n          saved_key_.clear();\n          ClearSavedValue();\n          return;\n        }\n        if (user_comparator_->Compare(ExtractUserKey(iter_->key()),\n                                      saved_key_) < 0) {\n          break;\n        }\n      }\n      direction_ = kReverse;\n    }\n  \n    FindPrevUserEntry();\n  }\n}"
  },
  {
    "function_name": "FindNextUserEntry",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "173-203",
    "snippet": "void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n  // Loop until we hit an acceptable entry to yield\n  assert(iter_->Valid());\n  assert(direction_ == kForward);\n  do {\n    ParsedInternalKey ikey;\n    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n      switch (ikey.type) {\n        case kTypeDeletion:\n          // Arrange to skip all upcoming entries for this key since\n          // they are hidden by this deletion.\n          SaveKey(ikey.user_key, skip);\n          skipping = true;\n          break;\n        case kTypeValue:\n          if (skipping &&\n              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n            // Entry hidden\n          } else {\n            valid_ = true;\n            saved_key_.clear();\n            return;\n          }\n          break;\n      }\n    }\n    iter_->Next();\n  } while (iter_->Valid());\n  saved_key_.clear();\n  valid_ = false;\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "saved_key_.clear",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Valid",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Next",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "user_comparator_->Compare",
          "args": [
            "ikey.user_key",
            "*skip"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "Compare",
          "container": "leveldb_comparator_t",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/c.cc",
          "lines": "73-75",
          "snippet": "virtual int Compare(const Slice& a, const Slice& b) const {\n    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include <unistd.h>",
            "#include <stdlib.h>",
            "#include \"leveldb/c.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include <unistd.h>\n#include <stdlib.h>\n#include \"leveldb/c.h\"\n\nleveldb_comparator_t {\n  virtual int Compare(const Slice& a, const Slice& b) const {\n      return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaveKey",
          "args": [
            "ikey.user_key",
            "skip"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "SaveKey",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "93-95",
          "snippet": "inline void SaveKey(const Slice& k, std::string* dst) {\n    dst->assign(k.data(), k.size());\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void SaveKey(const Slice& k, std::string* dst) {\n      dst->assign(k.data(), k.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseKey",
          "args": [
            "&ikey"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "ParseKey",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "130-144",
          "snippet": "inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n  Slice k = iter_->key();\n  ssize_t n = k.size() + iter_->value().size();\n  bytes_counter_ -= n;\n  while (bytes_counter_ < 0) {\n    bytes_counter_ += RandomPeriod();\n    db_->RecordReadSample(k);\n  }\n  if (!ParseInternalKey(k, ikey)) {\n    status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n    return false;\n  } else {\n    return true;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n    Slice k = iter_->key();\n    ssize_t n = k.size() + iter_->value().size();\n    bytes_counter_ -= n;\n    while (bytes_counter_ < 0) {\n      bytes_counter_ += RandomPeriod();\n      db_->RecordReadSample(k);\n    }\n    if (!ParseInternalKey(k, ikey)) {\n      status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n      return false;\n    } else {\n      return true;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "direction_ == kForward"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iter_->Valid()"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n    // Loop until we hit an acceptable entry to yield\n    assert(iter_->Valid());\n    assert(direction_ == kForward);\n    do {\n      ParsedInternalKey ikey;\n      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n        switch (ikey.type) {\n          case kTypeDeletion:\n            // Arrange to skip all upcoming entries for this key since\n            // they are hidden by this deletion.\n            SaveKey(ikey.user_key, skip);\n            skipping = true;\n            break;\n          case kTypeValue:\n            if (skipping &&\n                user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n              // Entry hidden\n            } else {\n              valid_ = true;\n              saved_key_.clear();\n              return;\n            }\n            break;\n        }\n      }\n      iter_->Next();\n    } while (iter_->Valid());\n    saved_key_.clear();\n    valid_ = false;\n  }\n}"
  },
  {
    "function_name": "Next",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "146-171",
    "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FindNextUserEntry",
          "args": [
            "true",
            "&saved_key_"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "FindNextUserEntry",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "173-203",
          "snippet": "void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n  // Loop until we hit an acceptable entry to yield\n  assert(iter_->Valid());\n  assert(direction_ == kForward);\n  do {\n    ParsedInternalKey ikey;\n    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n      switch (ikey.type) {\n        case kTypeDeletion:\n          // Arrange to skip all upcoming entries for this key since\n          // they are hidden by this deletion.\n          SaveKey(ikey.user_key, skip);\n          skipping = true;\n          break;\n        case kTypeValue:\n          if (skipping &&\n              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n            // Entry hidden\n          } else {\n            valid_ = true;\n            saved_key_.clear();\n            return;\n          }\n          break;\n      }\n    }\n    iter_->Next();\n  } while (iter_->Valid());\n  saved_key_.clear();\n  valid_ = false;\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {\n    // Loop until we hit an acceptable entry to yield\n    assert(iter_->Valid());\n    assert(direction_ == kForward);\n    do {\n      ParsedInternalKey ikey;\n      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {\n        switch (ikey.type) {\n          case kTypeDeletion:\n            // Arrange to skip all upcoming entries for this key since\n            // they are hidden by this deletion.\n            SaveKey(ikey.user_key, skip);\n            skipping = true;\n            break;\n          case kTypeValue:\n            if (skipping &&\n                user_comparator_->Compare(ikey.user_key, *skip) <= 0) {\n              // Entry hidden\n            } else {\n              valid_ = true;\n              saved_key_.clear();\n              return;\n            }\n            break;\n        }\n      }\n      iter_->Next();\n    } while (iter_->Valid());\n    saved_key_.clear();\n    valid_ = false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SaveKey",
          "args": [
            "ExtractUserKey(iter_->key())",
            "&saved_key_"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "SaveKey",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "93-95",
          "snippet": "inline void SaveKey(const Slice& k, std::string* dst) {\n    dst->assign(k.data(), k.size());\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void SaveKey(const Slice& k, std::string* dst) {\n      dst->assign(k.data(), k.size());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ExtractUserKey",
          "args": [
            "iter_->key()"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractUserKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "98-101",
          "snippet": "inline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->key",
          "args": [],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "saved_key_.clear",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Valid",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->Next",
          "args": [],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "iter_->SeekToFirst",
          "args": [],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "valid_"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
  },
  {
    "function_name": "ParseKey",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "130-144",
    "snippet": "inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n  Slice k = iter_->key();\n  ssize_t n = k.size() + iter_->value().size();\n  bytes_counter_ -= n;\n  while (bytes_counter_ < 0) {\n    bytes_counter_ += RandomPeriod();\n    db_->RecordReadSample(k);\n  }\n  if (!ParseInternalKey(k, ikey)) {\n    status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n    return false;\n  } else {\n    return true;\n  }\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Status::Corruption",
          "args": [
            "\"corrupted internal key in DBIter\""
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "Corruption",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "38-40",
          "snippet": "static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n    return Status(kCorruption, msg, msg2);\n  }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {\n      return Status(kCorruption, msg, msg2);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "k",
            "ikey"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->RecordReadSample",
          "args": [
            "k"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "RecordReadSample",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1136-1141",
          "snippet": "void DBImpl::RecordReadSample(Slice key) {\n  MutexLock l(&mutex_);\n  if (versions_->current()->RecordReadSample(key)) {\n    MaybeScheduleCompaction();\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::RecordReadSample(Slice key) {\n    MutexLock l(&mutex_);\n    if (versions_->current()->RecordReadSample(key)) {\n      MaybeScheduleCompaction();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "RandomPeriod",
          "args": [],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "RandomPeriod",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "107-109",
          "snippet": "ssize_t RandomPeriod() {\n    return rnd_.Uniform(2*config::kReadBytesPeriod);\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  ssize_t RandomPeriod() {\n      return rnd_.Uniform(2*config::kReadBytesPeriod);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->value",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "k.size",
          "args": [],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->key",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {\n    Slice k = iter_->key();\n    ssize_t n = k.size() + iter_->value().size();\n    bytes_counter_ -= n;\n    while (bytes_counter_ < 0) {\n      bytes_counter_ += RandomPeriod();\n      db_->RecordReadSample(k);\n    }\n    if (!ParseInternalKey(k, ikey)) {\n      status_ = Status::Corruption(\"corrupted internal key in DBIter\");\n      return false;\n    } else {\n      return true;\n    }\n  }\n}"
  },
  {
    "function_name": "RandomPeriod",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "107-109",
    "snippet": "ssize_t RandomPeriod() {\n    return rnd_.Uniform(2*config::kReadBytesPeriod);\n  }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rnd_.Uniform",
          "args": [
            "2*config::kReadBytesPeriod"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "Uniform",
          "container": "Random",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/random.h",
          "lines": "48-48",
          "snippet": "uint32_t Uniform(int n) { return Next() % n; }",
          "includes": [
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n\nRandom {\n  uint32_t Uniform(int n) { return Next() % n; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  ssize_t RandomPeriod() {\n      return rnd_.Uniform(2*config::kReadBytesPeriod);\n    }\n}"
  },
  {
    "function_name": "ClearSavedValue",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "97-104",
    "snippet": "inline void ClearSavedValue() {\n    if (saved_value_.capacity() > 1048576) {\n      std::string empty;\n      swap(empty, saved_value_);\n    } else {\n      saved_value_.clear();\n    }\n  }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "saved_value_.clear",
          "args": [],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "empty",
            "saved_value_"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saved_value_.capacity",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void ClearSavedValue() {\n      if (saved_value_.capacity() > 1048576) {\n        std::string empty;\n        swap(empty, saved_value_);\n      } else {\n        saved_value_.clear();\n      }\n    }\n}"
  },
  {
    "function_name": "SaveKey",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "93-95",
    "snippet": "inline void SaveKey(const Slice& k, std::string* dst) {\n    dst->assign(k.data(), k.size());\n  }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dst->assign",
          "args": [
            "k.data()",
            "k.size()"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k.size",
          "args": [],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "BlockHandle",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/format.h",
          "lines": "31-31",
          "snippet": "uint64_t size() const { return size_; }",
          "includes": [
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/slice.h\"",
            "#include <stdint.h>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/table_builder.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/slice.h\"\n#include <stdint.h>\n#include <string>\n\nBlockHandle {\n  uint64_t size() const { return size_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "k.data",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  inline void SaveKey(const Slice& k, std::string* dst) {\n      dst->assign(k.data(), k.size());\n    }\n}"
  },
  {
    "function_name": "status",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "74-80",
    "snippet": "virtual Status status() const {\n    if (status_.ok()) {\n      return iter_->status();\n    } else {\n      return status_;\n    }\n  }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_->status",
          "args": [],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "74-80",
          "snippet": "virtual Status status() const {\n    if (status_.ok()) {\n      return iter_->status();\n    } else {\n      return status_;\n    }\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "status_.ok",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "TableBuilder",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/table_builder.h",
          "lines": "78-78",
          "snippet": "bool ok() const { return status().ok(); }",
          "includes": [
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include <stdint.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include <stdint.h>\n\nTableBuilder {\n  bool ok() const { return status().ok(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Status status() const {\n      if (status_.ok()) {\n        return iter_->status();\n      } else {\n        return status_;\n      }\n    }\n}"
  },
  {
    "function_name": "value",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "70-73",
    "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iter_->value",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "valid_"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
  },
  {
    "function_name": "key",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "66-69",
    "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ExtractUserKey",
          "args": [
            "iter_->key()"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractUserKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "98-101",
          "snippet": "inline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline Slice ExtractUserKey(const Slice& internal_key) {\n  assert(internal_key.size() >= 8);\n  return Slice(internal_key.data(), internal_key.size() - 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter_->key",
          "args": [],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "valid_"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
  },
  {
    "function_name": "Valid",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "65-65",
    "snippet": "virtual bool Valid() const { return valid_; }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
  },
  {
    "function_name": "DBIter",
    "container": "DBIter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "51-61",
    "snippet": "DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,\n         uint32_t seed)\n      : db_(db),\n        user_comparator_(cmp),\n        iter_(iter),\n        sequence_(s),\n        direction_(kForward),\n        valid_(false),\n        rnd_(seed),\n        bytes_counter_(RandomPeriod()) {\n  }",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RandomPeriod",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "RandomPeriod",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "107-109",
          "snippet": "ssize_t RandomPeriod() {\n    return rnd_.Uniform(2*config::kReadBytesPeriod);\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  ssize_t RandomPeriod() {\n      return rnd_.Uniform(2*config::kReadBytesPeriod);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,\n           uint32_t seed)\n        : db_(db),\n          user_comparator_(cmp),\n          iter_(iter),\n          sequence_(s),\n          direction_(kForward),\n          valid_(false),\n          rnd_(seed),\n          bytes_counter_(RandomPeriod()) {\n    }\n}"
  },
  {
    "function_name": "DumpInternalIter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
    "lines": "20-29",
    "snippet": "static void DumpInternalIter(Iterator* iter) {\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey k;\n    if (!ParseInternalKey(iter->key(), &k)) {\n      fprintf(stderr, \"Corrupt '%s'\\n\", EscapeString(iter->key()).c_str());\n    } else {\n      fprintf(stderr, \"@ '%s'\\n\", k.DebugString().c_str());\n    }\n  }\n}",
    "includes": [
      "#include \"util/random.h\"",
      "#include \"util/mutexlock.h\"",
      "#include \"util/logging.h\"",
      "#include \"port/port.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/dbformat.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/db_iter.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"@ '%s'\\n\"",
            "k.DebugString().c_str()"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k.DebugString",
          "args": [],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "DebugString",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.cc",
          "lines": "212-264",
          "snippet": "std::string VersionEdit::DebugString() const {\n  std::string r;\n  r.append(\"VersionEdit {\");\n  if (has_comparator_) {\n    r.append(\"\\n  Comparator: \");\n    r.append(comparator_);\n  }\n  if (has_log_number_) {\n    r.append(\"\\n  LogNumber: \");\n    AppendNumberTo(&r, log_number_);\n  }\n  if (has_prev_log_number_) {\n    r.append(\"\\n  PrevLogNumber: \");\n    AppendNumberTo(&r, prev_log_number_);\n  }\n  if (has_next_file_number_) {\n    r.append(\"\\n  NextFile: \");\n    AppendNumberTo(&r, next_file_number_);\n  }\n  if (has_last_sequence_) {\n    r.append(\"\\n  LastSeq: \");\n    AppendNumberTo(&r, last_sequence_);\n  }\n  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n    r.append(\"\\n  CompactPointer: \");\n    AppendNumberTo(&r, compact_pointers_[i].first);\n    r.append(\" \");\n    r.append(compact_pointers_[i].second.DebugString());\n  }\n  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n       iter != deleted_files_.end();\n       ++iter) {\n    r.append(\"\\n  DeleteFile: \");\n    AppendNumberTo(&r, iter->first);\n    r.append(\" \");\n    AppendNumberTo(&r, iter->second);\n  }\n  for (size_t i = 0; i < new_files_.size(); i++) {\n    const FileMetaData& f = new_files_[i].second;\n    r.append(\"\\n  AddFile: \");\n    AppendNumberTo(&r, new_files_[i].first);\n    r.append(\" \");\n    AppendNumberTo(&r, f.number);\n    r.append(\" \");\n    AppendNumberTo(&r, f.file_size);\n    r.append(\" \");\n    r.append(f.smallest.DebugString());\n    r.append(\" .. \");\n    r.append(f.largest.DebugString());\n  }\n  r.append(\"\\n}\\n\");\n  return r;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/version_edit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/version_set.h\"\n#include \"db/version_edit.h\"\n\nVersionEdit {\n  std::string VersionEdit::DebugString() const {\n    std::string r;\n    r.append(\"VersionEdit {\");\n    if (has_comparator_) {\n      r.append(\"\\n  Comparator: \");\n      r.append(comparator_);\n    }\n    if (has_log_number_) {\n      r.append(\"\\n  LogNumber: \");\n      AppendNumberTo(&r, log_number_);\n    }\n    if (has_prev_log_number_) {\n      r.append(\"\\n  PrevLogNumber: \");\n      AppendNumberTo(&r, prev_log_number_);\n    }\n    if (has_next_file_number_) {\n      r.append(\"\\n  NextFile: \");\n      AppendNumberTo(&r, next_file_number_);\n    }\n    if (has_last_sequence_) {\n      r.append(\"\\n  LastSeq: \");\n      AppendNumberTo(&r, last_sequence_);\n    }\n    for (size_t i = 0; i < compact_pointers_.size(); i++) {\n      r.append(\"\\n  CompactPointer: \");\n      AppendNumberTo(&r, compact_pointers_[i].first);\n      r.append(\" \");\n      r.append(compact_pointers_[i].second.DebugString());\n    }\n    for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n         iter != deleted_files_.end();\n         ++iter) {\n      r.append(\"\\n  DeleteFile: \");\n      AppendNumberTo(&r, iter->first);\n      r.append(\" \");\n      AppendNumberTo(&r, iter->second);\n    }\n    for (size_t i = 0; i < new_files_.size(); i++) {\n      const FileMetaData& f = new_files_[i].second;\n      r.append(\"\\n  AddFile: \");\n      AppendNumberTo(&r, new_files_[i].first);\n      r.append(\" \");\n      AppendNumberTo(&r, f.number);\n      r.append(\" \");\n      AppendNumberTo(&r, f.file_size);\n      r.append(\" \");\n      r.append(f.smallest.DebugString());\n      r.append(\" .. \");\n      r.append(f.largest.DebugString());\n    }\n    r.append(\"\\n}\\n\");\n    return r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Corrupt '%s'\\n\"",
            "EscapeString(iter->key()).c_str()"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [
            "iter->key()"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "EscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "42-46",
          "snippet": "std::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "iter->key()",
            "&k"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nstatic void DumpInternalIter(Iterator* iter) {\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey k;\n    if (!ParseInternalKey(iter->key(), &k)) {\n      fprintf(stderr, \"Corrupt '%s'\\n\", EscapeString(iter->key()).c_str());\n    } else {\n      fprintf(stderr, \"@ '%s'\\n\", k.DebugString().c_str());\n    }\n  }\n}"
  }
]