[
  {
    "function_name": "SetPort",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1182-1185",
    "snippet": "void CService::SetPort(unsigned short portIn)\n{\n    port = portIn;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::SetPort(unsigned short portIn)\n  {\n      port = portIn;\n  }\n}"
  },
  {
    "function_name": "print",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1177-1180",
    "snippet": "void CService::print() const\n{\n    printf(\"CService(%s)\\n\", ToString().c_str());\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CService(%s)\\n\"",
            "ToString().c_str()"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ToString",
          "args": [],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::print() const\n  {\n      printf(\"CService(%s)\\n\", ToString().c_str());\n  }\n}"
  },
  {
    "function_name": "ToString",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1172-1175",
    "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ToStringIPPort",
          "args": [],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIPPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1163-1170",
          "snippet": "std::string CService::ToStringIPPort() const\n{\n    if (IsIPv4() || IsTor() || IsI2P()) {\n        return ToStringIP() + \":\" + ToStringPort();\n    } else {\n        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToStringIPPort() const\n  {\n      if (IsIPv4() || IsTor() || IsI2P()) {\n          return ToStringIP() + \":\" + ToStringPort();\n      } else {\n          return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
  },
  {
    "function_name": "ToStringIPPort",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1163-1170",
    "snippet": "std::string CService::ToStringIPPort() const\n{\n    if (IsIPv4() || IsTor() || IsI2P()) {\n        return ToStringIP() + \":\" + ToStringPort();\n    } else {\n        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n    }\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ToStringPort",
          "args": [],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1158-1161",
          "snippet": "std::string CService::ToStringPort() const\n{\n    return strprintf(\"%u\", port);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToStringPort() const\n  {\n      return strprintf(\"%u\", port);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ToStringIP",
          "args": [],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIPPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1163-1170",
          "snippet": "std::string CService::ToStringIPPort() const\n{\n    if (IsIPv4() || IsTor() || IsI2P()) {\n        return ToStringIP() + \":\" + ToStringPort();\n    } else {\n        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n    }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "IsI2P",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "IsI2P",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "700-703",
          "snippet": "bool CNetAddr::IsI2P() const\n{\n    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsI2P() const\n  {\n      return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTor",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "IsTor",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "695-698",
          "snippet": "bool CNetAddr::IsTor() const\n{\n    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsTor() const\n  {\n      return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToStringIPPort() const\n  {\n      if (IsIPv4() || IsTor() || IsI2P()) {\n          return ToStringIP() + \":\" + ToStringPort();\n      } else {\n          return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n      }\n  }\n}"
  },
  {
    "function_name": "ToStringPort",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1158-1161",
    "snippet": "std::string CService::ToStringPort() const\n{\n    return strprintf(\"%u\", port);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"%u\"",
            "port"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToStringPort() const\n  {\n      return strprintf(\"%u\", port);\n  }\n}"
  },
  {
    "function_name": "GetKey",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1148-1156",
    "snippet": "std::vector<unsigned char> CService::GetKey() const\n{\n     std::vector<unsigned char> vKey;\n     vKey.resize(18);\n     memcpy(&vKey[0], ip, 16);\n     vKey[16] = port / 0x100;\n     vKey[17] = port & 0x0FF;\n     return vKey;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vKey[0]",
            "ip",
            "16"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vKey.resize",
          "args": [
            "18"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::vector<unsigned char> CService::GetKey() const\n  {\n       std::vector<unsigned char> vKey;\n       vKey.resize(18);\n       memcpy(&vKey[0], ip, 16);\n       vKey[16] = port / 0x100;\n       vKey[17] = port & 0x0FF;\n       return vKey;\n  }\n}"
  },
  {
    "function_name": "GetSockAddr",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1117-1146",
    "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetIn6Addr",
          "args": [
            "&paddrin6->sin6_addr"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "GetIn6Addr",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "840-844",
          "snippet": "bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n{\n    memcpy(pipv6Addr, ip, 16);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n  {\n      memcpy(pipv6Addr, ip, 16);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "paddrin6",
            "0",
            "*addrlen"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsIPv6",
          "args": [],
          "line": 1132
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv6",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "634-637",
          "snippet": "bool CNetAddr::IsIPv6() const\n{\n    return (!IsIPv4() && !IsTor() && !IsI2P());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsIPv6() const\n  {\n      return (!IsIPv4() && !IsTor() && !IsI2P());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetInAddr",
          "args": [
            "&paddrin->sin_addr"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "GetInAddr",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "831-837",
          "snippet": "bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n{\n    if (!IsIPv4())\n        return false;\n    memcpy(pipv4Addr, ip+12, 4);\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n  {\n      if (!IsIPv4())\n          return false;\n      memcpy(pipv4Addr, ip+12, 4);\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "paddrin",
            "0",
            "*addrlen"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
  },
  {
    "function_name": "GetPort",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1097-1100",
    "snippet": "unsigned short CService::GetPort() const\n{\n    return port;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  unsigned short CService::GetPort() const\n  {\n      return port;\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1089-1095",
    "snippet": "CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n{\n    Init();\n    CService ip;\n    if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n        *this = ip;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "strIpPort.c_str()",
            "ip",
            "portDefault",
            "fAllowLookup"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "159-167",
          "snippet": "bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strIpPort.c_str",
          "args": [],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const std::string &strIpPort, int portDefault, bool fAllowLookup)\n  {\n      Init();\n      CService ip;\n      if (Lookup(strIpPort.c_str(), ip, portDefault, fAllowLookup))\n          *this = ip;\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1081-1087",
    "snippet": "CService::CService(const std::string &strIpPort, bool fAllowLookup)\n{\n    Init();\n    CService ip;\n    if (Lookup(strIpPort.c_str(), ip, 0, fAllowLookup))\n        *this = ip;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "strIpPort.c_str()",
            "ip",
            "0",
            "fAllowLookup"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "159-167",
          "snippet": "bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strIpPort.c_str",
          "args": [],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const std::string &strIpPort, bool fAllowLookup)\n  {\n      Init();\n      CService ip;\n      if (Lookup(strIpPort.c_str(), ip, 0, fAllowLookup))\n          *this = ip;\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1073-1079",
    "snippet": "CService::CService(const char *pszIpPort, int portDefault, bool fAllowLookup)\n{\n    Init();\n    CService ip;\n    if (Lookup(pszIpPort, ip, portDefault, fAllowLookup))\n        *this = ip;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "pszIpPort",
            "ip",
            "portDefault",
            "fAllowLookup"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "159-167",
          "snippet": "bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const char *pszIpPort, int portDefault, bool fAllowLookup)\n  {\n      Init();\n      CService ip;\n      if (Lookup(pszIpPort, ip, portDefault, fAllowLookup))\n          *this = ip;\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1065-1071",
    "snippet": "CService::CService(const char *pszIpPort, bool fAllowLookup)\n{\n    Init();\n    CService ip;\n    if (Lookup(pszIpPort, ip, 0, fAllowLookup))\n        *this = ip;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "pszIpPort",
            "ip",
            "0",
            "fAllowLookup"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "159-167",
          "snippet": "bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const char *pszIpPort, bool fAllowLookup)\n  {\n      Init();\n      CService ip;\n      if (Lookup(pszIpPort, ip, 0, fAllowLookup))\n          *this = ip;\n  }\n}"
  },
  {
    "function_name": "SetSockAddr",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1049-1063",
    "snippet": "bool CService::SetSockAddr(const struct sockaddr *paddr)\n{\n    switch (paddr->sa_family) {\n    case AF_INET:\n        *this = CService(*(const struct sockaddr_in*)paddr);\n        return true;\n#ifdef USE_IPV6\n    case AF_INET6:\n        *this = CService(*(const struct sockaddr_in6*)paddr);\n        return true;\n#endif\n    default:\n        return false;\n    }\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "*(const struct sockaddr_in6*)paddr"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "SetPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1182-1185",
          "snippet": "void CService::SetPort(unsigned short portIn)\n{\n    port = portIn;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::SetPort(unsigned short portIn)\n  {\n      port = portIn;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::SetSockAddr(const struct sockaddr *paddr)\n  {\n      switch (paddr->sa_family) {\n      case AF_INET:\n          *this = CService(*(const struct sockaddr_in*)paddr);\n          return true;\n  #ifdef USE_IPV6\n      case AF_INET6:\n          *this = CService(*(const struct sockaddr_in6*)paddr);\n          return true;\n  #endif\n      default:\n          return false;\n      }\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1043-1046",
    "snippet": "CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr), port(ntohs(addr.sin6_port))\n{\n   assert(addr.sin6_family == AF_INET6);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "addr.sin6_family == AF_INET6"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.sin6_port"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const struct sockaddr_in6 &addr) : CNetAddr(addr.sin6_addr), port(ntohs(addr.sin6_port))\n  {\n     assert(addr.sin6_family == AF_INET6);\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1037-1040",
    "snippet": "CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n{\n    assert(addr.sin_family == AF_INET);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "addr.sin_family == AF_INET"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.sin_port"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\n  {\n      assert(addr.sin_family == AF_INET);\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1032-1034",
    "snippet": "CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n{\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const struct in6_addr& ipv6Addr, unsigned short portIn) : CNetAddr(ipv6Addr), port(portIn)\n  {\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1027-1029",
    "snippet": "CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n{\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const struct in_addr& ipv4Addr, unsigned short portIn) : CNetAddr(ipv4Addr), port(portIn)\n  {\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1023-1025",
    "snippet": "CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n{\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService(const CNetAddr& cip, unsigned short portIn) : CNetAddr(cip), port(portIn)\n  {\n  }\n}"
  },
  {
    "function_name": "CService",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1018-1021",
    "snippet": "CService::CService()\n{\n    Init();\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  CService::CService()\n  {\n      Init();\n  }\n}"
  },
  {
    "function_name": "Init",
    "container": "CService",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "1013-1016",
    "snippet": "void CService::Init()\n{\n    port = 0;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
  },
  {
    "function_name": "GetReachabilityFrom",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "949-1011",
    "snippet": "int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n{\n    enum Reachability {\n        REACH_UNREACHABLE,\n        REACH_DEFAULT,\n        REACH_TEREDO,\n        REACH_IPV6_WEAK,\n        REACH_IPV4,\n        REACH_IPV6_STRONG,\n        REACH_PRIVATE\n    };\n\n    if (!IsRoutable())\n        return REACH_UNREACHABLE;\n\n    int ourNet = GetExtNetwork(this);\n    int theirNet = GetExtNetwork(paddrPartner);\n    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n\n    switch(theirNet) {\n    case NET_IPV4:\n        switch(ourNet) {\n        default:       return REACH_DEFAULT;\n        case NET_IPV4: return REACH_IPV4;\n        }\n    case NET_IPV6:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_TEREDO: return REACH_TEREDO;\n        case NET_IPV4:   return REACH_IPV4;\n        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n        }\n    case NET_TOR:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n        case NET_TOR:    return REACH_PRIVATE;\n        }\n    case NET_I2P:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_I2P:    return REACH_PRIVATE;\n        }\n    case NET_TEREDO:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        }\n    case NET_UNKNOWN:\n    case NET_UNROUTABLE:\n    default:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n        case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n        }\n    }\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsRFC6145",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC6145",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "684-688",
          "snippet": "bool CNetAddr::IsRFC6145() const\n{\n    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC6145() const\n  {\n      static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n      return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC6052",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC6052",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "662-666",
          "snippet": "bool CNetAddr::IsRFC6052() const\n{\n    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC6052() const\n  {\n      static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n      return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC3964",
          "args": [],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC3964",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "657-660",
          "snippet": "bool CNetAddr::IsRFC3964() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC3964() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetExtNetwork",
          "args": [
            "paddrPartner"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "GetExtNetwork",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "939-946",
          "snippet": "int static GetExtNetwork(const CNetAddr *addr)\n{\n    if (addr == NULL)\n        return NET_UNKNOWN;\n    if (addr->IsRFC4380())\n        return NET_TEREDO;\n    return addr->GetNetwork();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nint static GetExtNetwork(const CNetAddr *addr)\n{\n    if (addr == NULL)\n        return NET_UNKNOWN;\n    if (addr->IsRFC4380())\n        return NET_TEREDO;\n    return addr->GetNetwork();\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRoutable",
          "args": [],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n  {\n      enum Reachability {\n          REACH_UNREACHABLE,\n          REACH_DEFAULT,\n          REACH_TEREDO,\n          REACH_IPV6_WEAK,\n          REACH_IPV4,\n          REACH_IPV6_STRONG,\n          REACH_PRIVATE\n      };\n  \n      if (!IsRoutable())\n          return REACH_UNREACHABLE;\n  \n      int ourNet = GetExtNetwork(this);\n      int theirNet = GetExtNetwork(paddrPartner);\n      bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n  \n      switch(theirNet) {\n      case NET_IPV4:\n          switch(ourNet) {\n          default:       return REACH_DEFAULT;\n          case NET_IPV4: return REACH_IPV4;\n          }\n      case NET_IPV6:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_TEREDO: return REACH_TEREDO;\n          case NET_IPV4:   return REACH_IPV4;\n          case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n          }\n      case NET_TOR:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n          case NET_TOR:    return REACH_PRIVATE;\n          }\n      case NET_I2P:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_I2P:    return REACH_PRIVATE;\n          }\n      case NET_TEREDO:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          }\n      case NET_UNKNOWN:\n      case NET_UNROUTABLE:\n      default:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n          case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n          }\n      }\n  }\n}"
  },
  {
    "function_name": "GetExtNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "939-946",
    "snippet": "int static GetExtNetwork(const CNetAddr *addr)\n{\n    if (addr == NULL)\n        return NET_UNKNOWN;\n    if (addr->IsRFC4380())\n        return NET_TEREDO;\n    return addr->GetNetwork();\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr->GetNetwork",
          "args": [],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "GetNetwork",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "766-781",
          "snippet": "enum Network CNetAddr::GetNetwork() const\n{\n    if (!IsRoutable())\n        return NET_UNROUTABLE;\n\n    if (IsIPv4())\n        return NET_IPV4;\n\n    if (IsTor())\n        return NET_TOR;\n\n    if (IsI2P())\n        return NET_I2P;\n\n    return NET_IPV6;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  enum Network CNetAddr::GetNetwork() const\n  {\n      if (!IsRoutable())\n          return NET_UNROUTABLE;\n  \n      if (IsIPv4())\n          return NET_IPV4;\n  \n      if (IsTor())\n          return NET_TOR;\n  \n      if (IsI2P())\n          return NET_I2P;\n  \n      return NET_IPV6;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addr->IsRFC4380",
          "args": [],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC4380",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "668-671",
          "snippet": "bool CNetAddr::IsRFC4380() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4380() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nint static GetExtNetwork(const CNetAddr *addr)\n{\n    if (addr == NULL)\n        return NET_UNKNOWN;\n    if (addr->IsRFC4380())\n        return NET_TEREDO;\n    return addr->GetNetwork();\n}"
  },
  {
    "function_name": "print",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "930-933",
    "snippet": "void CNetAddr::print() const\n{\n    printf(\"CNetAddr(%s)\\n\", ToString().c_str());\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"CNetAddr(%s)\\n\"",
            "ToString().c_str()"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ToString",
          "args": [],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  void CNetAddr::print() const\n  {\n      printf(\"CNetAddr(%s)\\n\", ToString().c_str());\n  }\n}"
  },
  {
    "function_name": "GetHash",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "922-928",
    "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&nRet",
            "&hash",
            "sizeof(nRet)"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "&ip[0]",
            "&ip[16]"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
  },
  {
    "function_name": "GetGroup",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "849-920",
    "snippet": "std::vector<unsigned char> CNetAddr::GetGroup() const\n{\n    std::vector<unsigned char> vchRet;\n    int nClass = NET_IPV6;\n    int nStartByte = 0;\n    int nBits = 16;\n\n    // all local addresses belong to the same group\n    if (IsLocal())\n    {\n        nClass = 255;\n        nBits = 0;\n    }\n\n    // all unroutable addresses belong to the same group\n    if (!IsRoutable())\n    {\n        nClass = NET_UNROUTABLE;\n        nBits = 0;\n    }\n    // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n    // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n    else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 12;\n    }\n    // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n    else if (IsRFC3964())\n    {\n        nClass = NET_IPV4;\n        nStartByte = 2;\n    }\n    // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n    else if (IsRFC4380())\n    {\n        vchRet.push_back(NET_IPV4);\n        vchRet.push_back(GetByte(3) ^ 0xFF);\n        vchRet.push_back(GetByte(2) ^ 0xFF);\n        return vchRet;\n    }\n    else if (IsTor())\n    {\n        nClass = NET_TOR;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    else if (IsI2P())\n    {\n        nClass = NET_I2P;\n        nStartByte = 6;\n        nBits = 4;\n    }\n    // for he.net, use /36 groups\n    else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n        nBits = 36;\n    // for the rest of the IPv6 network, use /32 groups\n    else\n        nBits = 32;\n\n    vchRet.push_back(nClass);\n    while (nBits >= 8)\n    {\n        vchRet.push_back(GetByte(15 - nStartByte));\n        nStartByte++;\n        nBits -= 8;\n    }\n    if (nBits > 0)\n        vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n\n    return vchRet;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vchRet.push_back",
          "args": [
            "GetByte(15 - nStartByte) | ((1 << nBits) - 1)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "15 - nStartByte"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchRet.push_back",
          "args": [
            "GetByte(15 - nStartByte)"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchRet.push_back",
          "args": [
            "nClass"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsI2P",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "IsI2P",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "700-703",
          "snippet": "bool CNetAddr::IsI2P() const\n{\n    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsI2P() const\n  {\n      return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTor",
          "args": [],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "IsTor",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "695-698",
          "snippet": "bool CNetAddr::IsTor() const\n{\n    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsTor() const\n  {\n      return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchRet.push_back",
          "args": [
            "GetByte(2) ^ 0xFF"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchRet.push_back",
          "args": [
            "GetByte(3) ^ 0xFF"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchRet.push_back",
          "args": [
            "NET_IPV4"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsRFC4380",
          "args": [],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC4380",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "668-671",
          "snippet": "bool CNetAddr::IsRFC4380() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4380() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC3964",
          "args": [],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC3964",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "657-660",
          "snippet": "bool CNetAddr::IsRFC3964() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC3964() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC6052",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC6052",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "662-666",
          "snippet": "bool CNetAddr::IsRFC6052() const\n{\n    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC6052() const\n  {\n      static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n      return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC6145",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC6145",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "684-688",
          "snippet": "bool CNetAddr::IsRFC6145() const\n{\n    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC6145() const\n  {\n      static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n      return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRoutable",
          "args": [],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsLocal",
          "args": [],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocal",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "705-717",
          "snippet": "bool CNetAddr::IsLocal() const\n{\n    // IPv4 loopback\n   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n       return true;\n\n   // IPv6 loopback (::1/128)\n   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n   if (memcmp(ip, pchLocal, 16) == 0)\n       return true;\n\n   return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsLocal() const\n  {\n      // IPv4 loopback\n     if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n         return true;\n  \n     // IPv6 loopback (::1/128)\n     static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n     if (memcmp(ip, pchLocal, 16) == 0)\n         return true;\n  \n     return false;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::vector<unsigned char> CNetAddr::GetGroup() const\n  {\n      std::vector<unsigned char> vchRet;\n      int nClass = NET_IPV6;\n      int nStartByte = 0;\n      int nBits = 16;\n  \n      // all local addresses belong to the same group\n      if (IsLocal())\n      {\n          nClass = 255;\n          nBits = 0;\n      }\n  \n      // all unroutable addresses belong to the same group\n      if (!IsRoutable())\n      {\n          nClass = NET_UNROUTABLE;\n          nBits = 0;\n      }\n      // for IPv4 addresses, '1' + the 16 higher-order bits of the IP\n      // includes mapped IPv4, SIIT translated IPv4, and the well-known prefix\n      else if (IsIPv4() || IsRFC6145() || IsRFC6052())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 12;\n      }\n      // for 6to4 tunnelled addresses, use the encapsulated IPv4 address\n      else if (IsRFC3964())\n      {\n          nClass = NET_IPV4;\n          nStartByte = 2;\n      }\n      // for Teredo-tunnelled IPv6 addresses, use the encapsulated IPv4 address\n      else if (IsRFC4380())\n      {\n          vchRet.push_back(NET_IPV4);\n          vchRet.push_back(GetByte(3) ^ 0xFF);\n          vchRet.push_back(GetByte(2) ^ 0xFF);\n          return vchRet;\n      }\n      else if (IsTor())\n      {\n          nClass = NET_TOR;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      else if (IsI2P())\n      {\n          nClass = NET_I2P;\n          nStartByte = 6;\n          nBits = 4;\n      }\n      // for he.net, use /36 groups\n      else if (GetByte(15) == 0x20 && GetByte(14) == 0x11 && GetByte(13) == 0x04 && GetByte(12) == 0x70)\n          nBits = 36;\n      // for the rest of the IPv6 network, use /32 groups\n      else\n          nBits = 32;\n  \n      vchRet.push_back(nClass);\n      while (nBits >= 8)\n      {\n          vchRet.push_back(GetByte(15 - nStartByte));\n          nStartByte++;\n          nBits -= 8;\n      }\n      if (nBits > 0)\n          vchRet.push_back(GetByte(15 - nStartByte) | ((1 << nBits) - 1));\n  \n      return vchRet;\n  }\n}"
  },
  {
    "function_name": "GetIn6Addr",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "840-844",
    "snippet": "bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n{\n    memcpy(pipv6Addr, ip, 16);\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pipv6Addr",
            "ip",
            "16"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::GetIn6Addr(struct in6_addr* pipv6Addr) const\n  {\n      memcpy(pipv6Addr, ip, 16);\n      return true;\n  }\n}"
  },
  {
    "function_name": "GetInAddr",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "831-837",
    "snippet": "bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n{\n    if (!IsIPv4())\n        return false;\n    memcpy(pipv4Addr, ip+12, 4);\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pipv4Addr",
            "ip+12",
            "4"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::GetInAddr(struct in_addr* pipv4Addr) const\n  {\n      if (!IsIPv4())\n          return false;\n      memcpy(pipv4Addr, ip+12, 4);\n      return true;\n  }\n}"
  },
  {
    "function_name": "ToString",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "811-814",
    "snippet": "std::string CNetAddr::ToString() const\n{\n    return ToStringIP();\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ToStringIP",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIPPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1163-1170",
          "snippet": "std::string CService::ToStringIPPort() const\n{\n    if (IsIPv4() || IsTor() || IsI2P()) {\n        return ToStringIP() + \":\" + ToStringPort();\n    } else {\n        return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToStringIPPort() const\n  {\n      if (IsIPv4() || IsTor() || IsI2P()) {\n          return ToStringIP() + \":\" + ToStringPort();\n      } else {\n          return \"[\" + ToStringIP() + \"]:\" + ToStringPort();\n      }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::string CNetAddr::ToString() const\n  {\n      return ToStringIP();\n  }\n}"
  },
  {
    "function_name": "ToStringIP",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "783-809",
    "snippet": "std::string CNetAddr::ToStringIP() const\n{\n    if (IsTor())\n        return EncodeBase32(&ip[6], 10) + \".onion\";\n    if (IsI2P())\n        return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n    CService serv(*this, 0);\n#ifdef USE_IPV6\n    struct sockaddr_storage sockaddr;\n#else\n    struct sockaddr sockaddr;\n#endif\n    socklen_t socklen = sizeof(sockaddr);\n    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n        char name[1025] = \"\";\n        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n            return std::string(name);\n    }\n    if (IsIPv4())\n        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n    else\n        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"%x:%x:%x:%x:%x:%x:%x:%x\"",
            "GetByte(15) << 8 | GetByte(14)",
            "GetByte(13) << 8 | GetByte(12)",
            "GetByte(11) << 8 | GetByte(10)",
            "GetByte(9) << 8 | GetByte(8)",
            "GetByte(7) << 8 | GetByte(6)",
            "GetByte(5) << 8 | GetByte(4)",
            "GetByte(3) << 8 | GetByte(2)",
            "GetByte(1) << 8 | GetByte(0)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "0"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strprintf",
          "args": [
            "\"%u.%u.%u.%u\"",
            "GetByte(3)",
            "GetByte(2)",
            "GetByte(1)",
            "GetByte(0)"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "name"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "(const struct sockaddr*)&sockaddr",
            "socklen",
            "name",
            "sizeof(name)",
            "NULL",
            "0",
            "NI_NUMERICHOST"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "serv.GetSockAddr",
          "args": [
            "(struct sockaddr*)&sockaddr",
            "&socklen"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EncodeBase32",
          "args": [
            "&ip[6]",
            "10"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeBase32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "737-794",
          "snippet": "string EncodeBase32(const unsigned char* pch, size_t len)\n{\n    static const char *pbase32 = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    string strRet=\"\";\n    strRet.reserve((len+4)/5*8);\n\n    int mode=0, left=0;\n    const unsigned char *pchEnd = pch+len;\n\n    while (pch<pchEnd)\n    {\n        int enc = *(pch++);\n        switch (mode)\n        {\n            case 0: // we have no bits\n                strRet += pbase32[enc >> 3];\n                left = (enc & 7) << 2;\n                mode = 1;\n                break;\n\n            case 1: // we have three bits\n                strRet += pbase32[left | (enc >> 6)];\n                strRet += pbase32[(enc >> 1) & 31];\n                left = (enc & 1) << 4;\n                mode = 2;\n                break;\n\n            case 2: // we have one bit\n                strRet += pbase32[left | (enc >> 4)];\n                left = (enc & 15) << 1;\n                mode = 3;\n                break;\n\n            case 3: // we have four bits\n                strRet += pbase32[left | (enc >> 7)];\n                strRet += pbase32[(enc >> 2) & 31];\n                left = (enc & 3) << 3;\n                mode = 4;\n                break;\n\n            case 4: // we have two bits\n                strRet += pbase32[left | (enc >> 5)];\n                strRet += pbase32[enc & 31];\n                mode = 0;\n        }\n    }\n\n    static const int nPadding[5] = {0, 6, 4, 3, 1};\n    if (mode)\n    {\n        strRet += pbase32[left];\n        for (int n=0; n<nPadding[mode]; n++)\n             strRet += '=';\n    }\n\n    return strRet;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring EncodeBase32(const unsigned char* pch, size_t len)\n{\n    static const char *pbase32 = \"abcdefghijklmnopqrstuvwxyz234567\";\n\n    string strRet=\"\";\n    strRet.reserve((len+4)/5*8);\n\n    int mode=0, left=0;\n    const unsigned char *pchEnd = pch+len;\n\n    while (pch<pchEnd)\n    {\n        int enc = *(pch++);\n        switch (mode)\n        {\n            case 0: // we have no bits\n                strRet += pbase32[enc >> 3];\n                left = (enc & 7) << 2;\n                mode = 1;\n                break;\n\n            case 1: // we have three bits\n                strRet += pbase32[left | (enc >> 6)];\n                strRet += pbase32[(enc >> 1) & 31];\n                left = (enc & 1) << 4;\n                mode = 2;\n                break;\n\n            case 2: // we have one bit\n                strRet += pbase32[left | (enc >> 4)];\n                left = (enc & 15) << 1;\n                mode = 3;\n                break;\n\n            case 3: // we have four bits\n                strRet += pbase32[left | (enc >> 7)];\n                strRet += pbase32[(enc >> 2) & 31];\n                left = (enc & 3) << 3;\n                mode = 4;\n                break;\n\n            case 4: // we have two bits\n                strRet += pbase32[left | (enc >> 5)];\n                strRet += pbase32[enc & 31];\n                mode = 0;\n        }\n    }\n\n    static const int nPadding[5] = {0, 6, 4, 3, 1};\n    if (mode)\n    {\n        strRet += pbase32[left];\n        for (int n=0; n<nPadding[mode]; n++)\n             strRet += '=';\n    }\n\n    return strRet;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsI2P",
          "args": [],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "IsI2P",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "700-703",
          "snippet": "bool CNetAddr::IsI2P() const\n{\n    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsI2P() const\n  {\n      return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTor",
          "args": [],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "IsTor",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "695-698",
          "snippet": "bool CNetAddr::IsTor() const\n{\n    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsTor() const\n  {\n      return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::string CNetAddr::ToStringIP() const\n  {\n      if (IsTor())\n          return EncodeBase32(&ip[6], 10) + \".onion\";\n      if (IsI2P())\n          return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n      CService serv(*this, 0);\n  #ifdef USE_IPV6\n      struct sockaddr_storage sockaddr;\n  #else\n      struct sockaddr sockaddr;\n  #endif\n      socklen_t socklen = sizeof(sockaddr);\n      if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n          char name[1025] = \"\";\n          if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n              return std::string(name);\n      }\n      if (IsIPv4())\n          return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n      else\n          return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                           GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                           GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                           GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                           GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n  }\n}"
  },
  {
    "function_name": "GetNetwork",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "766-781",
    "snippet": "enum Network CNetAddr::GetNetwork() const\n{\n    if (!IsRoutable())\n        return NET_UNROUTABLE;\n\n    if (IsIPv4())\n        return NET_IPV4;\n\n    if (IsTor())\n        return NET_TOR;\n\n    if (IsI2P())\n        return NET_I2P;\n\n    return NET_IPV6;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsI2P",
          "args": [],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "IsI2P",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "700-703",
          "snippet": "bool CNetAddr::IsI2P() const\n{\n    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsI2P() const\n  {\n      return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTor",
          "args": [],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "IsTor",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "695-698",
          "snippet": "bool CNetAddr::IsTor() const\n{\n    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsTor() const\n  {\n      return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRoutable",
          "args": [],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "IsRoutable",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "761-764",
          "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  enum Network CNetAddr::GetNetwork() const\n  {\n      if (!IsRoutable())\n          return NET_UNROUTABLE;\n  \n      if (IsIPv4())\n          return NET_IPV4;\n  \n      if (IsTor())\n          return NET_TOR;\n  \n      if (IsI2P())\n          return NET_I2P;\n  \n      return NET_IPV6;\n  }\n}"
  },
  {
    "function_name": "IsRoutable",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "761-764",
    "snippet": "bool CNetAddr::IsRoutable() const\n{\n    return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsLocal",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsLocal",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "705-717",
          "snippet": "bool CNetAddr::IsLocal() const\n{\n    // IPv4 loopback\n   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n       return true;\n\n   // IPv6 loopback (::1/128)\n   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n   if (memcmp(ip, pchLocal, 16) == 0)\n       return true;\n\n   return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsLocal() const\n  {\n      // IPv4 loopback\n     if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n         return true;\n  \n     // IPv6 loopback (::1/128)\n     static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n     if (memcmp(ip, pchLocal, 16) == 0)\n         return true;\n  \n     return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC4843",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC4843",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "690-693",
          "snippet": "bool CNetAddr::IsRFC4843() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4843() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsI2P",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsI2P",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "700-703",
          "snippet": "bool CNetAddr::IsI2P() const\n{\n    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsI2P() const\n  {\n      return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTor",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsTor",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "695-698",
          "snippet": "bool CNetAddr::IsTor() const\n{\n    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsTor() const\n  {\n      return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC4193",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC4193",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "679-682",
          "snippet": "bool CNetAddr::IsRFC4193() const\n{\n    return ((GetByte(15) & 0xFE) == 0xFC);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4193() const\n  {\n      return ((GetByte(15) & 0xFE) == 0xFC);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC4862",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC4862",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "673-677",
          "snippet": "bool CNetAddr::IsRFC4862() const\n{\n    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4862() const\n  {\n      static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n      return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC3927",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC3927",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "647-650",
          "snippet": "bool CNetAddr::IsRFC3927() const\n{\n    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC3927() const\n  {\n      return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC1918",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC1918",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "639-645",
          "snippet": "bool CNetAddr::IsRFC1918() const\n{\n    return IsIPv4() && (\n        GetByte(3) == 10 ||\n        (GetByte(3) == 192 && GetByte(2) == 168) ||\n        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC1918() const\n  {\n      return IsIPv4() && (\n          GetByte(3) == 10 ||\n          (GetByte(3) == 192 && GetByte(2) == 168) ||\n          (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsValid",
          "args": [],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRoutable() const\n  {\n      return IsValid() && !(IsRFC1918() || IsRFC3927() || IsRFC4862() || (IsRFC4193() && !IsTor() && !IsI2P()) || IsRFC4843() || IsLocal());\n  }\n}"
  },
  {
    "function_name": "IsValid",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "725-759",
    "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip+12",
            "&ipNone",
            "4"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip+12",
            "&ipNone",
            "4"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsRFC3849",
          "args": [],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "IsRFC3849",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "652-655",
          "snippet": "bool CNetAddr::IsRFC3849() const\n{\n    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC3849() const\n  {\n      return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "ipNone",
            "16"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchIPv4+3",
            "sizeof(pchIPv4)-3"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
  },
  {
    "function_name": "IsMulticast",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "719-723",
    "snippet": "bool CNetAddr::IsMulticast() const\n{\n    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n           || (GetByte(15) == 0xFF);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "15"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsMulticast() const\n  {\n      return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n             || (GetByte(15) == 0xFF);\n  }\n}"
  },
  {
    "function_name": "IsLocal",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "705-717",
    "snippet": "bool CNetAddr::IsLocal() const\n{\n    // IPv4 loopback\n   if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n       return true;\n\n   // IPv6 loopback (::1/128)\n   static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n   if (memcmp(ip, pchLocal, 16) == 0)\n       return true;\n\n   return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchLocal",
            "16"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "3"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsLocal() const\n  {\n      // IPv4 loopback\n     if (IsIPv4() && (GetByte(3) == 127 || GetByte(3) == 0))\n         return true;\n  \n     // IPv6 loopback (::1/128)\n     static const unsigned char pchLocal[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};\n     if (memcmp(ip, pchLocal, 16) == 0)\n         return true;\n  \n     return false;\n  }\n}"
  },
  {
    "function_name": "IsI2P",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "700-703",
    "snippet": "bool CNetAddr::IsI2P() const\n{\n    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchGarliCat",
            "sizeof(pchGarliCat)"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsI2P() const\n  {\n      return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n  }\n}"
  },
  {
    "function_name": "IsTor",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "695-698",
    "snippet": "bool CNetAddr::IsTor() const\n{\n    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchOnionCat",
            "sizeof(pchOnionCat)"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsTor() const\n  {\n      return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n  }\n}"
  },
  {
    "function_name": "IsRFC4843",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "690-693",
    "snippet": "bool CNetAddr::IsRFC4843() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "12"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4843() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x00 && (GetByte(12) & 0xF0) == 0x10);\n  }\n}"
  },
  {
    "function_name": "IsRFC6145",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "684-688",
    "snippet": "bool CNetAddr::IsRFC6145() const\n{\n    static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n    return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchRFC6145",
            "sizeof(pchRFC6145)"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC6145() const\n  {\n      static const unsigned char pchRFC6145[] = {0,0,0,0,0,0,0,0,0xFF,0xFF,0,0};\n      return (memcmp(ip, pchRFC6145, sizeof(pchRFC6145)) == 0);\n  }\n}"
  },
  {
    "function_name": "IsRFC4193",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "679-682",
    "snippet": "bool CNetAddr::IsRFC4193() const\n{\n    return ((GetByte(15) & 0xFE) == 0xFC);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "15"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4193() const\n  {\n      return ((GetByte(15) & 0xFE) == 0xFC);\n  }\n}"
  },
  {
    "function_name": "IsRFC4862",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "673-677",
    "snippet": "bool CNetAddr::IsRFC4862() const\n{\n    static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n    return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchRFC4862",
            "sizeof(pchRFC4862)"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4862() const\n  {\n      static const unsigned char pchRFC4862[] = {0xFE,0x80,0,0,0,0,0,0};\n      return (memcmp(ip, pchRFC4862, sizeof(pchRFC4862)) == 0);\n  }\n}"
  },
  {
    "function_name": "IsRFC4380",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "668-671",
    "snippet": "bool CNetAddr::IsRFC4380() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "12"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC4380() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0 && GetByte(12) == 0);\n  }\n}"
  },
  {
    "function_name": "IsRFC6052",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "662-666",
    "snippet": "bool CNetAddr::IsRFC6052() const\n{\n    static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n    return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchRFC6052",
            "sizeof(pchRFC6052)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC6052() const\n  {\n      static const unsigned char pchRFC6052[] = {0,0x64,0xFF,0x9B,0,0,0,0,0,0,0,0};\n      return (memcmp(ip, pchRFC6052, sizeof(pchRFC6052)) == 0);\n  }\n}"
  },
  {
    "function_name": "IsRFC3964",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "657-660",
    "snippet": "bool CNetAddr::IsRFC3964() const\n{\n    return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "14"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC3964() const\n  {\n      return (GetByte(15) == 0x20 && GetByte(14) == 0x02);\n  }\n}"
  },
  {
    "function_name": "IsRFC3849",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "652-655",
    "snippet": "bool CNetAddr::IsRFC3849() const\n{\n    return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "12"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC3849() const\n  {\n      return GetByte(15) == 0x20 && GetByte(14) == 0x01 && GetByte(13) == 0x0D && GetByte(12) == 0xB8;\n  }\n}"
  },
  {
    "function_name": "IsRFC3927",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "647-650",
    "snippet": "bool CNetAddr::IsRFC3927() const\n{\n    return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "2"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC3927() const\n  {\n      return IsIPv4() && (GetByte(3) == 169 && GetByte(2) == 254);\n  }\n}"
  },
  {
    "function_name": "IsRFC1918",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "639-645",
    "snippet": "bool CNetAddr::IsRFC1918() const\n{\n    return IsIPv4() && (\n        GetByte(3) == 10 ||\n        (GetByte(3) == 192 && GetByte(2) == 168) ||\n        (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "GetByte",
          "args": [
            "2"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "GetByte",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "624-627",
          "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsRFC1918() const\n  {\n      return IsIPv4() && (\n          GetByte(3) == 10 ||\n          (GetByte(3) == 192 && GetByte(2) == 168) ||\n          (GetByte(3) == 172 && (GetByte(2) >= 16 && GetByte(2) <= 31)));\n  }\n}"
  },
  {
    "function_name": "IsIPv6",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "634-637",
    "snippet": "bool CNetAddr::IsIPv6() const\n{\n    return (!IsIPv4() && !IsTor() && !IsI2P());\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IsI2P",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "IsI2P",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "700-703",
          "snippet": "bool CNetAddr::IsI2P() const\n{\n    return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsI2P() const\n  {\n      return (memcmp(ip, pchGarliCat, sizeof(pchGarliCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsTor",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "IsTor",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "695-698",
          "snippet": "bool CNetAddr::IsTor() const\n{\n    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsTor() const\n  {\n      return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsIPv4",
          "args": [],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::IsIPv6() const\n  {\n      return (!IsIPv4() && !IsTor() && !IsI2P());\n  }\n}"
  },
  {
    "function_name": "IsIPv4",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "629-632",
    "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "ip",
            "pchIPv4",
            "sizeof(pchIPv4)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
  },
  {
    "function_name": "GetByte",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "624-627",
    "snippet": "unsigned int CNetAddr::GetByte(int n) const\n{\n    return ip[15-n];\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  unsigned int CNetAddr::GetByte(int n) const\n  {\n      return ip[15-n];\n  }\n}"
  },
  {
    "function_name": "CNetAddr",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "616-622",
    "snippet": "CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n{\n    Init();\n    std::vector<CNetAddr> vIP;\n    if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n        *this = vIP[0];\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LookupHost",
          "args": [
            "strIp.c_str()",
            "vIP",
            "1",
            "fAllowLookup"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "LookupHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "120-134",
          "snippet": "bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strIp.c_str",
          "args": [],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n  {\n      Init();\n      std::vector<CNetAddr> vIP;\n      if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n          *this = vIP[0];\n  }\n}"
  },
  {
    "function_name": "CNetAddr",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "608-614",
    "snippet": "CNetAddr::CNetAddr(const char *pszIp, bool fAllowLookup)\n{\n    Init();\n    std::vector<CNetAddr> vIP;\n    if (LookupHost(pszIp, vIP, 1, fAllowLookup))\n        *this = vIP[0];\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LookupHost",
          "args": [
            "pszIp",
            "vIP",
            "1",
            "fAllowLookup"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "LookupHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "120-134",
          "snippet": "bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  CNetAddr::CNetAddr(const char *pszIp, bool fAllowLookup)\n  {\n      Init();\n      std::vector<CNetAddr> vIP;\n      if (LookupHost(pszIp, vIP, 1, fAllowLookup))\n          *this = vIP[0];\n  }\n}"
  },
  {
    "function_name": "CNetAddr",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "602-605",
    "snippet": "CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr)\n{\n    memcpy(ip, &ipv6Addr, 16);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip",
            "&ipv6Addr",
            "16"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  CNetAddr::CNetAddr(const struct in6_addr& ipv6Addr)\n  {\n      memcpy(ip, &ipv6Addr, 16);\n  }\n}"
  },
  {
    "function_name": "CNetAddr",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "595-599",
    "snippet": "CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n{\n    memcpy(ip,    pchIPv4, 12);\n    memcpy(ip+12, &ipv4Addr, 4);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip+12",
            "&ipv4Addr",
            "4"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip",
            "pchIPv4",
            "12"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\n  {\n      memcpy(ip,    pchIPv4, 12);\n      memcpy(ip+12, &ipv4Addr, 4);\n  }\n}"
  },
  {
    "function_name": "CNetAddr",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "590-593",
    "snippet": "CNetAddr::CNetAddr()\n{\n    Init();\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Init",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "Init",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1013-1016",
          "snippet": "void CService::Init()\n{\n    port = 0;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::Init()\n  {\n      port = 0;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  CNetAddr::CNetAddr()\n  {\n      Init();\n  }\n}"
  },
  {
    "function_name": "SetSpecial",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "567-588",
    "snippet": "bool CNetAddr::SetSpecial(const std::string &strName)\n{\n    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n            return false;\n        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n        return true;\n    }\n    if (strName.size()>11 && strName.substr(strName.size() - 11, 11) == \".oc.b32.i2p\") {\n        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 11).c_str());\n        if (vchAddr.size() != 16-sizeof(pchGarliCat))\n            return false;\n        memcpy(ip, pchOnionCat, sizeof(pchGarliCat));\n        for (unsigned int i=0; i<16-sizeof(pchGarliCat); i++)\n            ip[i + sizeof(pchGarliCat)] = vchAddr[i];\n        return true;\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip",
            "pchOnionCat",
            "sizeof(pchGarliCat)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchAddr.size",
          "args": [],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DecodeBase32",
          "args": [
            "strName.substr(0, strName.size() - 11).c_str()"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeBase32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "918-922",
          "snippet": "string DecodeBase32(const string& str)\n{\n    vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n    return string((const char*)&vchRet[0], vchRet.size());\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring DecodeBase32(const string& str)\n{\n    vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n    return string((const char*)&vchRet[0], vchRet.size());\n}"
        }
      },
      {
        "call_info": {
          "callee": "strName.substr",
          "args": [],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strName.substr",
          "args": [
            "0",
            "strName.size() - 11"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strName.substr",
          "args": [
            "strName.size() - 11",
            "11"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip",
            "pchOnionCat",
            "sizeof(pchOnionCat)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strName.substr",
          "args": [],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strName.substr",
          "args": [
            "0",
            "strName.size() - 6"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strName.substr",
          "args": [
            "strName.size() - 6",
            "6"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::SetSpecial(const std::string &strName)\n  {\n      if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n          std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n          if (vchAddr.size() != 16-sizeof(pchOnionCat))\n              return false;\n          memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n          for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n              ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n          return true;\n      }\n      if (strName.size()>11 && strName.substr(strName.size() - 11, 11) == \".oc.b32.i2p\") {\n          std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 11).c_str());\n          if (vchAddr.size() != 16-sizeof(pchGarliCat))\n              return false;\n          memcpy(ip, pchOnionCat, sizeof(pchGarliCat));\n          for (unsigned int i=0; i<16-sizeof(pchGarliCat); i++)\n              ip[i + sizeof(pchGarliCat)] = vchAddr[i];\n          return true;\n      }\n      return false;\n  }\n}"
  },
  {
    "function_name": "SetIP",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "559-562",
    "snippet": "void CNetAddr::SetIP(const CNetAddr& ipIn)\n{\n    memcpy(ip, ipIn.ip, sizeof(ip));\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ip",
            "ipIn.ip",
            "sizeof(ip)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  void CNetAddr::SetIP(const CNetAddr& ipIn)\n  {\n      memcpy(ip, ipIn.ip, sizeof(ip));\n  }\n}"
  },
  {
    "function_name": "Init",
    "container": "CNetAddr",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "554-557",
    "snippet": "void CNetAddr::Init()\n{\n    memset(ip, 0, 16);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ip",
            "0",
            "16"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  void CNetAddr::Init()\n  {\n      memset(ip, 0, 16);\n  }\n}"
  },
  {
    "function_name": "ConnectSocketByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "517-552",
    "snippet": "bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout)\n{\n    string strDest;\n    int port = portDefault;\n    SplitHostPort(string(pszDest), port, strDest);\n\n    SOCKET hSocket = INVALID_SOCKET;\n\n    proxyType nameproxy;\n    GetNameProxy(nameproxy);\n\n    CService addrResolved(CNetAddr(strDest, fNameLookup && !nameproxy.second), port);\n    if (addrResolved.IsValid()) {\n        addr = addrResolved;\n        return ConnectSocket(addr, hSocketRet, nTimeout);\n    }\n    addr = CService(\"0.0.0.0:0\");\n    if (!nameproxy.second)\n        return false;\n    if (!ConnectSocketDirectly(nameproxy.first, hSocket, nTimeout))\n        return false;\n\n    switch(nameproxy.second) {\n        default:\n        case 4:\n            closesocket(hSocket);\n            return false;\n        case 5:\n            if (!Socks5(strDest, port, hSocket))\n                return false;\n            break;\n    }\n\n    hSocketRet = hSocket;\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool fNameLookup = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Socks5",
          "args": [
            "strDest",
            "port",
            "hSocket"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "Socks5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "218-321",
          "snippet": "bool static Socks5(string strDest, int port, SOCKET& hSocket)\n{\n    printf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n    if (strDest.size() > 255)\n    {\n        closesocket(hSocket);\n        return error(\"Hostname too long\");\n    }\n    char pszSocks5Init[] = \"\\5\\1\\0\";\n    char *pszSocks5 = pszSocks5Init;\n    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n\n    ssize_t ret = send(hSocket, pszSocks5, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet1[2];\n    if (recv(hSocket, pchRet1, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to initialize\");\n    }\n    string strSocks5(\"\\5\\1\");\n    strSocks5 += '\\000'; strSocks5 += '\\003';\n    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n    strSocks5 += strDest;\n    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n    ret = send(hSocket, strSocks5.c_str(), strSocks5.size(), MSG_NOSIGNAL);\n    if (ret != (ssize_t)strSocks5.size())\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet2[4];\n    if (recv(hSocket, pchRet2, 4, 0) != 4)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet2[0] != 0x05)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to accept request\");\n    }\n    if (pchRet2[1] != 0x00)\n    {\n        closesocket(hSocket);\n        switch (pchRet2[1])\n        {\n            case 0x01: return error(\"Proxy error: general failure\");\n            case 0x02: return error(\"Proxy error: connection not allowed\");\n            case 0x03: return error(\"Proxy error: network unreachable\");\n            case 0x04: return error(\"Proxy error: host unreachable\");\n            case 0x05: return error(\"Proxy error: connection refused\");\n            case 0x06: return error(\"Proxy error: TTL expired\");\n            case 0x07: return error(\"Proxy error: protocol error\");\n            case 0x08: return error(\"Proxy error: address type not supported\");\n            default:   return error(\"Proxy error: unknown\");\n        }\n    }\n    if (pchRet2[2] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Error: malformed proxy response\");\n    }\n    char pchRet3[256];\n    switch (pchRet2[3])\n    {\n        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n        case 0x03:\n        {\n            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n            if (ret) {\n                closesocket(hSocket);\n                return error(\"Error reading from proxy\");\n            }\n            int nRecv = pchRet3[0];\n            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n            break;\n        }\n        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n    }\n    if (ret)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    if (recv(hSocket, pchRet3, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    printf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static Socks5(string strDest, int port, SOCKET& hSocket)\n{\n    printf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n    if (strDest.size() > 255)\n    {\n        closesocket(hSocket);\n        return error(\"Hostname too long\");\n    }\n    char pszSocks5Init[] = \"\\5\\1\\0\";\n    char *pszSocks5 = pszSocks5Init;\n    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n\n    ssize_t ret = send(hSocket, pszSocks5, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet1[2];\n    if (recv(hSocket, pchRet1, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to initialize\");\n    }\n    string strSocks5(\"\\5\\1\");\n    strSocks5 += '\\000'; strSocks5 += '\\003';\n    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n    strSocks5 += strDest;\n    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n    ret = send(hSocket, strSocks5.c_str(), strSocks5.size(), MSG_NOSIGNAL);\n    if (ret != (ssize_t)strSocks5.size())\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet2[4];\n    if (recv(hSocket, pchRet2, 4, 0) != 4)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet2[0] != 0x05)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to accept request\");\n    }\n    if (pchRet2[1] != 0x00)\n    {\n        closesocket(hSocket);\n        switch (pchRet2[1])\n        {\n            case 0x01: return error(\"Proxy error: general failure\");\n            case 0x02: return error(\"Proxy error: connection not allowed\");\n            case 0x03: return error(\"Proxy error: network unreachable\");\n            case 0x04: return error(\"Proxy error: host unreachable\");\n            case 0x05: return error(\"Proxy error: connection refused\");\n            case 0x06: return error(\"Proxy error: TTL expired\");\n            case 0x07: return error(\"Proxy error: protocol error\");\n            case 0x08: return error(\"Proxy error: address type not supported\");\n            default:   return error(\"Proxy error: unknown\");\n        }\n    }\n    if (pchRet2[2] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Error: malformed proxy response\");\n    }\n    char pchRet3[256];\n    switch (pchRet2[3])\n    {\n        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n        case 0x03:\n        {\n            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n            if (ret) {\n                closesocket(hSocket);\n                return error(\"Error reading from proxy\");\n            }\n            int nRecv = pchRet3[0];\n            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n            break;\n        }\n        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n    }\n    if (ret)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    if (recv(hSocket, pchRet3, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    printf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConnectSocketDirectly",
          "args": [
            "nameproxy.first",
            "hSocket",
            "nTimeout"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "\"0.0.0.0:0\""
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "SetPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1182-1185",
          "snippet": "void CService::SetPort(unsigned short portIn)\n{\n    port = portIn;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  void CService::SetPort(unsigned short portIn)\n  {\n      port = portIn;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConnectSocket",
          "args": [
            "addr",
            "hSocketRet",
            "nTimeout"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "ConnectSocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "484-515",
          "snippet": "bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n{\n    proxyType proxy;\n\n    // no proxy needed\n    if (!GetProxy(addrDest.GetNetwork(), proxy))\n        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n\n    SOCKET hSocket = INVALID_SOCKET;\n\n    // first connect to proxy server\n    if (!ConnectSocketDirectly(proxy.first, hSocket, nTimeout))\n        return false;\n\n    // do socks negotiation\n    switch (proxy.second) {\n    case 4:\n        if (!Socks4(addrDest, hSocket))\n            return false;\n        break;\n    case 5:\n        if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n            return false;\n        break;\n    default:\n        closesocket(hSocket);\n        return false;\n    }\n\n    hSocketRet = hSocket;\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n{\n    proxyType proxy;\n\n    // no proxy needed\n    if (!GetProxy(addrDest.GetNetwork(), proxy))\n        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n\n    SOCKET hSocket = INVALID_SOCKET;\n\n    // first connect to proxy server\n    if (!ConnectSocketDirectly(proxy.first, hSocket, nTimeout))\n        return false;\n\n    // do socks negotiation\n    switch (proxy.second) {\n    case 4:\n        if (!Socks4(addrDest, hSocket))\n            return false;\n        break;\n    case 5:\n        if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n            return false;\n        break;\n    default:\n        closesocket(hSocket);\n        return false;\n    }\n\n    hSocketRet = hSocket;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrResolved.IsValid",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CNetAddr",
          "args": [
            "strDest",
            "fNameLookup && !nameproxy.second"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "CNetAddr",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "616-622",
          "snippet": "CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n{\n    Init();\n    std::vector<CNetAddr> vIP;\n    if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n        *this = vIP[0];\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  CNetAddr::CNetAddr(const std::string &strIp, bool fAllowLookup)\n  {\n      Init();\n      std::vector<CNetAddr> vIP;\n      if (LookupHost(strIp.c_str(), vIP, 1, fAllowLookup))\n          *this = vIP[0];\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetNameProxy",
          "args": [
            "nameproxy"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "GetNameProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "462-468",
          "snippet": "bool GetNameProxy(proxyType &nameproxyInfoOut) {\n    LOCK(cs_proxyInfos);\n    if (!nameproxyInfo.second)\n        return false;\n    nameproxyInfoOut = nameproxyInfo;\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static proxyType nameproxyInfo;",
            "static CCriticalSection cs_proxyInfos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType nameproxyInfo;\nstatic CCriticalSection cs_proxyInfos;\n\nbool GetNameProxy(proxyType &nameproxyInfoOut) {\n    LOCK(cs_proxyInfos);\n    if (!nameproxyInfo.second)\n        return false;\n    nameproxyInfoOut = nameproxyInfo;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SplitHostPort",
          "args": [
            "string(pszDest)",
            "port",
            "strDest"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "SplitHostPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "37-56",
          "snippet": "void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n    size_t colon = in.find_last_of(':');\n    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n    bool fHaveColon = colon != in.npos;\n    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n        char *endp = NULL;\n        int n = strtol(in.c_str() + colon + 1, &endp, 10);\n        if (endp && *endp == 0 && n >= 0) {\n            in = in.substr(0, colon);\n            if (n > 0 && n < 0x10000)\n                portOut = n;\n        }\n    }\n    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n        hostOut = in.substr(1, in.size()-2);\n    else\n        hostOut = in;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nvoid SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n    size_t colon = in.find_last_of(':');\n    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n    bool fHaveColon = colon != in.npos;\n    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n        char *endp = NULL;\n        int n = strtol(in.c_str() + colon + 1, &endp, 10);\n        if (endp && *endp == 0 && n >= 0) {\n            in = in.substr(0, colon);\n            if (n > 0 && n < 0x10000)\n                portOut = n;\n        }\n    }\n    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n        hostOut = in.substr(1, in.size()-2);\n    else\n        hostOut = in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "string",
          "args": [
            "pszDest"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "non_printable_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/json/json_spirit_writer_template.h",
          "lines": "29-41",
          "snippet": "String_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }",
          "includes": [
            "#include <iomanip>",
            "#include <sstream>",
            "#include <cassert>",
            "#include \"json_spirit_value.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include \"json_spirit_value.h\"\n\nString_type non_printable_to_string( unsigned int c )\n    {\n        String_type result( 6, '\\\\' );\n\n        result[1] = 'u';\n\n        result[ 5 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 4 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 3 ] = to_hex_char( c & 0x000F ); c >>= 4;\n        result[ 2 ] = to_hex_char( c & 0x000F );\n\n        return result;\n    }"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool fNameLookup = false;\n\nbool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault, int nTimeout)\n{\n    string strDest;\n    int port = portDefault;\n    SplitHostPort(string(pszDest), port, strDest);\n\n    SOCKET hSocket = INVALID_SOCKET;\n\n    proxyType nameproxy;\n    GetNameProxy(nameproxy);\n\n    CService addrResolved(CNetAddr(strDest, fNameLookup && !nameproxy.second), port);\n    if (addrResolved.IsValid()) {\n        addr = addrResolved;\n        return ConnectSocket(addr, hSocketRet, nTimeout);\n    }\n    addr = CService(\"0.0.0.0:0\");\n    if (!nameproxy.second)\n        return false;\n    if (!ConnectSocketDirectly(nameproxy.first, hSocket, nTimeout))\n        return false;\n\n    switch(nameproxy.second) {\n        default:\n        case 4:\n            closesocket(hSocket);\n            return false;\n        case 5:\n            if (!Socks5(strDest, port, hSocket))\n                return false;\n            break;\n    }\n\n    hSocketRet = hSocket;\n    return true;\n}"
  },
  {
    "function_name": "ConnectSocket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "484-515",
    "snippet": "bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n{\n    proxyType proxy;\n\n    // no proxy needed\n    if (!GetProxy(addrDest.GetNetwork(), proxy))\n        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n\n    SOCKET hSocket = INVALID_SOCKET;\n\n    // first connect to proxy server\n    if (!ConnectSocketDirectly(proxy.first, hSocket, nTimeout))\n        return false;\n\n    // do socks negotiation\n    switch (proxy.second) {\n    case 4:\n        if (!Socks4(addrDest, hSocket))\n            return false;\n        break;\n    case 5:\n        if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n            return false;\n        break;\n    default:\n        closesocket(hSocket);\n        return false;\n    }\n\n    hSocketRet = hSocket;\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Socks5",
          "args": [
            "addrDest.ToStringIP()",
            "addrDest.GetPort()",
            "hSocket"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "Socks5",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "218-321",
          "snippet": "bool static Socks5(string strDest, int port, SOCKET& hSocket)\n{\n    printf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n    if (strDest.size() > 255)\n    {\n        closesocket(hSocket);\n        return error(\"Hostname too long\");\n    }\n    char pszSocks5Init[] = \"\\5\\1\\0\";\n    char *pszSocks5 = pszSocks5Init;\n    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n\n    ssize_t ret = send(hSocket, pszSocks5, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet1[2];\n    if (recv(hSocket, pchRet1, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to initialize\");\n    }\n    string strSocks5(\"\\5\\1\");\n    strSocks5 += '\\000'; strSocks5 += '\\003';\n    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n    strSocks5 += strDest;\n    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n    ret = send(hSocket, strSocks5.c_str(), strSocks5.size(), MSG_NOSIGNAL);\n    if (ret != (ssize_t)strSocks5.size())\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet2[4];\n    if (recv(hSocket, pchRet2, 4, 0) != 4)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet2[0] != 0x05)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to accept request\");\n    }\n    if (pchRet2[1] != 0x00)\n    {\n        closesocket(hSocket);\n        switch (pchRet2[1])\n        {\n            case 0x01: return error(\"Proxy error: general failure\");\n            case 0x02: return error(\"Proxy error: connection not allowed\");\n            case 0x03: return error(\"Proxy error: network unreachable\");\n            case 0x04: return error(\"Proxy error: host unreachable\");\n            case 0x05: return error(\"Proxy error: connection refused\");\n            case 0x06: return error(\"Proxy error: TTL expired\");\n            case 0x07: return error(\"Proxy error: protocol error\");\n            case 0x08: return error(\"Proxy error: address type not supported\");\n            default:   return error(\"Proxy error: unknown\");\n        }\n    }\n    if (pchRet2[2] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Error: malformed proxy response\");\n    }\n    char pchRet3[256];\n    switch (pchRet2[3])\n    {\n        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n        case 0x03:\n        {\n            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n            if (ret) {\n                closesocket(hSocket);\n                return error(\"Error reading from proxy\");\n            }\n            int nRecv = pchRet3[0];\n            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n            break;\n        }\n        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n    }\n    if (ret)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    if (recv(hSocket, pchRet3, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    printf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static Socks5(string strDest, int port, SOCKET& hSocket)\n{\n    printf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n    if (strDest.size() > 255)\n    {\n        closesocket(hSocket);\n        return error(\"Hostname too long\");\n    }\n    char pszSocks5Init[] = \"\\5\\1\\0\";\n    char *pszSocks5 = pszSocks5Init;\n    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n\n    ssize_t ret = send(hSocket, pszSocks5, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet1[2];\n    if (recv(hSocket, pchRet1, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to initialize\");\n    }\n    string strSocks5(\"\\5\\1\");\n    strSocks5 += '\\000'; strSocks5 += '\\003';\n    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n    strSocks5 += strDest;\n    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n    ret = send(hSocket, strSocks5.c_str(), strSocks5.size(), MSG_NOSIGNAL);\n    if (ret != (ssize_t)strSocks5.size())\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet2[4];\n    if (recv(hSocket, pchRet2, 4, 0) != 4)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet2[0] != 0x05)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to accept request\");\n    }\n    if (pchRet2[1] != 0x00)\n    {\n        closesocket(hSocket);\n        switch (pchRet2[1])\n        {\n            case 0x01: return error(\"Proxy error: general failure\");\n            case 0x02: return error(\"Proxy error: connection not allowed\");\n            case 0x03: return error(\"Proxy error: network unreachable\");\n            case 0x04: return error(\"Proxy error: host unreachable\");\n            case 0x05: return error(\"Proxy error: connection refused\");\n            case 0x06: return error(\"Proxy error: TTL expired\");\n            case 0x07: return error(\"Proxy error: protocol error\");\n            case 0x08: return error(\"Proxy error: address type not supported\");\n            default:   return error(\"Proxy error: unknown\");\n        }\n    }\n    if (pchRet2[2] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Error: malformed proxy response\");\n    }\n    char pchRet3[256];\n    switch (pchRet2[3])\n    {\n        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n        case 0x03:\n        {\n            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n            if (ret) {\n                closesocket(hSocket);\n                return error(\"Error reading from proxy\");\n            }\n            int nRecv = pchRet3[0];\n            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n            break;\n        }\n        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n    }\n    if (ret)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    if (recv(hSocket, pchRet3, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    printf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrDest.GetPort",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "GetPort",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1097-1100",
          "snippet": "unsigned short CService::GetPort() const\n{\n    return port;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  unsigned short CService::GetPort() const\n  {\n      return port;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrDest.ToStringIP",
          "args": [],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ToStringIP",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "783-809",
          "snippet": "std::string CNetAddr::ToStringIP() const\n{\n    if (IsTor())\n        return EncodeBase32(&ip[6], 10) + \".onion\";\n    if (IsI2P())\n        return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n    CService serv(*this, 0);\n#ifdef USE_IPV6\n    struct sockaddr_storage sockaddr;\n#else\n    struct sockaddr sockaddr;\n#endif\n    socklen_t socklen = sizeof(sockaddr);\n    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n        char name[1025] = \"\";\n        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n            return std::string(name);\n    }\n    if (IsIPv4())\n        return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n    else\n        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  std::string CNetAddr::ToStringIP() const\n  {\n      if (IsTor())\n          return EncodeBase32(&ip[6], 10) + \".onion\";\n      if (IsI2P())\n          return EncodeBase32(&ip[6], 10) + \".oc.b32.i2p\";\n      CService serv(*this, 0);\n  #ifdef USE_IPV6\n      struct sockaddr_storage sockaddr;\n  #else\n      struct sockaddr sockaddr;\n  #endif\n      socklen_t socklen = sizeof(sockaddr);\n      if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n          char name[1025] = \"\";\n          if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))\n              return std::string(name);\n      }\n      if (IsIPv4())\n          return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\n      else\n          return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n                           GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\n                           GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\n                           GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\n                           GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Socks4",
          "args": [
            "addrDest",
            "hSocket"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "Socks4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "174-216",
          "snippet": "bool static Socks4(const CService &addrDest, SOCKET& hSocket)\n{\n    printf(\"SOCKS4 connecting %s\\n\", addrDest.ToString().c_str());\n    if (!addrDest.IsIPv4())\n    {\n        closesocket(hSocket);\n        return error(\"Proxy destination is not IPv4\");\n    }\n    char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n    struct sockaddr_in addr;\n    socklen_t len = sizeof(addr);\n    if (!addrDest.GetSockAddr((struct sockaddr*)&addr, &len) || addr.sin_family != AF_INET)\n    {\n        closesocket(hSocket);\n        return error(\"Cannot get proxy destination address\");\n    }\n    memcpy(pszSocks4IP + 2, &addr.sin_port, 2);\n    memcpy(pszSocks4IP + 4, &addr.sin_addr, 4);\n    char* pszSocks4 = pszSocks4IP;\n    int nSize = sizeof(pszSocks4IP);\n\n    int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet[8];\n    if (recv(hSocket, pchRet, 8, 0) != 8)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet[1] != 0x5a)\n    {\n        closesocket(hSocket);\n        if (pchRet[1] != 0x5b)\n            printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n        return false;\n    }\n    printf(\"SOCKS4 connected %s\\n\", addrDest.ToString().c_str());\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static Socks4(const CService &addrDest, SOCKET& hSocket)\n{\n    printf(\"SOCKS4 connecting %s\\n\", addrDest.ToString().c_str());\n    if (!addrDest.IsIPv4())\n    {\n        closesocket(hSocket);\n        return error(\"Proxy destination is not IPv4\");\n    }\n    char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n    struct sockaddr_in addr;\n    socklen_t len = sizeof(addr);\n    if (!addrDest.GetSockAddr((struct sockaddr*)&addr, &len) || addr.sin_family != AF_INET)\n    {\n        closesocket(hSocket);\n        return error(\"Cannot get proxy destination address\");\n    }\n    memcpy(pszSocks4IP + 2, &addr.sin_port, 2);\n    memcpy(pszSocks4IP + 4, &addr.sin_addr, 4);\n    char* pszSocks4 = pszSocks4IP;\n    int nSize = sizeof(pszSocks4IP);\n\n    int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet[8];\n    if (recv(hSocket, pchRet, 8, 0) != 8)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet[1] != 0x5a)\n    {\n        closesocket(hSocket);\n        if (pchRet[1] != 0x5b)\n            printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n        return false;\n    }\n    printf(\"SOCKS4 connected %s\\n\", addrDest.ToString().c_str());\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ConnectSocketDirectly",
          "args": [
            "proxy.first",
            "hSocket",
            "nTimeout"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ConnectSocketDirectly",
          "args": [
            "addrDest",
            "hSocketRet",
            "nTimeout"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetProxy",
          "args": [
            "addrDest.GetNetwork()",
            "proxy"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "GetProxy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "443-450",
          "snippet": "bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n    assert(net >= 0 && net < NET_MAX);\n    LOCK(cs_proxyInfos);\n    if (!proxyInfo[net].second)\n        return false;\n    proxyInfoOut = proxyInfo[net];\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static proxyType proxyInfo[NET_MAX];",
            "static CCriticalSection cs_proxyInfos;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType proxyInfo[NET_MAX];\nstatic CCriticalSection cs_proxyInfos;\n\nbool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n    assert(net >= 0 && net < NET_MAX);\n    LOCK(cs_proxyInfos);\n    if (!proxyInfo[net].second)\n        return false;\n    proxyInfoOut = proxyInfo[net];\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrDest.GetNetwork",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "GetNetwork",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "766-781",
          "snippet": "enum Network CNetAddr::GetNetwork() const\n{\n    if (!IsRoutable())\n        return NET_UNROUTABLE;\n\n    if (IsIPv4())\n        return NET_IPV4;\n\n    if (IsTor())\n        return NET_TOR;\n\n    if (IsI2P())\n        return NET_I2P;\n\n    return NET_IPV6;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  enum Network CNetAddr::GetNetwork() const\n  {\n      if (!IsRoutable())\n          return NET_UNROUTABLE;\n  \n      if (IsIPv4())\n          return NET_IPV4;\n  \n      if (IsTor())\n          return NET_TOR;\n  \n      if (IsI2P())\n          return NET_I2P;\n  \n      return NET_IPV6;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n{\n    proxyType proxy;\n\n    // no proxy needed\n    if (!GetProxy(addrDest.GetNetwork(), proxy))\n        return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n\n    SOCKET hSocket = INVALID_SOCKET;\n\n    // first connect to proxy server\n    if (!ConnectSocketDirectly(proxy.first, hSocket, nTimeout))\n        return false;\n\n    // do socks negotiation\n    switch (proxy.second) {\n    case 4:\n        if (!Socks4(addrDest, hSocket))\n            return false;\n        break;\n    case 5:\n        if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n            return false;\n        break;\n    default:\n        closesocket(hSocket);\n        return false;\n    }\n\n    hSocketRet = hSocket;\n    return true;\n}"
  },
  {
    "function_name": "IsProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "475-482",
    "snippet": "bool IsProxy(const CNetAddr &addr) {\n    LOCK(cs_proxyInfos);\n    for (int i = 0; i < NET_MAX; i++) {\n        if (proxyInfo[i].second && (addr == (CNetAddr)proxyInfo[i].first))\n            return true;\n    }\n    return false;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static proxyType proxyInfo[NET_MAX];",
      "static CCriticalSection cs_proxyInfos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_proxyInfos"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType proxyInfo[NET_MAX];\nstatic CCriticalSection cs_proxyInfos;\n\nbool IsProxy(const CNetAddr &addr) {\n    LOCK(cs_proxyInfos);\n    for (int i = 0; i < NET_MAX; i++) {\n        if (proxyInfo[i].second && (addr == (CNetAddr)proxyInfo[i].first))\n            return true;\n    }\n    return false;\n}"
  },
  {
    "function_name": "HaveNameProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "470-473",
    "snippet": "bool HaveNameProxy() {\n    LOCK(cs_proxyInfos);\n    return nameproxyInfo.second != 0;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static proxyType nameproxyInfo;",
      "static CCriticalSection cs_proxyInfos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_proxyInfos"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType nameproxyInfo;\nstatic CCriticalSection cs_proxyInfos;\n\nbool HaveNameProxy() {\n    LOCK(cs_proxyInfos);\n    return nameproxyInfo.second != 0;\n}"
  },
  {
    "function_name": "GetNameProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "462-468",
    "snippet": "bool GetNameProxy(proxyType &nameproxyInfoOut) {\n    LOCK(cs_proxyInfos);\n    if (!nameproxyInfo.second)\n        return false;\n    nameproxyInfoOut = nameproxyInfo;\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static proxyType nameproxyInfo;",
      "static CCriticalSection cs_proxyInfos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_proxyInfos"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType nameproxyInfo;\nstatic CCriticalSection cs_proxyInfos;\n\nbool GetNameProxy(proxyType &nameproxyInfoOut) {\n    LOCK(cs_proxyInfos);\n    if (!nameproxyInfo.second)\n        return false;\n    nameproxyInfoOut = nameproxyInfo;\n    return true;\n}"
  },
  {
    "function_name": "SetNameProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "452-460",
    "snippet": "bool SetNameProxy(CService addrProxy, int nSocksVersion) {\n    if (nSocksVersion != 0 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    nameproxyInfo = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static proxyType nameproxyInfo;",
      "static CCriticalSection cs_proxyInfos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "addrProxy",
            "nSocksVersion"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_proxyInfos"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrProxy.IsValid",
          "args": [],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType nameproxyInfo;\nstatic CCriticalSection cs_proxyInfos;\n\nbool SetNameProxy(CService addrProxy, int nSocksVersion) {\n    if (nSocksVersion != 0 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    nameproxyInfo = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}"
  },
  {
    "function_name": "GetProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "443-450",
    "snippet": "bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n    assert(net >= 0 && net < NET_MAX);\n    LOCK(cs_proxyInfos);\n    if (!proxyInfo[net].second)\n        return false;\n    proxyInfoOut = proxyInfo[net];\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static proxyType proxyInfo[NET_MAX];",
      "static CCriticalSection cs_proxyInfos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_proxyInfos"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "net >= 0 && net < NET_MAX"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType proxyInfo[NET_MAX];\nstatic CCriticalSection cs_proxyInfos;\n\nbool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n    assert(net >= 0 && net < NET_MAX);\n    LOCK(cs_proxyInfos);\n    if (!proxyInfo[net].second)\n        return false;\n    proxyInfoOut = proxyInfo[net];\n    return true;\n}"
  },
  {
    "function_name": "SetProxy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "432-441",
    "snippet": "bool SetProxy(enum Network net, CService addrProxy, int nSocksVersion) {\n    assert(net >= 0 && net < NET_MAX);\n    if (nSocksVersion != 0 && nSocksVersion != 4 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    proxyInfo[net] = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static proxyType proxyInfo[NET_MAX];",
      "static CCriticalSection cs_proxyInfos;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::make_pair",
          "args": [
            "addrProxy",
            "nSocksVersion"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_proxyInfos"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrProxy.IsValid",
          "args": [],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "IsValid",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "725-759",
          "snippet": "bool CNetAddr::IsValid() const\n{\n    // Cleanup 3-byte shifted addresses caused by garbage in size field\n    // of addr messages from versions before 0.2.9 checksum.\n    // Two consecutive addr messages look like this:\n    // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n    // so if the first length field is garbled, it reads the second batch\n    // of addr misaligned by 3 bytes.\n    if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n        return false;\n\n    // unspecified IPv6 address (::/128)\n    unsigned char ipNone[16] = {};\n    if (memcmp(ip, ipNone, 16) == 0)\n        return false;\n\n    // documentation IPv6 address\n    if (IsRFC3849())\n        return false;\n\n    if (IsIPv4())\n    {\n        // INADDR_NONE\n        uint32_t ipNone = INADDR_NONE;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n\n        // 0\n        ipNone = 0;\n        if (memcmp(ip+12, &ipNone, 4) == 0)\n            return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsValid() const\n  {\n      // Cleanup 3-byte shifted addresses caused by garbage in size field\n      // of addr messages from versions before 0.2.9 checksum.\n      // Two consecutive addr messages look like this:\n      // header20 vectorlen3 addr26 addr26 addr26 header20 vectorlen3 addr26 addr26 addr26...\n      // so if the first length field is garbled, it reads the second batch\n      // of addr misaligned by 3 bytes.\n      if (memcmp(ip, pchIPv4+3, sizeof(pchIPv4)-3) == 0)\n          return false;\n  \n      // unspecified IPv6 address (::/128)\n      unsigned char ipNone[16] = {};\n      if (memcmp(ip, ipNone, 16) == 0)\n          return false;\n  \n      // documentation IPv6 address\n      if (IsRFC3849())\n          return false;\n  \n      if (IsIPv4())\n      {\n          // INADDR_NONE\n          uint32_t ipNone = INADDR_NONE;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n  \n          // 0\n          ipNone = 0;\n          if (memcmp(ip+12, &ipNone, 4) == 0)\n              return false;\n      }\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "net >= 0 && net < NET_MAX"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic proxyType proxyInfo[NET_MAX];\nstatic CCriticalSection cs_proxyInfos;\n\nbool SetProxy(enum Network net, CService addrProxy, int nSocksVersion) {\n    assert(net >= 0 && net < NET_MAX);\n    if (nSocksVersion != 0 && nSocksVersion != 4 && nSocksVersion != 5)\n        return false;\n    if (nSocksVersion != 0 && !addrProxy.IsValid())\n        return false;\n    LOCK(cs_proxyInfos);\n    proxyInfo[net] = std::make_pair(addrProxy, nSocksVersion);\n    return true;\n}"
  },
  {
    "function_name": "Socks5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "218-321",
    "snippet": "bool static Socks5(string strDest, int port, SOCKET& hSocket)\n{\n    printf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n    if (strDest.size() > 255)\n    {\n        closesocket(hSocket);\n        return error(\"Hostname too long\");\n    }\n    char pszSocks5Init[] = \"\\5\\1\\0\";\n    char *pszSocks5 = pszSocks5Init;\n    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n\n    ssize_t ret = send(hSocket, pszSocks5, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet1[2];\n    if (recv(hSocket, pchRet1, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to initialize\");\n    }\n    string strSocks5(\"\\5\\1\");\n    strSocks5 += '\\000'; strSocks5 += '\\003';\n    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n    strSocks5 += strDest;\n    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n    ret = send(hSocket, strSocks5.c_str(), strSocks5.size(), MSG_NOSIGNAL);\n    if (ret != (ssize_t)strSocks5.size())\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet2[4];\n    if (recv(hSocket, pchRet2, 4, 0) != 4)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet2[0] != 0x05)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to accept request\");\n    }\n    if (pchRet2[1] != 0x00)\n    {\n        closesocket(hSocket);\n        switch (pchRet2[1])\n        {\n            case 0x01: return error(\"Proxy error: general failure\");\n            case 0x02: return error(\"Proxy error: connection not allowed\");\n            case 0x03: return error(\"Proxy error: network unreachable\");\n            case 0x04: return error(\"Proxy error: host unreachable\");\n            case 0x05: return error(\"Proxy error: connection refused\");\n            case 0x06: return error(\"Proxy error: TTL expired\");\n            case 0x07: return error(\"Proxy error: protocol error\");\n            case 0x08: return error(\"Proxy error: address type not supported\");\n            default:   return error(\"Proxy error: unknown\");\n        }\n    }\n    if (pchRet2[2] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Error: malformed proxy response\");\n    }\n    char pchRet3[256];\n    switch (pchRet2[3])\n    {\n        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n        case 0x03:\n        {\n            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n            if (ret) {\n                closesocket(hSocket);\n                return error(\"Error reading from proxy\");\n            }\n            int nRecv = pchRet3[0];\n            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n            break;\n        }\n        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n    }\n    if (ret)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    if (recv(hSocket, pchRet3, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    printf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SOCKS5 connected %s\\n\"",
            "strDest.c_str()"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strDest.c_str",
          "args": [],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Error reading from proxy\""
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet3",
            "2",
            "0"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet3",
            "nRecv",
            "0"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet3",
            "1",
            "0"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet3",
            "16",
            "0"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet3",
            "4",
            "0"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet2",
            "4",
            "0"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strSocks5.size",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "hSocket",
            "strSocks5.c_str()",
            "strSocks5.size()",
            "MSG_NOSIGNAL"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strSocks5.c_str",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "(port >> 0) & 0xFF"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "(port >> 8) & 0xFF"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<char>",
          "args": [
            "std::min((int)strDest.size(), 255)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::min",
          "args": [
            "(int)strDest.size()",
            "255"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet1",
            "2",
            "0"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "hSocket",
            "pszSocks5",
            "nSize",
            "MSG_NOSIGNAL"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strDest.c_str",
          "args": [],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static Socks5(string strDest, int port, SOCKET& hSocket)\n{\n    printf(\"SOCKS5 connecting %s\\n\", strDest.c_str());\n    if (strDest.size() > 255)\n    {\n        closesocket(hSocket);\n        return error(\"Hostname too long\");\n    }\n    char pszSocks5Init[] = \"\\5\\1\\0\";\n    char *pszSocks5 = pszSocks5Init;\n    ssize_t nSize = sizeof(pszSocks5Init) - 1;\n\n    ssize_t ret = send(hSocket, pszSocks5, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet1[2];\n    if (recv(hSocket, pchRet1, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to initialize\");\n    }\n    string strSocks5(\"\\5\\1\");\n    strSocks5 += '\\000'; strSocks5 += '\\003';\n    strSocks5 += static_cast<char>(std::min((int)strDest.size(), 255));\n    strSocks5 += strDest;\n    strSocks5 += static_cast<char>((port >> 8) & 0xFF);\n    strSocks5 += static_cast<char>((port >> 0) & 0xFF);\n    ret = send(hSocket, strSocks5.c_str(), strSocks5.size(), MSG_NOSIGNAL);\n    if (ret != (ssize_t)strSocks5.size())\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet2[4];\n    if (recv(hSocket, pchRet2, 4, 0) != 4)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet2[0] != 0x05)\n    {\n        closesocket(hSocket);\n        return error(\"Proxy failed to accept request\");\n    }\n    if (pchRet2[1] != 0x00)\n    {\n        closesocket(hSocket);\n        switch (pchRet2[1])\n        {\n            case 0x01: return error(\"Proxy error: general failure\");\n            case 0x02: return error(\"Proxy error: connection not allowed\");\n            case 0x03: return error(\"Proxy error: network unreachable\");\n            case 0x04: return error(\"Proxy error: host unreachable\");\n            case 0x05: return error(\"Proxy error: connection refused\");\n            case 0x06: return error(\"Proxy error: TTL expired\");\n            case 0x07: return error(\"Proxy error: protocol error\");\n            case 0x08: return error(\"Proxy error: address type not supported\");\n            default:   return error(\"Proxy error: unknown\");\n        }\n    }\n    if (pchRet2[2] != 0x00)\n    {\n        closesocket(hSocket);\n        return error(\"Error: malformed proxy response\");\n    }\n    char pchRet3[256];\n    switch (pchRet2[3])\n    {\n        case 0x01: ret = recv(hSocket, pchRet3, 4, 0) != 4; break;\n        case 0x04: ret = recv(hSocket, pchRet3, 16, 0) != 16; break;\n        case 0x03:\n        {\n            ret = recv(hSocket, pchRet3, 1, 0) != 1;\n            if (ret) {\n                closesocket(hSocket);\n                return error(\"Error reading from proxy\");\n            }\n            int nRecv = pchRet3[0];\n            ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n            break;\n        }\n        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n    }\n    if (ret)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    if (recv(hSocket, pchRet3, 2, 0) != 2)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading from proxy\");\n    }\n    printf(\"SOCKS5 connected %s\\n\", strDest.c_str());\n    return true;\n}"
  },
  {
    "function_name": "Socks4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "174-216",
    "snippet": "bool static Socks4(const CService &addrDest, SOCKET& hSocket)\n{\n    printf(\"SOCKS4 connecting %s\\n\", addrDest.ToString().c_str());\n    if (!addrDest.IsIPv4())\n    {\n        closesocket(hSocket);\n        return error(\"Proxy destination is not IPv4\");\n    }\n    char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n    struct sockaddr_in addr;\n    socklen_t len = sizeof(addr);\n    if (!addrDest.GetSockAddr((struct sockaddr*)&addr, &len) || addr.sin_family != AF_INET)\n    {\n        closesocket(hSocket);\n        return error(\"Cannot get proxy destination address\");\n    }\n    memcpy(pszSocks4IP + 2, &addr.sin_port, 2);\n    memcpy(pszSocks4IP + 4, &addr.sin_addr, 4);\n    char* pszSocks4 = pszSocks4IP;\n    int nSize = sizeof(pszSocks4IP);\n\n    int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet[8];\n    if (recv(hSocket, pchRet, 8, 0) != 8)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet[1] != 0x5a)\n    {\n        closesocket(hSocket);\n        if (pchRet[1] != 0x5b)\n            printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n        return false;\n    }\n    printf(\"SOCKS4 connected %s\\n\", addrDest.ToString().c_str());\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"SOCKS4 connected %s\\n\"",
            "addrDest.ToString().c_str()"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrDest.ToString",
          "args": [],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "closesocket",
          "args": [
            "hSocket"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "myclosesocket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/compat.h",
          "lines": "50-61",
          "snippet": "inline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}",
          "includes": [
            "#include \"errno.h\"",
            "#include <ifaddrs.h>",
            "#include <netinet/in.h>",
            "#include <net/if.h>",
            "#include <netdb.h>",
            "#include <arpa/inet.h>",
            "#include <sys/fcntl.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <ws2tcpip.h>",
            "#include <mswsock.h>",
            "#include <winsock2.h>"
          ],
          "macros_used": [
            "#define INVALID_SOCKET      (SOCKET)(~0)",
            "#define WSAENOTSOCK         EBADF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"errno.h\"\n#include <ifaddrs.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/fcntl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <ws2tcpip.h>\n#include <mswsock.h>\n#include <winsock2.h>\n\n#define INVALID_SOCKET      (SOCKET)(~0)\n#define WSAENOTSOCK         EBADF\n\ninline int myclosesocket(SOCKET& hSocket)\n{\n    if (hSocket == INVALID_SOCKET)\n        return WSAENOTSOCK;\n#ifdef WIN32\n    int ret = closesocket(hSocket);\n#else\n    int ret = close(hSocket);\n#endif\n    hSocket = INVALID_SOCKET;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Error reading proxy response\""
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "recv",
          "args": [
            "hSocket",
            "pchRet",
            "8",
            "0"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send",
          "args": [
            "hSocket",
            "pszSocks4",
            "nSize",
            "MSG_NOSIGNAL"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pszSocks4IP + 4",
            "&addr.sin_addr",
            "4"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "pszSocks4IP + 2",
            "&addr.sin_port",
            "2"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addrDest.GetSockAddr",
          "args": [
            "(struct sockaddr*)&addr",
            "&len"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "addrDest.IsIPv4",
          "args": [],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "IsIPv4",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "629-632",
          "snippet": "bool CNetAddr::IsIPv4() const\n{\n    return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nstatic const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n\nCNetAddr {\n  bool CNetAddr::IsIPv4() const\n  {\n      return (memcmp(ip, pchIPv4, sizeof(pchIPv4)) == 0);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static Socks4(const CService &addrDest, SOCKET& hSocket)\n{\n    printf(\"SOCKS4 connecting %s\\n\", addrDest.ToString().c_str());\n    if (!addrDest.IsIPv4())\n    {\n        closesocket(hSocket);\n        return error(\"Proxy destination is not IPv4\");\n    }\n    char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n    struct sockaddr_in addr;\n    socklen_t len = sizeof(addr);\n    if (!addrDest.GetSockAddr((struct sockaddr*)&addr, &len) || addr.sin_family != AF_INET)\n    {\n        closesocket(hSocket);\n        return error(\"Cannot get proxy destination address\");\n    }\n    memcpy(pszSocks4IP + 2, &addr.sin_port, 2);\n    memcpy(pszSocks4IP + 4, &addr.sin_addr, 4);\n    char* pszSocks4 = pszSocks4IP;\n    int nSize = sizeof(pszSocks4IP);\n\n    int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n    if (ret != nSize)\n    {\n        closesocket(hSocket);\n        return error(\"Error sending to proxy\");\n    }\n    char pchRet[8];\n    if (recv(hSocket, pchRet, 8, 0) != 8)\n    {\n        closesocket(hSocket);\n        return error(\"Error reading proxy response\");\n    }\n    if (pchRet[1] != 0x5a)\n    {\n        closesocket(hSocket);\n        if (pchRet[1] != 0x5b)\n            printf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n        return false;\n    }\n    printf(\"SOCKS4 connected %s\\n\", addrDest.ToString().c_str());\n    return true;\n}"
  },
  {
    "function_name": "LookupNumeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "169-172",
    "snippet": "bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n{\n    return Lookup(pszName, addr, portDefault, false);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "pszName",
            "addr",
            "portDefault",
            "false"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "159-167",
          "snippet": "bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n{\n    return Lookup(pszName, addr, portDefault, false);\n}"
  },
  {
    "function_name": "Lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "159-167",
    "snippet": "bool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Lookup",
          "args": [
            "pszName",
            "vService",
            "portDefault",
            "fAllowLookup",
            "1"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "Lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "141-157",
          "snippet": "bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n{\n    if (pszName[0] == 0)\n        return false;\n    int port = portDefault;\n    std::string hostname = \"\";\n    SplitHostPort(std::string(pszName), port, hostname);\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupIntern(hostname.c_str(), vIP, nMaxSolutions, fAllowLookup);\n    if (!fRet)\n        return false;\n    vAddr.resize(vIP.size());\n    for (unsigned int i = 0; i < vIP.size(); i++)\n        vAddr[i] = CService(vIP[i], port);\n    return true;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, CService& addr, int portDefault, bool fAllowLookup)\n{\n    std::vector<CService> vService;\n    bool fRet = Lookup(pszName, vService, portDefault, fAllowLookup, 1);\n    if (!fRet)\n        return false;\n    addr = vService[0];\n    return true;\n}"
  },
  {
    "function_name": "Lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "141-157",
    "snippet": "bool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n{\n    if (pszName[0] == 0)\n        return false;\n    int port = portDefault;\n    std::string hostname = \"\";\n    SplitHostPort(std::string(pszName), port, hostname);\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupIntern(hostname.c_str(), vIP, nMaxSolutions, fAllowLookup);\n    if (!fRet)\n        return false;\n    vAddr.resize(vIP.size());\n    for (unsigned int i = 0; i < vIP.size(); i++)\n        vAddr[i] = CService(vIP[i], port);\n    return true;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CService",
          "args": [
            "vIP[i]",
            "port"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "GetSockAddr",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1117-1146",
          "snippet": "bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n{\n    if (IsIPv4()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in);\n        struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n        memset(paddrin, 0, *addrlen);\n        if (!GetInAddr(&paddrin->sin_addr))\n            return false;\n        paddrin->sin_family = AF_INET;\n        paddrin->sin_port = htons(port);\n        return true;\n    }\n#ifdef USE_IPV6\n    if (IsIPv6()) {\n        if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n            return false;\n        *addrlen = sizeof(struct sockaddr_in6);\n        struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n        memset(paddrin6, 0, *addrlen);\n        if (!GetIn6Addr(&paddrin6->sin6_addr))\n            return false;\n        paddrin6->sin6_family = AF_INET6;\n        paddrin6->sin6_port = htons(port);\n        return true;\n    }\n#endif\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  bool CService::GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const\n  {\n      if (IsIPv4()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in);\n          struct sockaddr_in *paddrin = (struct sockaddr_in*)paddr;\n          memset(paddrin, 0, *addrlen);\n          if (!GetInAddr(&paddrin->sin_addr))\n              return false;\n          paddrin->sin_family = AF_INET;\n          paddrin->sin_port = htons(port);\n          return true;\n      }\n  #ifdef USE_IPV6\n      if (IsIPv6()) {\n          if (*addrlen < (socklen_t)sizeof(struct sockaddr_in6))\n              return false;\n          *addrlen = sizeof(struct sockaddr_in6);\n          struct sockaddr_in6 *paddrin6 = (struct sockaddr_in6*)paddr;\n          memset(paddrin6, 0, *addrlen);\n          if (!GetIn6Addr(&paddrin6->sin6_addr))\n              return false;\n          paddrin6->sin6_family = AF_INET6;\n          paddrin6->sin6_port = htons(port);\n          return true;\n      }\n  #endif\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vIP.size",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vAddr.resize",
          "args": [
            "vIP.size()"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LookupIntern",
          "args": [
            "hostname.c_str()",
            "vIP",
            "nMaxSolutions",
            "fAllowLookup"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "LookupIntern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "58-118",
          "snippet": "bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    vIP.clear();\n\n    {\n        CNetAddr addr;\n        if (addr.SetSpecial(std::string(pszName))) {\n            vIP.push_back(addr);\n            return true;\n        }\n    }\n\n    struct addrinfo aiHint;\n    memset(&aiHint, 0, sizeof(struct addrinfo));\n\n    aiHint.ai_socktype = SOCK_STREAM;\n    aiHint.ai_protocol = IPPROTO_TCP;\n#ifdef WIN32\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n#else\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n#endif\n    struct addrinfo *aiRes = NULL;\n    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n    if (nErr)\n        return false;\n\n    struct addrinfo *aiTrav = aiRes;\n    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n    {\n        if (aiTrav->ai_family == AF_INET)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n        }\n\n#ifdef USE_IPV6\n        if (aiTrav->ai_family == AF_INET6)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n            vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n        }\n#endif\n\n        aiTrav = aiTrav->ai_next;\n    }\n\n    freeaddrinfo(aiRes);\n\n    return (vIP.size() > 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    vIP.clear();\n\n    {\n        CNetAddr addr;\n        if (addr.SetSpecial(std::string(pszName))) {\n            vIP.push_back(addr);\n            return true;\n        }\n    }\n\n    struct addrinfo aiHint;\n    memset(&aiHint, 0, sizeof(struct addrinfo));\n\n    aiHint.ai_socktype = SOCK_STREAM;\n    aiHint.ai_protocol = IPPROTO_TCP;\n#ifdef WIN32\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n#else\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n#endif\n    struct addrinfo *aiRes = NULL;\n    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n    if (nErr)\n        return false;\n\n    struct addrinfo *aiTrav = aiRes;\n    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n    {\n        if (aiTrav->ai_family == AF_INET)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n        }\n\n#ifdef USE_IPV6\n        if (aiTrav->ai_family == AF_INET6)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n            vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n        }\n#endif\n\n        aiTrav = aiTrav->ai_next;\n    }\n\n    freeaddrinfo(aiRes);\n\n    return (vIP.size() > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hostname.c_str",
          "args": [],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SplitHostPort",
          "args": [
            "std::string(pszName)",
            "port",
            "hostname"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "SplitHostPort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "37-56",
          "snippet": "void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n    size_t colon = in.find_last_of(':');\n    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n    bool fHaveColon = colon != in.npos;\n    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n        char *endp = NULL;\n        int n = strtol(in.c_str() + colon + 1, &endp, 10);\n        if (endp && *endp == 0 && n >= 0) {\n            in = in.substr(0, colon);\n            if (n > 0 && n < 0x10000)\n                portOut = n;\n        }\n    }\n    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n        hostOut = in.substr(1, in.size()-2);\n    else\n        hostOut = in;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nvoid SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n    size_t colon = in.find_last_of(':');\n    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n    bool fHaveColon = colon != in.npos;\n    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n        char *endp = NULL;\n        int n = strtol(in.c_str() + colon + 1, &endp, 10);\n        if (endp && *endp == 0 && n >= 0) {\n            in = in.substr(0, colon);\n            if (n > 0 && n < 0x10000)\n                portOut = n;\n        }\n    }\n    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n        hostOut = in.substr(1, in.size()-2);\n    else\n        hostOut = in;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "pszName"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool Lookup(const char *pszName, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\n{\n    if (pszName[0] == 0)\n        return false;\n    int port = portDefault;\n    std::string hostname = \"\";\n    SplitHostPort(std::string(pszName), port, hostname);\n\n    std::vector<CNetAddr> vIP;\n    bool fRet = LookupIntern(hostname.c_str(), vIP, nMaxSolutions, fAllowLookup);\n    if (!fRet)\n        return false;\n    vAddr.resize(vIP.size());\n    for (unsigned int i = 0; i < vIP.size(); i++)\n        vAddr[i] = CService(vIP[i], port);\n    return true;\n}"
  },
  {
    "function_name": "LookupHostNumeric",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "136-139",
    "snippet": "bool LookupHostNumeric(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions)\n{\n    return LookupHost(pszName, vIP, nMaxSolutions, false);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LookupHost",
          "args": [
            "pszName",
            "vIP",
            "nMaxSolutions",
            "false"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "LookupHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "120-134",
          "snippet": "bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool LookupHostNumeric(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions)\n{\n    return LookupHost(pszName, vIP, nMaxSolutions, false);\n}"
  },
  {
    "function_name": "LookupHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "120-134",
    "snippet": "bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LookupIntern",
          "args": [
            "pszHost",
            "vIP",
            "nMaxSolutions",
            "fAllowLookup"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "LookupIntern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "58-118",
          "snippet": "bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    vIP.clear();\n\n    {\n        CNetAddr addr;\n        if (addr.SetSpecial(std::string(pszName))) {\n            vIP.push_back(addr);\n            return true;\n        }\n    }\n\n    struct addrinfo aiHint;\n    memset(&aiHint, 0, sizeof(struct addrinfo));\n\n    aiHint.ai_socktype = SOCK_STREAM;\n    aiHint.ai_protocol = IPPROTO_TCP;\n#ifdef WIN32\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n#else\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n#endif\n    struct addrinfo *aiRes = NULL;\n    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n    if (nErr)\n        return false;\n\n    struct addrinfo *aiTrav = aiRes;\n    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n    {\n        if (aiTrav->ai_family == AF_INET)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n        }\n\n#ifdef USE_IPV6\n        if (aiTrav->ai_family == AF_INET6)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n            vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n        }\n#endif\n\n        aiTrav = aiTrav->ai_next;\n    }\n\n    freeaddrinfo(aiRes);\n\n    return (vIP.size() > 0);\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    vIP.clear();\n\n    {\n        CNetAddr addr;\n        if (addr.SetSpecial(std::string(pszName))) {\n            vIP.push_back(addr);\n            return true;\n        }\n    }\n\n    struct addrinfo aiHint;\n    memset(&aiHint, 0, sizeof(struct addrinfo));\n\n    aiHint.ai_socktype = SOCK_STREAM;\n    aiHint.ai_protocol = IPPROTO_TCP;\n#ifdef WIN32\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n#else\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n#endif\n    struct addrinfo *aiRes = NULL;\n    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n    if (nErr)\n        return false;\n\n    struct addrinfo *aiTrav = aiRes;\n    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n    {\n        if (aiTrav->ai_family == AF_INET)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n        }\n\n#ifdef USE_IPV6\n        if (aiTrav->ai_family == AF_INET6)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n            vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n        }\n#endif\n\n        aiTrav = aiTrav->ai_next;\n    }\n\n    freeaddrinfo(aiRes);\n\n    return (vIP.size() > 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "psz"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "psz"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "psz",
            "pszName",
            "sizeof(psz)"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "strlcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/strlcpy.h",
          "lines": "27-53",
          "snippet": "inline size_t strlcpy(char *dst, const char *src, size_t siz)\n{\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n\n    /* Copy as many bytes as will fit */\n    if (n != 0)\n    {\n        while (--n != 0)\n        {\n            if ((*d++ = *s++) == '\\0')\n                break;\n        }\n    }\n\n    /* Not enough room in dst, add NUL and traverse rest of src */\n    if (n == 0)\n    {\n        if (siz != 0)\n            *d = '\\0';  /* NUL-terminate dst */\n        while (*s++)\n            ;\n    }\n\n    return(s - src - 1); /* count does not include NUL */\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n\ninline size_t strlcpy(char *dst, const char *src, size_t siz)\n{\n    char *d = dst;\n    const char *s = src;\n    size_t n = siz;\n\n    /* Copy as many bytes as will fit */\n    if (n != 0)\n    {\n        while (--n != 0)\n        {\n            if ((*d++ = *s++) == '\\0')\n                break;\n        }\n    }\n\n    /* Not enough room in dst, add NUL and traverse rest of src */\n    if (n == 0)\n    {\n        if (siz != 0)\n            *d = '\\0';  /* NUL-terminate dst */\n        while (*s++)\n            ;\n    }\n\n    return(s - src - 1); /* count does not include NUL */\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    if (pszName[0] == 0)\n        return false;\n    char psz[256];\n    char *pszHost = psz;\n    strlcpy(psz, pszName, sizeof(psz));\n    if (psz[0] == '[' && psz[strlen(psz)-1] == ']')\n    {\n        pszHost = psz+1;\n        psz[strlen(psz)-1] = 0;\n    }\n\n    return LookupIntern(pszHost, vIP, nMaxSolutions, fAllowLookup);\n}"
  },
  {
    "function_name": "LookupIntern",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "58-118",
    "snippet": "bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    vIP.clear();\n\n    {\n        CNetAddr addr;\n        if (addr.SetSpecial(std::string(pszName))) {\n            vIP.push_back(addr);\n            return true;\n        }\n    }\n\n    struct addrinfo aiHint;\n    memset(&aiHint, 0, sizeof(struct addrinfo));\n\n    aiHint.ai_socktype = SOCK_STREAM;\n    aiHint.ai_protocol = IPPROTO_TCP;\n#ifdef WIN32\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n#else\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n#endif\n    struct addrinfo *aiRes = NULL;\n    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n    if (nErr)\n        return false;\n\n    struct addrinfo *aiTrav = aiRes;\n    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n    {\n        if (aiTrav->ai_family == AF_INET)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n        }\n\n#ifdef USE_IPV6\n        if (aiTrav->ai_family == AF_INET6)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n            vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n        }\n#endif\n\n        aiTrav = aiTrav->ai_next;\n    }\n\n    freeaddrinfo(aiRes);\n\n    return (vIP.size() > 0);\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vIP.size",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "aiRes"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vIP.push_back",
          "args": [
            "CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr)"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CNetAddr",
          "args": [
            "((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "GetReachabilityFrom",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "949-1011",
          "snippet": "int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n{\n    enum Reachability {\n        REACH_UNREACHABLE,\n        REACH_DEFAULT,\n        REACH_TEREDO,\n        REACH_IPV6_WEAK,\n        REACH_IPV4,\n        REACH_IPV6_STRONG,\n        REACH_PRIVATE\n    };\n\n    if (!IsRoutable())\n        return REACH_UNREACHABLE;\n\n    int ourNet = GetExtNetwork(this);\n    int theirNet = GetExtNetwork(paddrPartner);\n    bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n\n    switch(theirNet) {\n    case NET_IPV4:\n        switch(ourNet) {\n        default:       return REACH_DEFAULT;\n        case NET_IPV4: return REACH_IPV4;\n        }\n    case NET_IPV6:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_TEREDO: return REACH_TEREDO;\n        case NET_IPV4:   return REACH_IPV4;\n        case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n        }\n    case NET_TOR:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n        case NET_TOR:    return REACH_PRIVATE;\n        }\n    case NET_I2P:\n        switch(ourNet) {\n        default:         return REACH_DEFAULT;\n        case NET_I2P:    return REACH_PRIVATE;\n        }\n    case NET_TEREDO:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        }\n    case NET_UNKNOWN:\n    case NET_UNROUTABLE:\n    default:\n        switch(ourNet) {\n        default:          return REACH_DEFAULT;\n        case NET_TEREDO:  return REACH_TEREDO;\n        case NET_IPV6:    return REACH_IPV6_WEAK;\n        case NET_IPV4:    return REACH_IPV4;\n        case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n        case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n        }\n    }\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n  {\n      enum Reachability {\n          REACH_UNREACHABLE,\n          REACH_DEFAULT,\n          REACH_TEREDO,\n          REACH_IPV6_WEAK,\n          REACH_IPV4,\n          REACH_IPV6_STRONG,\n          REACH_PRIVATE\n      };\n  \n      if (!IsRoutable())\n          return REACH_UNREACHABLE;\n  \n      int ourNet = GetExtNetwork(this);\n      int theirNet = GetExtNetwork(paddrPartner);\n      bool fTunnel = IsRFC3964() || IsRFC6052() || IsRFC6145();\n  \n      switch(theirNet) {\n      case NET_IPV4:\n          switch(ourNet) {\n          default:       return REACH_DEFAULT;\n          case NET_IPV4: return REACH_IPV4;\n          }\n      case NET_IPV6:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_TEREDO: return REACH_TEREDO;\n          case NET_IPV4:   return REACH_IPV4;\n          case NET_IPV6:   return fTunnel ? REACH_IPV6_WEAK : REACH_IPV6_STRONG; // only prefer giving our IPv6 address if it's not tunnelled\n          }\n      case NET_TOR:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_IPV4:   return REACH_IPV4; // Tor users can connect to IPv4 as well\n          case NET_TOR:    return REACH_PRIVATE;\n          }\n      case NET_I2P:\n          switch(ourNet) {\n          default:         return REACH_DEFAULT;\n          case NET_I2P:    return REACH_PRIVATE;\n          }\n      case NET_TEREDO:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          }\n      case NET_UNKNOWN:\n      case NET_UNROUTABLE:\n      default:\n          switch(ourNet) {\n          default:          return REACH_DEFAULT;\n          case NET_TEREDO:  return REACH_TEREDO;\n          case NET_IPV6:    return REACH_IPV6_WEAK;\n          case NET_IPV4:    return REACH_IPV4;\n          case NET_I2P:     return REACH_PRIVATE; // assume connections from unroutable addresses are\n          case NET_TOR:     return REACH_PRIVATE; // either from Tor/I2P, or don't care about our address\n          }\n      }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "aiTrav->ai_addrlen >= sizeof(sockaddr_in6)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vIP.push_back",
          "args": [
            "CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "aiTrav->ai_addrlen >= sizeof(sockaddr_in)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "pszName",
            "NULL",
            "&aiHint",
            "&aiRes"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&aiHint",
            "0",
            "sizeof(struct addrinfo)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vIP.push_back",
          "args": [
            "addr"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "addr.SetSpecial",
          "args": [
            "std::string(pszName)"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "SetSpecial",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "567-588",
          "snippet": "bool CNetAddr::SetSpecial(const std::string &strName)\n{\n    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n        if (vchAddr.size() != 16-sizeof(pchOnionCat))\n            return false;\n        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n        return true;\n    }\n    if (strName.size()>11 && strName.substr(strName.size() - 11, 11) == \".oc.b32.i2p\") {\n        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 11).c_str());\n        if (vchAddr.size() != 16-sizeof(pchGarliCat))\n            return false;\n        memcpy(ip, pchOnionCat, sizeof(pchGarliCat));\n        for (unsigned int i=0; i<16-sizeof(pchGarliCat); i++)\n            ip[i + sizeof(pchGarliCat)] = vchAddr[i];\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  bool CNetAddr::SetSpecial(const std::string &strName)\n  {\n      if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n          std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n          if (vchAddr.size() != 16-sizeof(pchOnionCat))\n              return false;\n          memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\n          for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\n              ip[i + sizeof(pchOnionCat)] = vchAddr[i];\n          return true;\n      }\n      if (strName.size()>11 && strName.substr(strName.size() - 11, 11) == \".oc.b32.i2p\") {\n          std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 11).c_str());\n          if (vchAddr.size() != 16-sizeof(pchGarliCat))\n              return false;\n          memcpy(ip, pchOnionCat, sizeof(pchGarliCat));\n          for (unsigned int i=0; i<16-sizeof(pchGarliCat); i++)\n              ip[i + sizeof(pchGarliCat)] = vchAddr[i];\n          return true;\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "pszName"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vIP.clear",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nbool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n{\n    vIP.clear();\n\n    {\n        CNetAddr addr;\n        if (addr.SetSpecial(std::string(pszName))) {\n            vIP.push_back(addr);\n            return true;\n        }\n    }\n\n    struct addrinfo aiHint;\n    memset(&aiHint, 0, sizeof(struct addrinfo));\n\n    aiHint.ai_socktype = SOCK_STREAM;\n    aiHint.ai_protocol = IPPROTO_TCP;\n#ifdef WIN32\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? 0 : AI_NUMERICHOST;\n#else\n#  ifdef USE_IPV6\n    aiHint.ai_family = AF_UNSPEC;\n#  else\n    aiHint.ai_family = AF_INET;\n#  endif\n    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n#endif\n    struct addrinfo *aiRes = NULL;\n    int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n    if (nErr)\n        return false;\n\n    struct addrinfo *aiTrav = aiRes;\n    while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n    {\n        if (aiTrav->ai_family == AF_INET)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n        }\n\n#ifdef USE_IPV6\n        if (aiTrav->ai_family == AF_INET6)\n        {\n            assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n            vIP.push_back(CNetAddr(((struct sockaddr_in6*)(aiTrav->ai_addr))->sin6_addr));\n        }\n#endif\n\n        aiTrav = aiTrav->ai_next;\n    }\n\n    freeaddrinfo(aiRes);\n\n    return (vIP.size() > 0);\n}"
  },
  {
    "function_name": "SplitHostPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "37-56",
    "snippet": "void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n    size_t colon = in.find_last_of(':');\n    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n    bool fHaveColon = colon != in.npos;\n    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n        char *endp = NULL;\n        int n = strtol(in.c_str() + colon + 1, &endp, 10);\n        if (endp && *endp == 0 && n >= 0) {\n            in = in.substr(0, colon);\n            if (n > 0 && n < 0x10000)\n                portOut = n;\n        }\n    }\n    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n        hostOut = in.substr(1, in.size()-2);\n    else\n        hostOut = in;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in.substr",
          "args": [
            "1",
            "in.size()-2"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.size",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "in.substr",
          "args": [
            "0",
            "colon"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "in.c_str() + colon + 1",
            "&endp",
            "10"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.c_str",
          "args": [],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.find_last_of",
          "args": [
            "':'",
            "colon-1"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in.find_last_of",
          "args": [
            "':'"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nvoid SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n    size_t colon = in.find_last_of(':');\n    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n    bool fHaveColon = colon != in.npos;\n    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n        char *endp = NULL;\n        int n = strtol(in.c_str() + colon + 1, &endp, 10);\n        if (endp && *endp == 0 && n >= 0) {\n            in = in.substr(0, colon);\n            if (n > 0 && n < 0x10000)\n                portOut = n;\n        }\n    }\n    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n        hostOut = in.substr(1, in.size()-2);\n    else\n        hostOut = in;\n}"
  },
  {
    "function_name": "ParseNetwork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
    "lines": "28-35",
    "snippet": "enum Network ParseNetwork(std::string net) {\n    boost::to_lower(net);\n    if (net == \"ipv4\") return NET_IPV4;\n    if (net == \"ipv6\") return NET_IPV6;\n    if (net == \"tor\")  return NET_TOR;\n    if (net == \"i2p\")  return NET_I2P;\n    return NET_UNROUTABLE;\n}",
    "includes": [
      "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
      "#include \"strlcpy.h\"",
      "#include <sys/fcntl.h>",
      "#include \"sync.h\"",
      "#include \"util.h\"",
      "#include \"netbase.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boost::to_lower",
          "args": [
            "net"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nenum Network ParseNetwork(std::string net) {\n    boost::to_lower(net);\n    if (net == \"ipv4\") return NET_IPV4;\n    if (net == \"ipv6\") return NET_IPV6;\n    if (net == \"tor\")  return NET_TOR;\n    if (net == \"i2p\")  return NET_I2P;\n    return NET_UNROUTABLE;\n}"
  }
]