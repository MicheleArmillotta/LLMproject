[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
    "lines": "118-120",
    "snippet": "int main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/memtable.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leveldb::test::RunAllTests",
          "args": [],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "RunAllTests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "36-58",
          "snippet": "int RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nint RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nint main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
    "lines": "90-114",
    "snippet": "TEST(WriteBatchTest, Append) {\n  WriteBatch b1, b2;\n  WriteBatchInternal::SetSequence(&b1, 200);\n  WriteBatchInternal::SetSequence(&b2, 300);\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"\",\n            PrintContents(&b1));\n  b2.Put(\"a\", \"va\");\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"Put(a, va)@200\",\n            PrintContents(&b1));\n  b2.Clear();\n  b2.Put(\"b\", \"vb\");\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"Put(a, va)@200\"\n            \"Put(b, vb)@201\",\n            PrintContents(&b1));\n  b2.Delete(\"foo\");\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"Put(a, va)@200\"\n            \"Put(b, vb)@202\"\n            \"Put(b, vb)@201\"\n            \"Delete(foo)@203\",\n            PrintContents(&b1));\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/memtable.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"Put(a, va)@200\"\n            \"Put(b, vb)@202\"\n            \"Put(b, vb)@201\"\n            \"Delete(foo)@203\"",
            "PrintContents(&b1)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintContents",
          "args": [
            "&b1"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "PrintContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
          "lines": "15-53",
          "snippet": "static std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nstatic std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Append",
          "args": [
            "&b1",
            "&b2"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "Append",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "141-145",
          "snippet": "void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {\n  SetCount(dst, Count(dst) + Count(src));\n  assert(src->rep_.size() >= kHeader);\n  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {\n    SetCount(dst, Count(dst) + Count(src));\n    assert(src->rep_.size() >= kHeader);\n    dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2.Delete",
          "args": [
            "\"foo\""
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "78-81",
          "snippet": "virtual void Delete(const Slice& key) {\n    printf(\"  del '%s'\\n\",\n           EscapeString(key).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Delete(const Slice& key) {\n      printf(\"  del '%s'\\n\",\n             EscapeString(key).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"Put(a, va)@200\"\n            \"Put(b, vb)@201\"",
            "PrintContents(&b1)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b2.Put",
          "args": [
            "\"b\"",
            "\"vb\""
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "73-77",
          "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "b2.Clear",
          "args": [],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "Clear",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "166-166",
          "snippet": "void Clear() { rep_.clear(); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void Clear() { rep_.clear(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"Put(a, va)@200\"",
            "PrintContents(&b1)"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"\"",
            "PrintContents(&b1)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetSequence",
          "args": [
            "&b2",
            "300"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "SetSequence",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "94-96",
          "snippet": "void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n  EncodeFixed64(&b->rep_[0], seq);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n    EncodeFixed64(&b->rep_[0], seq);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nTEST(WriteBatchTest, Append) {\n  WriteBatch b1, b2;\n  WriteBatchInternal::SetSequence(&b1, 200);\n  WriteBatchInternal::SetSequence(&b2, 300);\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"\",\n            PrintContents(&b1));\n  b2.Put(\"a\", \"va\");\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"Put(a, va)@200\",\n            PrintContents(&b1));\n  b2.Clear();\n  b2.Put(\"b\", \"vb\");\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"Put(a, va)@200\"\n            \"Put(b, vb)@201\",\n            PrintContents(&b1));\n  b2.Delete(\"foo\");\n  WriteBatchInternal::Append(&b1, &b2);\n  ASSERT_EQ(\"Put(a, va)@200\"\n            \"Put(b, vb)@202\"\n            \"Put(b, vb)@201\"\n            \"Delete(foo)@203\",\n            PrintContents(&b1));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
    "lines": "77-88",
    "snippet": "TEST(WriteBatchTest, Corruption) {\n  WriteBatch batch;\n  batch.Put(Slice(\"foo\"), Slice(\"bar\"));\n  batch.Delete(Slice(\"box\"));\n  WriteBatchInternal::SetSequence(&batch, 200);\n  Slice contents = WriteBatchInternal::Contents(&batch);\n  WriteBatchInternal::SetContents(&batch,\n                                  Slice(contents.data(),contents.size()-1));\n  ASSERT_EQ(\"Put(foo, bar)@200\"\n            \"ParseError()\",\n            PrintContents(&batch));\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/memtable.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"Put(foo, bar)@200\"\n            \"ParseError()\"",
            "PrintContents(&batch)"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintContents",
          "args": [
            "&batch"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "PrintContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
          "lines": "15-53",
          "snippet": "static std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nstatic std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetContents",
          "args": [
            "&batch",
            "Slice(contents.data(),contents.size()-1)"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "SetContents",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "136-139",
          "snippet": "void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n  assert(contents.size() >= kHeader);\n  b->rep_.assign(contents.data(), contents.size());\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n    assert(contents.size() >= kHeader);\n    b->rep_.assign(contents.data(), contents.size());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "contents.data()",
            "contents.size()-1"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/coding.cc",
          "lines": "182-192",
          "snippet": "bool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}",
          "includes": [
            "#include \"util/coding.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n\nbool GetLengthPrefixedSlice(Slice* input, Slice* result) {\n  uint32_t len;\n  if (GetVarint32(input, &len) &&\n      input->size() >= len) {\n    *result = Slice(input->data(), len);\n    input->remove_prefix(len);\n    return true;\n  } else {\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.size",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "contents.data",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Contents",
          "args": [
            "&batch"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "Contents",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_internal.h",
          "lines": "31-33",
          "snippet": "static Slice Contents(const WriteBatch* batch) {\n    return Slice(batch->rep_);\n  }",
          "includes": [
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  static Slice Contents(const WriteBatch* batch) {\n      return Slice(batch->rep_);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetSequence",
          "args": [
            "&batch",
            "200"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "SetSequence",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "94-96",
          "snippet": "void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n  EncodeFixed64(&b->rep_[0], seq);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n    EncodeFixed64(&b->rep_[0], seq);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Delete",
          "args": [
            "Slice(\"box\")"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "78-81",
          "snippet": "virtual void Delete(const Slice& key) {\n    printf(\"  del '%s'\\n\",\n           EscapeString(key).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Delete(const Slice& key) {\n      printf(\"  del '%s'\\n\",\n             EscapeString(key).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Put",
          "args": [
            "Slice(\"foo\")",
            "Slice(\"bar\")"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "73-77",
          "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nTEST(WriteBatchTest, Corruption) {\n  WriteBatch batch;\n  batch.Put(Slice(\"foo\"), Slice(\"bar\"));\n  batch.Delete(Slice(\"box\"));\n  WriteBatchInternal::SetSequence(&batch, 200);\n  Slice contents = WriteBatchInternal::Contents(&batch);\n  WriteBatchInternal::SetContents(&batch,\n                                  Slice(contents.data(),contents.size()-1));\n  ASSERT_EQ(\"Put(foo, bar)@200\"\n            \"ParseError()\",\n            PrintContents(&batch));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
    "lines": "63-75",
    "snippet": "TEST(WriteBatchTest, Multiple) {\n  WriteBatch batch;\n  batch.Put(Slice(\"foo\"), Slice(\"bar\"));\n  batch.Delete(Slice(\"box\"));\n  batch.Put(Slice(\"baz\"), Slice(\"boo\"));\n  WriteBatchInternal::SetSequence(&batch, 100);\n  ASSERT_EQ(100, WriteBatchInternal::Sequence(&batch));\n  ASSERT_EQ(3, WriteBatchInternal::Count(&batch));\n  ASSERT_EQ(\"Put(baz, boo)@102\"\n            \"Delete(box)@101\"\n            \"Put(foo, bar)@100\",\n            PrintContents(&batch));\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/memtable.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"Put(baz, boo)@102\"\n            \"Delete(box)@101\"\n            \"Put(foo, bar)@100\"",
            "PrintContents(&batch)"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintContents",
          "args": [
            "&batch"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "PrintContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
          "lines": "15-53",
          "snippet": "static std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nstatic std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "3",
            "WriteBatchInternal::Count(&batch)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Count",
          "args": [
            "&batch"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "Count",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "82-84",
          "snippet": "int WriteBatchInternal::Count(const WriteBatch* b) {\n  return DecodeFixed32(b->rep_.data() + 8);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  int WriteBatchInternal::Count(const WriteBatch* b) {\n    return DecodeFixed32(b->rep_.data() + 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "100",
            "WriteBatchInternal::Sequence(&batch)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Sequence",
          "args": [
            "&batch"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "Sequence",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "90-92",
          "snippet": "SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {\n  return SequenceNumber(DecodeFixed64(b->rep_.data()));\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {\n    return SequenceNumber(DecodeFixed64(b->rep_.data()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetSequence",
          "args": [
            "&batch",
            "100"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "SetSequence",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "94-96",
          "snippet": "void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n  EncodeFixed64(&b->rep_[0], seq);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {\n    EncodeFixed64(&b->rep_[0], seq);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Put",
          "args": [
            "Slice(\"baz\")",
            "Slice(\"boo\")"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "73-77",
          "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Slice",
          "args": [
            "\"boo\""
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "GetLengthPrefixedSlice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.cc",
          "lines": "14-19",
          "snippet": "static Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/memtable.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"db/dbformat.h\"\n#include \"db/memtable.h\"\n\nstatic Slice GetLengthPrefixedSlice(const char* data) {\n  uint32_t len;\n  const char* p = data;\n  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume \"p\" is not corrupted\n  return Slice(p, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Delete",
          "args": [
            "Slice(\"box\")"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "WriteBatchItemPrinter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "78-81",
          "snippet": "virtual void Delete(const Slice& key) {\n    printf(\"  del '%s'\\n\",\n           EscapeString(key).c_str());\n  }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Delete(const Slice& key) {\n      printf(\"  del '%s'\\n\",\n             EscapeString(key).c_str());\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nTEST(WriteBatchTest, Multiple) {\n  WriteBatch batch;\n  batch.Put(Slice(\"foo\"), Slice(\"bar\"));\n  batch.Delete(Slice(\"box\"));\n  batch.Put(Slice(\"baz\"), Slice(\"boo\"));\n  WriteBatchInternal::SetSequence(&batch, 100);\n  ASSERT_EQ(100, WriteBatchInternal::Sequence(&batch));\n  ASSERT_EQ(3, WriteBatchInternal::Count(&batch));\n  ASSERT_EQ(\"Put(baz, boo)@102\"\n            \"Delete(box)@101\"\n            \"Put(foo, bar)@100\",\n            PrintContents(&batch));\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
    "lines": "57-61",
    "snippet": "TEST(WriteBatchTest, Empty) {\n  WriteBatch batch;\n  ASSERT_EQ(\"\", PrintContents(&batch));\n  ASSERT_EQ(0, WriteBatchInternal::Count(&batch));\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/memtable.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "0",
            "WriteBatchInternal::Count(&batch)"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Count",
          "args": [
            "&batch"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "Count",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "82-84",
          "snippet": "int WriteBatchInternal::Count(const WriteBatch* b) {\n  return DecodeFixed32(b->rep_.data() + 8);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  int WriteBatchInternal::Count(const WriteBatch* b) {\n    return DecodeFixed32(b->rep_.data() + 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_EQ",
          "args": [
            "\"\"",
            "PrintContents(&batch)"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintContents",
          "args": [
            "&batch"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "PrintContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
          "lines": "15-53",
          "snippet": "static std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}",
          "includes": [
            "#include \"util/testharness.h\"",
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nstatic std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nTEST(WriteBatchTest, Empty) {\n  WriteBatch batch;\n  ASSERT_EQ(\"\", PrintContents(&batch));\n  ASSERT_EQ(0, WriteBatchInternal::Count(&batch));\n}"
  },
  {
    "function_name": "PrintContents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch_test.cc",
    "lines": "15-53",
    "snippet": "static std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}",
    "includes": [
      "#include \"util/testharness.h\"",
      "#include \"util/logging.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/memtable.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem->Unref",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "Unref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "30-36",
          "snippet": "void Unref() {\n    --refs_;\n    assert(refs_ >= 0);\n    if (refs_ <= 0) {\n      delete this;\n    }\n  }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Unref() {\n      --refs_;\n      assert(refs_ >= 0);\n      if (refs_ <= 0) {\n        delete this;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\"CountMismatch()\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Count",
          "args": [
            "b"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "Count",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "82-84",
          "snippet": "int WriteBatchInternal::Count(const WriteBatch* b) {\n  return DecodeFixed32(b->rep_.data() + 8);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  int WriteBatchInternal::Count(const WriteBatch* b) {\n    return DecodeFixed32(b->rep_.data() + 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\"ParseError()\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "NumberToString(ikey.sequence)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NumberToString",
          "args": [
            "ikey.sequence"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "NumberToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "36-40",
          "snippet": "std::string NumberToString(uint64_t num) {\n  std::string r;\n  AppendNumberTo(&r, num);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string NumberToString(uint64_t num) {\n  std::string r;\n  AppendNumberTo(&r, num);\n  return r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\"@\""
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\")\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "ikey.user_key.ToString()"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ikey.user_key.ToString",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\"Delete(\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\")\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "iter->value().ToString()"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\", \""
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "ikey.user_key.ToString()"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "state.append",
          "args": [
            "\"Put(\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_TRUE",
          "args": [
            "ParseInternalKey(iter->key(), &ikey)"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "iter->key()",
            "&ikey"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->NewIterator",
          "args": [],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::InsertInto",
          "args": [
            "b",
            "mem"
          ],
          "line": 20
        },
        "resolved": true,
        "details": {
          "function_name": "InsertInto",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "128-134",
          "snippet": "Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                      MemTable* memtable) {\n  MemTableInserter inserter;\n  inserter.sequence_ = WriteBatchInternal::Sequence(b);\n  inserter.mem_ = memtable;\n  return b->Iterate(&inserter);\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  Status WriteBatchInternal::InsertInto(const WriteBatch* b,\n                                        MemTable* memtable) {\n    MemTableInserter inserter;\n    inserter.sequence_ = WriteBatchInternal::Sequence(b);\n    inserter.mem_ = memtable;\n    return b->Iterate(&inserter);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem->Ref",
          "args": [],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "Ref",
          "container": "MemTable",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/memtable.h",
          "lines": "27-27",
          "snippet": "void Ref() { ++refs_; }",
          "includes": [
            "#include \"util/arena.h\"",
            "#include \"db/skiplist.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/arena.h\"\n#include \"db/skiplist.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include <string>\n\nMemTable {\n  void Ref() { ++refs_; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testharness.h\"\n#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"leveldb/db.h\"\n\nstatic std::string PrintContents(WriteBatch* b) {\n  InternalKeyComparator cmp(BytewiseComparator());\n  MemTable* mem = new MemTable(cmp);\n  mem->Ref();\n  std::string state;\n  Status s = WriteBatchInternal::InsertInto(b, mem);\n  int count = 0;\n  Iterator* iter = mem->NewIterator();\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey ikey;\n    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));\n    switch (ikey.type) {\n      case kTypeValue:\n        state.append(\"Put(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\", \");\n        state.append(iter->value().ToString());\n        state.append(\")\");\n        count++;\n        break;\n      case kTypeDeletion:\n        state.append(\"Delete(\");\n        state.append(ikey.user_key.ToString());\n        state.append(\")\");\n        count++;\n        break;\n    }\n    state.append(\"@\");\n    state.append(NumberToString(ikey.sequence));\n  }\n  delete iter;\n  if (!s.ok()) {\n    state.append(\"ParseError()\");\n  } else if (count != WriteBatchInternal::Count(b)) {\n    state.append(\"CountMismatch()\");\n  }\n  mem->Unref();\n  return state;\n}"
  }
]