[
  {
    "function_name": "CCrypter",
    "container": "CCrypter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.h",
    "lines": "104-113",
    "snippet": "CCrypter()\n    {\n        fKeySet = false;\n\n        // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n        // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n        // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.\n        LockedPageManager::instance.LockRange(&chKey[0], sizeof chKey);\n        LockedPageManager::instance.LockRange(&chIV[0], sizeof chIV);\n    }",
    "includes": [
      "#include \"serialize.h\"",
      "#include \"key.h\"",
      "#include \"allocators.h\" /* for SecureString */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LockedPageManager::instance.LockRange",
          "args": [
            "&chIV[0]",
            "sizeof chIV"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "LockRange",
          "container": "LockedPageManagerBase",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/allocators.h",
          "lines": "56-76",
          "snippet": "void LockRange(void *p, size_t size)\n    {\n        boost::mutex::scoped_lock lock(mutex);\n        if(!size) return;\n        const size_t base_addr = reinterpret_cast<size_t>(p);\n        const size_t start_page = base_addr & page_mask;\n        const size_t end_page = (base_addr + size - 1) & page_mask;\n        for(size_t page = start_page; page <= end_page; page += page_size)\n        {\n            Histogram::iterator it = histogram.find(page);\n            if(it == histogram.end()) // Newly locked page\n            {\n                locker.Lock(reinterpret_cast<void*>(page), page_size);\n                histogram.insert(std::make_pair(page, 1));\n            }\n            else // Page was already locked; increase counter\n            {\n                it->second += 1;\n            }\n        }\n    }",
          "includes": [
            "#include <unistd.h> // for sysconf",
            "#include <limits.h> // for PAGESIZE",
            "#include <sys/mman.h>",
            "#include <windows.h>",
            "#include <map>",
            "#include <boost/thread/mutex.hpp>",
            "#include <string>",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h> // for sysconf\n#include <limits.h> // for PAGESIZE\n#include <sys/mman.h>\n#include <windows.h>\n#include <map>\n#include <boost/thread/mutex.hpp>\n#include <string>\n#include <string.h>\n\nLockedPageManagerBase {\n  void LockRange(void *p, size_t size)\n      {\n          boost::mutex::scoped_lock lock(mutex);\n          if(!size) return;\n          const size_t base_addr = reinterpret_cast<size_t>(p);\n          const size_t start_page = base_addr & page_mask;\n          const size_t end_page = (base_addr + size - 1) & page_mask;\n          for(size_t page = start_page; page <= end_page; page += page_size)\n          {\n              Histogram::iterator it = histogram.find(page);\n              if(it == histogram.end()) // Newly locked page\n              {\n                  locker.Lock(reinterpret_cast<void*>(page), page_size);\n                  histogram.insert(std::make_pair(page, 1));\n              }\n              else // Page was already locked; increase counter\n              {\n                  it->second += 1;\n              }\n          }\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"serialize.h\"\n#include \"key.h\"\n#include \"allocators.h\" /* for SecureString */\n\nCCrypter {\n  CCrypter()\n      {\n          fKeySet = false;\n  \n          // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)\n          // Note that this does nothing about suspend-to-disk (which will put all our key data on disk)\n          // Note as well that at no point in this program is any attempt made to prevent stealing of keys by reading the memory of the running process.\n          LockedPageManager::instance.LockRange(&chKey[0], sizeof chKey);\n          LockedPageManager::instance.LockRange(&chIV[0], sizeof chIV);\n      }\n}"
  },
  {
    "function_name": "CleanKey",
    "container": "CCrypter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.h",
    "lines": "97-102",
    "snippet": "void CleanKey()\n    {\n        OPENSSL_cleanse(&chKey, sizeof chKey);\n        OPENSSL_cleanse(&chIV, sizeof chIV);\n        fKeySet = false;\n    }",
    "includes": [
      "#include \"serialize.h\"",
      "#include \"key.h\"",
      "#include \"allocators.h\" /* for SecureString */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "OPENSSL_cleanse",
          "args": [
            "&chIV",
            "sizeof chIV"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPENSSL_cleanse",
          "args": [
            "&chKey",
            "sizeof chKey"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"serialize.h\"\n#include \"key.h\"\n#include \"allocators.h\" /* for SecureString */\n\nCCrypter {\n  void CleanKey()\n      {\n          OPENSSL_cleanse(&chKey, sizeof chKey);\n          OPENSSL_cleanse(&chIV, sizeof chIV);\n          fKeySet = false;\n      }\n}"
  },
  {
    "function_name": "CMasterKey",
    "container": "CMasterKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.h",
    "lines": "60-77",
    "snippet": "CMasterKey(unsigned int nDerivationMethodIndex)\n    {\n        switch (nDerivationMethodIndex)\n        {\n            case 0: // sha512\n            default:\n                nDeriveIterations = 25000;\n                nDerivationMethod = 0;\n                vchOtherDerivationParameters = std::vector<unsigned char>(0);\n            break;\n\n            case 1: // scrypt+sha512\n                nDeriveIterations = 10000;\n                nDerivationMethod = 1;\n                vchOtherDerivationParameters = std::vector<unsigned char>(0);\n            break;\n        }\n    }",
    "includes": [
      "#include \"serialize.h\"",
      "#include \"key.h\"",
      "#include \"allocators.h\" /* for SecureString */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::vector<unsigned char>",
          "args": [
            "0"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "std::vector<unsigned char>",
          "args": [
            "0"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"serialize.h\"\n#include \"key.h\"\n#include \"allocators.h\" /* for SecureString */\n\nCMasterKey {\n  CMasterKey(unsigned int nDerivationMethodIndex)\n      {\n          switch (nDerivationMethodIndex)\n          {\n              case 0: // sha512\n              default:\n                  nDeriveIterations = 25000;\n                  nDerivationMethod = 0;\n                  vchOtherDerivationParameters = std::vector<unsigned char>(0);\n              break;\n  \n              case 1: // scrypt+sha512\n                  nDeriveIterations = 10000;\n                  nDerivationMethod = 1;\n                  vchOtherDerivationParameters = std::vector<unsigned char>(0);\n              break;\n          }\n      }\n}"
  },
  {
    "function_name": "CMasterKey",
    "container": "CMasterKey",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/crypter.h",
    "lines": "51-58",
    "snippet": "CMasterKey()\n    {\n        // 25000 rounds is just under 0.1 seconds on a 1.86 GHz Pentium M\n        // ie slightly lower than the lowest hardware we need bother supporting\n        nDeriveIterations = 25000;\n        nDerivationMethod = 1;\n        vchOtherDerivationParameters = std::vector<unsigned char>(0);\n    }",
    "includes": [
      "#include \"serialize.h\"",
      "#include \"key.h\"",
      "#include \"allocators.h\" /* for SecureString */"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::vector<unsigned char>",
          "args": [
            "0"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"serialize.h\"\n#include \"key.h\"\n#include \"allocators.h\" /* for SecureString */\n\nCMasterKey {\n  CMasterKey()\n      {\n          // 25000 rounds is just under 0.1 seconds on a 1.86 GHz Pentium M\n          // ie slightly lower than the lowest hardware we need bother supporting\n          nDeriveIterations = 25000;\n          nDerivationMethod = 1;\n          vchOtherDerivationParameters = std::vector<unsigned char>(0);\n      }\n}"
  }
]