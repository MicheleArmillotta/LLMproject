[
  {
    "function_name": "UpdateEmptyFull",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "171-182",
    "snippet": "void CBloomFilter::UpdateEmptyFull()\n{\n    bool full = true;\n    bool empty = true;\n    for (unsigned int i = 0; i < vData.size(); i++)\n    {\n        full &= vData[i] == 0xff;\n        empty &= vData[i] == 0;\n    }\n    isFull = full;\n    isEmpty = empty;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vData.size",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::UpdateEmptyFull()\n  {\n      bool full = true;\n      bool empty = true;\n      for (unsigned int i = 0; i < vData.size(); i++)\n      {\n          full &= vData[i] == 0xff;\n          empty &= vData[i] == 0;\n      }\n      isFull = full;\n      isEmpty = empty;\n  }\n}"
  },
  {
    "function_name": "IsRelevantAndUpdate",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "102-169",
    "snippet": "bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx, const uint256& hash)\n{\n    bool fFound = false;\n    // Match if the filter contains the hash of tx\n    //  for finding tx when they appear in a block\n    if (isFull)\n        return true;\n    if (isEmpty)\n        return false;\n    if (contains(hash))\n        fFound = true;\n\n    for (unsigned int i = 0; i < tx.vout.size(); i++)\n    {\n        const CTxOut& txout = tx.vout[i];\n        // Match if the filter contains any arbitrary script data element in any scriptPubKey in tx\n        // If this matches, also add the specific output that was matched.\n        // This means clients don't have to update the filter themselves when a new relevant tx \n        // is discovered in order to find spending transactions, which avoids round-tripping and race conditions.\n        CScript::const_iterator pc = txout.scriptPubKey.begin();\n        vector<unsigned char> data;\n        while (pc < txout.scriptPubKey.end())\n        {\n            opcodetype opcode;\n            if (!txout.scriptPubKey.GetOp(pc, opcode, data))\n                break;\n            if (data.size() != 0 && contains(data))\n            {\n                fFound = true;\n                if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_ALL)\n                    insert(COutPoint(hash, i));\n                else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY)\n                {\n                    txnouttype type;\n                    vector<vector<unsigned char> > vSolutions;\n                    if (Solver(txout.scriptPubKey, type, vSolutions) &&\n                            (type == TX_PUBKEY || type == TX_MULTISIG))\n                        insert(COutPoint(hash, i));\n                }\n                break;\n            }\n        }\n    }\n\n    if (fFound)\n        return true;\n\n    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n    {\n        // Match if the filter contains an outpoint tx spends\n        if (contains(txin.prevout))\n            return true;\n\n        // Match if the filter contains any arbitrary script data element in any scriptSig in tx\n        CScript::const_iterator pc = txin.scriptSig.begin();\n        vector<unsigned char> data;\n        while (pc < txin.scriptSig.end())\n        {\n            opcodetype opcode;\n            if (!txin.scriptSig.GetOp(pc, opcode, data))\n                break;\n            if (data.size() != 0 && contains(data))\n                return true;\n        }\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "contains",
          "args": [
            "data"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "contains",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "91-95",
          "snippet": "bool CBloomFilter::contains(const uint256& hash) const\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    return contains(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  bool CBloomFilter::contains(const uint256& hash) const\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      return contains(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.GetOp",
          "args": [
            "pc",
            "opcode",
            "data"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "GetOp",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "408-411",
          "snippet": "bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n    {\n        return GetOp2(pc, opcodeRet, &vchRet);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n      {\n          return GetOp2(pc, opcodeRet, &vchRet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.end",
          "args": [],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txin.scriptSig.begin",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert",
          "args": [
            "COutPoint(hash, i)"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "COutPoint",
          "args": [
            "hash",
            "i"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "COutPoint",
          "container": "COutPoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "227-227",
          "snippet": "COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCOutPoint {\n  COutPoint(uint256 hashIn, unsigned int nIn) { hash = hashIn; n = nIn; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "txout.scriptPubKey",
            "type",
            "vSolutions"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx, const uint256& hash)\n  {\n      bool fFound = false;\n      // Match if the filter contains the hash of tx\n      //  for finding tx when they appear in a block\n      if (isFull)\n          return true;\n      if (isEmpty)\n          return false;\n      if (contains(hash))\n          fFound = true;\n  \n      for (unsigned int i = 0; i < tx.vout.size(); i++)\n      {\n          const CTxOut& txout = tx.vout[i];\n          // Match if the filter contains any arbitrary script data element in any scriptPubKey in tx\n          // If this matches, also add the specific output that was matched.\n          // This means clients don't have to update the filter themselves when a new relevant tx \n          // is discovered in order to find spending transactions, which avoids round-tripping and race conditions.\n          CScript::const_iterator pc = txout.scriptPubKey.begin();\n          vector<unsigned char> data;\n          while (pc < txout.scriptPubKey.end())\n          {\n              opcodetype opcode;\n              if (!txout.scriptPubKey.GetOp(pc, opcode, data))\n                  break;\n              if (data.size() != 0 && contains(data))\n              {\n                  fFound = true;\n                  if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_ALL)\n                      insert(COutPoint(hash, i));\n                  else if ((nFlags & BLOOM_UPDATE_MASK) == BLOOM_UPDATE_P2PUBKEY_ONLY)\n                  {\n                      txnouttype type;\n                      vector<vector<unsigned char> > vSolutions;\n                      if (Solver(txout.scriptPubKey, type, vSolutions) &&\n                              (type == TX_PUBKEY || type == TX_MULTISIG))\n                          insert(COutPoint(hash, i));\n                  }\n                  break;\n              }\n          }\n      }\n  \n      if (fFound)\n          return true;\n  \n      BOOST_FOREACH(const CTxIn& txin, tx.vin)\n      {\n          // Match if the filter contains an outpoint tx spends\n          if (contains(txin.prevout))\n              return true;\n  \n          // Match if the filter contains any arbitrary script data element in any scriptSig in tx\n          CScript::const_iterator pc = txin.scriptSig.begin();\n          vector<unsigned char> data;\n          while (pc < txin.scriptSig.end())\n          {\n              opcodetype opcode;\n              if (!txin.scriptSig.GetOp(pc, opcode, data))\n                  break;\n              if (data.size() != 0 && contains(data))\n                  return true;\n          }\n      }\n  \n      return false;\n  }\n}"
  },
  {
    "function_name": "IsWithinSizeConstraints",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "97-100",
    "snippet": "bool CBloomFilter::IsWithinSizeConstraints() const\n{\n    return vData.size() <= MAX_BLOOM_FILTER_SIZE && nHashFuncs <= MAX_HASH_FUNCS;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vData.size",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  bool CBloomFilter::IsWithinSizeConstraints() const\n  {\n      return vData.size() <= MAX_BLOOM_FILTER_SIZE && nHashFuncs <= MAX_HASH_FUNCS;\n  }\n}"
  },
  {
    "function_name": "contains",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "91-95",
    "snippet": "bool CBloomFilter::contains(const uint256& hash) const\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    return contains(data);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "contains",
          "args": [
            "data"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "contains",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "91-95",
          "snippet": "bool CBloomFilter::contains(const uint256& hash) const\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    return contains(data);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  bool CBloomFilter::contains(const uint256& hash) const\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      return contains(data);\n  }\n}"
  },
  {
    "function_name": "contains",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "83-89",
    "snippet": "bool CBloomFilter::contains(const COutPoint& outpoint) const\n{\n    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n    stream << outpoint;\n    vector<unsigned char> data(stream.begin(), stream.end());\n    return contains(data);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "contains",
          "args": [
            "data"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "contains",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "91-95",
          "snippet": "bool CBloomFilter::contains(const uint256& hash) const\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    return contains(data);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "stream.end",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stream.begin",
          "args": [],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  bool CBloomFilter::contains(const COutPoint& outpoint) const\n  {\n      CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n      stream << outpoint;\n      vector<unsigned char> data(stream.begin(), stream.end());\n      return contains(data);\n  }\n}"
  },
  {
    "function_name": "contains",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "67-81",
    "snippet": "bool CBloomFilter::contains(const vector<unsigned char>& vKey) const\n{\n    if (isFull)\n        return true;\n    if (isEmpty)\n        return false;\n    for (unsigned int i = 0; i < nHashFuncs; i++)\n    {\n        unsigned int nIndex = Hash(i, vKey);\n        // Checks bit nIndex of vData\n        if (!(vData[nIndex >> 3] & bit_mask[7 & nIndex]))\n            return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned char bit_mask[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "i",
            "vKey"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nstatic const unsigned char bit_mask[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};\n\nCBloomFilter {\n  bool CBloomFilter::contains(const vector<unsigned char>& vKey) const\n  {\n      if (isFull)\n          return true;\n      if (isEmpty)\n          return false;\n      for (unsigned int i = 0; i < nHashFuncs; i++)\n      {\n          unsigned int nIndex = Hash(i, vKey);\n          // Checks bit nIndex of vData\n          if (!(vData[nIndex >> 3] & bit_mask[7 & nIndex]))\n              return false;\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "insert",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "61-65",
    "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert",
          "args": [
            "data"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
  },
  {
    "function_name": "insert",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "53-59",
    "snippet": "void CBloomFilter::insert(const COutPoint& outpoint)\n{\n    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n    stream << outpoint;\n    vector<unsigned char> data(stream.begin(), stream.end());\n    insert(data);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert",
          "args": [
            "data"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "stream.end",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stream.begin",
          "args": [],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const COutPoint& outpoint)\n  {\n      CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n      stream << outpoint;\n      vector<unsigned char> data(stream.begin(), stream.end());\n      insert(data);\n  }\n}"
  },
  {
    "function_name": "insert",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "40-51",
    "snippet": "void CBloomFilter::insert(const vector<unsigned char>& vKey)\n{\n    if (isFull)\n        return;\n    for (unsigned int i = 0; i < nHashFuncs; i++)\n    {\n        unsigned int nIndex = Hash(i, vKey);\n        // Sets bit nIndex of vData\n        vData[nIndex >> 3] |= bit_mask[7 & nIndex];\n    }\n    isEmpty = false;\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned char bit_mask[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "i",
            "vKey"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nstatic const unsigned char bit_mask[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};\n\nCBloomFilter {\n  void CBloomFilter::insert(const vector<unsigned char>& vKey)\n  {\n      if (isFull)\n          return;\n      for (unsigned int i = 0; i < nHashFuncs; i++)\n      {\n          unsigned int nIndex = Hash(i, vKey);\n          // Sets bit nIndex of vData\n          vData[nIndex >> 3] |= bit_mask[7 & nIndex];\n      }\n      isEmpty = false;\n  }\n}"
  },
  {
    "function_name": "Hash",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "34-38",
    "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vData.size",
          "args": [],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "MurmurHash3",
          "args": [
            "nHashNum * 0xFBA4C795 + nTweak",
            "vDataToHash"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "MurmurHash3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/hash.cpp",
          "lines": "8-58",
          "snippet": "unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash)\n{\n    // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n    uint32_t h1 = nHashSeed;\n    const uint32_t c1 = 0xcc9e2d51;\n    const uint32_t c2 = 0x1b873593;\n\n    const int nblocks = vDataToHash.size() / 4;\n\n    //----------\n    // body\n    const uint32_t * blocks = (const uint32_t *)(&vDataToHash[0] + nblocks*4);\n\n    for(int i = -nblocks; i; i++)\n    {\n        uint32_t k1 = blocks[i];\n\n        k1 *= c1;\n        k1 = ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = ROTL32(h1,13); \n        h1 = h1*5+0xe6546b64;\n    }\n\n    //----------\n    // tail\n    const uint8_t * tail = (const uint8_t*)(&vDataToHash[0] + nblocks*4);\n\n    uint32_t k1 = 0;\n\n    switch(vDataToHash.size() & 3)\n    {\n    case 3: k1 ^= tail[2] << 16;\n    case 2: k1 ^= tail[1] << 8;\n    case 1: k1 ^= tail[0];\n            k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;\n    };\n\n    //----------\n    // finalization\n    h1 ^= vDataToHash.size();\n    h1 ^= h1 >> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >> 16;\n\n    return h1;\n}",
          "includes": [
            "#include \"hash.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n\nunsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash)\n{\n    // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n    uint32_t h1 = nHashSeed;\n    const uint32_t c1 = 0xcc9e2d51;\n    const uint32_t c2 = 0x1b873593;\n\n    const int nblocks = vDataToHash.size() / 4;\n\n    //----------\n    // body\n    const uint32_t * blocks = (const uint32_t *)(&vDataToHash[0] + nblocks*4);\n\n    for(int i = -nblocks; i; i++)\n    {\n        uint32_t k1 = blocks[i];\n\n        k1 *= c1;\n        k1 = ROTL32(k1,15);\n        k1 *= c2;\n\n        h1 ^= k1;\n        h1 = ROTL32(h1,13); \n        h1 = h1*5+0xe6546b64;\n    }\n\n    //----------\n    // tail\n    const uint8_t * tail = (const uint8_t*)(&vDataToHash[0] + nblocks*4);\n\n    uint32_t k1 = 0;\n\n    switch(vDataToHash.size() & 3)\n    {\n    case 3: k1 ^= tail[2] << 16;\n    case 2: k1 ^= tail[1] << 8;\n    case 1: k1 ^= tail[0];\n            k1 *= c1; k1 = ROTL32(k1,15); k1 *= c2; h1 ^= k1;\n    };\n\n    //----------\n    // finalization\n    h1 ^= vDataToHash.size();\n    h1 ^= h1 >> 16;\n    h1 *= 0x85ebca6b;\n    h1 ^= h1 >> 13;\n    h1 *= 0xc2b2ae35;\n    h1 ^= h1 >> 16;\n\n    return h1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
  },
  {
    "function_name": "CBloomFilter",
    "container": "CBloomFilter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
    "lines": "18-32",
    "snippet": "CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n// The ideal size for a bloom filter with a given number of elements and false positive rate is:\n// - nElements * log(fp rate) / ln(2)^2\n// We ignore filter parameters which will create a bloom filter larger than the protocol limits\nvData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n// The ideal number of hash functions is filter size * ln(2) / number of elements\n// Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n// See http://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\nisFull(false),\nisEmpty(false),\nnHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\nnTweak(nTweakIn),\nnFlags(nFlagsIn)\n{\n}",
    "includes": [
      "#include \"hash.h\"",
      "#include \"script.h\"",
      "#include \"main.h\"",
      "#include \"bloom.h\"",
      "#include <stdlib.h>",
      "#include <math.h>"
    ],
    "macros_used": [
      "#define LN2 0.6931471805599453094172321214581765680755001343602552",
      "#define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(unsigned int)(vData.size() * 8 / nElements * LN2)",
            "MAX_HASH_FUNCS"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "TimingResistantEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "569-576",
          "snippet": "bool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\nbool TimingResistantEqual(const T& a, const T& b)\n{\n    if (b.size() == 0) return a.size() == 0;\n    size_t accumulator = a.size() ^ b.size();\n    for (size_t i = 0; i < a.size(); i++)\n        accumulator |= a[i] ^ b[i%b.size()];\n    return accumulator == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vData.size",
          "args": [],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "log",
          "args": [
            "nFPRate"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "on_chkReqPayment_toggled",
          "container": "QRCodeDialog",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/qt/qrcodedialog.cpp",
          "lines": "155-162",
          "snippet": "void QRCodeDialog::on_chkReqPayment_toggled(bool fChecked)\n{\n    if (!fChecked)\n        // if chkReqPayment is not active, don't display lnReqAmount as invalid\n        ui->lnReqAmount->setValid(true);\n\n    genCode();\n}",
          "includes": [
            "#include <qrencode.h>",
            "#include <QUrl>",
            "#include <QPixmap>",
            "#include \"optionsmodel.h\"",
            "#include \"guiutil.h\"",
            "#include \"guiconstants.h\"",
            "#include \"bitcoinunits.h\"",
            "#include \"ui_qrcodedialog.h\"",
            "#include \"qrcodedialog.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <qrencode.h>\n#include <QUrl>\n#include <QPixmap>\n#include \"optionsmodel.h\"\n#include \"guiutil.h\"\n#include \"guiconstants.h\"\n#include \"bitcoinunits.h\"\n#include \"ui_qrcodedialog.h\"\n#include \"qrcodedialog.h\"\n\nQRCodeDialog {\n  void QRCodeDialog::on_chkReqPayment_toggled(bool fChecked)\n  {\n      if (!fChecked)\n          // if chkReqPayment is not active, don't display lnReqAmount as invalid\n          ui->lnReqAmount->setValid(true);\n  \n      genCode();\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\n#define LN2 0.6931471805599453094172321214581765680755001343602552\n#define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n\nCBloomFilter {\n  CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n  // The ideal size for a bloom filter with a given number of elements and false positive rate is:\n  // - nElements * log(fp rate) / ln(2)^2\n  // We ignore filter parameters which will create a bloom filter larger than the protocol limits\n  vData(min((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)), MAX_BLOOM_FILTER_SIZE * 8) / 8),\n  // The ideal number of hash functions is filter size * ln(2) / number of elements\n  // Again, we ignore filter parameters which will create a bloom filter with more hash functions than the protocol limits\n  // See http://en.wikipedia.org/wiki/Bloom_filter for an explanation of these formulas\n  isFull(false),\n  isEmpty(false),\n  nHashFuncs(min((unsigned int)(vData.size() * 8 / nElements * LN2), MAX_HASH_FUNCS)),\n  nTweak(nTweakIn),\n  nFlags(nFlagsIn)\n  {\n  }\n}"
  }
]