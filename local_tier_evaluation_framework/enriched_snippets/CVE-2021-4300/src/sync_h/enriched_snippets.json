[
  {
    "function_name": "CSemaphoreGrant",
    "container": "CSemaphoreGrant",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "196-201",
    "snippet": "CSemaphoreGrant(CSemaphore &sema, bool fTry = false) : sem(&sema), fHaveGrant(false) {\n        if (fTry)\n            TryAcquire();\n        else\n            Acquire();\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Acquire",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "TryAcquire",
          "container": "CSemaphoreGrant",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "180-184",
          "snippet": "bool TryAcquire() {\n        if (!fHaveGrant && sem->try_wait())\n            fHaveGrant = true;\n        return fHaveGrant;\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  bool TryAcquire() {\n          if (!fHaveGrant && sem->try_wait())\n              fHaveGrant = true;\n          return fHaveGrant;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  CSemaphoreGrant(CSemaphore &sema, bool fTry = false) : sem(&sema), fHaveGrant(false) {\n          if (fTry)\n              TryAcquire();\n          else\n              Acquire();\n      }\n}"
  },
  {
    "function_name": "CSemaphoreGrant",
    "container": "CSemaphoreGrant",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "194-194",
    "snippet": "CSemaphoreGrant() : sem(NULL), fHaveGrant(false) {}",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  CSemaphoreGrant() : sem(NULL), fHaveGrant(false) {}\n}"
  },
  {
    "function_name": "MoveTo",
    "container": "CSemaphoreGrant",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "186-192",
    "snippet": "void MoveTo(CSemaphoreGrant &grant) {\n        grant.Release();\n        grant.sem = sem;\n        grant.fHaveGrant = fHaveGrant;\n        sem = NULL;\n        fHaveGrant = false;\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "grant.Release",
          "args": [],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "Release",
          "container": "CSemaphoreGrant",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "173-178",
          "snippet": "void Release() {\n        if (!fHaveGrant)\n            return;\n        sem->post();\n        fHaveGrant = false;\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  void Release() {\n          if (!fHaveGrant)\n              return;\n          sem->post();\n          fHaveGrant = false;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  void MoveTo(CSemaphoreGrant &grant) {\n          grant.Release();\n          grant.sem = sem;\n          grant.fHaveGrant = fHaveGrant;\n          sem = NULL;\n          fHaveGrant = false;\n      }\n}"
  },
  {
    "function_name": "TryAcquire",
    "container": "CSemaphoreGrant",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "180-184",
    "snippet": "bool TryAcquire() {\n        if (!fHaveGrant && sem->try_wait())\n            fHaveGrant = true;\n        return fHaveGrant;\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sem->try_wait",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait",
          "container": "CSemaphore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "141-147",
          "snippet": "bool try_wait() {\n        boost::unique_lock<boost::mutex> lock(mutex);\n        if (value < 1)\n            return false;\n        value--;\n        return true;\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  bool try_wait() {\n          boost::unique_lock<boost::mutex> lock(mutex);\n          if (value < 1)\n              return false;\n          value--;\n          return true;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  bool TryAcquire() {\n          if (!fHaveGrant && sem->try_wait())\n              fHaveGrant = true;\n          return fHaveGrant;\n      }\n}"
  },
  {
    "function_name": "Release",
    "container": "CSemaphoreGrant",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "173-178",
    "snippet": "void Release() {\n        if (!fHaveGrant)\n            return;\n        sem->post();\n        fHaveGrant = false;\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sem->post",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "post",
          "container": "CSemaphore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "149-155",
          "snippet": "void post() {\n        {\n            boost::unique_lock<boost::mutex> lock(mutex);\n            value++;\n        }\n        condition.notify_one();\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  void post() {\n          {\n              boost::unique_lock<boost::mutex> lock(mutex);\n              value++;\n          }\n          condition.notify_one();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  void Release() {\n          if (!fHaveGrant)\n              return;\n          sem->post();\n          fHaveGrant = false;\n      }\n}"
  },
  {
    "function_name": "Acquire",
    "container": "CSemaphoreGrant",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "166-171",
    "snippet": "void Acquire() {\n        if (fHaveGrant)\n            return;\n        sem->wait();\n        fHaveGrant = true;\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sem->wait",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "wait",
          "container": "CSemaphore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "133-139",
          "snippet": "void wait() {\n        boost::unique_lock<boost::mutex> lock(mutex);\n        while (value < 1) {\n            condition.wait(lock);\n        }\n        value--;\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  void wait() {\n          boost::unique_lock<boost::mutex> lock(mutex);\n          while (value < 1) {\n              condition.wait(lock);\n          }\n          value--;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphoreGrant {\n  void Acquire() {\n          if (fHaveGrant)\n              return;\n          sem->wait();\n          fHaveGrant = true;\n      }\n}"
  },
  {
    "function_name": "post",
    "container": "CSemaphore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "149-155",
    "snippet": "void post() {\n        {\n            boost::unique_lock<boost::mutex> lock(mutex);\n            value++;\n        }\n        condition.notify_one();\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "condition.notify_one",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  void post() {\n          {\n              boost::unique_lock<boost::mutex> lock(mutex);\n              value++;\n          }\n          condition.notify_one();\n      }\n}"
  },
  {
    "function_name": "try_wait",
    "container": "CSemaphore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "141-147",
    "snippet": "bool try_wait() {\n        boost::unique_lock<boost::mutex> lock(mutex);\n        if (value < 1)\n            return false;\n        value--;\n        return true;\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  bool try_wait() {\n          boost::unique_lock<boost::mutex> lock(mutex);\n          if (value < 1)\n              return false;\n          value--;\n          return true;\n      }\n}"
  },
  {
    "function_name": "wait",
    "container": "CSemaphore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "133-139",
    "snippet": "void wait() {\n        boost::unique_lock<boost::mutex> lock(mutex);\n        while (value < 1) {\n            condition.wait(lock);\n        }\n        value--;\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "condition.wait",
          "args": [
            "lock"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  void wait() {\n          boost::unique_lock<boost::mutex> lock(mutex);\n          while (value < 1) {\n              condition.wait(lock);\n          }\n          value--;\n      }\n}"
  },
  {
    "function_name": "CSemaphore",
    "container": "CSemaphore",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "131-131",
    "snippet": "CSemaphore(int init) : value(init) {}",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCSemaphore {\n  CSemaphore(int init) : value(init) {}\n}"
  },
  {
    "function_name": "CMutexLock",
    "container": "CMutexLock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "80-86",
    "snippet": "CMutexLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) : lock(mutexIn, boost::defer_lock)\n    {\n        if (fTry)\n            TryEnter(pszName, pszFile, nLine);\n        else\n            Enter(pszName, pszFile, nLine);\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Enter",
          "args": [
            "pszName",
            "pszFile",
            "nLine"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "TryEnter",
          "container": "CMutexLock",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "68-78",
          "snippet": "bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n    {\n        if (!lock.owns_lock())\n        {\n            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n            lock.try_lock();\n            if (!lock.owns_lock())\n                LeaveCritical();\n        }\n        return lock.owns_lock();\n    }",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCMutexLock {\n  bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n      {\n          if (!lock.owns_lock())\n          {\n              EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n              lock.try_lock();\n              if (!lock.owns_lock())\n                  LeaveCritical();\n          }\n          return lock.owns_lock();\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCMutexLock {\n  CMutexLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) : lock(mutexIn, boost::defer_lock)\n      {\n          if (fTry)\n              TryEnter(pszName, pszFile, nLine);\n          else\n              Enter(pszName, pszFile, nLine);\n      }\n}"
  },
  {
    "function_name": "TryEnter",
    "container": "CMutexLock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "68-78",
    "snippet": "bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n    {\n        if (!lock.owns_lock())\n        {\n            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n            lock.try_lock();\n            if (!lock.owns_lock())\n                LeaveCritical();\n        }\n        return lock.owns_lock();\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock.owns_lock",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LeaveCritical",
          "args": [],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "LeaveCritical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "27-27",
          "snippet": "void static inline LeaveCritical() {}",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nvoid static inline LeaveCritical() {}"
        }
      },
      {
        "call_info": {
          "callee": "lock.owns_lock",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.try_lock",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnterCritical",
          "args": [
            "pszName",
            "pszFile",
            "nLine",
            "(void*)(lock.mutex())",
            "true"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "EnterCritical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.cpp",
          "lines": "118-121",
          "snippet": "void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n{\n    push_lock(cs, CLockLocation(pszName, pszFile, nLine), fTry);\n}",
          "includes": [
            "#include <boost/foreach.hpp>",
            "#include \"util.h\"",
            "#include \"sync.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/foreach.hpp>\n#include \"util.h\"\n#include \"sync.h\"\n\nvoid EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n{\n    push_lock(cs, CLockLocation(pszName, pszFile, nLine), fTry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock.mutex",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.owns_lock",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCMutexLock {\n  bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n      {\n          if (!lock.owns_lock())\n          {\n              EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()), true);\n              lock.try_lock();\n              if (!lock.owns_lock())\n                  LeaveCritical();\n          }\n          return lock.owns_lock();\n      }\n}"
  },
  {
    "function_name": "Leave",
    "container": "CMutexLock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "59-66",
    "snippet": "void Leave()\n    {\n        if (lock.owns_lock())\n        {\n            lock.unlock();\n            LeaveCritical();\n        }\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LeaveCritical",
          "args": [],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "LeaveCritical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "27-27",
          "snippet": "void static inline LeaveCritical() {}",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nvoid static inline LeaveCritical() {}"
        }
      },
      {
        "call_info": {
          "callee": "lock.unlock",
          "args": [],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.owns_lock",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCMutexLock {\n  void Leave()\n      {\n          if (lock.owns_lock())\n          {\n              lock.unlock();\n              LeaveCritical();\n          }\n      }\n}"
  },
  {
    "function_name": "Enter",
    "container": "CMutexLock",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "42-57",
    "snippet": "void Enter(const char* pszName, const char* pszFile, int nLine)\n    {\n        if (!lock.owns_lock())\n        {\n            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n#ifdef DEBUG_LOCKCONTENTION\n            if (!lock.try_lock())\n            {\n                PrintLockContention(pszName, pszFile, nLine);\n#endif\n            lock.lock();\n#ifdef DEBUG_LOCKCONTENTION\n            }\n#endif\n        }\n    }",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lock.lock",
          "args": [],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PrintLockContention",
          "args": [
            "pszName",
            "pszFile",
            "nLine"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "PrintLockContention",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.cpp",
          "lines": "11-15",
          "snippet": "void PrintLockContention(const char* pszName, const char* pszFile, int nLine)\n{\n    printf(\"LOCKCONTENTION: %s\\n\", pszName);\n    printf(\"Locker: %s:%d\\n\", pszFile, nLine);\n}",
          "includes": [
            "#include <boost/foreach.hpp>",
            "#include \"util.h\"",
            "#include \"sync.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/foreach.hpp>\n#include \"util.h\"\n#include \"sync.h\"\n\nvoid PrintLockContention(const char* pszName, const char* pszFile, int nLine)\n{\n    printf(\"LOCKCONTENTION: %s\\n\", pszName);\n    printf(\"Locker: %s:%d\\n\", pszFile, nLine);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock.try_lock",
          "args": [],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EnterCritical",
          "args": [
            "pszName",
            "pszFile",
            "nLine",
            "(void*)(lock.mutex())"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "EnterCritical",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
          "lines": "26-26",
          "snippet": "void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}",
          "includes": [
            "#include <boost/thread/condition_variable.hpp>",
            "#include <boost/thread/locks.hpp>",
            "#include <boost/thread/recursive_mutex.hpp>",
            "#include <boost/thread/mutex.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nvoid static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}"
        }
      },
      {
        "call_info": {
          "callee": "lock.mutex",
          "args": [],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock.owns_lock",
          "args": [],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nCMutexLock {\n  void Enter(const char* pszName, const char* pszFile, int nLine)\n      {\n          if (!lock.owns_lock())\n          {\n              EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n  #ifdef DEBUG_LOCKCONTENTION\n              if (!lock.try_lock())\n              {\n                  PrintLockContention(pszName, pszFile, nLine);\n  #endif\n              lock.lock();\n  #ifdef DEBUG_LOCKCONTENTION\n              }\n  #endif\n          }\n      }\n}"
  },
  {
    "function_name": "LeaveCritical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "27-27",
    "snippet": "void static inline LeaveCritical() {}",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nvoid static inline LeaveCritical() {}"
  },
  {
    "function_name": "EnterCritical",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/sync.h",
    "lines": "26-26",
    "snippet": "void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}",
    "includes": [
      "#include <boost/thread/condition_variable.hpp>",
      "#include <boost/thread/locks.hpp>",
      "#include <boost/thread/recursive_mutex.hpp>",
      "#include <boost/thread/mutex.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <boost/thread/condition_variable.hpp>\n#include <boost/thread/locks.hpp>\n#include <boost/thread/recursive_mutex.hpp>\n#include <boost/thread/mutex.hpp>\n\nvoid static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}"
  }
]