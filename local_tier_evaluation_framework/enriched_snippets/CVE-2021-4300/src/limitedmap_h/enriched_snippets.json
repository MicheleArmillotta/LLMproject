[
  {
    "function_name": "max_size",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "87-97",
    "snippet": "size_type max_size(size_type s)\n    {\n        if (s)\n            while (map.size() > s)\n            {\n                map.erase(rmap.begin()->second);\n                rmap.erase(rmap.begin());\n            }\n        nMaxSize = s;\n        return nMaxSize;\n    }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap.erase",
          "args": [
            "rmap.begin()"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap.begin",
          "args": [],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map.size",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "31-31",
          "snippet": "size_type size() const { return map.size(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type size() const { return map.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type max_size(size_type s)\n      {\n          if (s)\n              while (map.size() > s)\n              {\n                  map.erase(rmap.begin()->second);\n                  rmap.erase(rmap.begin());\n              }\n          nMaxSize = s;\n          return nMaxSize;\n      }\n}"
  },
  {
    "function_name": "max_size",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "86-86",
    "snippet": "size_type max_size() const { return nMaxSize; }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type max_size() const { return nMaxSize; }\n}"
  },
  {
    "function_name": "update",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "66-85",
    "snippet": "void update(const_iterator itIn, const mapped_type& v)\n    {\n        //TODO: When we switch to C++11, use map.erase(itIn, itIn) to get the non-const iterator\n        iterator itTarget = map.find(itIn->first);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                itTarget->second = v;\n                rmap.insert(make_pair(v, itTarget));\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        itTarget->second = v;\n        rmap.insert(make_pair(v, itTarget));\n    }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap.insert",
          "args": [
            "make_pair(v, itTarget)"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "35-48",
          "snippet": "void insert(const value_type& x)\n    {\n        std::pair<iterator, bool> ret = map.insert(x);\n        if (ret.second)\n        {\n            if (nMaxSize && map.size() == nMaxSize)\n            {\n                map.erase(rmap.begin()->second);\n                rmap.erase(rmap.begin());\n            }\n            rmap.insert(make_pair(x.second, ret.first));\n        }\n        return;\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void insert(const value_type& x)\n      {\n          std::pair<iterator, bool> ret = map.insert(x);\n          if (ret.second)\n          {\n              if (nMaxSize && map.size() == nMaxSize)\n              {\n                  map.erase(rmap.begin()->second);\n                  rmap.erase(rmap.begin());\n              }\n              rmap.insert(make_pair(x.second, ret.first));\n          }\n          return;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "v",
            "itTarget"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "v",
            "itTarget"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap.erase",
          "args": [
            "it"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap.equal_range",
          "args": [
            "itTarget->second"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.end",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map.find",
          "args": [
            "itIn->first"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void update(const_iterator itIn, const mapped_type& v)\n      {\n          //TODO: When we switch to C++11, use map.erase(itIn, itIn) to get the non-const iterator\n          iterator itTarget = map.find(itIn->first);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  itTarget->second = v;\n                  rmap.insert(make_pair(v, itTarget));\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          itTarget->second = v;\n          rmap.insert(make_pair(v, itTarget));\n      }\n}"
  },
  {
    "function_name": "erase",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "49-65",
    "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.erase",
          "args": [
            "itTarget"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap.equal_range",
          "args": [
            "itTarget->second"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map.end",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map.find",
          "args": [
            "k"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
  },
  {
    "function_name": "insert",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "35-48",
    "snippet": "void insert(const value_type& x)\n    {\n        std::pair<iterator, bool> ret = map.insert(x);\n        if (ret.second)\n        {\n            if (nMaxSize && map.size() == nMaxSize)\n            {\n                map.erase(rmap.begin()->second);\n                rmap.erase(rmap.begin());\n            }\n            rmap.insert(make_pair(x.second, ret.first));\n        }\n        return;\n    }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap.insert",
          "args": [
            "make_pair(x.second, ret.first)"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "35-48",
          "snippet": "void insert(const value_type& x)\n    {\n        std::pair<iterator, bool> ret = map.insert(x);\n        if (ret.second)\n        {\n            if (nMaxSize && map.size() == nMaxSize)\n            {\n                map.erase(rmap.begin()->second);\n                rmap.erase(rmap.begin());\n            }\n            rmap.insert(make_pair(x.second, ret.first));\n        }\n        return;\n    }",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "x.second",
            "ret.first"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap.erase",
          "args": [
            "rmap.begin()"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap.begin",
          "args": [],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "map.size",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "31-31",
          "snippet": "size_type size() const { return map.size(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type size() const { return map.size(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void insert(const value_type& x)\n      {\n          std::pair<iterator, bool> ret = map.insert(x);\n          if (ret.second)\n          {\n              if (nMaxSize && map.size() == nMaxSize)\n              {\n                  map.erase(rmap.begin()->second);\n                  rmap.erase(rmap.begin());\n              }\n              rmap.insert(make_pair(x.second, ret.first));\n          }\n          return;\n      }\n}"
  },
  {
    "function_name": "count",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "34-34",
    "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.count",
          "args": [
            "k"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
  },
  {
    "function_name": "find",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "33-33",
    "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.find",
          "args": [
            "k"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
  },
  {
    "function_name": "empty",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "32-32",
    "snippet": "bool empty() const { return map.empty(); }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.empty",
          "args": [],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
  },
  {
    "function_name": "size",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "31-31",
    "snippet": "size_type size() const { return map.size(); }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.size",
          "args": [],
          "line": 31
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "31-31",
          "snippet": "size_type size() const { return map.size(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type size() const { return map.size(); }\n}"
  },
  {
    "function_name": "end",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "30-30",
    "snippet": "const_iterator end() const { return map.end(); }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.end",
          "args": [],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
  },
  {
    "function_name": "begin",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "29-29",
    "snippet": "const_iterator begin() const { return map.begin(); }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map.begin",
          "args": [],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
  },
  {
    "function_name": "limitedmap",
    "container": "limitedmap",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
    "lines": "28-28",
    "snippet": "limitedmap(size_type nMaxSizeIn = 0) { nMaxSize = nMaxSizeIn; }",
    "includes": [
      "#include <deque>",
      "#include <map>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  limitedmap(size_type nMaxSizeIn = 0) { nMaxSize = nMaxSizeIn; }\n}"
  }
]