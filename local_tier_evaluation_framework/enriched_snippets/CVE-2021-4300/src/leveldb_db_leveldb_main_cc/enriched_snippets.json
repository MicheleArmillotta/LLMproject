[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "222-238",
    "snippet": "int main(int argc, char** argv) {\n  leveldb::Env* env = leveldb::Env::Default();\n  bool ok = true;\n  if (argc < 2) {\n    Usage();\n    ok = false;\n  } else {\n    std::string command = argv[1];\n    if (command == \"dump\") {\n      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);\n    } else {\n      Usage();\n      ok = false;\n    }\n  }\n  return (ok ? 0 : 1);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Usage",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "Usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "214-220",
          "snippet": "static void Usage() {\n  fprintf(\n      stderr,\n      \"Usage: leveldbutil command...\\n\"\n      \"   dump files...         -- dump contents of specified files\\n\"\n      );\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nstatic void Usage() {\n  fprintf(\n      stderr,\n      \"Usage: leveldbutil command...\\n\"\n      \"   dump files...         -- dump contents of specified files\\n\"\n      );\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::HandleDumpCommand",
          "args": [
            "env",
            "argv+2",
            "argc-2"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "HandleDumpCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "203-209",
          "snippet": "bool HandleDumpCommand(Env* env, char** files, int num) {\n  bool ok = true;\n  for (int i = 0; i < num; i++) {\n    ok &= DumpFile(env, files[i]);\n  }\n  return ok;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool HandleDumpCommand(Env* env, char** files, int num) {\n  bool ok = true;\n  for (int i = 0; i < num; i++) {\n    ok &= DumpFile(env, files[i]);\n  }\n  return ok;\n}"
        }
      },
      {
        "call_info": {
          "callee": "leveldb::Env::Default",
          "args": [],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nint main(int argc, char** argv) {\n  leveldb::Env* env = leveldb::Env::Default();\n  bool ok = true;\n  if (argc < 2) {\n    Usage();\n    ok = false;\n  } else {\n    std::string command = argv[1];\n    if (command == \"dump\") {\n      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);\n    } else {\n      Usage();\n      ok = false;\n    }\n  }\n  return (ok ? 0 : 1);\n}"
  },
  {
    "function_name": "Usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "214-220",
    "snippet": "static void Usage() {\n  fprintf(\n      stderr,\n      \"Usage: leveldbutil command...\\n\"\n      \"   dump files...         -- dump contents of specified files\\n\"\n      );\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: leveldbutil command...\\n\"\n      \"   dump files...         -- dump contents of specified files\\n\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nstatic void Usage() {\n  fprintf(\n      stderr,\n      \"Usage: leveldbutil command...\\n\"\n      \"   dump files...         -- dump contents of specified files\\n\"\n      );\n}"
  },
  {
    "function_name": "HandleDumpCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "203-209",
    "snippet": "bool HandleDumpCommand(Env* env, char** files, int num) {\n  bool ok = true;\n  for (int i = 0; i < num; i++) {\n    ok &= DumpFile(env, files[i]);\n  }\n  return ok;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DumpFile",
          "args": [
            "env",
            "files[i]"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "DumpFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "184-201",
          "snippet": "bool DumpFile(Env* env, const std::string& fname) {\n  FileType ftype;\n  if (!GuessType(fname, &ftype)) {\n    fprintf(stderr, \"%s: unknown file type\\n\", fname.c_str());\n    return false;\n  }\n  switch (ftype) {\n    case kLogFile:         return DumpLog(env, fname);\n    case kDescriptorFile:  return DumpDescriptor(env, fname);\n    case kTableFile:       return DumpTable(env, fname);\n\n    default: {\n      fprintf(stderr, \"%s: not a dump-able file type\\n\", fname.c_str());\n      break;\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpFile(Env* env, const std::string& fname) {\n  FileType ftype;\n  if (!GuessType(fname, &ftype)) {\n    fprintf(stderr, \"%s: unknown file type\\n\", fname.c_str());\n    return false;\n  }\n  switch (ftype) {\n    case kLogFile:         return DumpLog(env, fname);\n    case kDescriptorFile:  return DumpDescriptor(env, fname);\n    case kTableFile:       return DumpTable(env, fname);\n\n    default: {\n      fprintf(stderr, \"%s: not a dump-able file type\\n\", fname.c_str());\n      break;\n    }\n  }\n  return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool HandleDumpCommand(Env* env, char** files, int num) {\n  bool ok = true;\n  for (int i = 0; i < num; i++) {\n    ok &= DumpFile(env, files[i]);\n  }\n  return ok;\n}"
  },
  {
    "function_name": "DumpFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "184-201",
    "snippet": "bool DumpFile(Env* env, const std::string& fname) {\n  FileType ftype;\n  if (!GuessType(fname, &ftype)) {\n    fprintf(stderr, \"%s: unknown file type\\n\", fname.c_str());\n    return false;\n  }\n  switch (ftype) {\n    case kLogFile:         return DumpLog(env, fname);\n    case kDescriptorFile:  return DumpDescriptor(env, fname);\n    case kTableFile:       return DumpTable(env, fname);\n\n    default: {\n      fprintf(stderr, \"%s: not a dump-able file type\\n\", fname.c_str());\n      break;\n    }\n  }\n  return false;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: not a dump-able file type\\n\"",
            "fname.c_str()"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DumpTable",
          "args": [
            "env",
            "fname"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "DumpTable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "124-182",
          "snippet": "bool DumpTable(Env* env, const std::string& fname) {\n  uint64_t file_size;\n  RandomAccessFile* file = NULL;\n  Table* table = NULL;\n  Status s = env->GetFileSize(fname, &file_size);\n  if (s.ok()) {\n    s = env->NewRandomAccessFile(fname, &file);\n  }\n  if (s.ok()) {\n    // We use the default comparator, which may or may not match the\n    // comparator used in this database. However this should not cause\n    // problems since we only use Table operations that do not require\n    // any comparisons.  In particular, we do not call Seek or Prev.\n    s = Table::Open(Options(), file, file_size, &table);\n  }\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    delete table;\n    delete file;\n    return false;\n  }\n\n  ReadOptions ro;\n  ro.fill_cache = false;\n  Iterator* iter = table->NewIterator(ro);\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey key;\n    if (!ParseInternalKey(iter->key(), &key)) {\n      printf(\"badkey '%s' => '%s'\\n\",\n             EscapeString(iter->key()).c_str(),\n             EscapeString(iter->value()).c_str());\n    } else {\n      char kbuf[20];\n      const char* type;\n      if (key.type == kTypeDeletion) {\n        type = \"del\";\n      } else if (key.type == kTypeValue) {\n        type = \"val\";\n      } else {\n        snprintf(kbuf, sizeof(kbuf), \"%d\", static_cast<int>(key.type));\n        type = kbuf;\n      }\n      printf(\"'%s' @ %8llu : %s => '%s'\\n\",\n             EscapeString(key.user_key).c_str(),\n             static_cast<unsigned long long>(key.sequence),\n             type,\n             EscapeString(iter->value()).c_str());\n    }\n  }\n  s = iter->status();\n  if (!s.ok()) {\n    printf(\"iterator error: %s\\n\", s.ToString().c_str());\n  }\n\n  delete iter;\n  delete table;\n  delete file;\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpTable(Env* env, const std::string& fname) {\n  uint64_t file_size;\n  RandomAccessFile* file = NULL;\n  Table* table = NULL;\n  Status s = env->GetFileSize(fname, &file_size);\n  if (s.ok()) {\n    s = env->NewRandomAccessFile(fname, &file);\n  }\n  if (s.ok()) {\n    // We use the default comparator, which may or may not match the\n    // comparator used in this database. However this should not cause\n    // problems since we only use Table operations that do not require\n    // any comparisons.  In particular, we do not call Seek or Prev.\n    s = Table::Open(Options(), file, file_size, &table);\n  }\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    delete table;\n    delete file;\n    return false;\n  }\n\n  ReadOptions ro;\n  ro.fill_cache = false;\n  Iterator* iter = table->NewIterator(ro);\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey key;\n    if (!ParseInternalKey(iter->key(), &key)) {\n      printf(\"badkey '%s' => '%s'\\n\",\n             EscapeString(iter->key()).c_str(),\n             EscapeString(iter->value()).c_str());\n    } else {\n      char kbuf[20];\n      const char* type;\n      if (key.type == kTypeDeletion) {\n        type = \"del\";\n      } else if (key.type == kTypeValue) {\n        type = \"val\";\n      } else {\n        snprintf(kbuf, sizeof(kbuf), \"%d\", static_cast<int>(key.type));\n        type = kbuf;\n      }\n      printf(\"'%s' @ %8llu : %s => '%s'\\n\",\n             EscapeString(key.user_key).c_str(),\n             static_cast<unsigned long long>(key.sequence),\n             type,\n             EscapeString(iter->value()).c_str());\n    }\n  }\n  s = iter->status();\n  if (!s.ok()) {\n    printf(\"iterator error: %s\\n\", s.ToString().c_str());\n  }\n\n  delete iter;\n  delete table;\n  delete file;\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DumpDescriptor",
          "args": [
            "env",
            "fname"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "DumpDescriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "120-122",
          "snippet": "bool DumpDescriptor(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, VersionEditPrinter);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpDescriptor(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, VersionEditPrinter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "DumpLog",
          "args": [
            "env",
            "fname"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "DumpLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "104-106",
          "snippet": "bool DumpLog(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, WriteBatchPrinter);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpLog(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, WriteBatchPrinter);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: unknown file type\\n\"",
            "fname.c_str()"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.c_str",
          "args": [],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GuessType",
          "args": [
            "fname",
            "&ftype"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "GuessType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "23-33",
          "snippet": "bool GuessType(const std::string& fname, FileType* type) {\n  size_t pos = fname.rfind('/');\n  std::string basename;\n  if (pos == std::string::npos) {\n    basename = fname;\n  } else {\n    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);\n  }\n  uint64_t ignored;\n  return ParseFileName(basename, &ignored, type);\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool GuessType(const std::string& fname, FileType* type) {\n  size_t pos = fname.rfind('/');\n  std::string basename;\n  if (pos == std::string::npos) {\n    basename = fname;\n  } else {\n    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);\n  }\n  uint64_t ignored;\n  return ParseFileName(basename, &ignored, type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpFile(Env* env, const std::string& fname) {\n  FileType ftype;\n  if (!GuessType(fname, &ftype)) {\n    fprintf(stderr, \"%s: unknown file type\\n\", fname.c_str());\n    return false;\n  }\n  switch (ftype) {\n    case kLogFile:         return DumpLog(env, fname);\n    case kDescriptorFile:  return DumpDescriptor(env, fname);\n    case kTableFile:       return DumpTable(env, fname);\n\n    default: {\n      fprintf(stderr, \"%s: not a dump-able file type\\n\", fname.c_str());\n      break;\n    }\n  }\n  return false;\n}"
  },
  {
    "function_name": "DumpTable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "124-182",
    "snippet": "bool DumpTable(Env* env, const std::string& fname) {\n  uint64_t file_size;\n  RandomAccessFile* file = NULL;\n  Table* table = NULL;\n  Status s = env->GetFileSize(fname, &file_size);\n  if (s.ok()) {\n    s = env->NewRandomAccessFile(fname, &file);\n  }\n  if (s.ok()) {\n    // We use the default comparator, which may or may not match the\n    // comparator used in this database. However this should not cause\n    // problems since we only use Table operations that do not require\n    // any comparisons.  In particular, we do not call Seek or Prev.\n    s = Table::Open(Options(), file, file_size, &table);\n  }\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    delete table;\n    delete file;\n    return false;\n  }\n\n  ReadOptions ro;\n  ro.fill_cache = false;\n  Iterator* iter = table->NewIterator(ro);\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey key;\n    if (!ParseInternalKey(iter->key(), &key)) {\n      printf(\"badkey '%s' => '%s'\\n\",\n             EscapeString(iter->key()).c_str(),\n             EscapeString(iter->value()).c_str());\n    } else {\n      char kbuf[20];\n      const char* type;\n      if (key.type == kTypeDeletion) {\n        type = \"del\";\n      } else if (key.type == kTypeValue) {\n        type = \"val\";\n      } else {\n        snprintf(kbuf, sizeof(kbuf), \"%d\", static_cast<int>(key.type));\n        type = kbuf;\n      }\n      printf(\"'%s' @ %8llu : %s => '%s'\\n\",\n             EscapeString(key.user_key).c_str(),\n             static_cast<unsigned long long>(key.sequence),\n             type,\n             EscapeString(iter->value()).c_str());\n    }\n  }\n  s = iter->status();\n  if (!s.ok()) {\n    printf(\"iterator error: %s\\n\", s.ToString().c_str());\n  }\n\n  delete iter;\n  delete table;\n  delete file;\n  return true;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"iterator error: %s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->status",
          "args": [],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "status",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "74-80",
          "snippet": "virtual Status status() const {\n    if (status_.ok()) {\n      return iter_->status();\n    } else {\n      return status_;\n    }\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Status status() const {\n      if (status_.ok()) {\n        return iter_->status();\n      } else {\n        return status_;\n      }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"'%s' @ %8llu : %s => '%s'\\n\"",
            "EscapeString(key.user_key).c_str()",
            "static_cast<unsigned long long>(key.sequence)",
            "type",
            "EscapeString(iter->value()).c_str()"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [
            "iter->value()"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "EscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "42-46",
          "snippet": "std::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->value",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "value",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "70-73",
          "snippet": "virtual Slice value() const {\n    assert(valid_);\n    return (direction_ == kForward) ? iter_->value() : saved_value_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice value() const {\n      assert(valid_);\n      return (direction_ == kForward) ? iter_->value() : saved_value_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned long long>",
          "args": [
            "key.sequence"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kbuf",
            "sizeof(kbuf)",
            "\"%d\"",
            "static_cast<int>(key.type)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "key.type"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"badkey '%s' => '%s'\\n\"",
            "EscapeString(iter->key()).c_str()",
            "EscapeString(iter->value()).c_str()"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ParseInternalKey",
          "args": [
            "iter->key()",
            "&key"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ParseInternalKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "176-186",
          "snippet": "inline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\ninline bool ParseInternalKey(const Slice& internal_key,\n                             ParsedInternalKey* result) {\n  const size_t n = internal_key.size();\n  if (n < 8) return false;\n  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);\n  unsigned char c = num & 0xff;\n  result->sequence = num >> 8;\n  result->type = static_cast<ValueType>(c);\n  result->user_key = Slice(internal_key.data(), n - 8);\n  return (c <= static_cast<unsigned char>(kTypeValue));\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "table->NewIterator",
          "args": [
            "ro"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Table::Open",
          "args": [
            "Options()",
            "file",
            "file_size",
            "&table"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "Table",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/table/table.cc",
          "lines": "38-85",
          "snippet": "Status Table::Open(const Options& options,\n                   RandomAccessFile* file,\n                   uint64_t size,\n                   Table** table) {\n  *table = NULL;\n  if (size < Footer::kEncodedLength) {\n    return Status::InvalidArgument(\"file is too short to be an sstable\");\n  }\n\n  char footer_space[Footer::kEncodedLength];\n  Slice footer_input;\n  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,\n                        &footer_input, footer_space);\n  if (!s.ok()) return s;\n\n  Footer footer;\n  s = footer.DecodeFrom(&footer_input);\n  if (!s.ok()) return s;\n\n  // Read the index block\n  BlockContents contents;\n  Block* index_block = NULL;\n  if (s.ok()) {\n    s = ReadBlock(file, ReadOptions(), footer.index_handle(), &contents);\n    if (s.ok()) {\n      index_block = new Block(contents);\n    }\n  }\n\n  if (s.ok()) {\n    // We've successfully read the footer and the index block: we're\n    // ready to serve requests.\n    Rep* rep = new Table::Rep;\n    rep->options = options;\n    rep->file = file;\n    rep->metaindex_handle = footer.metaindex_handle();\n    rep->index_block = index_block;\n    rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);\n    rep->filter_data = NULL;\n    rep->filter = NULL;\n    *table = new Table(rep);\n    (*table)->ReadMeta(footer);\n  } else {\n    if (index_block) delete index_block;\n  }\n\n  return s;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/format.h\"",
            "#include \"table/filter_block.h\"",
            "#include \"table/block.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"leveldb/table.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/format.h\"\n#include \"table/filter_block.h\"\n#include \"table/block.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/comparator.h\"\n#include \"leveldb/cache.h\"\n#include \"leveldb/table.h\"\n\nTable {\n  Status Table::Open(const Options& options,\n                     RandomAccessFile* file,\n                     uint64_t size,\n                     Table** table) {\n    *table = NULL;\n    if (size < Footer::kEncodedLength) {\n      return Status::InvalidArgument(\"file is too short to be an sstable\");\n    }\n  \n    char footer_space[Footer::kEncodedLength];\n    Slice footer_input;\n    Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,\n                          &footer_input, footer_space);\n    if (!s.ok()) return s;\n  \n    Footer footer;\n    s = footer.DecodeFrom(&footer_input);\n    if (!s.ok()) return s;\n  \n    // Read the index block\n    BlockContents contents;\n    Block* index_block = NULL;\n    if (s.ok()) {\n      s = ReadBlock(file, ReadOptions(), footer.index_handle(), &contents);\n      if (s.ok()) {\n        index_block = new Block(contents);\n      }\n    }\n  \n    if (s.ok()) {\n      // We've successfully read the footer and the index block: we're\n      // ready to serve requests.\n      Rep* rep = new Table::Rep;\n      rep->options = options;\n      rep->file = file;\n      rep->metaindex_handle = footer.metaindex_handle();\n      rep->index_block = index_block;\n      rep->cache_id = (options.block_cache ? options.block_cache->NewId() : 0);\n      rep->filter_data = NULL;\n      rep->filter = NULL;\n      *table = new Table(rep);\n      (*table)->ReadMeta(footer);\n    } else {\n      if (index_block) delete index_block;\n    }\n  \n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Options",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "CurrentOptions",
          "container": "DBTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "238-251",
          "snippet": "Options CurrentOptions() {\n    Options options;\n    switch (option_config_) {\n      case kFilter:\n        options.filter_policy = filter_policy_;\n        break;\n      case kUncompressed:\n        options.compression = kNoCompression;\n        break;\n      default:\n        break;\n    }\n    return options;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nDBTest {\n  Options CurrentOptions() {\n      Options options;\n      switch (option_config_) {\n        case kFilter:\n          options.filter_policy = filter_policy_;\n          break;\n        case kUncompressed:\n          options.compression = kNoCompression;\n          break;\n        default:\n          break;\n      }\n      return options;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->NewRandomAccessFile",
          "args": [
            "fname",
            "&file"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "NewRandomAccessFile",
          "container": "SpecialEnv",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_test.cc",
          "lines": "164-186",
          "snippet": "Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {\n    class CountingFile : public RandomAccessFile {\n     private:\n      RandomAccessFile* target_;\n      AtomicCounter* counter_;\n     public:\n      CountingFile(RandomAccessFile* target, AtomicCounter* counter)\n          : target_(target), counter_(counter) {\n      }\n      virtual ~CountingFile() { delete target_; }\n      virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                          char* scratch) const {\n        counter_->Increment();\n        return target_->Read(offset, n, result, scratch);\n      }\n    };\n\n    Status s = target()->NewRandomAccessFile(f, r);\n    if (s.ok() && count_random_reads_) {\n      *r = new CountingFile(*r, &random_read_counter_);\n    }\n    return s;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/hash.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/hash.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/cache.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/filename.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n\nSpecialEnv {\n  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {\n      class CountingFile : public RandomAccessFile {\n       private:\n        RandomAccessFile* target_;\n        AtomicCounter* counter_;\n       public:\n        CountingFile(RandomAccessFile* target, AtomicCounter* counter)\n            : target_(target), counter_(counter) {\n        }\n        virtual ~CountingFile() { delete target_; }\n        virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                            char* scratch) const {\n          counter_->Increment();\n          return target_->Read(offset, n, result, scratch);\n        }\n      };\n  \n      Status s = target()->NewRandomAccessFile(f, r);\n      if (s.ok() && count_random_reads_) {\n        *r = new CountingFile(*r, &random_read_counter_);\n      }\n      return s;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->GetFileSize",
          "args": [
            "fname",
            "&file_size"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "GetFileSize",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "814-830",
          "snippet": "Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n{\n    Status sRet;\n    std::string path = fname;\n    std::wstring wpath;\n\tToWidePath(ModifyPath(path), wpath);\n\n    HANDLE file = ::CreateFileW(wpath.c_str(),\n        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n    LARGE_INTEGER li;\n    if(::GetFileSizeEx(file,&li)){\n        *file_size = (uint64_t)li.QuadPart;\n    }else\n        sRet = Status::IOError(path,\"Could not get the file size.\");\n    CloseHandle(file);\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n  {\n      Status sRet;\n      std::string path = fname;\n      std::wstring wpath;\n  \tToWidePath(ModifyPath(path), wpath);\n  \n      HANDLE file = ::CreateFileW(wpath.c_str(),\n          GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n      LARGE_INTEGER li;\n      if(::GetFileSizeEx(file,&li)){\n          *file_size = (uint64_t)li.QuadPart;\n      }else\n          sRet = Status::IOError(path,\"Could not get the file size.\");\n      CloseHandle(file);\n      return sRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpTable(Env* env, const std::string& fname) {\n  uint64_t file_size;\n  RandomAccessFile* file = NULL;\n  Table* table = NULL;\n  Status s = env->GetFileSize(fname, &file_size);\n  if (s.ok()) {\n    s = env->NewRandomAccessFile(fname, &file);\n  }\n  if (s.ok()) {\n    // We use the default comparator, which may or may not match the\n    // comparator used in this database. However this should not cause\n    // problems since we only use Table operations that do not require\n    // any comparisons.  In particular, we do not call Seek or Prev.\n    s = Table::Open(Options(), file, file_size, &table);\n  }\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    delete table;\n    delete file;\n    return false;\n  }\n\n  ReadOptions ro;\n  ro.fill_cache = false;\n  Iterator* iter = table->NewIterator(ro);\n  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {\n    ParsedInternalKey key;\n    if (!ParseInternalKey(iter->key(), &key)) {\n      printf(\"badkey '%s' => '%s'\\n\",\n             EscapeString(iter->key()).c_str(),\n             EscapeString(iter->value()).c_str());\n    } else {\n      char kbuf[20];\n      const char* type;\n      if (key.type == kTypeDeletion) {\n        type = \"del\";\n      } else if (key.type == kTypeValue) {\n        type = \"val\";\n      } else {\n        snprintf(kbuf, sizeof(kbuf), \"%d\", static_cast<int>(key.type));\n        type = kbuf;\n      }\n      printf(\"'%s' @ %8llu : %s => '%s'\\n\",\n             EscapeString(key.user_key).c_str(),\n             static_cast<unsigned long long>(key.sequence),\n             type,\n             EscapeString(iter->value()).c_str());\n    }\n  }\n  s = iter->status();\n  if (!s.ok()) {\n    printf(\"iterator error: %s\\n\", s.ToString().c_str());\n  }\n\n  delete iter;\n  delete table;\n  delete file;\n  return true;\n}"
  },
  {
    "function_name": "DumpDescriptor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "120-122",
    "snippet": "bool DumpDescriptor(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, VersionEditPrinter);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrintLogContents",
          "args": [
            "env",
            "fname",
            "VersionEditPrinter"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "PrintLogContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "46-65",
          "snippet": "bool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpDescriptor(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, VersionEditPrinter);\n}"
  },
  {
    "function_name": "VersionEditPrinter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "110-118",
    "snippet": "static void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\"",
            "edit.DebugString().c_str()"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.DebugString",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "DebugString",
          "container": "VersionEdit",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/version_edit.cc",
          "lines": "212-264",
          "snippet": "std::string VersionEdit::DebugString() const {\n  std::string r;\n  r.append(\"VersionEdit {\");\n  if (has_comparator_) {\n    r.append(\"\\n  Comparator: \");\n    r.append(comparator_);\n  }\n  if (has_log_number_) {\n    r.append(\"\\n  LogNumber: \");\n    AppendNumberTo(&r, log_number_);\n  }\n  if (has_prev_log_number_) {\n    r.append(\"\\n  PrevLogNumber: \");\n    AppendNumberTo(&r, prev_log_number_);\n  }\n  if (has_next_file_number_) {\n    r.append(\"\\n  NextFile: \");\n    AppendNumberTo(&r, next_file_number_);\n  }\n  if (has_last_sequence_) {\n    r.append(\"\\n  LastSeq: \");\n    AppendNumberTo(&r, last_sequence_);\n  }\n  for (size_t i = 0; i < compact_pointers_.size(); i++) {\n    r.append(\"\\n  CompactPointer: \");\n    AppendNumberTo(&r, compact_pointers_[i].first);\n    r.append(\" \");\n    r.append(compact_pointers_[i].second.DebugString());\n  }\n  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n       iter != deleted_files_.end();\n       ++iter) {\n    r.append(\"\\n  DeleteFile: \");\n    AppendNumberTo(&r, iter->first);\n    r.append(\" \");\n    AppendNumberTo(&r, iter->second);\n  }\n  for (size_t i = 0; i < new_files_.size(); i++) {\n    const FileMetaData& f = new_files_[i].second;\n    r.append(\"\\n  AddFile: \");\n    AppendNumberTo(&r, new_files_[i].first);\n    r.append(\" \");\n    AppendNumberTo(&r, f.number);\n    r.append(\" \");\n    AppendNumberTo(&r, f.file_size);\n    r.append(\" \");\n    r.append(f.smallest.DebugString());\n    r.append(\" .. \");\n    r.append(f.largest.DebugString());\n  }\n  r.append(\"\\n}\\n\");\n  return r;\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/version_edit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/version_set.h\"\n#include \"db/version_edit.h\"\n\nVersionEdit {\n  std::string VersionEdit::DebugString() const {\n    std::string r;\n    r.append(\"VersionEdit {\");\n    if (has_comparator_) {\n      r.append(\"\\n  Comparator: \");\n      r.append(comparator_);\n    }\n    if (has_log_number_) {\n      r.append(\"\\n  LogNumber: \");\n      AppendNumberTo(&r, log_number_);\n    }\n    if (has_prev_log_number_) {\n      r.append(\"\\n  PrevLogNumber: \");\n      AppendNumberTo(&r, prev_log_number_);\n    }\n    if (has_next_file_number_) {\n      r.append(\"\\n  NextFile: \");\n      AppendNumberTo(&r, next_file_number_);\n    }\n    if (has_last_sequence_) {\n      r.append(\"\\n  LastSeq: \");\n      AppendNumberTo(&r, last_sequence_);\n    }\n    for (size_t i = 0; i < compact_pointers_.size(); i++) {\n      r.append(\"\\n  CompactPointer: \");\n      AppendNumberTo(&r, compact_pointers_[i].first);\n      r.append(\" \");\n      r.append(compact_pointers_[i].second.DebugString());\n    }\n    for (DeletedFileSet::const_iterator iter = deleted_files_.begin();\n         iter != deleted_files_.end();\n         ++iter) {\n      r.append(\"\\n  DeleteFile: \");\n      AppendNumberTo(&r, iter->first);\n      r.append(\" \");\n      AppendNumberTo(&r, iter->second);\n    }\n    for (size_t i = 0; i < new_files_.size(); i++) {\n      const FileMetaData& f = new_files_[i].second;\n      r.append(\"\\n  AddFile: \");\n      AppendNumberTo(&r, new_files_[i].first);\n      r.append(\" \");\n      AppendNumberTo(&r, f.number);\n      r.append(\" \");\n      AppendNumberTo(&r, f.file_size);\n      r.append(\" \");\n      r.append(f.smallest.DebugString());\n      r.append(\" .. \");\n      r.append(f.largest.DebugString());\n    }\n    r.append(\"\\n}\\n\");\n    return r;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "edit.DecodeFrom",
          "args": [
            "record"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeFrom",
          "container": "InternalKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/dbformat.h",
          "lines": "153-153",
          "snippet": "void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/filter_policy.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/comparator.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/slice.h\"\n#include \"leveldb/filter_policy.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/comparator.h\"\n#include <stdio.h>\n\nInternalKey {\n  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nstatic void VersionEditPrinter(Slice record) {\n  VersionEdit edit;\n  Status s = edit.DecodeFrom(record);\n  if (!s.ok()) {\n    printf(\"%s\\n\", s.ToString().c_str());\n    return;\n  }\n  printf(\"%s\", edit.DebugString().c_str());\n}"
  },
  {
    "function_name": "DumpLog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "104-106",
    "snippet": "bool DumpLog(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, WriteBatchPrinter);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PrintLogContents",
          "args": [
            "env",
            "fname",
            "WriteBatchPrinter"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "PrintLogContents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
          "lines": "46-65",
          "snippet": "bool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/write_batch.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/options.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_edit.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool DumpLog(Env* env, const std::string& fname) {\n  return PrintLogContents(env, fname, WriteBatchPrinter);\n}"
  },
  {
    "function_name": "WriteBatchPrinter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "87-102",
    "snippet": "static void WriteBatchPrinter(Slice record) {\n  if (record.size() < 12) {\n    printf(\"log record length %d is too small\\n\",\n           static_cast<int>(record.size()));\n    return;\n  }\n  WriteBatch batch;\n  WriteBatchInternal::SetContents(&batch, record);\n  printf(\"sequence %llu\\n\",\n         static_cast<unsigned long long>(WriteBatchInternal::Sequence(&batch)));\n  WriteBatchItemPrinter batch_item_printer;\n  Status s = batch.Iterate(&batch_item_printer);\n  if (!s.ok()) {\n    printf(\"  error: %s\\n\", s.ToString().c_str());\n  }\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  error: %s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "batch.Iterate",
          "args": [
            "&batch_item_printer"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "Iterate",
          "container": "WriteBatch",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "42-80",
          "snippet": "Status WriteBatch::Iterate(Handler* handler) const {\n  Slice input(rep_);\n  if (input.size() < kHeader) {\n    return Status::Corruption(\"malformed WriteBatch (too small)\");\n  }\n\n  input.remove_prefix(kHeader);\n  Slice key, value;\n  int found = 0;\n  while (!input.empty()) {\n    found++;\n    char tag = input[0];\n    input.remove_prefix(1);\n    switch (tag) {\n      case kTypeValue:\n        if (GetLengthPrefixedSlice(&input, &key) &&\n            GetLengthPrefixedSlice(&input, &value)) {\n          handler->Put(key, value);\n        } else {\n          return Status::Corruption(\"bad WriteBatch Put\");\n        }\n        break;\n      case kTypeDeletion:\n        if (GetLengthPrefixedSlice(&input, &key)) {\n          handler->Delete(key);\n        } else {\n          return Status::Corruption(\"bad WriteBatch Delete\");\n        }\n        break;\n      default:\n        return Status::Corruption(\"unknown WriteBatch tag\");\n    }\n  }\n  if (found != WriteBatchInternal::Count(this)) {\n    return Status::Corruption(\"WriteBatch has wrong count\");\n  } else {\n    return Status::OK();\n  }\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatch {\n  Status WriteBatch::Iterate(Handler* handler) const {\n    Slice input(rep_);\n    if (input.size() < kHeader) {\n      return Status::Corruption(\"malformed WriteBatch (too small)\");\n    }\n  \n    input.remove_prefix(kHeader);\n    Slice key, value;\n    int found = 0;\n    while (!input.empty()) {\n      found++;\n      char tag = input[0];\n      input.remove_prefix(1);\n      switch (tag) {\n        case kTypeValue:\n          if (GetLengthPrefixedSlice(&input, &key) &&\n              GetLengthPrefixedSlice(&input, &value)) {\n            handler->Put(key, value);\n          } else {\n            return Status::Corruption(\"bad WriteBatch Put\");\n          }\n          break;\n        case kTypeDeletion:\n          if (GetLengthPrefixedSlice(&input, &key)) {\n            handler->Delete(key);\n          } else {\n            return Status::Corruption(\"bad WriteBatch Delete\");\n          }\n          break;\n        default:\n          return Status::Corruption(\"unknown WriteBatch tag\");\n      }\n    }\n    if (found != WriteBatchInternal::Count(this)) {\n      return Status::Corruption(\"WriteBatch has wrong count\");\n    } else {\n      return Status::OK();\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned long long>",
          "args": [
            "WriteBatchInternal::Sequence(&batch)"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::Sequence",
          "args": [
            "&batch"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "Sequence",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "90-92",
          "snippet": "SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {\n  return SequenceNumber(DecodeFixed64(b->rep_.data()));\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {\n    return SequenceNumber(DecodeFixed64(b->rep_.data()));\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteBatchInternal::SetContents",
          "args": [
            "&batch",
            "record"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "SetContents",
          "container": "WriteBatchInternal",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/write_batch.cc",
          "lines": "136-139",
          "snippet": "void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n  assert(contents.size() >= kHeader);\n  b->rep_.assign(contents.data(), contents.size());\n}",
          "includes": [
            "#include \"util/coding.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"leveldb/write_batch.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/coding.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/memtable.h\"\n#include \"db/dbformat.h\"\n#include \"leveldb/db.h\"\n#include \"leveldb/write_batch.h\"\n\nWriteBatchInternal {\n  void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {\n    assert(contents.size() >= kHeader);\n    b->rep_.assign(contents.data(), contents.size());\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "record.size()"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "record.size",
          "args": [],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nstatic void WriteBatchPrinter(Slice record) {\n  if (record.size() < 12) {\n    printf(\"log record length %d is too small\\n\",\n           static_cast<int>(record.size()));\n    return;\n  }\n  WriteBatch batch;\n  WriteBatchInternal::SetContents(&batch, record);\n  printf(\"sequence %llu\\n\",\n         static_cast<unsigned long long>(WriteBatchInternal::Sequence(&batch)));\n  WriteBatchItemPrinter batch_item_printer;\n  Status s = batch.Iterate(&batch_item_printer);\n  if (!s.ok()) {\n    printf(\"  error: %s\\n\", s.ToString().c_str());\n  }\n}"
  },
  {
    "function_name": "Delete",
    "container": "WriteBatchItemPrinter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "78-81",
    "snippet": "virtual void Delete(const Slice& key) {\n    printf(\"  del '%s'\\n\",\n           EscapeString(key).c_str());\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  del '%s'\\n\"",
            "EscapeString(key).c_str()"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [
            "key"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "EscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "42-46",
          "snippet": "std::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Delete(const Slice& key) {\n      printf(\"  del '%s'\\n\",\n             EscapeString(key).c_str());\n    }\n}"
  },
  {
    "function_name": "Put",
    "container": "WriteBatchItemPrinter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "73-77",
    "snippet": "virtual void Put(const Slice& key, const Slice& value) {\n    printf(\"  put '%s' '%s'\\n\",\n           EscapeString(key).c_str(),\n           EscapeString(value).c_str());\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  put '%s' '%s'\\n\"",
            "EscapeString(key).c_str()",
            "EscapeString(value).c_str()"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [
            "value"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "EscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/logging.cc",
          "lines": "42-46",
          "snippet": "std::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include <errno.h>",
            "#include \"util/logging.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include \"leveldb/env.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdarg.h>\n#include <errno.h>\n#include \"util/logging.h\"\n\nstd::string EscapeString(const Slice& value) {\n  std::string r;\n  AppendEscapedStringTo(&r, value);\n  return r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EscapeString",
          "args": [],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nWriteBatchItemPrinter {\n  virtual void Put(const Slice& key, const Slice& value) {\n      printf(\"  put '%s' '%s'\\n\",\n             EscapeString(key).c_str(),\n             EscapeString(value).c_str());\n    }\n}"
  },
  {
    "function_name": "PrintLogContents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "46-65",
    "snippet": "bool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "record"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"--- offset %llu; \"",
            "static_cast<unsigned long long>(reader.LastRecordOffset())"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<unsigned long long>",
          "args": [
            "reader.LastRecordOffset()"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reader.LastRecordOffset",
          "args": [],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "LastRecordOffset",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "164-166",
          "snippet": "uint64_t Reader::LastRecordOffset() {\n  return last_record_offset_;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  uint64_t Reader::LastRecordOffset() {\n    return last_record_offset_;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reader.ReadRecord",
          "args": [
            "&record",
            "&scratch"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "ReadRecord",
          "container": "Reader",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/log_reader.cc",
          "lines": "59-162",
          "snippet": "bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n  if (last_record_offset_ < initial_offset_) {\n    if (!SkipToInitialBlock()) {\n      return false;\n    }\n  }\n\n  scratch->clear();\n  record->clear();\n  bool in_fragmented_record = false;\n  // Record offset of the logical record that we're reading\n  // 0 is a dummy value to make compilers happy\n  uint64_t prospective_record_offset = 0;\n\n  Slice fragment;\n  while (true) {\n    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n    const unsigned int record_type = ReadPhysicalRecord(&fragment);\n    switch (record_type) {\n      case kFullType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(1)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->clear();\n        *record = fragment;\n        last_record_offset_ = prospective_record_offset;\n        return true;\n\n      case kFirstType:\n        if (in_fragmented_record) {\n          // Handle bug in earlier versions of log::Writer where\n          // it could emit an empty kFirstType record at the tail end\n          // of a block followed by a kFullType or kFirstType record\n          // at the beginning of the next block.\n          if (scratch->empty()) {\n            in_fragmented_record = false;\n          } else {\n            ReportCorruption(scratch->size(), \"partial record without end(2)\");\n          }\n        }\n        prospective_record_offset = physical_record_offset;\n        scratch->assign(fragment.data(), fragment.size());\n        in_fragmented_record = true;\n        break;\n\n      case kMiddleType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(1)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n        }\n        break;\n\n      case kLastType:\n        if (!in_fragmented_record) {\n          ReportCorruption(fragment.size(),\n                           \"missing start of fragmented record(2)\");\n        } else {\n          scratch->append(fragment.data(), fragment.size());\n          *record = Slice(*scratch);\n          last_record_offset_ = prospective_record_offset;\n          return true;\n        }\n        break;\n\n      case kEof:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"partial record without end(3)\");\n          scratch->clear();\n        }\n        return false;\n\n      case kBadRecord:\n        if (in_fragmented_record) {\n          ReportCorruption(scratch->size(), \"error in middle of record\");\n          in_fragmented_record = false;\n          scratch->clear();\n        }\n        break;\n\n      default: {\n        char buf[40];\n        snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n        ReportCorruption(\n            (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n            buf);\n        in_fragmented_record = false;\n        scratch->clear();\n        break;\n      }\n    }\n  }\n  return false;\n}",
          "includes": [
            "#include \"util/crc32c.h\"",
            "#include \"util/coding.h\"",
            "#include \"leveldb/env.h\"",
            "#include <stdio.h>",
            "#include \"db/log_reader.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/crc32c.h\"\n#include \"util/coding.h\"\n#include \"leveldb/env.h\"\n#include <stdio.h>\n#include \"db/log_reader.h\"\n\nReader {\n  bool Reader::ReadRecord(Slice* record, std::string* scratch) {\n    if (last_record_offset_ < initial_offset_) {\n      if (!SkipToInitialBlock()) {\n        return false;\n      }\n    }\n  \n    scratch->clear();\n    record->clear();\n    bool in_fragmented_record = false;\n    // Record offset of the logical record that we're reading\n    // 0 is a dummy value to make compilers happy\n    uint64_t prospective_record_offset = 0;\n  \n    Slice fragment;\n    while (true) {\n      uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();\n      const unsigned int record_type = ReadPhysicalRecord(&fragment);\n      switch (record_type) {\n        case kFullType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(1)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->clear();\n          *record = fragment;\n          last_record_offset_ = prospective_record_offset;\n          return true;\n  \n        case kFirstType:\n          if (in_fragmented_record) {\n            // Handle bug in earlier versions of log::Writer where\n            // it could emit an empty kFirstType record at the tail end\n            // of a block followed by a kFullType or kFirstType record\n            // at the beginning of the next block.\n            if (scratch->empty()) {\n              in_fragmented_record = false;\n            } else {\n              ReportCorruption(scratch->size(), \"partial record without end(2)\");\n            }\n          }\n          prospective_record_offset = physical_record_offset;\n          scratch->assign(fragment.data(), fragment.size());\n          in_fragmented_record = true;\n          break;\n  \n        case kMiddleType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(1)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n          }\n          break;\n  \n        case kLastType:\n          if (!in_fragmented_record) {\n            ReportCorruption(fragment.size(),\n                             \"missing start of fragmented record(2)\");\n          } else {\n            scratch->append(fragment.data(), fragment.size());\n            *record = Slice(*scratch);\n            last_record_offset_ = prospective_record_offset;\n            return true;\n          }\n          break;\n  \n        case kEof:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"partial record without end(3)\");\n            scratch->clear();\n          }\n          return false;\n  \n        case kBadRecord:\n          if (in_fragmented_record) {\n            ReportCorruption(scratch->size(), \"error in middle of record\");\n            in_fragmented_record = false;\n            scratch->clear();\n          }\n          break;\n  \n        default: {\n          char buf[40];\n          snprintf(buf, sizeof(buf), \"unknown record type %u\", record_type);\n          ReportCorruption(\n              (fragment.size() + (in_fragmented_record ? scratch->size() : 0)),\n              buf);\n          in_fragmented_record = false;\n          scratch->clear();\n          break;\n        }\n      }\n    }\n    return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "s.ToString().c_str()"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s.ToString",
          "args": [],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CUnsignedSyncCheckpoint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/checkpoints.h",
          "lines": "89-98",
          "snippet": "std::string ToString() const\n    {\n        return strprintf(\n                \"CSyncCheckpoint(\\n\"\n                \"    nVersion       = %d\\n\"\n                \"    hashCheckpoint = %s\\n\"\n                \")\\n\",\n            nVersion,\n            hashCheckpoint.ToString().c_str());\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"net.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"net.h\"\n#include <map>\n\nCUnsignedSyncCheckpoint {\n  std::string ToString() const\n      {\n          return strprintf(\n                  \"CSyncCheckpoint(\\n\"\n                  \"    nVersion       = %d\\n\"\n                  \"    hashCheckpoint = %s\\n\"\n                  \")\\n\",\n              nVersion,\n              hashCheckpoint.ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "s.ok",
          "args": [],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ok",
          "container": "Status",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/status.h",
          "lines": "52-52",
          "snippet": "bool ok() const { return (state_ == NULL); }",
          "includes": [
            "#include \"leveldb/slice.h\"",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"leveldb/slice.h\"\n#include <string>\n\nStatus {\n  bool ok() const { return (state_ == NULL); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "env->NewSequentialFile",
          "args": [
            "fname",
            "&file"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "NewSequentialFile",
          "container": "Win32Env",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/env_win.cc",
          "lines": "951-964",
          "snippet": "Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n{\n    Status sRet;\n    std::string path = fname;\n    ModifyPath(path);\n    Win32SequentialFile* pFile = new Win32SequentialFile(path);\n    if(pFile->isEnable()){\n        *result = pFile;\n    }else {\n        delete pFile;\n        sRet = Status::IOError(path, Win32::GetLastErrSz());\n    }\n    return sRet;\n}",
          "includes": [
            "#include <algorithm>",
            "#include <io.h>",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <cstring>",
            "#include <process.h>",
            "#include <shlwapi.h>",
            "#include \"util/logging.h\"",
            "#include \"leveldb/slice.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/env.h\"",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <algorithm>\n#include <io.h>\n#include <errno.h>\n#include <stdio.h>\n#include <cstring>\n#include <process.h>\n#include <shlwapi.h>\n#include \"util/logging.h\"\n#include \"leveldb/slice.h\"\n#include \"port/port.h\"\n#include \"leveldb/env.h\"\n#include <map>\n\nWin32Env {\n  Status Win32Env::NewSequentialFile( const std::string& fname, SequentialFile** result )\n  {\n      Status sRet;\n      std::string path = fname;\n      ModifyPath(path);\n      Win32SequentialFile* pFile = new Win32SequentialFile(path);\n      if(pFile->isEnable()){\n          *result = pFile;\n      }else {\n          delete pFile;\n          sRet = Status::IOError(path, Win32::GetLastErrSz());\n      }\n      return sRet;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool PrintLogContents(Env* env, const std::string& fname,\n                      void (*func)(Slice)) {\n  SequentialFile* file;\n  Status s = env->NewSequentialFile(fname, &file);\n  if (!s.ok()) {\n    fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n    return false;\n  }\n  CorruptionReporter reporter;\n  log::Reader reader(file, &reporter, true, 0);\n  Slice record;\n  std::string scratch;\n  while (reader.ReadRecord(&record, &scratch)) {\n    printf(\"--- offset %llu; \",\n           static_cast<unsigned long long>(reader.LastRecordOffset()));\n    (*func)(record);\n  }\n  delete file;\n  return true;\n}"
  },
  {
    "function_name": "Corruption",
    "container": "CorruptionReporter",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "38-42",
    "snippet": "virtual void Corruption(size_t bytes, const Status& status) {\n    printf(\"corruption: %d bytes; %s\\n\",\n            static_cast<int>(bytes),\n            status.ToString().c_str());\n  }",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"corruption: %d bytes; %s\\n\"",
            "static_cast<int>(bytes)",
            "status.ToString().c_str()"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "status.ToString",
          "args": [],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "ToString",
          "container": "CService",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "1172-1175",
          "snippet": "std::string CService::ToString() const\n{\n    return ToStringIPPort();\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCService {\n  std::string CService::ToString() const\n  {\n      return ToStringIPPort();\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int>",
          "args": [
            "bytes"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nCorruptionReporter {\n  virtual void Corruption(size_t bytes, const Status& status) {\n      printf(\"corruption: %d bytes; %s\\n\",\n              static_cast<int>(bytes),\n              status.ToString().c_str());\n    }\n}"
  },
  {
    "function_name": "GuessType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/leveldb_main.cc",
    "lines": "23-33",
    "snippet": "bool GuessType(const std::string& fname, FileType* type) {\n  size_t pos = fname.rfind('/');\n  std::string basename;\n  if (pos == std::string::npos) {\n    basename = fname;\n  } else {\n    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);\n  }\n  uint64_t ignored;\n  return ParseFileName(basename, &ignored, type);\n}",
    "includes": [
      "#include \"util/logging.h\"",
      "#include \"leveldb/write_batch.h\"",
      "#include \"leveldb/table.h\"",
      "#include \"leveldb/status.h\"",
      "#include \"leveldb/options.h\"",
      "#include \"leveldb/iterator.h\"",
      "#include \"leveldb/env.h\"",
      "#include \"db/write_batch_internal.h\"",
      "#include \"db/version_edit.h\"",
      "#include \"db/log_reader.h\"",
      "#include \"db/filename.h\"",
      "#include \"db/dbformat.h\"",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ParseFileName",
          "args": [
            "basename",
            "&ignored",
            "type"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "ParseFileName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/filename.cc",
          "lines": "85-129",
          "snippet": "bool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}",
          "includes": [
            "#include \"util/logging.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/filename.h\"",
            "#include <stdio.h>",
            "#include <ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/filename.h\"\n#include <stdio.h>\n#include <ctype.h>\n\nbool ParseFileName(const std::string& fname,\n                   uint64_t* number,\n                   FileType* type) {\n  Slice rest(fname);\n  if (rest == \"CURRENT\") {\n    *number = 0;\n    *type = kCurrentFile;\n  } else if (rest == \"LOCK\") {\n    *number = 0;\n    *type = kDBLockFile;\n  } else if (rest == \"LOG\" || rest == \"LOG.old\") {\n    *number = 0;\n    *type = kInfoLogFile;\n  } else if (rest.starts_with(\"MANIFEST-\")) {\n    rest.remove_prefix(strlen(\"MANIFEST-\"));\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    if (!rest.empty()) {\n      return false;\n    }\n    *type = kDescriptorFile;\n    *number = num;\n  } else {\n    // Avoid strtoull() to keep filename format independent of the\n    // current locale\n    uint64_t num;\n    if (!ConsumeDecimalNumber(&rest, &num)) {\n      return false;\n    }\n    Slice suffix = rest;\n    if (suffix == Slice(\".log\")) {\n      *type = kLogFile;\n    } else if (suffix == Slice(\".sst\") || suffix == Slice(\".ldb\")) {\n      *type = kTableFile;\n    } else if (suffix == Slice(\".dbtmp\")) {\n      *type = kTempFile;\n    } else {\n      return false;\n    }\n    *number = num;\n  }\n  return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "fname.data() + pos + 1",
            "fname.size() - pos - 1"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.size",
          "args": [],
          "line": 29
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fname.data",
          "args": [],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname.rfind",
          "args": [
            "'/'"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/logging.h\"\n#include \"leveldb/write_batch.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/options.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_edit.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include <stdio.h>\n\nbool GuessType(const std::string& fname, FileType* type) {\n  size_t pos = fname.rfind('/');\n  std::string basename;\n  if (pos == std::string::npos) {\n    basename = fname;\n  } else {\n    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);\n  }\n  uint64_t ignored;\n  return ParseFileName(basename, &ignored, type);\n}"
  }
]