[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
    "lines": "116-118",
    "snippet": "int main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "leveldb::test::RunAllTests",
          "args": [],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "RunAllTests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "36-58",
          "snippet": "int RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nint RunAllTests() {\n  const char* matcher = getenv(\"LEVELDB_TESTS\");\n\n  int num = 0;\n  if (tests != NULL) {\n    for (size_t i = 0; i < tests->size(); i++) {\n      const Test& t = (*tests)[i];\n      if (matcher != NULL) {\n        std::string name = t.base;\n        name.push_back('.');\n        name.append(t.name);\n        if (strstr(name.c_str(), matcher) == NULL) {\n          continue;\n        }\n      }\n      fprintf(stderr, \"==== Test %s.%s\\n\", t.base, t.name);\n      (*t.func)();\n      ++num;\n    }\n  }\n  fprintf(stderr, \"==== PASSED %d tests\\n\", num);\n  return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nint main(int argc, char** argv) {\n  return leveldb::test::RunAllTests();\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
    "lines": "110-112",
    "snippet": "TEST(AutoCompactTest, ReadHalf) {\n  DoReads(kCount/2);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoReads",
          "args": [
            "kCount/2"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "DoReads",
          "container": "AutoCompactTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
          "lines": "58-104",
          "snippet": "void AutoCompactTest::DoReads(int n) {\n  std::string value(kValueSize, 'x');\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n\n  // Fill database\n  for (int i = 0; i < kCount; i++) {\n    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n  }\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  // Delete everything\n  for (int i = 0; i < kCount; i++) {\n    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n  }\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  // Get initial measurement of the space we will be reading.\n  const int64_t initial_size = Size(Key(0), Key(n));\n  const int64_t initial_other_size = Size(Key(n), Key(kCount));\n\n  // Read until size drops significantly.\n  std::string limit_key = Key(n);\n  for (int read = 0; true; read++) {\n    ASSERT_LT(read, 100) << \"Taking too long to compact\";\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst();\n         iter->Valid() && iter->key().ToString() < limit_key;\n         iter->Next()) {\n      // Drop data\n    }\n    delete iter;\n    // Wait a little bit to allow any triggered compactions to complete.\n    Env::Default()->SleepForMicroseconds(1000000);\n    uint64_t size = Size(Key(0), Key(n));\n    fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n            read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n    if (size <= initial_size/10) {\n      break;\n    }\n  }\n\n  // Verify that the size of the key space not touched by the reads\n  // is pretty much unchanged.\n  const int64_t final_other_size = Size(Key(n), Key(kCount));\n  ASSERT_LE(final_other_size, initial_other_size + 1048576);\n  ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  void AutoCompactTest::DoReads(int n) {\n    std::string value(kValueSize, 'x');\n    DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  \n    // Fill database\n    for (int i = 0; i < kCount; i++) {\n      ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n    }\n    ASSERT_OK(dbi->TEST_CompactMemTable());\n  \n    // Delete everything\n    for (int i = 0; i < kCount; i++) {\n      ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n    }\n    ASSERT_OK(dbi->TEST_CompactMemTable());\n  \n    // Get initial measurement of the space we will be reading.\n    const int64_t initial_size = Size(Key(0), Key(n));\n    const int64_t initial_other_size = Size(Key(n), Key(kCount));\n  \n    // Read until size drops significantly.\n    std::string limit_key = Key(n);\n    for (int read = 0; true; read++) {\n      ASSERT_LT(read, 100) << \"Taking too long to compact\";\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst();\n           iter->Valid() && iter->key().ToString() < limit_key;\n           iter->Next()) {\n        // Drop data\n      }\n      delete iter;\n      // Wait a little bit to allow any triggered compactions to complete.\n      Env::Default()->SleepForMicroseconds(1000000);\n      uint64_t size = Size(Key(0), Key(n));\n      fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n              read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n      if (size <= initial_size/10) {\n        break;\n      }\n    }\n  \n    // Verify that the size of the key space not touched by the reads\n    // is pretty much unchanged.\n    const int64_t final_other_size = Size(Key(n), Key(kCount));\n    ASSERT_LE(final_other_size, initial_other_size + 1048576);\n    ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nTEST(AutoCompactTest, ReadHalf) {\n  DoReads(kCount/2);\n}"
  },
  {
    "function_name": "TEST",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
    "lines": "106-108",
    "snippet": "TEST(AutoCompactTest, ReadAll) {\n  DoReads(kCount);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DoReads",
          "args": [
            "kCount"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "DoReads",
          "container": "AutoCompactTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
          "lines": "58-104",
          "snippet": "void AutoCompactTest::DoReads(int n) {\n  std::string value(kValueSize, 'x');\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n\n  // Fill database\n  for (int i = 0; i < kCount; i++) {\n    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n  }\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  // Delete everything\n  for (int i = 0; i < kCount; i++) {\n    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n  }\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  // Get initial measurement of the space we will be reading.\n  const int64_t initial_size = Size(Key(0), Key(n));\n  const int64_t initial_other_size = Size(Key(n), Key(kCount));\n\n  // Read until size drops significantly.\n  std::string limit_key = Key(n);\n  for (int read = 0; true; read++) {\n    ASSERT_LT(read, 100) << \"Taking too long to compact\";\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst();\n         iter->Valid() && iter->key().ToString() < limit_key;\n         iter->Next()) {\n      // Drop data\n    }\n    delete iter;\n    // Wait a little bit to allow any triggered compactions to complete.\n    Env::Default()->SleepForMicroseconds(1000000);\n    uint64_t size = Size(Key(0), Key(n));\n    fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n            read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n    if (size <= initial_size/10) {\n      break;\n    }\n  }\n\n  // Verify that the size of the key space not touched by the reads\n  // is pretty much unchanged.\n  const int64_t final_other_size = Size(Key(n), Key(kCount));\n  ASSERT_LE(final_other_size, initial_other_size + 1048576);\n  ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n}",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  void AutoCompactTest::DoReads(int n) {\n    std::string value(kValueSize, 'x');\n    DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  \n    // Fill database\n    for (int i = 0; i < kCount; i++) {\n      ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n    }\n    ASSERT_OK(dbi->TEST_CompactMemTable());\n  \n    // Delete everything\n    for (int i = 0; i < kCount; i++) {\n      ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n    }\n    ASSERT_OK(dbi->TEST_CompactMemTable());\n  \n    // Get initial measurement of the space we will be reading.\n    const int64_t initial_size = Size(Key(0), Key(n));\n    const int64_t initial_other_size = Size(Key(n), Key(kCount));\n  \n    // Read until size drops significantly.\n    std::string limit_key = Key(n);\n    for (int read = 0; true; read++) {\n      ASSERT_LT(read, 100) << \"Taking too long to compact\";\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst();\n           iter->Valid() && iter->key().ToString() < limit_key;\n           iter->Next()) {\n        // Drop data\n      }\n      delete iter;\n      // Wait a little bit to allow any triggered compactions to complete.\n      Env::Default()->SleepForMicroseconds(1000000);\n      uint64_t size = Size(Key(0), Key(n));\n      fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n              read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n      if (size <= initial_size/10) {\n        break;\n      }\n    }\n  \n    // Verify that the size of the key space not touched by the reads\n    // is pretty much unchanged.\n    const int64_t final_other_size = Size(Key(n), Key(kCount));\n    ASSERT_LE(final_other_size, initial_other_size + 1048576);\n    ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nTEST(AutoCompactTest, ReadAll) {\n  DoReads(kCount);\n}"
  },
  {
    "function_name": "DoReads",
    "container": "AutoCompactTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
    "lines": "58-104",
    "snippet": "void AutoCompactTest::DoReads(int n) {\n  std::string value(kValueSize, 'x');\n  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n\n  // Fill database\n  for (int i = 0; i < kCount; i++) {\n    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n  }\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  // Delete everything\n  for (int i = 0; i < kCount; i++) {\n    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n  }\n  ASSERT_OK(dbi->TEST_CompactMemTable());\n\n  // Get initial measurement of the space we will be reading.\n  const int64_t initial_size = Size(Key(0), Key(n));\n  const int64_t initial_other_size = Size(Key(n), Key(kCount));\n\n  // Read until size drops significantly.\n  std::string limit_key = Key(n);\n  for (int read = 0; true; read++) {\n    ASSERT_LT(read, 100) << \"Taking too long to compact\";\n    Iterator* iter = db_->NewIterator(ReadOptions());\n    for (iter->SeekToFirst();\n         iter->Valid() && iter->key().ToString() < limit_key;\n         iter->Next()) {\n      // Drop data\n    }\n    delete iter;\n    // Wait a little bit to allow any triggered compactions to complete.\n    Env::Default()->SleepForMicroseconds(1000000);\n    uint64_t size = Size(Key(0), Key(n));\n    fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n            read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n    if (size <= initial_size/10) {\n      break;\n    }\n  }\n\n  // Verify that the size of the key space not touched by the reads\n  // is pretty much unchanged.\n  const int64_t final_other_size = Size(Key(n), Key(kCount));\n  ASSERT_LE(final_other_size, initial_other_size + 1048576);\n  ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n}",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_GE",
          "args": [
            "final_other_size",
            "initial_other_size/5 - 1048576"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_LE",
          "args": [
            "final_other_size",
            "initial_other_size + 1048576"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Size",
          "args": [
            "Key(n)",
            "Key(kCount)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "Size",
          "container": "AutoCompactTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
          "lines": "42-47",
          "snippet": "uint64_t Size(const Slice& start, const Slice& limit) {\n    Range r(start, limit);\n    uint64_t size;\n    db_->GetApproximateSizes(&r, 1, &size);\n    return size;\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  uint64_t Size(const Slice& start, const Slice& limit) {\n      Range r(start, limit);\n      uint64_t size;\n      db_->GetApproximateSizes(&r, 1, &size);\n      return size;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Key",
          "args": [
            "kCount"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "Key",
          "container": "AutoCompactTest",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
          "lines": "36-40",
          "snippet": "std::string Key(int i) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"key%06d\", i);\n    return std::string(buf);\n  }",
          "includes": [
            "#include \"util/testutil.h\"",
            "#include \"util/testharness.h\"",
            "#include \"leveldb/cache.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"leveldb/db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  std::string Key(int i) {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"key%06d\", i);\n      return std::string(buf);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"iter %3d => %7.3f MB [other %7.3f MB]\\n\"",
            "read+1",
            "size/1048576.0",
            "Size(Key(n), Key(kCount))/1048576.0"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [
            "1000000"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Env::Default",
          "args": [],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iter->Next",
          "args": [],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "Next",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "146-171",
          "snippet": "void DBIter::Next() {\n  assert(valid_);\n\n  if (direction_ == kReverse) {  // Switch directions?\n    direction_ = kForward;\n    // iter_ is pointing just before the entries for this->key(),\n    // so advance into the range of entries for this->key() and then\n    // use the normal skipping code below.\n    if (!iter_->Valid()) {\n      iter_->SeekToFirst();\n    } else {\n      iter_->Next();\n    }\n    if (!iter_->Valid()) {\n      valid_ = false;\n      saved_key_.clear();\n      return;\n    }\n    // saved_key_ already contains the key to skip past.\n  } else {\n    // Store in saved_key_ the current key so we skip it below.\n    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n  }\n\n  FindNextUserEntry(true, &saved_key_);\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::Next() {\n    assert(valid_);\n  \n    if (direction_ == kReverse) {  // Switch directions?\n      direction_ = kForward;\n      // iter_ is pointing just before the entries for this->key(),\n      // so advance into the range of entries for this->key() and then\n      // use the normal skipping code below.\n      if (!iter_->Valid()) {\n        iter_->SeekToFirst();\n      } else {\n        iter_->Next();\n      }\n      if (!iter_->Valid()) {\n        valid_ = false;\n        saved_key_.clear();\n        return;\n      }\n      // saved_key_ already contains the key to skip past.\n    } else {\n      // Store in saved_key_ the current key so we skip it below.\n      SaveKey(ExtractUserKey(iter_->key()), &saved_key_);\n    }\n  \n    FindNextUserEntry(true, &saved_key_);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->key",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "key",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "66-69",
          "snippet": "virtual Slice key() const {\n    assert(valid_);\n    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n  }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual Slice key() const {\n      assert(valid_);\n      return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->Valid",
          "args": [],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "Valid",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "65-65",
          "snippet": "virtual bool Valid() const { return valid_; }",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  virtual bool Valid() const { return valid_; }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iter->SeekToFirst",
          "args": [],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "SeekToFirst",
          "container": "DBIter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_iter.cc",
          "lines": "288-297",
          "snippet": "void DBIter::SeekToFirst() {\n  direction_ = kForward;\n  ClearSavedValue();\n  iter_->SeekToFirst();\n  if (iter_->Valid()) {\n    FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n  } else {\n    valid_ = false;\n  }\n}",
          "includes": [
            "#include \"util/random.h\"",
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/iterator.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_impl.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/db_iter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/random.h\"\n#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"port/port.h\"\n#include \"leveldb/iterator.h\"\n#include \"leveldb/env.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_impl.h\"\n#include \"db/filename.h\"\n#include \"db/db_iter.h\"\n\nDBIter {\n  void DBIter::SeekToFirst() {\n    direction_ = kForward;\n    ClearSavedValue();\n    iter_->SeekToFirst();\n    if (iter_->Valid()) {\n      FindNextUserEntry(false, &saved_key_ /* temporary storage */);\n    } else {\n      valid_ = false;\n    }\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "db_->NewIterator",
          "args": [
            "ReadOptions()"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ReadOptions",
          "args": [],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "ReadOptions",
          "container": "ReadOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "161-165",
          "snippet": "ReadOptions()\n      : verify_checksums(false),\n        fill_cache(true),\n        snapshot(NULL) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nReadOptions {\n  ReadOptions()\n        : verify_checksums(false),\n          fill_cache(true),\n          snapshot(NULL) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_LT",
          "args": [
            "read",
            "100"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "dbi->TEST_CompactMemTable()"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbi->TEST_CompactMemTable",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "TEST_CompactMemTable",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "590-604",
          "snippet": "Status DBImpl::TEST_CompactMemTable() {\n  // NULL batch means just wait for earlier writes to be done\n  Status s = Write(WriteOptions(), NULL);\n  if (s.ok()) {\n    // Wait until the compaction completes\n    MutexLock l(&mutex_);\n    while (imm_ != NULL && bg_error_.ok()) {\n      bg_cv_.Wait();\n    }\n    if (imm_ != NULL) {\n      s = bg_error_;\n    }\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  Status DBImpl::TEST_CompactMemTable() {\n    // NULL batch means just wait for earlier writes to be done\n    Status s = Write(WriteOptions(), NULL);\n    if (s.ok()) {\n      // Wait until the compaction completes\n      MutexLock l(&mutex_);\n      while (imm_ != NULL && bg_error_.ok()) {\n        bg_cv_.Wait();\n      }\n      if (imm_ != NULL) {\n        s = bg_error_;\n      }\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Delete(WriteOptions(), Key(i))"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Delete",
          "args": [
            "WriteOptions()",
            "Key(i)"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "Delete",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1437-1441",
          "snippet": "Status DB::Delete(const WriteOptions& opt, const Slice& key) {\n  WriteBatch batch;\n  batch.Delete(key);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Delete(const WriteOptions& opt, const Slice& key) {\n    WriteBatch batch;\n    batch.Delete(key);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "WriteOptions",
          "args": [],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "WriteOptions",
          "container": "WriteOptions",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/include/leveldb/options.h",
          "lines": "188-190",
          "snippet": "WriteOptions()\n      : sync(false) {\n  }",
          "includes": [
            "#include <stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stddef.h>\n\nWriteOptions {\n  WriteOptions()\n        : sync(false) {\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "dbi->TEST_CompactMemTable()"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "db_->Put(WriteOptions(), Key(i), value)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "db_->Put",
          "args": [
            "WriteOptions()",
            "Key(i)",
            "value"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "Put",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1431-1435",
          "snippet": "Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n  WriteBatch batch;\n  batch.Put(key, value);\n  return Write(opt, &batch);\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {\n    WriteBatch batch;\n    batch.Put(key, value);\n    return Write(opt, &batch);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "reinterpret_cast<DBImpl*>",
          "args": [
            "db_"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  void AutoCompactTest::DoReads(int n) {\n    std::string value(kValueSize, 'x');\n    DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);\n  \n    // Fill database\n    for (int i = 0; i < kCount; i++) {\n      ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));\n    }\n    ASSERT_OK(dbi->TEST_CompactMemTable());\n  \n    // Delete everything\n    for (int i = 0; i < kCount; i++) {\n      ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));\n    }\n    ASSERT_OK(dbi->TEST_CompactMemTable());\n  \n    // Get initial measurement of the space we will be reading.\n    const int64_t initial_size = Size(Key(0), Key(n));\n    const int64_t initial_other_size = Size(Key(n), Key(kCount));\n  \n    // Read until size drops significantly.\n    std::string limit_key = Key(n);\n    for (int read = 0; true; read++) {\n      ASSERT_LT(read, 100) << \"Taking too long to compact\";\n      Iterator* iter = db_->NewIterator(ReadOptions());\n      for (iter->SeekToFirst();\n           iter->Valid() && iter->key().ToString() < limit_key;\n           iter->Next()) {\n        // Drop data\n      }\n      delete iter;\n      // Wait a little bit to allow any triggered compactions to complete.\n      Env::Default()->SleepForMicroseconds(1000000);\n      uint64_t size = Size(Key(0), Key(n));\n      fprintf(stderr, \"iter %3d => %7.3f MB [other %7.3f MB]\\n\",\n              read+1, size/1048576.0, Size(Key(n), Key(kCount))/1048576.0);\n      if (size <= initial_size/10) {\n        break;\n      }\n    }\n  \n    // Verify that the size of the key space not touched by the reads\n    // is pretty much unchanged.\n    const int64_t final_other_size = Size(Key(n), Key(kCount));\n    ASSERT_LE(final_other_size, initial_other_size + 1048576);\n    ASSERT_GE(final_other_size, initial_other_size/5 - 1048576);\n  }\n}"
  },
  {
    "function_name": "Size",
    "container": "AutoCompactTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
    "lines": "42-47",
    "snippet": "uint64_t Size(const Slice& start, const Slice& limit) {\n    Range r(start, limit);\n    uint64_t size;\n    db_->GetApproximateSizes(&r, 1, &size);\n    return size;\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "db_->GetApproximateSizes",
          "args": [
            "&r",
            "1",
            "&size"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "GetApproximateSizes",
          "container": "DBImpl",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1403-1427",
          "snippet": "void DBImpl::GetApproximateSizes(\n    const Range* range, int n,\n    uint64_t* sizes) {\n  // TODO(opt): better implementation\n  Version* v;\n  {\n    MutexLock l(&mutex_);\n    versions_->current()->Ref();\n    v = versions_->current();\n  }\n\n  for (int i = 0; i < n; i++) {\n    // Convert user_key into a corresponding internal key.\n    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);\n    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);\n    uint64_t start = versions_->ApproximateOffsetOf(v, k1);\n    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);\n    sizes[i] = (limit >= start ? limit - start : 0);\n  }\n\n  {\n    MutexLock l(&mutex_);\n    v->Unref();\n  }\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDBImpl {\n  void DBImpl::GetApproximateSizes(\n      const Range* range, int n,\n      uint64_t* sizes) {\n    // TODO(opt): better implementation\n    Version* v;\n    {\n      MutexLock l(&mutex_);\n      versions_->current()->Ref();\n      v = versions_->current();\n    }\n  \n    for (int i = 0; i < n; i++) {\n      // Convert user_key into a corresponding internal key.\n      InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);\n      InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);\n      uint64_t start = versions_->ApproximateOffsetOf(v, k1);\n      uint64_t limit = versions_->ApproximateOffsetOf(v, k2);\n      sizes[i] = (limit >= start ? limit - start : 0);\n    }\n  \n    {\n      MutexLock l(&mutex_);\n      v->Unref();\n    }\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  uint64_t Size(const Slice& start, const Slice& limit) {\n      Range r(start, limit);\n      uint64_t size;\n      db_->GetApproximateSizes(&r, 1, &size);\n      return size;\n    }\n}"
  },
  {
    "function_name": "Key",
    "container": "AutoCompactTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
    "lines": "36-40",
    "snippet": "std::string Key(int i) {\n    char buf[100];\n    snprintf(buf, sizeof(buf), \"key%06d\", i);\n    return std::string(buf);\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "std::string",
          "args": [
            "buf"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"key%06d\"",
            "i"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  std::string Key(int i) {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"key%06d\", i);\n      return std::string(buf);\n    }\n}"
  },
  {
    "function_name": "AutoCompactTest",
    "container": "AutoCompactTest",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/autocompact_test.cc",
    "lines": "20-28",
    "snippet": "AutoCompactTest() {\n    dbname_ = test::TmpDir() + \"/autocompact_test\";\n    tiny_cache_ = NewLRUCache(100);\n    options_.block_cache = tiny_cache_;\n    DestroyDB(dbname_, options_);\n    options_.create_if_missing = true;\n    options_.compression = kNoCompression;\n    ASSERT_OK(DB::Open(options_, dbname_, &db_));\n  }",
    "includes": [
      "#include \"util/testutil.h\"",
      "#include \"util/testharness.h\"",
      "#include \"leveldb/cache.h\"",
      "#include \"db/db_impl.h\"",
      "#include \"leveldb/db.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT_OK",
          "args": [
            "DB::Open(options_, dbname_, &db_)"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DB::Open",
          "args": [
            "options_",
            "dbname_",
            "&db_"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "Open",
          "container": "DB",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1445-1477",
          "snippet": "Status DB::Open(const Options& options, const std::string& dbname,\n                DB** dbptr) {\n  *dbptr = NULL;\n\n  DBImpl* impl = new DBImpl(options, dbname);\n  impl->mutex_.Lock();\n  VersionEdit edit;\n  Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n  if (s.ok()) {\n    uint64_t new_log_number = impl->versions_->NewFileNumber();\n    WritableFile* lfile;\n    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                     &lfile);\n    if (s.ok()) {\n      edit.SetLogNumber(new_log_number);\n      impl->logfile_ = lfile;\n      impl->logfile_number_ = new_log_number;\n      impl->log_ = new log::Writer(lfile);\n      s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n    }\n    if (s.ok()) {\n      impl->DeleteObsoleteFiles();\n      impl->MaybeScheduleCompaction();\n    }\n  }\n  impl->mutex_.Unlock();\n  if (s.ok()) {\n    *dbptr = impl;\n  } else {\n    delete impl;\n  }\n  return s;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nDB {\n  Status DB::Open(const Options& options, const std::string& dbname,\n                  DB** dbptr) {\n    *dbptr = NULL;\n  \n    DBImpl* impl = new DBImpl(options, dbname);\n    impl->mutex_.Lock();\n    VersionEdit edit;\n    Status s = impl->Recover(&edit); // Handles create_if_missing, error_if_exists\n    if (s.ok()) {\n      uint64_t new_log_number = impl->versions_->NewFileNumber();\n      WritableFile* lfile;\n      s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),\n                                       &lfile);\n      if (s.ok()) {\n        edit.SetLogNumber(new_log_number);\n        impl->logfile_ = lfile;\n        impl->logfile_number_ = new_log_number;\n        impl->log_ = new log::Writer(lfile);\n        s = impl->versions_->LogAndApply(&edit, &impl->mutex_);\n      }\n      if (s.ok()) {\n        impl->DeleteObsoleteFiles();\n        impl->MaybeScheduleCompaction();\n      }\n    }\n    impl->mutex_.Unlock();\n    if (s.ok()) {\n      *dbptr = impl;\n    } else {\n      delete impl;\n    }\n    return s;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "DestroyDB",
          "args": [
            "dbname_",
            "options_"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "DestroyDB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/db/db_impl.cc",
          "lines": "1482-1511",
          "snippet": "Status DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}",
          "includes": [
            "#include \"util/mutexlock.h\"",
            "#include \"util/logging.h\"",
            "#include \"util/coding.h\"",
            "#include \"table/two_level_iterator.h\"",
            "#include \"table/merger.h\"",
            "#include \"table/block.h\"",
            "#include \"port/port.h\"",
            "#include \"leveldb/table_builder.h\"",
            "#include \"leveldb/table.h\"",
            "#include \"leveldb/status.h\"",
            "#include \"leveldb/env.h\"",
            "#include \"leveldb/db.h\"",
            "#include \"db/write_batch_internal.h\"",
            "#include \"db/version_set.h\"",
            "#include \"db/table_cache.h\"",
            "#include \"db/memtable.h\"",
            "#include \"db/log_writer.h\"",
            "#include \"db/log_reader.h\"",
            "#include \"db/filename.h\"",
            "#include \"db/dbformat.h\"",
            "#include \"db/db_iter.h\"",
            "#include \"db/builder.h\"",
            "#include <vector>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <string>",
            "#include <set>",
            "#include <algorithm>",
            "#include \"db/db_impl.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/mutexlock.h\"\n#include \"util/logging.h\"\n#include \"util/coding.h\"\n#include \"table/two_level_iterator.h\"\n#include \"table/merger.h\"\n#include \"table/block.h\"\n#include \"port/port.h\"\n#include \"leveldb/table_builder.h\"\n#include \"leveldb/table.h\"\n#include \"leveldb/status.h\"\n#include \"leveldb/env.h\"\n#include \"leveldb/db.h\"\n#include \"db/write_batch_internal.h\"\n#include \"db/version_set.h\"\n#include \"db/table_cache.h\"\n#include \"db/memtable.h\"\n#include \"db/log_writer.h\"\n#include \"db/log_reader.h\"\n#include \"db/filename.h\"\n#include \"db/dbformat.h\"\n#include \"db/db_iter.h\"\n#include \"db/builder.h\"\n#include <vector>\n#include <stdio.h>\n#include <stdint.h>\n#include <string>\n#include <set>\n#include <algorithm>\n#include \"db/db_impl.h\"\n\nStatus DestroyDB(const std::string& dbname, const Options& options) {\n  Env* env = options.env;\n  std::vector<std::string> filenames;\n  // Ignore error in case directory does not exist\n  env->GetChildren(dbname, &filenames);\n  if (filenames.empty()) {\n    return Status::OK();\n  }\n\n  FileLock* lock;\n  const std::string lockname = LockFileName(dbname);\n  Status result = env->LockFile(lockname, &lock);\n  if (result.ok()) {\n    uint64_t number;\n    FileType type;\n    for (size_t i = 0; i < filenames.size(); i++) {\n      if (ParseFileName(filenames[i], &number, &type) &&\n          type != kDBLockFile) {  // Lock file will be deleted at end\n        Status del = env->DeleteFile(dbname + \"/\" + filenames[i]);\n        if (result.ok() && !del.ok()) {\n          result = del;\n        }\n      }\n    }\n    env->UnlockFile(lock);  // Ignore error since state is already gone\n    env->DeleteFile(lockname);\n    env->DeleteDir(dbname);  // Ignore error in case dir contains other files\n  }\n  return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NewLRUCache",
          "args": [
            "100"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test::TmpDir",
          "args": [],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "TmpDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/leveldb/util/testharness.cc",
          "lines": "60-65",
          "snippet": "std::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}",
          "includes": [
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string>",
            "#include \"util/testharness.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string>\n#include \"util/testharness.h\"\n\nstd::string TmpDir() {\n  std::string dir;\n  Status s = Env::Default()->GetTestDirectory(&dir);\n  ASSERT_TRUE(s.ok()) << s.ToString();\n  return dir;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util/testutil.h\"\n#include \"util/testharness.h\"\n#include \"leveldb/cache.h\"\n#include \"db/db_impl.h\"\n#include \"leveldb/db.h\"\n\nAutoCompactTest {\n  AutoCompactTest() {\n      dbname_ = test::TmpDir() + \"/autocompact_test\";\n      tiny_cache_ = NewLRUCache(100);\n      options_.block_cache = tiny_cache_;\n      DestroyDB(dbname_, options_);\n      options_.create_if_missing = true;\n      options_.compression = kNoCompression;\n      ASSERT_OK(DB::Open(options_, dbname_, &db_));\n    }\n}"
  }
]