[
  {
    "function_name": "SetMultisig",
    "container": "CScript",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "2016-2024",
    "snippet": "void CScript::SetMultisig(int nRequired, const std::vector<CKey>& keys)\n{\n    this->clear();\n\n    *this << EncodeOP_N(nRequired);\n    BOOST_FOREACH(const CKey& key, keys)\n        *this << key.GetPubKey();\n    *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EncodeOP_N",
          "args": [
            "keys.size()"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "EncodeOP_N",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "479-485",
          "snippet": "static opcodetype EncodeOP_N(int n)\n    {\n        assert(n >= 0 && n <= 16);\n        if (n == 0)\n            return OP_0;\n        return (opcodetype)(OP_1+n-1);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  static opcodetype EncodeOP_N(int n)\n      {\n          assert(n >= 0 && n <= 16);\n          if (n == 0)\n              return OP_0;\n          return (opcodetype)(OP_1+n-1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "keys.size",
          "args": [],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.GetPubKey",
          "args": [],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "274-284",
          "snippet": "CPubKey CKey::GetPubKey() const\n{\n    int nSize = i2o_ECPublicKey(pkey, NULL);\n    if (!nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n    std::vector<unsigned char> vchPubKey(nSize, 0);\n    unsigned char* pbegin = &vchPubKey[0];\n    if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n        throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n    return CPubKey(vchPubKey);\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  CPubKey CKey::GetPubKey() const\n  {\n      int nSize = i2o_ECPublicKey(pkey, NULL);\n      if (!nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey failed\");\n      std::vector<unsigned char> vchPubKey(nSize, 0);\n      unsigned char* pbegin = &vchPubKey[0];\n      if (i2o_ECPublicKey(pkey, &pbegin) != nSize)\n          throw key_error(\"CKey::GetPubKey() : i2o_ECPublicKey returned unexpected size\");\n      return CPubKey(vchPubKey);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "this->clear",
          "args": [],
          "line": 2018
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  void CScript::SetMultisig(int nRequired, const std::vector<CKey>& keys)\n  {\n      this->clear();\n  \n      *this << EncodeOP_N(nRequired);\n      BOOST_FOREACH(const CKey& key, keys)\n          *this << key.GetPubKey();\n      *this << EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n  }\n}"
  },
  {
    "function_name": "SetDestination",
    "container": "CScript",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "2011-2014",
    "snippet": "void CScript::SetDestination(const CTxDestination& dest)\n{\n    boost::apply_visitor(CScriptVisitor(this), dest);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boost::apply_visitor",
          "args": [
            "CScriptVisitor(this)",
            "dest"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CScriptVisitor",
          "args": [
            "this"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "CScriptVisitor",
          "container": "CScriptVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1991-1991",
          "snippet": "CScriptVisitor(CScript *scriptin) { script = scriptin; }",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScriptVisitor {\n  CScriptVisitor(CScript *scriptin) { script = scriptin; }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  void CScript::SetDestination(const CTxDestination& dest)\n  {\n      boost::apply_visitor(CScriptVisitor(this), dest);\n  }\n}"
  },
  {
    "function_name": "CScriptVisitor",
    "container": "CScriptVisitor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1991-1991",
    "snippet": "CScriptVisitor(CScript *scriptin) { script = scriptin; }",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScriptVisitor {\n  CScriptVisitor(CScript *scriptin) { script = scriptin; }\n}"
  },
  {
    "function_name": "HasCanonicalPushes",
    "container": "CScript",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1959-1984",
    "snippet": "bool CScript::HasCanonicalPushes() const\n{\n    const_iterator pc = begin();\n    while (pc < end())\n    {\n        opcodetype opcode;\n        std::vector<unsigned char> data;\n        if (!GetOp(pc, opcode, data))\n            return false;\n        if (opcode > OP_16)\n            continue;\n        if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n            // Could have used an OP_n code, rather than a 1-byte push.\n            return false;\n        if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n            // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n            // Could have used an OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n            // Could have used an OP_PUSHDATA2.\n            return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data.size",
          "args": [],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOp",
          "args": [
            "pc",
            "opcode",
            "data"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "GetOp2",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "418-469",
          "snippet": "bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const\n    {\n        opcodeRet = OP_INVALIDOPCODE;\n        if (pvchRet)\n            pvchRet->clear();\n        if (pc >= end())\n            return false;\n\n        // Read instruction\n        if (end() - pc < 1)\n            return false;\n        unsigned int opcode = *pc++;\n\n        // Immediate operand\n        if (opcode <= OP_PUSHDATA4)\n        {\n            unsigned int nSize;\n            if (opcode < OP_PUSHDATA1)\n            {\n                nSize = opcode;\n            }\n            else if (opcode == OP_PUSHDATA1)\n            {\n                if (end() - pc < 1)\n                    return false;\n                nSize = *pc++;\n            }\n            else if (opcode == OP_PUSHDATA2)\n            {\n                if (end() - pc < 2)\n                    return false;\n                nSize = 0;\n                memcpy(&nSize, &pc[0], 2);\n                pc += 2;\n            }\n            else if (opcode == OP_PUSHDATA4)\n            {\n                if (end() - pc < 4)\n                    return false;\n                memcpy(&nSize, &pc[0], 4);\n                pc += 4;\n            }\n            if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)\n                return false;\n            if (pvchRet)\n                pvchRet->assign(pc, pc + nSize);\n            pc += nSize;\n        }\n\n        opcodeRet = (opcodetype)opcode;\n        return true;\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool GetOp2(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>* pvchRet) const\n      {\n          opcodeRet = OP_INVALIDOPCODE;\n          if (pvchRet)\n              pvchRet->clear();\n          if (pc >= end())\n              return false;\n  \n          // Read instruction\n          if (end() - pc < 1)\n              return false;\n          unsigned int opcode = *pc++;\n  \n          // Immediate operand\n          if (opcode <= OP_PUSHDATA4)\n          {\n              unsigned int nSize;\n              if (opcode < OP_PUSHDATA1)\n              {\n                  nSize = opcode;\n              }\n              else if (opcode == OP_PUSHDATA1)\n              {\n                  if (end() - pc < 1)\n                      return false;\n                  nSize = *pc++;\n              }\n              else if (opcode == OP_PUSHDATA2)\n              {\n                  if (end() - pc < 2)\n                      return false;\n                  nSize = 0;\n                  memcpy(&nSize, &pc[0], 2);\n                  pc += 2;\n              }\n              else if (opcode == OP_PUSHDATA4)\n              {\n                  if (end() - pc < 4)\n                      return false;\n                  memcpy(&nSize, &pc[0], 4);\n                  pc += 4;\n              }\n              if (end() - pc < 0 || (unsigned int)(end() - pc) < nSize)\n                  return false;\n              if (pvchRet)\n                  pvchRet->assign(pc, pc + nSize);\n              pc += nSize;\n          }\n  \n          opcodeRet = (opcodetype)opcode;\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "end",
          "args": [],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "SendBufferSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "30-30",
          "snippet": "inline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\ninline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }"
        }
      },
      {
        "call_info": {
          "callee": "begin",
          "args": [],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::HasCanonicalPushes() const\n  {\n      const_iterator pc = begin();\n      while (pc < end())\n      {\n          opcodetype opcode;\n          std::vector<unsigned char> data;\n          if (!GetOp(pc, opcode, data))\n              return false;\n          if (opcode > OP_16)\n              continue;\n          if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n              // Could have used an OP_n code, rather than a 1-byte push.\n              return false;\n          if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n              // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n              // Could have used an OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n              // Could have used an OP_PUSHDATA2.\n              return false;\n      }\n      return true;\n  }\n}"
  },
  {
    "function_name": "IsPayToScriptHash",
    "container": "CScript",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1950-1957",
    "snippet": "bool CScript::IsPayToScriptHash() const\n{\n    // Extra-fast test for pay-to-script-hash CScripts:\n    return (this->size() == 23 &&\n            this->at(0) == OP_HASH160 &&\n            this->at(1) == 0x14 &&\n            this->at(22) == OP_EQUAL);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this->at",
          "args": [
            "22"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->at",
          "args": [
            "1"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->at",
          "args": [
            "0"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this->size",
          "args": [],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::IsPayToScriptHash() const\n  {\n      // Extra-fast test for pay-to-script-hash CScripts:\n      return (this->size() == 23 &&\n              this->at(0) == OP_HASH160 &&\n              this->at(1) == 0x14 &&\n              this->at(22) == OP_EQUAL);\n  }\n}"
  },
  {
    "function_name": "GetSigOpCount",
    "container": "CScript",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1926-1948",
    "snippet": "unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n{\n    if (!IsPayToScriptHash())\n        return GetSigOpCount(true);\n\n    // This is a pay-to-script-hash scriptPubKey;\n    // get the last item that the scriptSig\n    // pushes onto the stack:\n    const_iterator pc = scriptSig.begin();\n    vector<unsigned char> data;\n    while (pc < scriptSig.end())\n    {\n        opcodetype opcode;\n        if (!scriptSig.GetOp(pc, opcode, data))\n            return 0;\n        if (opcode > OP_16)\n            return 0;\n    }\n\n    /// ... and return its opcount:\n    CScript subscript(data.begin(), data.end());\n    return subscript.GetSigOpCount(true);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "subscript.GetSigOpCount",
          "args": [
            "true"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "GetSigOpCount",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1926-1948",
          "snippet": "unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n{\n    if (!IsPayToScriptHash())\n        return GetSigOpCount(true);\n\n    // This is a pay-to-script-hash scriptPubKey;\n    // get the last item that the scriptSig\n    // pushes onto the stack:\n    const_iterator pc = scriptSig.begin();\n    vector<unsigned char> data;\n    while (pc < scriptSig.end())\n    {\n        opcodetype opcode;\n        if (!scriptSig.GetOp(pc, opcode, data))\n            return 0;\n        if (opcode > OP_16)\n            return 0;\n    }\n\n    /// ... and return its opcount:\n    CScript subscript(data.begin(), data.end());\n    return subscript.GetSigOpCount(true);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "data.end",
          "args": [],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "data.begin",
          "args": [],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptSig.GetOp",
          "args": [
            "pc",
            "opcode",
            "data"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "GetOp",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "408-411",
          "snippet": "bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n    {\n        return GetOp2(pc, opcodeRet, &vchRet);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n      {\n          return GetOp2(pc, opcodeRet, &vchRet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsPayToScriptHash",
          "args": [],
          "line": 1928
        },
        "resolved": true,
        "details": {
          "function_name": "IsPayToScriptHash",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1950-1957",
          "snippet": "bool CScript::IsPayToScriptHash() const\n{\n    // Extra-fast test for pay-to-script-hash CScripts:\n    return (this->size() == 23 &&\n            this->at(0) == OP_HASH160 &&\n            this->at(1) == 0x14 &&\n            this->at(22) == OP_EQUAL);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::IsPayToScriptHash() const\n  {\n      // Extra-fast test for pay-to-script-hash CScripts:\n      return (this->size() == 23 &&\n              this->at(0) == OP_HASH160 &&\n              this->at(1) == 0x14 &&\n              this->at(22) == OP_EQUAL);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const\n  {\n      if (!IsPayToScriptHash())\n          return GetSigOpCount(true);\n  \n      // This is a pay-to-script-hash scriptPubKey;\n      // get the last item that the scriptSig\n      // pushes onto the stack:\n      const_iterator pc = scriptSig.begin();\n      vector<unsigned char> data;\n      while (pc < scriptSig.end())\n      {\n          opcodetype opcode;\n          if (!scriptSig.GetOp(pc, opcode, data))\n              return 0;\n          if (opcode > OP_16)\n              return 0;\n      }\n  \n      /// ... and return its opcount:\n      CScript subscript(data.begin(), data.end());\n      return subscript.GetSigOpCount(true);\n  }\n}"
  },
  {
    "function_name": "GetSigOpCount",
    "container": "CScript",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1902-1924",
    "snippet": "unsigned int CScript::GetSigOpCount(bool fAccurate) const\n{\n    unsigned int n = 0;\n    const_iterator pc = begin();\n    opcodetype lastOpcode = OP_INVALIDOPCODE;\n    while (pc < end())\n    {\n        opcodetype opcode;\n        if (!GetOp(pc, opcode))\n            break;\n        if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n            n++;\n        else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n        {\n            if (fAccurate && lastOpcode >= OP_1 && lastOpcode <= OP_16)\n                n += DecodeOP_N(lastOpcode);\n            else\n                n += 20;\n        }\n        lastOpcode = opcode;\n    }\n    return n;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "DecodeOP_N",
          "args": [
            "lastOpcode"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeOP_N",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "472-478",
          "snippet": "static int DecodeOP_N(opcodetype opcode)\n    {\n        if (opcode == OP_0)\n            return 0;\n        assert(opcode >= OP_1 && opcode <= OP_16);\n        return (int)opcode - (int)(OP_1 - 1);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  static int DecodeOP_N(opcodetype opcode)\n      {\n          if (opcode == OP_0)\n              return 0;\n          assert(opcode >= OP_1 && opcode <= OP_16);\n          return (int)opcode - (int)(OP_1 - 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "GetOp",
          "args": [
            "pc",
            "opcode"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "GetOp",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "413-416",
          "snippet": "bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n    {\n        return GetOp2(pc, opcodeRet, NULL);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool GetOp(const_iterator& pc, opcodetype& opcodeRet) const\n      {\n          return GetOp2(pc, opcodeRet, NULL);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "end",
          "args": [],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "SendBufferSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/net.h",
          "lines": "30-30",
          "snippet": "inline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }",
          "includes": [
            "#include \"addrman.h\"",
            "#include \"protocol.h\"",
            "#include \"netbase.h\"",
            "#include \"mruset.h\"",
            "#include <arpa/inet.h>",
            "#include <openssl/rand.h>",
            "#include <boost/foreach.hpp>",
            "#include <boost/array.hpp>",
            "#include <deque>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"addrman.h\"\n#include \"protocol.h\"\n#include \"netbase.h\"\n#include \"mruset.h\"\n#include <arpa/inet.h>\n#include <openssl/rand.h>\n#include <boost/foreach.hpp>\n#include <boost/array.hpp>\n#include <deque>\n\ninline unsigned int SendBufferSize() { return 1000*GetArg(\"-maxsendbuffer\", 1*1000); }"
        }
      },
      {
        "call_info": {
          "callee": "begin",
          "args": [],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  unsigned int CScript::GetSigOpCount(bool fAccurate) const\n  {\n      unsigned int n = 0;\n      const_iterator pc = begin();\n      opcodetype lastOpcode = OP_INVALIDOPCODE;\n      while (pc < end())\n      {\n          opcodetype opcode;\n          if (!GetOp(pc, opcode))\n              break;\n          if (opcode == OP_CHECKSIG || opcode == OP_CHECKSIGVERIFY)\n              n++;\n          else if (opcode == OP_CHECKMULTISIG || opcode == OP_CHECKMULTISIGVERIFY)\n          {\n              if (fAccurate && lastOpcode >= OP_1 && lastOpcode <= OP_16)\n                  n += DecodeOP_N(lastOpcode);\n              else\n                  n += 20;\n          }\n          lastOpcode = opcode;\n      }\n      return n;\n  }\n}"
  },
  {
    "function_name": "CombineSignatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1887-1900",
    "snippet": "CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                          const CScript& scriptSig1, const CScript& scriptSig2)\n{\n    txnouttype txType;\n    vector<vector<unsigned char> > vSolutions;\n    Solver(scriptPubKey, txType, vSolutions);\n\n    vector<valtype> stack1;\n    EvalScript(stack1, scriptSig1, CTransaction(), 0, 0);\n    vector<valtype> stack2;\n    EvalScript(stack2, scriptSig2, CTransaction(), 0, 0);\n\n    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CombineSignatures",
          "args": [
            "scriptPubKey",
            "txTo",
            "nIn",
            "txType",
            "vSolutions",
            "stack1",
            "stack2"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "CombineSignatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1843-1885",
          "snippet": "static CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                                 const txnouttype txType, const vector<valtype>& vSolutions,\n                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    switch (txType)\n    {\n    case TX_NONSTANDARD:\n        // Don't know anything about this, assume bigger one is correct:\n        if (sigs1.size() >= sigs2.size())\n            return PushAll(sigs1);\n        return PushAll(sigs2);\n    case TX_PUBKEY:\n    case TX_PUBKEYHASH:\n        // Signatures are bigger than placeholders or empty scripts:\n        if (sigs1.empty() || sigs1[0].empty())\n            return PushAll(sigs2);\n        return PushAll(sigs1);\n    case TX_SCRIPTHASH:\n        if (sigs1.empty() || sigs1.back().empty())\n            return PushAll(sigs2);\n        else if (sigs2.empty() || sigs2.back().empty())\n            return PushAll(sigs1);\n        else\n        {\n            // Recur to combine:\n            valtype spk = sigs1.back();\n            CScript pubKey2(spk.begin(), spk.end());\n\n            txnouttype txType2;\n            vector<vector<unsigned char> > vSolutions2;\n            Solver(pubKey2, txType2, vSolutions2);\n            sigs1.pop_back();\n            sigs2.pop_back();\n            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n            result << spk;\n            return result;\n        }\n    case TX_MULTISIG:\n        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n    }\n\n    return CScript();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "EvalScript",
          "args": [
            "stack2",
            "scriptSig2",
            "CTransaction()",
            "0",
            "0"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "EvalScript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "323-1125",
          "snippet": "bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);",
            "static const valtype vchFalse(0);",
            "static const valtype vchTrue(1, 1);",
            "static const CBigNum bnZero(0);",
            "static const CBigNum bnOne(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\nstatic const valtype vchFalse(0);\nstatic const valtype vchTrue(1, 1);\nstatic const CBigNum bnZero(0);\nstatic const CBigNum bnOne(1);\n\nbool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CTransaction",
          "args": [],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "print",
          "container": "CTransaction",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.h",
          "lines": "667-670",
          "snippet": "void print() const\n    {\n        printf(\"%s\", ToString().c_str());\n    }",
          "includes": [
            "#include <list>",
            "#include \"x15hash.h\"",
            "#include \"neoscrypt.h\"",
            "#include \"script.h\"",
            "#include \"net.h\"",
            "#include \"sync.h\"",
            "#include \"bignum.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <list>\n#include \"x15hash.h\"\n#include \"neoscrypt.h\"\n#include \"script.h\"\n#include \"net.h\"\n#include \"sync.h\"\n#include \"bignum.h\"\n\nCTransaction {\n  void print() const\n      {\n          printf(\"%s\", ToString().c_str());\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "scriptPubKey",
            "txType",
            "vSolutions"
          ],
          "line": 1892
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                          const CScript& scriptSig1, const CScript& scriptSig2)\n{\n    txnouttype txType;\n    vector<vector<unsigned char> > vSolutions;\n    Solver(scriptPubKey, txType, vSolutions);\n\n    vector<valtype> stack1;\n    EvalScript(stack1, scriptSig1, CTransaction(), 0, 0);\n    vector<valtype> stack2;\n    EvalScript(stack2, scriptSig2, CTransaction(), 0, 0);\n\n    return CombineSignatures(scriptPubKey, txTo, nIn, txType, vSolutions, stack1, stack2);\n}"
  },
  {
    "function_name": "CombineSignatures",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1843-1885",
    "snippet": "static CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                                 const txnouttype txType, const vector<valtype>& vSolutions,\n                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    switch (txType)\n    {\n    case TX_NONSTANDARD:\n        // Don't know anything about this, assume bigger one is correct:\n        if (sigs1.size() >= sigs2.size())\n            return PushAll(sigs1);\n        return PushAll(sigs2);\n    case TX_PUBKEY:\n    case TX_PUBKEYHASH:\n        // Signatures are bigger than placeholders or empty scripts:\n        if (sigs1.empty() || sigs1[0].empty())\n            return PushAll(sigs2);\n        return PushAll(sigs1);\n    case TX_SCRIPTHASH:\n        if (sigs1.empty() || sigs1.back().empty())\n            return PushAll(sigs2);\n        else if (sigs2.empty() || sigs2.back().empty())\n            return PushAll(sigs1);\n        else\n        {\n            // Recur to combine:\n            valtype spk = sigs1.back();\n            CScript pubKey2(spk.begin(), spk.end());\n\n            txnouttype txType2;\n            vector<vector<unsigned char> > vSolutions2;\n            Solver(pubKey2, txType2, vSolutions2);\n            sigs1.pop_back();\n            sigs2.pop_back();\n            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n            result << spk;\n            return result;\n        }\n    case TX_MULTISIG:\n        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n    }\n\n    return CScript();\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CScript",
          "args": [],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "HasCanonicalPushes",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1959-1984",
          "snippet": "bool CScript::HasCanonicalPushes() const\n{\n    const_iterator pc = begin();\n    while (pc < end())\n    {\n        opcodetype opcode;\n        std::vector<unsigned char> data;\n        if (!GetOp(pc, opcode, data))\n            return false;\n        if (opcode > OP_16)\n            continue;\n        if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n            // Could have used an OP_n code, rather than a 1-byte push.\n            return false;\n        if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n            // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n            // Could have used an OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n            // Could have used an OP_PUSHDATA2.\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::HasCanonicalPushes() const\n  {\n      const_iterator pc = begin();\n      while (pc < end())\n      {\n          opcodetype opcode;\n          std::vector<unsigned char> data;\n          if (!GetOp(pc, opcode, data))\n              return false;\n          if (opcode > OP_16)\n              continue;\n          if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n              // Could have used an OP_n code, rather than a 1-byte push.\n              return false;\n          if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n              // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n              // Could have used an OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n              // Could have used an OP_PUSHDATA2.\n              return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CombineMultisig",
          "args": [
            "scriptPubKey",
            "txTo",
            "nIn",
            "vSolutions",
            "sigs1",
            "sigs2"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "CombineMultisig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1788-1841",
          "snippet": "static CScript CombineMultisig(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                               const vector<valtype>& vSolutions,\n                               vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    // Combine all the signatures we've got:\n    set<valtype> allsigs;\n    BOOST_FOREACH(const valtype& v, sigs1)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n    BOOST_FOREACH(const valtype& v, sigs2)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n\n    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n    assert(vSolutions.size() > 1);\n    unsigned int nSigsRequired = vSolutions.front()[0];\n    unsigned int nPubKeys = vSolutions.size()-2;\n    map<valtype, valtype> sigs;\n    BOOST_FOREACH(const valtype& sig, allsigs)\n    {\n        for (unsigned int i = 0; i < nPubKeys; i++)\n        {\n            const valtype& pubkey = vSolutions[i+1];\n            if (sigs.count(pubkey))\n                continue; // Already got a sig for this pubkey\n\n            if (CheckSig(sig, pubkey, scriptPubKey, txTo, nIn, 0))\n            {\n                sigs[pubkey] = sig;\n                break;\n            }\n        }\n    }\n    // Now build a merged CScript:\n    unsigned int nSigsHave = 0;\n    CScript result; result << OP_0; // pop-one-too-many workaround\n    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n    {\n        if (sigs.count(vSolutions[i+1]))\n        {\n            result << sigs[vSolutions[i+1]];\n            ++nSigsHave;\n        }\n    }\n    // Fill any missing with OP_0:\n    for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n        result << OP_0;\n\n    return result;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic CScript CombineMultisig(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                               const vector<valtype>& vSolutions,\n                               vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    // Combine all the signatures we've got:\n    set<valtype> allsigs;\n    BOOST_FOREACH(const valtype& v, sigs1)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n    BOOST_FOREACH(const valtype& v, sigs2)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n\n    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n    assert(vSolutions.size() > 1);\n    unsigned int nSigsRequired = vSolutions.front()[0];\n    unsigned int nPubKeys = vSolutions.size()-2;\n    map<valtype, valtype> sigs;\n    BOOST_FOREACH(const valtype& sig, allsigs)\n    {\n        for (unsigned int i = 0; i < nPubKeys; i++)\n        {\n            const valtype& pubkey = vSolutions[i+1];\n            if (sigs.count(pubkey))\n                continue; // Already got a sig for this pubkey\n\n            if (CheckSig(sig, pubkey, scriptPubKey, txTo, nIn, 0))\n            {\n                sigs[pubkey] = sig;\n                break;\n            }\n        }\n    }\n    // Now build a merged CScript:\n    unsigned int nSigsHave = 0;\n    CScript result; result << OP_0; // pop-one-too-many workaround\n    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n    {\n        if (sigs.count(vSolutions[i+1]))\n        {\n            result << sigs[vSolutions[i+1]];\n            ++nSigsHave;\n        }\n    }\n    // Fill any missing with OP_0:\n    for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n        result << OP_0;\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CombineSignatures",
          "args": [
            "pubKey2",
            "txTo",
            "nIn",
            "txType2",
            "vSolutions2",
            "sigs1",
            "sigs2"
          ],
          "line": 1876
        },
        "resolved": true,
        "details": {
          "function_name": "CombineSignatures",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1843-1885",
          "snippet": "static CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                                 const txnouttype txType, const vector<valtype>& vSolutions,\n                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    switch (txType)\n    {\n    case TX_NONSTANDARD:\n        // Don't know anything about this, assume bigger one is correct:\n        if (sigs1.size() >= sigs2.size())\n            return PushAll(sigs1);\n        return PushAll(sigs2);\n    case TX_PUBKEY:\n    case TX_PUBKEYHASH:\n        // Signatures are bigger than placeholders or empty scripts:\n        if (sigs1.empty() || sigs1[0].empty())\n            return PushAll(sigs2);\n        return PushAll(sigs1);\n    case TX_SCRIPTHASH:\n        if (sigs1.empty() || sigs1.back().empty())\n            return PushAll(sigs2);\n        else if (sigs2.empty() || sigs2.back().empty())\n            return PushAll(sigs1);\n        else\n        {\n            // Recur to combine:\n            valtype spk = sigs1.back();\n            CScript pubKey2(spk.begin(), spk.end());\n\n            txnouttype txType2;\n            vector<vector<unsigned char> > vSolutions2;\n            Solver(pubKey2, txType2, vSolutions2);\n            sigs1.pop_back();\n            sigs2.pop_back();\n            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n            result << spk;\n            return result;\n        }\n    case TX_MULTISIG:\n        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n    }\n\n    return CScript();\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "sigs2.pop_back",
          "args": [],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigs1.pop_back",
          "args": [],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "pubKey2",
            "txType2",
            "vSolutions2"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spk.end",
          "args": [],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "spk.begin",
          "args": [],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigs1.back",
          "args": [],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PushAll",
          "args": [
            "sigs1"
          ],
          "line": 1864
        },
        "resolved": true,
        "details": {
          "function_name": "PushAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1780-1786",
          "snippet": "static CScript PushAll(const vector<valtype>& values)\n{\n    CScript result;\n    BOOST_FOREACH(const valtype& v, values)\n        result << v;\n    return result;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic CScript PushAll(const vector<valtype>& values)\n{\n    CScript result;\n    BOOST_FOREACH(const valtype& v, values)\n        result << v;\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigs2.back",
          "args": [],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigs2.back",
          "args": [],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigs2.empty",
          "args": [],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigs1.back",
          "args": [],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigs1.back",
          "args": [],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigs2.size",
          "args": [],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic CScript CombineSignatures(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                                 const txnouttype txType, const vector<valtype>& vSolutions,\n                                 vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    switch (txType)\n    {\n    case TX_NONSTANDARD:\n        // Don't know anything about this, assume bigger one is correct:\n        if (sigs1.size() >= sigs2.size())\n            return PushAll(sigs1);\n        return PushAll(sigs2);\n    case TX_PUBKEY:\n    case TX_PUBKEYHASH:\n        // Signatures are bigger than placeholders or empty scripts:\n        if (sigs1.empty() || sigs1[0].empty())\n            return PushAll(sigs2);\n        return PushAll(sigs1);\n    case TX_SCRIPTHASH:\n        if (sigs1.empty() || sigs1.back().empty())\n            return PushAll(sigs2);\n        else if (sigs2.empty() || sigs2.back().empty())\n            return PushAll(sigs1);\n        else\n        {\n            // Recur to combine:\n            valtype spk = sigs1.back();\n            CScript pubKey2(spk.begin(), spk.end());\n\n            txnouttype txType2;\n            vector<vector<unsigned char> > vSolutions2;\n            Solver(pubKey2, txType2, vSolutions2);\n            sigs1.pop_back();\n            sigs2.pop_back();\n            CScript result = CombineSignatures(pubKey2, txTo, nIn, txType2, vSolutions2, sigs1, sigs2);\n            result << spk;\n            return result;\n        }\n    case TX_MULTISIG:\n        return CombineMultisig(scriptPubKey, txTo, nIn, vSolutions, sigs1, sigs2);\n    }\n\n    return CScript();\n}"
  },
  {
    "function_name": "CombineMultisig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1788-1841",
    "snippet": "static CScript CombineMultisig(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                               const vector<valtype>& vSolutions,\n                               vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    // Combine all the signatures we've got:\n    set<valtype> allsigs;\n    BOOST_FOREACH(const valtype& v, sigs1)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n    BOOST_FOREACH(const valtype& v, sigs2)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n\n    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n    assert(vSolutions.size() > 1);\n    unsigned int nSigsRequired = vSolutions.front()[0];\n    unsigned int nPubKeys = vSolutions.size()-2;\n    map<valtype, valtype> sigs;\n    BOOST_FOREACH(const valtype& sig, allsigs)\n    {\n        for (unsigned int i = 0; i < nPubKeys; i++)\n        {\n            const valtype& pubkey = vSolutions[i+1];\n            if (sigs.count(pubkey))\n                continue; // Already got a sig for this pubkey\n\n            if (CheckSig(sig, pubkey, scriptPubKey, txTo, nIn, 0))\n            {\n                sigs[pubkey] = sig;\n                break;\n            }\n        }\n    }\n    // Now build a merged CScript:\n    unsigned int nSigsHave = 0;\n    CScript result; result << OP_0; // pop-one-too-many workaround\n    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n    {\n        if (sigs.count(vSolutions[i+1]))\n        {\n            result << sigs[vSolutions[i+1]];\n            ++nSigsHave;\n        }\n    }\n    // Fill any missing with OP_0:\n    for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n        result << OP_0;\n\n    return result;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigs.count",
          "args": [
            "vSolutions[i+1]"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "34-34",
          "snippet": "size_type count(const key_type& k) const { return map.count(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  size_type count(const key_type& k) const { return map.count(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CheckSig",
          "args": [
            "sig",
            "pubkey",
            "scriptPubKey",
            "txTo",
            "nIn",
            "0"
          ],
          "line": 1818
        },
        "resolved": true,
        "details": {
          "function_name": "CheckSig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1254-1282",
          "snippet": "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n              const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    static CSignatureCache signatureCache;\n\n    // Hash type is one byte tacked on to the end of the signature\n    if (vchSig.empty())\n        return false;\n    if (nHashType == 0)\n        nHashType = vchSig.back();\n    else if (nHashType != vchSig.back())\n        return false;\n    vchSig.pop_back();\n\n    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n\n    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n        return true;\n\n    CKey key;\n    if (!key.SetPubKey(vchPubKey))\n        return false;\n\n    if (!key.Verify(sighash, vchSig))\n        return false;\n\n    signatureCache.Set(sighash, vchSig, vchPubKey);\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n              const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    static CSignatureCache signatureCache;\n\n    // Hash type is one byte tacked on to the end of the signature\n    if (vchSig.empty())\n        return false;\n    if (nHashType == 0)\n        nHashType = vchSig.back();\n    else if (nHashType != vchSig.back())\n        return false;\n    vchSig.pop_back();\n\n    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n\n    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n        return true;\n\n    CKey key;\n    if (!key.SetPubKey(vchPubKey))\n        return false;\n\n    if (!key.Verify(sighash, vchSig))\n        return false;\n\n    signatureCache.Set(sighash, vchSig, vchPubKey);\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutions.size",
          "args": [],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutions.front",
          "args": [],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "vSolutions.size() > 1"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allsigs.insert",
          "args": [
            "v"
          ],
          "line": 1802
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "v.empty",
          "args": [],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic CScript CombineMultisig(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                               const vector<valtype>& vSolutions,\n                               vector<valtype>& sigs1, vector<valtype>& sigs2)\n{\n    // Combine all the signatures we've got:\n    set<valtype> allsigs;\n    BOOST_FOREACH(const valtype& v, sigs1)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n    BOOST_FOREACH(const valtype& v, sigs2)\n    {\n        if (!v.empty())\n            allsigs.insert(v);\n    }\n\n    // Build a map of pubkey -> signature by matching sigs to pubkeys:\n    assert(vSolutions.size() > 1);\n    unsigned int nSigsRequired = vSolutions.front()[0];\n    unsigned int nPubKeys = vSolutions.size()-2;\n    map<valtype, valtype> sigs;\n    BOOST_FOREACH(const valtype& sig, allsigs)\n    {\n        for (unsigned int i = 0; i < nPubKeys; i++)\n        {\n            const valtype& pubkey = vSolutions[i+1];\n            if (sigs.count(pubkey))\n                continue; // Already got a sig for this pubkey\n\n            if (CheckSig(sig, pubkey, scriptPubKey, txTo, nIn, 0))\n            {\n                sigs[pubkey] = sig;\n                break;\n            }\n        }\n    }\n    // Now build a merged CScript:\n    unsigned int nSigsHave = 0;\n    CScript result; result << OP_0; // pop-one-too-many workaround\n    for (unsigned int i = 0; i < nPubKeys && nSigsHave < nSigsRequired; i++)\n    {\n        if (sigs.count(vSolutions[i+1]))\n        {\n            result << sigs[vSolutions[i+1]];\n            ++nSigsHave;\n        }\n    }\n    // Fill any missing with OP_0:\n    for (unsigned int i = nSigsHave; i < nSigsRequired; i++)\n        result << OP_0;\n\n    return result;\n}"
  },
  {
    "function_name": "PushAll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1780-1786",
    "snippet": "static CScript PushAll(const vector<valtype>& values)\n{\n    CScript result;\n    BOOST_FOREACH(const valtype& v, values)\n        result << v;\n    return result;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic CScript PushAll(const vector<valtype>& values)\n{\n    CScript result;\n    BOOST_FOREACH(const valtype& v, values)\n        result << v;\n    return result;\n}"
  },
  {
    "function_name": "VerifySignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1766-1778",
    "snippet": "bool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyScript",
          "args": [
            "txin.scriptSig",
            "txout.scriptPubKey",
            "txTo",
            "nIn",
            "nHashType"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyScript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1682-1717",
          "snippet": "bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txFrom.GetHash",
          "args": [],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txFrom.vout.size",
          "args": [],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nIn < txTo.vin.size()"
          ],
          "line": 1768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifySignature(const CTransaction& txFrom, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    const CTxIn& txin = txTo.vin[nIn];\n    if (txin.prevout.n >= txFrom.vout.size())\n        return false;\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    if (txin.prevout.hash != txFrom.GetHash())\n        return false;\n\n    return VerifyScript(txin.scriptSig, txout.scriptPubKey, txTo, nIn, nHashType);\n}"
  },
  {
    "function_name": "SignSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1755-1764",
    "snippet": "bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    CTxIn& txin = txTo.vin[nIn];\n    assert(txin.prevout.n < txFrom.vout.size());\n    assert(txin.prevout.hash == txFrom.GetHash());\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignSignature",
          "args": [
            "keystore",
            "txout.scriptPubKey",
            "txTo",
            "nIn",
            "nHashType"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "SignSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1755-1764",
          "snippet": "bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    CTxIn& txin = txTo.vin[nIn];\n    assert(txin.prevout.n < txFrom.vout.size());\n    assert(txin.prevout.hash == txFrom.GetHash());\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "txin.prevout.hash == txFrom.GetHash()"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txFrom.GetHash",
          "args": [],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "GetHash",
          "container": "CNetAddr",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/netbase.cpp",
          "lines": "922-928",
          "snippet": "uint64_t CNetAddr::GetHash() const\n{\n    uint256 hash = Hash(&ip[0], &ip[16]);\n    uint64_t nRet;\n    memcpy(&nRet, &hash, sizeof(nRet));\n    return nRet;\n}",
          "includes": [
            "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()",
            "#include \"strlcpy.h\"",
            "#include <sys/fcntl.h>",
            "#include \"sync.h\"",
            "#include \"util.h\"",
            "#include \"netbase.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n#include \"strlcpy.h\"\n#include <sys/fcntl.h>\n#include \"sync.h\"\n#include \"util.h\"\n#include \"netbase.h\"\n\nCNetAddr {\n  uint64_t CNetAddr::GetHash() const\n  {\n      uint256 hash = Hash(&ip[0], &ip[16]);\n      uint64_t nRet;\n      memcpy(&nRet, &hash, sizeof(nRet));\n      return nRet;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "txin.prevout.n < txFrom.vout.size()"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txFrom.vout.size",
          "args": [],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nIn < txTo.vin.size()"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    CTxIn& txin = txTo.vin[nIn];\n    assert(txin.prevout.n < txFrom.vout.size());\n    assert(txin.prevout.hash == txFrom.GetHash());\n    const CTxOut& txout = txFrom.vout[txin.prevout.n];\n\n    return SignSignature(keystore, txout.scriptPubKey, txTo, nIn, nHashType);\n}"
  },
  {
    "function_name": "SignSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1720-1753",
    "snippet": "bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    CTxIn& txin = txTo.vin[nIn];\n\n    // Leave out the signature from the hash, since a signature can't sign itself.\n    // The checksig op will also drop the signatures from its hash.\n    uint256 hash = SignatureHash(fromPubKey, txTo, nIn, nHashType);\n\n    txnouttype whichType;\n    if (!Solver(keystore, fromPubKey, hash, nHashType, txin.scriptSig, whichType))\n        return false;\n\n    if (whichType == TX_SCRIPTHASH)\n    {\n        // Solver returns the subscript that need to be evaluated;\n        // the final scriptSig is the signatures from that\n        // and then the serialized subscript:\n        CScript subscript = txin.scriptSig;\n\n        // Recompute txn hash using subscript in place of scriptPubKey:\n        uint256 hash2 = SignatureHash(subscript, txTo, nIn, nHashType);\n\n        txnouttype subType;\n        bool fSolved =\n            Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType) && subType != TX_SCRIPTHASH;\n        // Append serialized subscript whether or not it is completely signed:\n        txin.scriptSig << static_cast<valtype>(subscript);\n        if (!fSolved) return false;\n    }\n\n    // Test solution\n    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, 0);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VerifyScript",
          "args": [
            "txin.scriptSig",
            "fromPubKey",
            "txTo",
            "nIn",
            "0"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "VerifyScript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1682-1717",
          "snippet": "bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<valtype>",
          "args": [
            "subscript"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "keystore",
            "subscript",
            "hash2",
            "nHashType",
            "txin.scriptSig",
            "subType"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1442-1478",
          "snippet": "bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n{\n    scriptSigRet.clear();\n\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichTypeRet)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return Sign1(keyID, keystore, hash, nHashType, scriptSigRet);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            return false;\n        else\n        {\n            CPubKey vch;\n            keystore.GetPubKey(keyID, vch);\n            scriptSigRet << vch;\n        }\n        return true;\n    case TX_SCRIPTHASH:\n        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n\n    case TX_MULTISIG:\n        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n    }\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n{\n    scriptSigRet.clear();\n\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichTypeRet)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return Sign1(keyID, keystore, hash, nHashType, scriptSigRet);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            return false;\n        else\n        {\n            CPubKey vch;\n            keystore.GetPubKey(keyID, vch);\n            scriptSigRet << vch;\n        }\n        return true;\n    case TX_SCRIPTHASH:\n        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n\n    case TX_MULTISIG:\n        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignatureHash",
          "args": [
            "subscript",
            "txTo",
            "nIn",
            "nHashType"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1135-1195",
          "snippet": "uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    if (nIn >= txTo.vin.size())\n    {\n        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n        return 1;\n    }\n    CTransaction txTmp(txTo);\n\n    // In case concatenating two scripts ends up with two codeseparators,\n    // or an extra one at the end, this prevents all those possible incompatibilities.\n    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n\n    // Blank out other inputs' signatures\n    for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n        txTmp.vin[i].scriptSig = CScript();\n    txTmp.vin[nIn].scriptSig = scriptCode;\n\n    // Blank out some of the outputs\n    if ((nHashType & 0x1f) == SIGHASH_NONE)\n    {\n        // Wildcard payee\n        txTmp.vout.clear();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n    {\n        // Only lock-in the txout payee at same index as txin\n        unsigned int nOut = nIn;\n        if (nOut >= txTmp.vout.size())\n        {\n            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n            return 1;\n        }\n        txTmp.vout.resize(nOut+1);\n        for (unsigned int i = 0; i < nOut; i++)\n            txTmp.vout[i].SetNull();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n\n    // Blank out other inputs completely, not recommended for open transactions\n    if (nHashType & SIGHASH_ANYONECANPAY)\n    {\n        txTmp.vin[0] = txTmp.vin[nIn];\n        txTmp.vin.resize(1);\n    }\n\n    // Serialize and hash\n    CDataStream ss(SER_GETHASH, 0);\n    ss.reserve(10000);\n    ss << txTmp << nHashType;\n    return Hash(ss.begin(), ss.end());\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nuint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    if (nIn >= txTo.vin.size())\n    {\n        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n        return 1;\n    }\n    CTransaction txTmp(txTo);\n\n    // In case concatenating two scripts ends up with two codeseparators,\n    // or an extra one at the end, this prevents all those possible incompatibilities.\n    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n\n    // Blank out other inputs' signatures\n    for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n        txTmp.vin[i].scriptSig = CScript();\n    txTmp.vin[nIn].scriptSig = scriptCode;\n\n    // Blank out some of the outputs\n    if ((nHashType & 0x1f) == SIGHASH_NONE)\n    {\n        // Wildcard payee\n        txTmp.vout.clear();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n    {\n        // Only lock-in the txout payee at same index as txin\n        unsigned int nOut = nIn;\n        if (nOut >= txTmp.vout.size())\n        {\n            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n            return 1;\n        }\n        txTmp.vout.resize(nOut+1);\n        for (unsigned int i = 0; i < nOut; i++)\n            txTmp.vout[i].SetNull();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n\n    // Blank out other inputs completely, not recommended for open transactions\n    if (nHashType & SIGHASH_ANYONECANPAY)\n    {\n        txTmp.vin[0] = txTmp.vin[nIn];\n        txTmp.vin.resize(1);\n    }\n\n    // Serialize and hash\n    CDataStream ss(SER_GETHASH, 0);\n    ss.reserve(10000);\n    ss << txTmp << nHashType;\n    return Hash(ss.begin(), ss.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "nIn < txTo.vin.size()"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "txTo.vin.size",
          "args": [],
          "line": 1722
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    assert(nIn < txTo.vin.size());\n    CTxIn& txin = txTo.vin[nIn];\n\n    // Leave out the signature from the hash, since a signature can't sign itself.\n    // The checksig op will also drop the signatures from its hash.\n    uint256 hash = SignatureHash(fromPubKey, txTo, nIn, nHashType);\n\n    txnouttype whichType;\n    if (!Solver(keystore, fromPubKey, hash, nHashType, txin.scriptSig, whichType))\n        return false;\n\n    if (whichType == TX_SCRIPTHASH)\n    {\n        // Solver returns the subscript that need to be evaluated;\n        // the final scriptSig is the signatures from that\n        // and then the serialized subscript:\n        CScript subscript = txin.scriptSig;\n\n        // Recompute txn hash using subscript in place of scriptPubKey:\n        uint256 hash2 = SignatureHash(subscript, txTo, nIn, nHashType);\n\n        txnouttype subType;\n        bool fSolved =\n            Solver(keystore, subscript, hash2, nHashType, txin.scriptSig, subType) && subType != TX_SCRIPTHASH;\n        // Append serialized subscript whether or not it is completely signed:\n        txin.scriptSig << static_cast<valtype>(subscript);\n        if (!fSolved) return false;\n    }\n\n    // Test solution\n    return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, 0);\n}"
  },
  {
    "function_name": "VerifyScript",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1682-1717",
    "snippet": "bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CastToBool",
          "args": [
            "stackCopy.back()"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "CastToBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "41-54",
          "snippet": "bool CastToBool(const valtype& vch)\n{\n    for (unsigned int i = 0; i < vch.size(); i++)\n    {\n        if (vch[i] != 0)\n        {\n            // Can be negative zero\n            if (i == vch.size()-1 && vch[i] == 0x80)\n                return false;\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CastToBool(const valtype& vch)\n{\n    for (unsigned int i = 0; i < vch.size(); i++)\n    {\n        if (vch[i] != 0)\n        {\n            // Can be negative zero\n            if (i == vch.size()-1 && vch[i] == 0x80)\n                return false;\n            return true;\n        }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stackCopy.back",
          "args": [],
          "line": 1713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stackCopy.empty",
          "args": [],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "EvalScript",
          "args": [
            "stackCopy",
            "pubKey2",
            "txTo",
            "nIn",
            "nHashType"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "EvalScript",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "323-1125",
          "snippet": "bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);",
            "static const valtype vchFalse(0);",
            "static const valtype vchTrue(1, 1);",
            "static const CBigNum bnZero(0);",
            "static const CBigNum bnOne(1);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\nstatic const valtype vchFalse(0);\nstatic const valtype vchTrue(1, 1);\nstatic const CBigNum bnZero(0);\nstatic const CBigNum bnOne(1);\n\nbool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "popstack",
          "args": [
            "stackCopy"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "popstack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "90-95",
          "snippet": "static inline void popstack(vector<valtype>& stack)\n{\n    if (stack.empty())\n        throw runtime_error(\"popstack() : stack empty\");\n    stack.pop_back();\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic inline void popstack(vector<valtype>& stack)\n{\n    if (stack.empty())\n        throw runtime_error(\"popstack() : stack empty\");\n    stack.pop_back();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pubKeySerialized.end",
          "args": [],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pubKeySerialized.begin",
          "args": [],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stackCopy.back",
          "args": [],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scriptSig.IsPushOnly",
          "args": [],
          "line": 1702
        },
        "resolved": true,
        "details": {
          "function_name": "IsPushOnly",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "529-541",
          "snippet": "bool IsPushOnly() const\n    {\n        const_iterator pc = begin();\n        while (pc < end())\n        {\n            opcodetype opcode;\n            if (!GetOp(pc, opcode))\n                return false;\n            if (opcode > OP_16)\n                return false;\n        }\n        return true;\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool IsPushOnly() const\n      {\n          const_iterator pc = begin();\n          while (pc < end())\n          {\n              opcodetype opcode;\n              if (!GetOp(pc, opcode))\n                  return false;\n              if (opcode > OP_16)\n                  return false;\n          }\n          return true;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptPubKey.IsPayToScriptHash",
          "args": [],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "IsPayToScriptHash",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1950-1957",
          "snippet": "bool CScript::IsPayToScriptHash() const\n{\n    // Extra-fast test for pay-to-script-hash CScripts:\n    return (this->size() == 23 &&\n            this->at(0) == OP_HASH160 &&\n            this->at(1) == 0x14 &&\n            this->at(22) == OP_EQUAL);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::IsPayToScriptHash() const\n  {\n      // Extra-fast test for pay-to-script-hash CScripts:\n      return (this->size() == 23 &&\n              this->at(0) == OP_HASH160 &&\n              this->at(1) == 0x14 &&\n              this->at(22) == OP_EQUAL);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack.back",
          "args": [],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n                  int nHashType)\n{\n    vector<vector<unsigned char> > stack, stackCopy;\n    if (!EvalScript(stack, scriptSig, txTo, nIn, nHashType))\n        return false;\n\n    stackCopy = stack;\n\n    if (!EvalScript(stack, scriptPubKey, txTo, nIn, nHashType))\n        return false;\n    if (stack.empty())\n        return false;\n\n    if (CastToBool(stack.back()) == false)\n        return false;\n\n    // Additional validation for spend-to-script-hash transactions:\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        if (!scriptSig.IsPushOnly()) // scriptSig must be literals-only\n            return false;            // or validation fails\n\n        const valtype& pubKeySerialized = stackCopy.back();\n        CScript pubKey2(pubKeySerialized.begin(), pubKeySerialized.end());\n        popstack(stackCopy);\n\n        if (!EvalScript(stackCopy, pubKey2, txTo, nIn, nHashType))\n            return false;\n        if (stackCopy.empty())\n            return false;\n        return CastToBool(stackCopy.back());\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "ExtractDestinations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1653-1680",
    "snippet": "bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n{\n    addressRet.clear();\n    typeRet = TX_NONSTANDARD;\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, typeRet, vSolutions))\n        return false;\n\n    if (typeRet == TX_MULTISIG)\n    {\n        nRequiredRet = vSolutions.front()[0];\n        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n        {\n            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n            addressRet.push_back(address);\n        }\n    }\n    else\n    {\n        nRequiredRet = 1;\n        CTxDestination address;\n        if (!ExtractDestination(scriptPubKey, address))\n           return false;\n        addressRet.push_back(address);\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addressRet.push_back",
          "args": [
            "address"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExtractDestination",
          "args": [
            "scriptPubKey",
            "address"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestination",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1590-1614",
          "snippet": "bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressRet.push_back",
          "args": [
            "address"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [
            "vSolutions[i]"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "CPubKey",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "71-71",
          "snippet": "CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutions.size",
          "args": [],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutions.front",
          "args": [],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "scriptPubKey",
            "typeRet",
            "vSolutions"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "addressRet.clear",
          "args": [],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n{\n    addressRet.clear();\n    typeRet = TX_NONSTANDARD;\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, typeRet, vSolutions))\n        return false;\n\n    if (typeRet == TX_MULTISIG)\n    {\n        nRequiredRet = vSolutions.front()[0];\n        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n        {\n            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n            addressRet.push_back(address);\n        }\n    }\n    else\n    {\n        nRequiredRet = 1;\n        CTxDestination address;\n        if (!ExtractDestination(scriptPubKey, address))\n           return false;\n        addressRet.push_back(address);\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "ExtractAffectedKeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1649-1651",
    "snippet": "void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys) {\n    CAffectedKeysVisitor(keystore, vKeys).Process(scriptPubKey);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CAffectedKeysVisitor",
          "args": [
            "scriptPubKey"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "Process",
          "container": "CAffectedKeysVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1624-1632",
          "snippet": "void Process(const CScript &script) {\n        txnouttype type;\n        std::vector<CTxDestination> vDest;\n        int nRequired;\n        if (ExtractDestinations(script, type, vDest, nRequired)) {\n            BOOST_FOREACH(const CTxDestination &dest, vDest)\n                boost::apply_visitor(*this, dest);\n        }\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCAffectedKeysVisitor {\n  void Process(const CScript &script) {\n          txnouttype type;\n          std::vector<CTxDestination> vDest;\n          int nRequired;\n          if (ExtractDestinations(script, type, vDest, nRequired)) {\n              BOOST_FOREACH(const CTxDestination &dest, vDest)\n                  boost::apply_visitor(*this, dest);\n          }\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CAffectedKeysVisitor",
          "args": [
            "keystore",
            "vKeys"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "CAffectedKeysVisitor",
          "container": "CAffectedKeysVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1622-1622",
          "snippet": "CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCAffectedKeysVisitor {\n  CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nvoid ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys) {\n    CAffectedKeysVisitor(keystore, vKeys).Process(scriptPubKey);\n}"
  },
  {
    "function_name": "Process",
    "container": "CAffectedKeysVisitor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1624-1632",
    "snippet": "void Process(const CScript &script) {\n        txnouttype type;\n        std::vector<CTxDestination> vDest;\n        int nRequired;\n        if (ExtractDestinations(script, type, vDest, nRequired)) {\n            BOOST_FOREACH(const CTxDestination &dest, vDest)\n                boost::apply_visitor(*this, dest);\n        }\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boost::apply_visitor",
          "args": [
            "*this",
            "dest"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ExtractDestinations",
          "args": [
            "script",
            "type",
            "vDest",
            "nRequired"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "ExtractDestinations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1653-1680",
          "snippet": "bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n{\n    addressRet.clear();\n    typeRet = TX_NONSTANDARD;\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, typeRet, vSolutions))\n        return false;\n\n    if (typeRet == TX_MULTISIG)\n    {\n        nRequiredRet = vSolutions.front()[0];\n        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n        {\n            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n            addressRet.push_back(address);\n        }\n    }\n    else\n    {\n        nRequiredRet = 1;\n        CTxDestination address;\n        if (!ExtractDestination(scriptPubKey, address))\n           return false;\n        addressRet.push_back(address);\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)\n{\n    addressRet.clear();\n    typeRet = TX_NONSTANDARD;\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, typeRet, vSolutions))\n        return false;\n\n    if (typeRet == TX_MULTISIG)\n    {\n        nRequiredRet = vSolutions.front()[0];\n        for (unsigned int i = 1; i < vSolutions.size()-1; i++)\n        {\n            CTxDestination address = CPubKey(vSolutions[i]).GetID();\n            addressRet.push_back(address);\n        }\n    }\n    else\n    {\n        nRequiredRet = 1;\n        CTxDestination address;\n        if (!ExtractDestination(scriptPubKey, address))\n           return false;\n        addressRet.push_back(address);\n    }\n\n    return true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCAffectedKeysVisitor {\n  void Process(const CScript &script) {\n          txnouttype type;\n          std::vector<CTxDestination> vDest;\n          int nRequired;\n          if (ExtractDestinations(script, type, vDest, nRequired)) {\n              BOOST_FOREACH(const CTxDestination &dest, vDest)\n                  boost::apply_visitor(*this, dest);\n          }\n      }\n}"
  },
  {
    "function_name": "CAffectedKeysVisitor",
    "container": "CAffectedKeysVisitor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1622-1622",
    "snippet": "CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCAffectedKeysVisitor {\n  CAffectedKeysVisitor(const CKeyStore &keystoreIn, std::vector<CKeyID> &vKeysIn) : keystore(keystoreIn), vKeys(vKeysIn) {}\n}"
  },
  {
    "function_name": "ExtractDestination",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1590-1614",
    "snippet": "bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CScriptID",
          "args": [
            "uint160(vSolutions[0])"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "CScriptID",
          "container": "CScriptID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "60-60",
          "snippet": "CScriptID(const uint160 &in) : uint160(in) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCScriptID {\n  CScriptID(const uint160 &in) : uint160(in) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint160",
          "args": [
            "vSolutions[0]"
          ],
          "line": 1609
        },
        "resolved": true,
        "details": {
          "function_name": "uint160",
          "container": "uint160",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "450-456",
          "snippet": "explicit uint160(const std::vector<unsigned char>& vch)\n    {\n        if (vch.size() == sizeof(pn))\n            memcpy(pn, &vch[0], sizeof(pn));\n        else\n            *this = 0;\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nuint160 {\n  explicit uint160(const std::vector<unsigned char>& vch)\n      {\n          if (vch.size() == sizeof(pn))\n              memcpy(pn, &vch[0], sizeof(pn));\n          else\n              *this = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CKeyID",
          "args": [
            "uint160(vSolutions[0])"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "CKeyID",
          "container": "CKeyID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "52-52",
          "snippet": "CKeyID(const uint160 &in) : uint160(in) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCKeyID {\n  CKeyID(const uint160 &in) : uint160(in) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [
            "vSolutions[0]"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "CPubKey",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "71-71",
          "snippet": "CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "scriptPubKey",
            "whichType",
            "vSolutions"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_PUBKEY)\n    {\n        addressRet = CPubKey(vSolutions[0]).GetID();\n        return true;\n    }\n    else if (whichType == TX_PUBKEYHASH)\n    {\n        addressRet = CKeyID(uint160(vSolutions[0]));\n        return true;\n    }\n    else if (whichType == TX_SCRIPTHASH)\n    {\n        addressRet = CScriptID(uint160(vSolutions[0]));\n        return true;\n    }\n    // Multisig txns have more than one address...\n    return false;\n}"
  },
  {
    "function_name": "IsMine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1551-1588",
    "snippet": "bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichType)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return keystore.HaveKey(keyID);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        return keystore.HaveKey(keyID);\n    case TX_SCRIPTHASH:\n    {\n        CScript subscript;\n        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n            return false;\n        return IsMine(keystore, subscript);\n    }\n    case TX_MULTISIG:\n    {\n        // Only consider transactions \"mine\" if we own ALL the\n        // keys involved. multi-signature transactions that are\n        // partially owned (somebody else has a key that can spend\n        // them) enable spend-out-from-under-you attacks, especially\n        // in shared-wallet situations.\n        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n        return HaveKeys(keys, keystore) == keys.size();\n    }\n    }\n    return false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keys.size",
          "args": [],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "HaveKeys",
          "args": [
            "keys",
            "keystore"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "HaveKeys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1522-1532",
          "snippet": "unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n{\n    unsigned int nResult = 0;\n    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n    {\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (keystore.HaveKey(keyID))\n            ++nResult;\n    }\n    return nResult;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nunsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n{\n    unsigned int nResult = 0;\n    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n    {\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (keystore.HaveKey(keyID))\n            ++nResult;\n    }\n    return nResult;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutions.begin",
          "args": [],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsMine",
          "args": [
            "keystore",
            "subscript"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "IsMine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1551-1588",
          "snippet": "bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichType)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return keystore.HaveKey(keyID);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        return keystore.HaveKey(keyID);\n    case TX_SCRIPTHASH:\n    {\n        CScript subscript;\n        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n            return false;\n        return IsMine(keystore, subscript);\n    }\n    case TX_MULTISIG:\n    {\n        // Only consider transactions \"mine\" if we own ALL the\n        // keys involved. multi-signature transactions that are\n        // partially owned (somebody else has a key that can spend\n        // them) enable spend-out-from-under-you attacks, especially\n        // in shared-wallet situations.\n        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n        return HaveKeys(keys, keystore) == keys.size();\n    }\n    }\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "keystore.GetCScript",
          "args": [
            "CScriptID(uint160(vSolutions[0]))",
            "subscript"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "GetCScript",
          "container": "CBasicKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "49-61",
          "snippet": "bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const\n{\n    {\n        LOCK(cs_KeyStore);\n        ScriptMap::const_iterator mi = mapScripts.find(hash);\n        if (mi != mapScripts.end())\n        {\n            redeemScriptOut = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCBasicKeyStore {\n  bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const\n  {\n      {\n          LOCK(cs_KeyStore);\n          ScriptMap::const_iterator mi = mapScripts.find(hash);\n          if (mi != mapScripts.end())\n          {\n              redeemScriptOut = (*mi).second;\n              return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CScriptID",
          "args": [
            "uint160(vSolutions[0])"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "CScriptID",
          "container": "CScriptID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "60-60",
          "snippet": "CScriptID(const uint160 &in) : uint160(in) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCScriptID {\n  CScriptID(const uint160 &in) : uint160(in) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint160",
          "args": [
            "vSolutions[0]"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "uint160",
          "container": "uint160",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "450-456",
          "snippet": "explicit uint160(const std::vector<unsigned char>& vch)\n    {\n        if (vch.size() == sizeof(pn))\n            memcpy(pn, &vch[0], sizeof(pn));\n        else\n            *this = 0;\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nuint160 {\n  explicit uint160(const std::vector<unsigned char>& vch)\n      {\n          if (vch.size() == sizeof(pn))\n              memcpy(pn, &vch[0], sizeof(pn));\n          else\n              *this = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "keystore.HaveKey",
          "args": [
            "keyID"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "HaveKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "150-159",
          "snippet": "bool HaveKey(const CKeyID &address) const\n    {\n        {\n            LOCK(cs_KeyStore);\n            if (!IsCrypted())\n                return CBasicKeyStore::HaveKey(address);\n            return mapCryptedKeys.count(address) > 0;\n        }\n        return false;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool HaveKey(const CKeyID &address) const\n      {\n          {\n              LOCK(cs_KeyStore);\n              if (!IsCrypted())\n                  return CBasicKeyStore::HaveKey(address);\n              return mapCryptedKeys.count(address) > 0;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CKeyID",
          "args": [
            "uint160(vSolutions[0])"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "CKeyID",
          "container": "CKeyID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "52-52",
          "snippet": "CKeyID(const uint160 &in) : uint160(in) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCKeyID {\n  CKeyID(const uint160 &in) : uint160(in) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [
            "vSolutions[0]"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "CPubKey",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "71-71",
          "snippet": "CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "scriptPubKey",
            "whichType",
            "vSolutions"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichType)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return keystore.HaveKey(keyID);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        return keystore.HaveKey(keyID);\n    case TX_SCRIPTHASH:\n    {\n        CScript subscript;\n        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n            return false;\n        return IsMine(keystore, subscript);\n    }\n    case TX_MULTISIG:\n    {\n        // Only consider transactions \"mine\" if we own ALL the\n        // keys involved. multi-signature transactions that are\n        // partially owned (somebody else has a key that can spend\n        // them) enable spend-out-from-under-you attacks, especially\n        // in shared-wallet situations.\n        vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n        return HaveKeys(keys, keystore) == keys.size();\n    }\n    }\n    return false;\n}"
  },
  {
    "function_name": "IsMine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1546-1549",
    "snippet": "bool IsMine(const CKeyStore &keystore, const CTxDestination &dest)\n{\n    return boost::apply_visitor(CKeyStoreIsMineVisitor(&keystore), dest);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boost::apply_visitor",
          "args": [
            "CKeyStoreIsMineVisitor(&keystore)",
            "dest"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CKeyStoreIsMineVisitor",
          "args": [
            "&keystore"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "CKeyStoreIsMineVisitor",
          "container": "CKeyStoreIsMineVisitor",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1540-1540",
          "snippet": "CKeyStoreIsMineVisitor(const CKeyStore *keystoreIn) : keystore(keystoreIn) { }",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCKeyStoreIsMineVisitor {\n  CKeyStoreIsMineVisitor(const CKeyStore *keystoreIn) : keystore(keystoreIn) { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool IsMine(const CKeyStore &keystore, const CTxDestination &dest)\n{\n    return boost::apply_visitor(CKeyStoreIsMineVisitor(&keystore), dest);\n}"
  },
  {
    "function_name": "CKeyStoreIsMineVisitor",
    "container": "CKeyStoreIsMineVisitor",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1540-1540",
    "snippet": "CKeyStoreIsMineVisitor(const CKeyStore *keystoreIn) : keystore(keystoreIn) { }",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCKeyStoreIsMineVisitor {\n  CKeyStoreIsMineVisitor(const CKeyStore *keystoreIn) : keystore(keystoreIn) { }\n}"
  },
  {
    "function_name": "HaveKeys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1522-1532",
    "snippet": "unsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n{\n    unsigned int nResult = 0;\n    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n    {\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (keystore.HaveKey(keyID))\n            ++nResult;\n    }\n    return nResult;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keystore.HaveKey",
          "args": [
            "keyID"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "HaveKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "150-159",
          "snippet": "bool HaveKey(const CKeyID &address) const\n    {\n        {\n            LOCK(cs_KeyStore);\n            if (!IsCrypted())\n                return CBasicKeyStore::HaveKey(address);\n            return mapCryptedKeys.count(address) > 0;\n        }\n        return false;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCCryptoKeyStore {\n  bool HaveKey(const CKeyID &address) const\n      {\n          {\n              LOCK(cs_KeyStore);\n              if (!IsCrypted())\n                  return CBasicKeyStore::HaveKey(address);\n              return mapCryptedKeys.count(address) > 0;\n          }\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [
            "pubkey"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "CPubKey",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "71-71",
          "snippet": "CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nunsigned int HaveKeys(const vector<valtype>& pubkeys, const CKeyStore& keystore)\n{\n    unsigned int nResult = 0;\n    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n    {\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (keystore.HaveKey(keyID))\n            ++nResult;\n    }\n    return nResult;\n}"
  },
  {
    "function_name": "IsStandard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1500-1519",
    "snippet": "bool IsStandard(const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_MULTISIG)\n    {\n        unsigned char m = vSolutions.front()[0];\n        unsigned char n = vSolutions.back()[0];\n        // Support up to x-of-3 multisig txns as standard\n        if (n < 1 || n > 3)\n            return false;\n        if (m < 1 || m > n)\n            return false;\n    }\n\n    return whichType != TX_NONSTANDARD;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vSolutions.back",
          "args": [],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vSolutions.front",
          "args": [],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "scriptPubKey",
            "whichType",
            "vSolutions"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool IsStandard(const CScript& scriptPubKey)\n{\n    vector<valtype> vSolutions;\n    txnouttype whichType;\n    if (!Solver(scriptPubKey, whichType, vSolutions))\n        return false;\n\n    if (whichType == TX_MULTISIG)\n    {\n        unsigned char m = vSolutions.front()[0];\n        unsigned char n = vSolutions.back()[0];\n        // Support up to x-of-3 multisig txns as standard\n        if (n < 1 || n > 3)\n            return false;\n        if (m < 1 || m > n)\n            return false;\n    }\n\n    return whichType != TX_NONSTANDARD;\n}"
  },
  {
    "function_name": "ScriptSigArgsExpected",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1480-1498",
    "snippet": "int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions)\n{\n    switch (t)\n    {\n    case TX_NONSTANDARD:\n        return -1;\n    case TX_PUBKEY:\n        return 1;\n    case TX_PUBKEYHASH:\n        return 2;\n    case TX_MULTISIG:\n        if (vSolutions.size() < 1 || vSolutions[0].size() < 1)\n            return -1;\n        return vSolutions[0][0] + 1;\n    case TX_SCRIPTHASH:\n        return 1; // doesn't include args needed by the script\n    }\n    return -1;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vSolutions[0].size",
          "args": [],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nint ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions)\n{\n    switch (t)\n    {\n    case TX_NONSTANDARD:\n        return -1;\n    case TX_PUBKEY:\n        return 1;\n    case TX_PUBKEYHASH:\n        return 2;\n    case TX_MULTISIG:\n        if (vSolutions.size() < 1 || vSolutions[0].size() < 1)\n            return -1;\n        return vSolutions[0][0] + 1;\n    case TX_SCRIPTHASH:\n        return 1; // doesn't include args needed by the script\n    }\n    return -1;\n}"
  },
  {
    "function_name": "Solver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1442-1478",
    "snippet": "bool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n{\n    scriptSigRet.clear();\n\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichTypeRet)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return Sign1(keyID, keystore, hash, nHashType, scriptSigRet);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            return false;\n        else\n        {\n            CPubKey vch;\n            keystore.GetPubKey(keyID, vch);\n            scriptSigRet << vch;\n        }\n        return true;\n    case TX_SCRIPTHASH:\n        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n\n    case TX_MULTISIG:\n        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n    }\n    return false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SignN",
          "args": [
            "vSolutions",
            "keystore",
            "hash",
            "nHashType",
            "scriptSigRet"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "SignN",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1422-1434",
          "snippet": "bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    int nSigned = 0;\n    int nRequired = multisigdata.front()[0];\n    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n    {\n        const valtype& pubkey = multisigdata[i];\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            ++nSigned;\n    }\n    return nSigned==nRequired;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    int nSigned = 0;\n    int nRequired = multisigdata.front()[0];\n    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n    {\n        const valtype& pubkey = multisigdata[i];\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            ++nSigned;\n    }\n    return nSigned==nRequired;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keystore.GetCScript",
          "args": [
            "uint160(vSolutions[0])",
            "scriptSigRet"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "GetCScript",
          "container": "CBasicKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "49-61",
          "snippet": "bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const\n{\n    {\n        LOCK(cs_KeyStore);\n        ScriptMap::const_iterator mi = mapScripts.find(hash);\n        if (mi != mapScripts.end())\n        {\n            redeemScriptOut = (*mi).second;\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCBasicKeyStore {\n  bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const\n  {\n      {\n          LOCK(cs_KeyStore);\n          ScriptMap::const_iterator mi = mapScripts.find(hash);\n          if (mi != mapScripts.end())\n          {\n              redeemScriptOut = (*mi).second;\n              return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "uint160",
          "args": [
            "vSolutions[0]"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "uint160",
          "container": "uint160",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "450-456",
          "snippet": "explicit uint160(const std::vector<unsigned char>& vch)\n    {\n        if (vch.size() == sizeof(pn))\n            memcpy(pn, &vch[0], sizeof(pn));\n        else\n            *this = 0;\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nuint160 {\n  explicit uint160(const std::vector<unsigned char>& vch)\n      {\n          if (vch.size() == sizeof(pn))\n              memcpy(pn, &vch[0], sizeof(pn));\n          else\n              *this = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "keystore.GetPubKey",
          "args": [
            "keyID",
            "vch"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "GetPubKey",
          "container": "CCryptoKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.cpp",
          "lines": "180-195",
          "snippet": "bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n{\n    {\n        LOCK(cs_KeyStore);\n        if (!IsCrypted())\n            return CKeyStore::GetPubKey(address, vchPubKeyOut);\n\n        CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n        if (mi != mapCryptedKeys.end())\n        {\n            vchPubKeyOut = (*mi).second.first;\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include \"script.h\"",
            "#include \"keystore.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"script.h\"\n#include \"keystore.h\"\n\nCCryptoKeyStore {\n  bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const\n  {\n      {\n          LOCK(cs_KeyStore);\n          if (!IsCrypted())\n              return CKeyStore::GetPubKey(address, vchPubKeyOut);\n  \n          CryptedKeyMap::const_iterator mi = mapCryptedKeys.find(address);\n          if (mi != mapCryptedKeys.end())\n          {\n              vchPubKeyOut = (*mi).second.first;\n              return true;\n          }\n      }\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Sign1",
          "args": [
            "keyID",
            "keystore",
            "hash",
            "nHashType",
            "scriptSigRet"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "Sign1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1407-1420",
          "snippet": "bool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    CKey key;\n    if (!keystore.GetKey(address, key))\n        return false;\n\n    vector<unsigned char> vchSig;\n    if (!key.Sign(hash, vchSig))\n        return false;\n    vchSig.push_back((unsigned char)nHashType);\n    scriptSigRet << vchSig;\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    CKey key;\n    if (!keystore.GetKey(address, key))\n        return false;\n\n    vector<unsigned char> vchSig;\n    if (!key.Sign(hash, vchSig))\n        return false;\n    vchSig.push_back((unsigned char)nHashType);\n    scriptSigRet << vchSig;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CKeyID",
          "args": [
            "uint160(vSolutions[0])"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "CKeyID",
          "container": "CKeyID",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "52-52",
          "snippet": "CKeyID(const uint160 &in) : uint160(in) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCKeyID {\n  CKeyID(const uint160 &in) : uint160(in) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [
            "vSolutions[0]"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "CPubKey",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "71-71",
          "snippet": "CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "Solver",
          "args": [
            "scriptPubKey",
            "whichTypeRet",
            "vSolutions"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "Solver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1295-1404",
          "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "scriptSigRet.clear",
          "args": [],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool Solver(const CKeyStore& keystore, const CScript& scriptPubKey, uint256 hash, int nHashType,\n                  CScript& scriptSigRet, txnouttype& whichTypeRet)\n{\n    scriptSigRet.clear();\n\n    vector<valtype> vSolutions;\n    if (!Solver(scriptPubKey, whichTypeRet, vSolutions))\n        return false;\n\n    CKeyID keyID;\n    switch (whichTypeRet)\n    {\n    case TX_NONSTANDARD:\n        return false;\n    case TX_PUBKEY:\n        keyID = CPubKey(vSolutions[0]).GetID();\n        return Sign1(keyID, keystore, hash, nHashType, scriptSigRet);\n    case TX_PUBKEYHASH:\n        keyID = CKeyID(uint160(vSolutions[0]));\n        if (!Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            return false;\n        else\n        {\n            CPubKey vch;\n            keystore.GetPubKey(keyID, vch);\n            scriptSigRet << vch;\n        }\n        return true;\n    case TX_SCRIPTHASH:\n        return keystore.GetCScript(uint160(vSolutions[0]), scriptSigRet);\n\n    case TX_MULTISIG:\n        scriptSigRet << OP_0; // workaround CHECKMULTISIG bug\n        return (SignN(vSolutions, keystore, hash, nHashType, scriptSigRet));\n    }\n    return false;\n}"
  },
  {
    "function_name": "SignN",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1422-1434",
    "snippet": "bool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    int nSigned = 0;\n    int nRequired = multisigdata.front()[0];\n    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n    {\n        const valtype& pubkey = multisigdata[i];\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            ++nSigned;\n    }\n    return nSigned==nRequired;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Sign1",
          "args": [
            "keyID",
            "keystore",
            "hash",
            "nHashType",
            "scriptSigRet"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "Sign1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1407-1420",
          "snippet": "bool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    CKey key;\n    if (!keystore.GetKey(address, key))\n        return false;\n\n    vector<unsigned char> vchSig;\n    if (!key.Sign(hash, vchSig))\n        return false;\n    vchSig.push_back((unsigned char)nHashType);\n    scriptSigRet << vchSig;\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    CKey key;\n    if (!keystore.GetKey(address, key))\n        return false;\n\n    vector<unsigned char> vchSig;\n    if (!key.Sign(hash, vchSig))\n        return false;\n    vchSig.push_back((unsigned char)nHashType);\n    scriptSigRet << vchSig;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "Raw",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "96-98",
          "snippet": "std::vector<unsigned char> Raw() const {\n        return vchPubKey;\n    }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  std::vector<unsigned char> Raw() const {\n          return vchPubKey;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CPubKey",
          "args": [
            "pubkey"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "CPubKey",
          "container": "CPubKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "71-71",
          "snippet": "CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nCPubKey {\n  CPubKey(const std::vector<unsigned char> &vchPubKeyIn) : vchPubKey(vchPubKeyIn) { }\n}"
        }
      },
      {
        "call_info": {
          "callee": "multisigdata.size",
          "args": [],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "multisigdata.front",
          "args": [],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool SignN(const vector<valtype>& multisigdata, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    int nSigned = 0;\n    int nRequired = multisigdata.front()[0];\n    for (unsigned int i = 1; i < multisigdata.size()-1 && nSigned < nRequired; i++)\n    {\n        const valtype& pubkey = multisigdata[i];\n        CKeyID keyID = CPubKey(pubkey).GetID();\n        if (Sign1(keyID, keystore, hash, nHashType, scriptSigRet))\n            ++nSigned;\n    }\n    return nSigned==nRequired;\n}"
  },
  {
    "function_name": "Sign1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1407-1420",
    "snippet": "bool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    CKey key;\n    if (!keystore.GetKey(address, key))\n        return false;\n\n    vector<unsigned char> vchSig;\n    if (!key.Sign(hash, vchSig))\n        return false;\n    vchSig.push_back((unsigned char)nHashType);\n    scriptSigRet << vchSig;\n\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vchSig.push_back",
          "args": [
            "(unsigned char)nHashType"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key.Sign",
          "args": [
            "hash",
            "vchSig"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "Sign",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "286-312",
          "snippet": "bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n{\n    vchSig.clear();\n    ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n    if (sig == NULL)\n        return false;\n    BN_CTX *ctx = BN_CTX_new();\n    BN_CTX_start(ctx);\n    const EC_GROUP *group = EC_KEY_get0_group(pkey);\n    BIGNUM *order = BN_CTX_get(ctx);\n    BIGNUM *halforder = BN_CTX_get(ctx);\n    EC_GROUP_get_order(group, order, ctx);\n    BN_rshift1(halforder, order);\n    if (BN_cmp(sig->s, halforder) > 0) {\n        // enforce low S values, by negating the value (modulo the order) if above order/2.\n        BN_sub(sig->s, order, sig->s);\n    }\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    unsigned int nSize = ECDSA_size(pkey);\n    vchSig.resize(nSize); // Make sure it is big enough\n    unsigned char *pos = &vchSig[0];\n    nSize = i2d_ECDSA_SIG(sig, &pos);\n    ECDSA_SIG_free(sig);\n    vchSig.resize(nSize); // Shrink to fit actual size\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Sign(uint256 hash, std::vector<unsigned char>& vchSig)\n  {\n      vchSig.clear();\n      ECDSA_SIG *sig = ECDSA_do_sign((unsigned char*)&hash, sizeof(hash), pkey);\n      if (sig == NULL)\n          return false;\n      BN_CTX *ctx = BN_CTX_new();\n      BN_CTX_start(ctx);\n      const EC_GROUP *group = EC_KEY_get0_group(pkey);\n      BIGNUM *order = BN_CTX_get(ctx);\n      BIGNUM *halforder = BN_CTX_get(ctx);\n      EC_GROUP_get_order(group, order, ctx);\n      BN_rshift1(halforder, order);\n      if (BN_cmp(sig->s, halforder) > 0) {\n          // enforce low S values, by negating the value (modulo the order) if above order/2.\n          BN_sub(sig->s, order, sig->s);\n      }\n      BN_CTX_end(ctx);\n      BN_CTX_free(ctx);\n      unsigned int nSize = ECDSA_size(pkey);\n      vchSig.resize(nSize); // Make sure it is big enough\n      unsigned char *pos = &vchSig[0];\n      nSize = i2d_ECDSA_SIG(sig, &pos);\n      ECDSA_SIG_free(sig);\n      vchSig.resize(nSize); // Shrink to fit actual size\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "keystore.GetKey",
          "args": [
            "address",
            "key"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "GetKey",
          "container": "CBasicKeyStore",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/keystore.h",
          "lines": "81-94",
          "snippet": "bool GetKey(const CKeyID &address, CKey &keyOut) const\n    {\n        {\n            LOCK(cs_KeyStore);\n            KeyMap::const_iterator mi = mapKeys.find(address);\n            if (mi != mapKeys.end())\n            {\n                keyOut.Reset();\n                keyOut.SetSecret((*mi).second.first, (*mi).second.second);\n                return true;\n            }\n        }\n        return false;\n    }",
          "includes": [
            "#include <boost/signals2/signal.hpp>",
            "#include \"sync.h\"",
            "#include \"crypter.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <boost/signals2/signal.hpp>\n#include \"sync.h\"\n#include \"crypter.h\"\n\nCBasicKeyStore {\n  bool GetKey(const CKeyID &address, CKey &keyOut) const\n      {\n          {\n              LOCK(cs_KeyStore);\n              KeyMap::const_iterator mi = mapKeys.find(address);\n              if (mi != mapKeys.end())\n              {\n                  keyOut.Reset();\n                  keyOut.SetSecret((*mi).second.first, (*mi).second.second);\n                  return true;\n              }\n          }\n          return false;\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool Sign1(const CKeyID& address, const CKeyStore& keystore, uint256 hash, int nHashType, CScript& scriptSigRet)\n{\n    CKey key;\n    if (!keystore.GetKey(address, key))\n        return false;\n\n    vector<unsigned char> vchSig;\n    if (!key.Sign(hash, vchSig))\n        return false;\n    vchSig.push_back((unsigned char)nHashType);\n    scriptSigRet << vchSig;\n\n    return true;\n}"
  },
  {
    "function_name": "Solver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1295-1404",
    "snippet": "bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vSolutionsRet.clear",
          "args": [],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutionsRet.push_back",
          "args": [
            "valtype(1, n)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valtype",
          "args": [
            "1",
            "n"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CScript::DecodeOP_N",
          "args": [
            "opcode1"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "DecodeOP_N",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "472-478",
          "snippet": "static int DecodeOP_N(opcodetype opcode)\n    {\n        if (opcode == OP_0)\n            return 0;\n        assert(opcode >= OP_1 && opcode <= OP_16);\n        return (int)opcode - (int)(OP_1 - 1);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  static int DecodeOP_N(opcodetype opcode)\n      {\n          if (opcode == OP_0)\n              return 0;\n          assert(opcode >= OP_1 && opcode <= OP_16);\n          return (int)opcode - (int)(OP_1 - 1);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutionsRet.push_back",
          "args": [
            "vch1"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vch1.size",
          "args": [],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutionsRet.push_back",
          "args": [
            "vch1"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "script2.GetOp",
          "args": [
            "pc2",
            "opcode2",
            "vch2"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "GetOp",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "408-411",
          "snippet": "bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n    {\n        return GetOp2(pc, opcodeRet, &vchRet);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n      {\n          return GetOp2(pc, opcodeRet, &vchRet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutionsRet.push_back",
          "args": [
            "vch1"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vSolutionsRet.back",
          "args": [],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vSolutionsRet.front",
          "args": [],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "script2.end",
          "args": [],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "script2.begin",
          "args": [],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vSolutionsRet.push_back",
          "args": [
            "hashBytes"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scriptPubKey.IsPayToScriptHash",
          "args": [],
          "line": 1313
        },
        "resolved": true,
        "details": {
          "function_name": "IsPayToScriptHash",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1950-1957",
          "snippet": "bool CScript::IsPayToScriptHash() const\n{\n    // Extra-fast test for pay-to-script-hash CScripts:\n    return (this->size() == 23 &&\n            this->at(0) == OP_HASH160 &&\n            this->at(1) == 0x14 &&\n            this->at(22) == OP_EQUAL);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::IsPayToScriptHash() const\n  {\n      // Extra-fast test for pay-to-script-hash CScripts:\n      return (this->size() == 23 &&\n              this->at(0) == OP_HASH160 &&\n              this->at(1) == 0x14 &&\n              this->at(22) == OP_EQUAL);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mTemplates.insert",
          "args": [
            "make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG)"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "TX_MULTISIG",
            "CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "HasCanonicalPushes",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1959-1984",
          "snippet": "bool CScript::HasCanonicalPushes() const\n{\n    const_iterator pc = begin();\n    while (pc < end())\n    {\n        opcodetype opcode;\n        std::vector<unsigned char> data;\n        if (!GetOp(pc, opcode, data))\n            return false;\n        if (opcode > OP_16)\n            continue;\n        if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n            // Could have used an OP_n code, rather than a 1-byte push.\n            return false;\n        if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n            // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n            // Could have used an OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n            // Could have used an OP_PUSHDATA2.\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::HasCanonicalPushes() const\n  {\n      const_iterator pc = begin();\n      while (pc < end())\n      {\n          opcodetype opcode;\n          std::vector<unsigned char> data;\n          if (!GetOp(pc, opcode, data))\n              return false;\n          if (opcode > OP_16)\n              continue;\n          if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n              // Could have used an OP_n code, rather than a 1-byte push.\n              return false;\n          if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n              // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n              // Could have used an OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n              // Could have used an OP_PUSHDATA2.\n              return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "TX_PUBKEYHASH",
            "CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_pair",
          "args": [
            "TX_PUBKEY",
            "CScript() << OP_PUBKEY << OP_CHECKSIG"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mTemplates.empty",
          "args": [],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsigned char> >& vSolutionsRet)\n{\n    // Templates\n    static map<txnouttype, CScript> mTemplates;\n    if (mTemplates.empty())\n    {\n        // Standard tx, sender provides pubkey, receiver adds signature\n        mTemplates.insert(make_pair(TX_PUBKEY, CScript() << OP_PUBKEY << OP_CHECKSIG));\n\n        // Bitcoin address tx, sender provides hash of pubkey, receiver provides signature and pubkey\n        mTemplates.insert(make_pair(TX_PUBKEYHASH, CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG));\n\n        // Sender provides N pubkeys, receivers provides M signatures\n        mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n    }\n\n    // Shortcut for pay-to-script-hash, which are more constrained than the other types:\n    // it is always OP_HASH160 20 [20 byte hash] OP_EQUAL\n    if (scriptPubKey.IsPayToScriptHash())\n    {\n        typeRet = TX_SCRIPTHASH;\n        vector<unsigned char> hashBytes(scriptPubKey.begin()+2, scriptPubKey.begin()+22);\n        vSolutionsRet.push_back(hashBytes);\n        return true;\n    }\n\n    // Scan templates\n    const CScript& script1 = scriptPubKey;\n    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n    {\n        const CScript& script2 = tplate.second;\n        vSolutionsRet.clear();\n\n        opcodetype opcode1, opcode2;\n        vector<unsigned char> vch1, vch2;\n\n        // Compare\n        CScript::const_iterator pc1 = script1.begin();\n        CScript::const_iterator pc2 = script2.begin();\n        while (true)\n        {\n            if (pc1 == script1.end() && pc2 == script2.end())\n            {\n                // Found a match\n                typeRet = tplate.first;\n                if (typeRet == TX_MULTISIG)\n                {\n                    // Additional checks for TX_MULTISIG:\n                    unsigned char m = vSolutionsRet.front()[0];\n                    unsigned char n = vSolutionsRet.back()[0];\n                    if (m < 1 || n < 1 || m > n || vSolutionsRet.size()-2 != n)\n                        return false;\n                }\n                return true;\n            }\n            if (!script1.GetOp(pc1, opcode1, vch1))\n                break;\n            if (!script2.GetOp(pc2, opcode2, vch2))\n                break;\n\n            // Template matching opcodes:\n            if (opcode2 == OP_PUBKEYS)\n            {\n                while (vch1.size() >= 33 && vch1.size() <= 120)\n                {\n                    vSolutionsRet.push_back(vch1);\n                    if (!script1.GetOp(pc1, opcode1, vch1))\n                        break;\n                }\n                if (!script2.GetOp(pc2, opcode2, vch2))\n                    break;\n                // Normal situation is to fall through\n                // to other if/else statements\n            }\n\n            if (opcode2 == OP_PUBKEY)\n            {\n                if (vch1.size() < 33 || vch1.size() > 120)\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_PUBKEYHASH)\n            {\n                if (vch1.size() != sizeof(uint160))\n                    break;\n                vSolutionsRet.push_back(vch1);\n            }\n            else if (opcode2 == OP_SMALLINTEGER)\n            {   // Single-byte small integer pushed onto vSolutions\n                if (opcode1 == OP_0 ||\n                    (opcode1 >= OP_1 && opcode1 <= OP_16))\n                {\n                    char n = (char)CScript::DecodeOP_N(opcode1);\n                    vSolutionsRet.push_back(valtype(1, n));\n                }\n                else\n                    break;\n            }\n            else if (opcode1 != opcode2 || vch1 != vch2)\n            {\n                // Others must match exactly\n                break;\n            }\n        }\n    }\n\n    vSolutionsRet.clear();\n    typeRet = TX_NONSTANDARD;\n    return false;\n}"
  },
  {
    "function_name": "CheckSig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1254-1282",
    "snippet": "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n              const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    static CSignatureCache signatureCache;\n\n    // Hash type is one byte tacked on to the end of the signature\n    if (vchSig.empty())\n        return false;\n    if (nHashType == 0)\n        nHashType = vchSig.back();\n    else if (nHashType != vchSig.back())\n        return false;\n    vchSig.pop_back();\n\n    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n\n    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n        return true;\n\n    CKey key;\n    if (!key.SetPubKey(vchPubKey))\n        return false;\n\n    if (!key.Verify(sighash, vchSig))\n        return false;\n\n    signatureCache.Set(sighash, vchSig, vchPubKey);\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "signatureCache.Set",
          "args": [
            "sighash",
            "vchSig",
            "vchPubKey"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "Set",
          "container": "CSignatureCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1223-1251",
          "snippet": "void Set(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n    {\n        // DoS prevention: limit cache size to less than 10MB\n        // (~200 bytes per cache entry times 50,000 entries)\n        // Since there are a maximum of 20,000 signature operations per block\n        // 50,000 is a reasonable default.\n        int64_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n        if (nMaxCacheSize <= 0) return;\n\n        LOCK(cs_sigcache);\n\n        while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize)\n        {\n            // Evict a random entry. Random because that helps\n            // foil would-be DoS attackers who might try to pre-generate\n            // and re-use a set of valid signatures just-slightly-greater\n            // than our cache size.\n            uint256 randomHash = GetRandHash();\n            std::vector<unsigned char> unused;\n            std::set<sigdata_type>::iterator it =\n                setValid.lower_bound(sigdata_type(randomHash, unused, unused));\n            if (it == setValid.end())\n                it = setValid.begin();\n            setValid.erase(*it);\n        }\n\n        sigdata_type k(hash, vchSig, pubKey);\n        setValid.insert(k);\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCSignatureCache {\n  void Set(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n      {\n          // DoS prevention: limit cache size to less than 10MB\n          // (~200 bytes per cache entry times 50,000 entries)\n          // Since there are a maximum of 20,000 signature operations per block\n          // 50,000 is a reasonable default.\n          int64_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n          if (nMaxCacheSize <= 0) return;\n  \n          LOCK(cs_sigcache);\n  \n          while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize)\n          {\n              // Evict a random entry. Random because that helps\n              // foil would-be DoS attackers who might try to pre-generate\n              // and re-use a set of valid signatures just-slightly-greater\n              // than our cache size.\n              uint256 randomHash = GetRandHash();\n              std::vector<unsigned char> unused;\n              std::set<sigdata_type>::iterator it =\n                  setValid.lower_bound(sigdata_type(randomHash, unused, unused));\n              if (it == setValid.end())\n                  it = setValid.begin();\n              setValid.erase(*it);\n          }\n  \n          sigdata_type k(hash, vchSig, pubKey);\n          setValid.insert(k);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.Verify",
          "args": [
            "sighash",
            "vchSig"
          ],
          "line": 1277
        },
        "resolved": true,
        "details": {
          "function_name": "Verify",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "392-399",
          "snippet": "bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n{\n    // -1 = error, 0 = bad sig, 1 = good\n    if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::Verify(uint256 hash, const std::vector<unsigned char>& vchSig)\n  {\n      // -1 = error, 0 = bad sig, 1 = good\n      if (ECDSA_verify(0, (unsigned char*)&hash, sizeof(hash), &vchSig[0], vchSig.size(), pkey) != 1)\n          return false;\n  \n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "key.SetPubKey",
          "args": [
            "vchPubKey"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "SetPubKey",
          "container": "CKey",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.cpp",
          "lines": "259-272",
          "snippet": "bool CKey::SetPubKey(const CPubKey& vchPubKey)\n{\n    const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n    if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n    {\n        fSet = true;\n        if (vchPubKey.vchPubKey.size() == 33)\n            SetCompressedPubKey();\n        return true;\n    }\n    pkey = NULL;\n    Reset();\n    return false;\n}",
          "includes": [
            "#include \"key.h\"",
            "#include <openssl/obj_mac.h>",
            "#include <openssl/ecdsa.h>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"key.h\"\n#include <openssl/obj_mac.h>\n#include <openssl/ecdsa.h>\n#include <map>\n\nCKey {\n  bool CKey::SetPubKey(const CPubKey& vchPubKey)\n  {\n      const unsigned char* pbegin = &vchPubKey.vchPubKey[0];\n      if (o2i_ECPublicKey(&pkey, &pbegin, vchPubKey.vchPubKey.size()))\n      {\n          fSet = true;\n          if (vchPubKey.vchPubKey.size() == 33)\n              SetCompressedPubKey();\n          return true;\n      }\n      pkey = NULL;\n      Reset();\n      return false;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "signatureCache.Get",
          "args": [
            "sighash",
            "vchSig",
            "vchPubKey"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "Get",
          "container": "CSignatureCache",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1211-1221",
          "snippet": "bool\n    Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n    {\n        LOCK(cs_sigcache);\n\n        sigdata_type k(hash, vchSig, pubKey);\n        std::set<sigdata_type>::iterator mi = setValid.find(k);\n        if (mi != setValid.end())\n            return true;\n        return false;\n    }",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCSignatureCache {\n  bool\n      Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n      {\n          LOCK(cs_sigcache);\n  \n          sigdata_type k(hash, vchSig, pubKey);\n          std::set<sigdata_type>::iterator mi = setValid.find(k);\n          if (mi != setValid.end())\n              return true;\n          return false;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "SignatureHash",
          "args": [
            "scriptCode",
            "txTo",
            "nIn",
            "nHashType"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "SignatureHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1135-1195",
          "snippet": "uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    if (nIn >= txTo.vin.size())\n    {\n        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n        return 1;\n    }\n    CTransaction txTmp(txTo);\n\n    // In case concatenating two scripts ends up with two codeseparators,\n    // or an extra one at the end, this prevents all those possible incompatibilities.\n    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n\n    // Blank out other inputs' signatures\n    for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n        txTmp.vin[i].scriptSig = CScript();\n    txTmp.vin[nIn].scriptSig = scriptCode;\n\n    // Blank out some of the outputs\n    if ((nHashType & 0x1f) == SIGHASH_NONE)\n    {\n        // Wildcard payee\n        txTmp.vout.clear();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n    {\n        // Only lock-in the txout payee at same index as txin\n        unsigned int nOut = nIn;\n        if (nOut >= txTmp.vout.size())\n        {\n            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n            return 1;\n        }\n        txTmp.vout.resize(nOut+1);\n        for (unsigned int i = 0; i < nOut; i++)\n            txTmp.vout[i].SetNull();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n\n    // Blank out other inputs completely, not recommended for open transactions\n    if (nHashType & SIGHASH_ANYONECANPAY)\n    {\n        txTmp.vin[0] = txTmp.vin[nIn];\n        txTmp.vin.resize(1);\n    }\n\n    // Serialize and hash\n    CDataStream ss(SER_GETHASH, 0);\n    ss.reserve(10000);\n    ss << txTmp << nHashType;\n    return Hash(ss.begin(), ss.end());\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nuint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    if (nIn >= txTo.vin.size())\n    {\n        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n        return 1;\n    }\n    CTransaction txTmp(txTo);\n\n    // In case concatenating two scripts ends up with two codeseparators,\n    // or an extra one at the end, this prevents all those possible incompatibilities.\n    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n\n    // Blank out other inputs' signatures\n    for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n        txTmp.vin[i].scriptSig = CScript();\n    txTmp.vin[nIn].scriptSig = scriptCode;\n\n    // Blank out some of the outputs\n    if ((nHashType & 0x1f) == SIGHASH_NONE)\n    {\n        // Wildcard payee\n        txTmp.vout.clear();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n    {\n        // Only lock-in the txout payee at same index as txin\n        unsigned int nOut = nIn;\n        if (nOut >= txTmp.vout.size())\n        {\n            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n            return 1;\n        }\n        txTmp.vout.resize(nOut+1);\n        for (unsigned int i = 0; i < nOut; i++)\n            txTmp.vout[i].SetNull();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n\n    // Blank out other inputs completely, not recommended for open transactions\n    if (nHashType & SIGHASH_ANYONECANPAY)\n    {\n        txTmp.vin[0] = txTmp.vin[nIn];\n        txTmp.vin.resize(1);\n    }\n\n    // Serialize and hash\n    CDataStream ss(SER_GETHASH, 0);\n    ss.reserve(10000);\n    ss << txTmp << nHashType;\n    return Hash(ss.begin(), ss.end());\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSig.pop_back",
          "args": [],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.back",
          "args": [],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.back",
          "args": [],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vchSig.empty",
          "args": [],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n              const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    static CSignatureCache signatureCache;\n\n    // Hash type is one byte tacked on to the end of the signature\n    if (vchSig.empty())\n        return false;\n    if (nHashType == 0)\n        nHashType = vchSig.back();\n    else if (nHashType != vchSig.back())\n        return false;\n    vchSig.pop_back();\n\n    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n\n    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n        return true;\n\n    CKey key;\n    if (!key.SetPubKey(vchPubKey))\n        return false;\n\n    if (!key.Verify(sighash, vchSig))\n        return false;\n\n    signatureCache.Set(sighash, vchSig, vchPubKey);\n    return true;\n}"
  },
  {
    "function_name": "Set",
    "container": "CSignatureCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1223-1251",
    "snippet": "void Set(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n    {\n        // DoS prevention: limit cache size to less than 10MB\n        // (~200 bytes per cache entry times 50,000 entries)\n        // Since there are a maximum of 20,000 signature operations per block\n        // 50,000 is a reasonable default.\n        int64_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n        if (nMaxCacheSize <= 0) return;\n\n        LOCK(cs_sigcache);\n\n        while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize)\n        {\n            // Evict a random entry. Random because that helps\n            // foil would-be DoS attackers who might try to pre-generate\n            // and re-use a set of valid signatures just-slightly-greater\n            // than our cache size.\n            uint256 randomHash = GetRandHash();\n            std::vector<unsigned char> unused;\n            std::set<sigdata_type>::iterator it =\n                setValid.lower_bound(sigdata_type(randomHash, unused, unused));\n            if (it == setValid.end())\n                it = setValid.begin();\n            setValid.erase(*it);\n        }\n\n        sigdata_type k(hash, vchSig, pubKey);\n        setValid.insert(k);\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setValid.insert",
          "args": [
            "k"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "61-65",
          "snippet": "void CBloomFilter::insert(const uint256& hash)\n{\n    vector<unsigned char> data(BEGIN(hash), END(hash));\n    insert(data);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  void CBloomFilter::insert(const uint256& hash)\n  {\n      vector<unsigned char> data(BEGIN(hash), END(hash));\n      insert(data);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setValid.erase",
          "args": [
            "*it"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setValid.begin",
          "args": [],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setValid.end",
          "args": [],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setValid.lower_bound",
          "args": [
            "sigdata_type(randomHash, unused, unused)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdata_type",
          "args": [
            "randomHash",
            "unused",
            "unused"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetRandHash",
          "args": [],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "GetRandHash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "193-198",
          "snippet": "uint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nuint256 GetRandHash()\n{\n    uint256 hash;\n    RAND_bytes((unsigned char*)&hash, sizeof(hash));\n    return hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cast<int64_t>",
          "args": [
            "setValid.size()"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setValid.size",
          "args": [],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_sigcache"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GetArg",
          "args": [
            "\"-maxsigcachesize\"",
            "50000"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "GetArg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "562-567",
          "snippet": "int64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "map<string, string> mapArgs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nmap<string, string> mapArgs;\n\nint64_t GetArg(const std::string& strArg, int64_t nDefault)\n{\n    if (mapArgs.count(strArg))\n        return atoi64(mapArgs[strArg]);\n    return nDefault;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCSignatureCache {\n  void Set(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n      {\n          // DoS prevention: limit cache size to less than 10MB\n          // (~200 bytes per cache entry times 50,000 entries)\n          // Since there are a maximum of 20,000 signature operations per block\n          // 50,000 is a reasonable default.\n          int64_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", 50000);\n          if (nMaxCacheSize <= 0) return;\n  \n          LOCK(cs_sigcache);\n  \n          while (static_cast<int64_t>(setValid.size()) > nMaxCacheSize)\n          {\n              // Evict a random entry. Random because that helps\n              // foil would-be DoS attackers who might try to pre-generate\n              // and re-use a set of valid signatures just-slightly-greater\n              // than our cache size.\n              uint256 randomHash = GetRandHash();\n              std::vector<unsigned char> unused;\n              std::set<sigdata_type>::iterator it =\n                  setValid.lower_bound(sigdata_type(randomHash, unused, unused));\n              if (it == setValid.end())\n                  it = setValid.begin();\n              setValid.erase(*it);\n          }\n  \n          sigdata_type k(hash, vchSig, pubKey);\n          setValid.insert(k);\n      }\n}"
  },
  {
    "function_name": "Get",
    "container": "CSignatureCache",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1211-1221",
    "snippet": "bool\n    Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n    {\n        LOCK(cs_sigcache);\n\n        sigdata_type k(hash, vchSig, pubKey);\n        std::set<sigdata_type>::iterator mi = setValid.find(k);\n        if (mi != setValid.end())\n            return true;\n        return false;\n    }",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setValid.end",
          "args": [],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "setValid.find",
          "args": [
            "k"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "find",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "33-33",
          "snippet": "const_iterator find(const key_type& k) const { return map.find(k); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator find(const key_type& k) const { return map.find(k); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOCK",
          "args": [
            "cs_sigcache"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCSignatureCache {\n  bool\n      Get(uint256 hash, const std::vector<unsigned char>& vchSig, const std::vector<unsigned char>& pubKey)\n      {\n          LOCK(cs_sigcache);\n  \n          sigdata_type k(hash, vchSig, pubKey);\n          std::set<sigdata_type>::iterator mi = setValid.find(k);\n          if (mi != setValid.end())\n              return true;\n          return false;\n      }\n}"
  },
  {
    "function_name": "SignatureHash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "1135-1195",
    "snippet": "uint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    if (nIn >= txTo.vin.size())\n    {\n        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n        return 1;\n    }\n    CTransaction txTmp(txTo);\n\n    // In case concatenating two scripts ends up with two codeseparators,\n    // or an extra one at the end, this prevents all those possible incompatibilities.\n    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n\n    // Blank out other inputs' signatures\n    for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n        txTmp.vin[i].scriptSig = CScript();\n    txTmp.vin[nIn].scriptSig = scriptCode;\n\n    // Blank out some of the outputs\n    if ((nHashType & 0x1f) == SIGHASH_NONE)\n    {\n        // Wildcard payee\n        txTmp.vout.clear();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n    {\n        // Only lock-in the txout payee at same index as txin\n        unsigned int nOut = nIn;\n        if (nOut >= txTmp.vout.size())\n        {\n            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n            return 1;\n        }\n        txTmp.vout.resize(nOut+1);\n        for (unsigned int i = 0; i < nOut; i++)\n            txTmp.vout[i].SetNull();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n\n    // Blank out other inputs completely, not recommended for open transactions\n    if (nHashType & SIGHASH_ANYONECANPAY)\n    {\n        txTmp.vin[0] = txTmp.vin[nIn];\n        txTmp.vin.resize(1);\n    }\n\n    // Serialize and hash\n    CDataStream ss(SER_GETHASH, 0);\n    ss.reserve(10000);\n    ss << txTmp << nHashType;\n    return Hash(ss.begin(), ss.end());\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "ss.begin()",
            "ss.end()"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.end",
          "args": [],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.begin",
          "args": [],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss.reserve",
          "args": [
            "10000"
          ],
          "line": 1192
        },
        "resolved": true,
        "details": {
          "function_name": "reserve",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "805-805",
          "snippet": "void reserve(size_type n)                        { vch.reserve(n + nReadPos); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void reserve(size_type n)                        { vch.reserve(n + nReadPos); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txTmp.vin.resize",
          "args": [
            "1"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "resize",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "804-804",
          "snippet": "void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void resize(size_type n, value_type c=0)         { vch.resize(n + nReadPos, c); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txTmp.vin.size",
          "args": [],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "txTmp.vout[i].SetNull",
          "args": [],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "SetNull",
          "container": "CKeyMetadata",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/walletdb.h",
          "lines": "50-54",
          "snippet": "void SetNull()\n    {\n        nVersion = CKeyMetadata::CURRENT_VERSION;\n        nCreateTime = 0;\n    }",
          "includes": [
            "#include \"base58.h\"",
            "#include \"db.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"db.h\"\n\nCKeyMetadata {\n  void SetNull()\n      {\n          nVersion = CKeyMetadata::CURRENT_VERSION;\n          nCreateTime = 0;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"ERROR: SignatureHash() : nOut=%d out of range\\n\"",
            "nOut"
          ],
          "line": 1170
        },
        "resolved": true,
        "details": {
          "function_name": "real_strprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.cpp",
          "lines": "331-338",
          "snippet": "string real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}",
          "includes": [
            "#include <execinfo.h>",
            "# include <sys/prctl.h>",
            "#include \"shlobj.h\"",
            "#include <io.h> /* for _commit */",
            "#include <stdarg.h>",
            "#include <openssl/rand.h>",
            "#include <openssl/crypto.h>",
            "#include <boost/thread.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/program_options/parsers.hpp>",
            "#include <boost/program_options/detail/config_file.hpp>",
            "#include <boost/algorithm/string/join.hpp>",
            "#include \"ui_interface.h\"",
            "#include \"version.h\"",
            "#include \"strlcpy.h\"",
            "#include \"sync.h\"",
            "#include \"util.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <execinfo.h>\n# include <sys/prctl.h>\n#include \"shlobj.h\"\n#include <io.h> /* for _commit */\n#include <stdarg.h>\n#include <openssl/rand.h>\n#include <openssl/crypto.h>\n#include <boost/thread.hpp>\n#include <boost/foreach.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/program_options/parsers.hpp>\n#include <boost/program_options/detail/config_file.hpp>\n#include <boost/algorithm/string/join.hpp>\n#include \"ui_interface.h\"\n#include \"version.h\"\n#include \"strlcpy.h\"\n#include \"sync.h\"\n#include \"util.h\"\n\nstring real_strprintf(const std::string &format, int dummy, ...)\n{\n    va_list arg_ptr;\n    va_start(arg_ptr, dummy);\n    string str = vstrprintf(format.c_str(), arg_ptr);\n    va_end(arg_ptr);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "txTmp.vout.clear",
          "args": [],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "clear",
          "container": "CTxMemPool",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/main.cpp",
          "lines": "768-774",
          "snippet": "void CTxMemPool::clear()\n{\n    LOCK(cs);\n    mapTx.clear();\n    mapNextTx.clear();\n    ++nTransactionsUpdated;\n}",
          "includes": [
            "#include <boost/filesystem/fstream.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/algorithm/string/replace.hpp>",
            "#include \"kernel.h\"",
            "#include \"ui_interface.h\"",
            "#include \"init.h\"",
            "#include \"net.h\"",
            "#include \"txdb.h\"",
            "#include \"db.h\"",
            "#include \"checkpoints.h\"",
            "#include \"alert.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int nTransactionsUpdated = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <boost/filesystem/fstream.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/algorithm/string/replace.hpp>\n#include \"kernel.h\"\n#include \"ui_interface.h\"\n#include \"init.h\"\n#include \"net.h\"\n#include \"txdb.h\"\n#include \"db.h\"\n#include \"checkpoints.h\"\n#include \"alert.h\"\n\nunsigned int nTransactionsUpdated = 0;\n\nCTxMemPool {\n  void CTxMemPool::clear()\n  {\n      LOCK(cs);\n      mapTx.clear();\n      mapNextTx.clear();\n      ++nTransactionsUpdated;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "HasCanonicalPushes",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1959-1984",
          "snippet": "bool CScript::HasCanonicalPushes() const\n{\n    const_iterator pc = begin();\n    while (pc < end())\n    {\n        opcodetype opcode;\n        std::vector<unsigned char> data;\n        if (!GetOp(pc, opcode, data))\n            return false;\n        if (opcode > OP_16)\n            continue;\n        if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n            // Could have used an OP_n code, rather than a 1-byte push.\n            return false;\n        if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n            // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n            // Could have used an OP_PUSHDATA1.\n            return false;\n        if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n            // Could have used an OP_PUSHDATA2.\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  bool CScript::HasCanonicalPushes() const\n  {\n      const_iterator pc = begin();\n      while (pc < end())\n      {\n          opcodetype opcode;\n          std::vector<unsigned char> data;\n          if (!GetOp(pc, opcode, data))\n              return false;\n          if (opcode > OP_16)\n              continue;\n          if (opcode < OP_PUSHDATA1 && opcode > OP_0 && (data.size() == 1 && data[0] <= 16))\n              // Could have used an OP_n code, rather than a 1-byte push.\n              return false;\n          if (opcode == OP_PUSHDATA1 && data.size() < OP_PUSHDATA1)\n              // Could have used a normal n-byte push, rather than OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA2 && data.size() <= 0xFF)\n              // Could have used an OP_PUSHDATA1.\n              return false;\n          if (opcode == OP_PUSHDATA4 && data.size() <= 0xFFFF)\n              // Could have used an OP_PUSHDATA2.\n              return false;\n      }\n      return true;\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "scriptCode.FindAndDelete",
          "args": [
            "CScript(OP_CODESEPARATOR)"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "FindAndDelete",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "487-504",
          "snippet": "int FindAndDelete(const CScript& b)\n    {\n        int nFound = 0;\n        if (b.empty())\n            return nFound;\n        iterator pc = begin();\n        opcodetype opcode;\n        do\n        {\n            while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n            {\n                erase(pc, pc + b.size());\n                ++nFound;\n            }\n        }\n        while (GetOp(pc, opcode));\n        return nFound;\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  int FindAndDelete(const CScript& b)\n      {\n          int nFound = 0;\n          if (b.empty())\n              return nFound;\n          iterator pc = begin();\n          opcodetype opcode;\n          do\n          {\n              while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n              {\n                  erase(pc, pc + b.size());\n                  ++nFound;\n              }\n          }\n          while (GetOp(pc, opcode));\n          return nFound;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [
            "OP_CODESEPARATOR"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "SetDestination",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "2011-2014",
          "snippet": "void CScript::SetDestination(const CTxDestination& dest)\n{\n    boost::apply_visitor(CScriptVisitor(this), dest);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  void CScript::SetDestination(const CTxDestination& dest)\n  {\n      boost::apply_visitor(CScriptVisitor(this), dest);\n  }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nuint256 SignatureHash(CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    if (nIn >= txTo.vin.size())\n    {\n        printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n        return 1;\n    }\n    CTransaction txTmp(txTo);\n\n    // In case concatenating two scripts ends up with two codeseparators,\n    // or an extra one at the end, this prevents all those possible incompatibilities.\n    scriptCode.FindAndDelete(CScript(OP_CODESEPARATOR));\n\n    // Blank out other inputs' signatures\n    for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n        txTmp.vin[i].scriptSig = CScript();\n    txTmp.vin[nIn].scriptSig = scriptCode;\n\n    // Blank out some of the outputs\n    if ((nHashType & 0x1f) == SIGHASH_NONE)\n    {\n        // Wildcard payee\n        txTmp.vout.clear();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n    else if ((nHashType & 0x1f) == SIGHASH_SINGLE)\n    {\n        // Only lock-in the txout payee at same index as txin\n        unsigned int nOut = nIn;\n        if (nOut >= txTmp.vout.size())\n        {\n            printf(\"ERROR: SignatureHash() : nOut=%d out of range\\n\", nOut);\n            return 1;\n        }\n        txTmp.vout.resize(nOut+1);\n        for (unsigned int i = 0; i < nOut; i++)\n            txTmp.vout[i].SetNull();\n\n        // Let the others update at will\n        for (unsigned int i = 0; i < txTmp.vin.size(); i++)\n            if (i != nIn)\n                txTmp.vin[i].nSequence = 0;\n    }\n\n    // Blank out other inputs completely, not recommended for open transactions\n    if (nHashType & SIGHASH_ANYONECANPAY)\n    {\n        txTmp.vin[0] = txTmp.vin[nIn];\n        txTmp.vin.resize(1);\n    }\n\n    // Serialize and hash\n    CDataStream ss(SER_GETHASH, 0);\n    ss.reserve(10000);\n    ss << txTmp << nHashType;\n    return Hash(ss.begin(), ss.end());\n}"
  },
  {
    "function_name": "EvalScript",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "323-1125",
    "snippet": "bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);",
      "static const valtype vchFalse(0);",
      "static const valtype vchTrue(1, 1);",
      "static const CBigNum bnZero(0);",
      "static const CBigNum bnOne(1);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfExec.empty",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "altstack.size",
          "args": [],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "popstack",
          "args": [
            "stack"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "popstack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "90-95",
          "snippet": "static inline void popstack(vector<valtype>& stack)\n{\n    if (stack.empty())\n        throw runtime_error(\"popstack() : stack empty\");\n    stack.pop_back();\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic inline void popstack(vector<valtype>& stack)\n{\n    if (stack.empty())\n        throw runtime_error(\"popstack() : stack empty\");\n    stack.pop_back();\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "fSuccess ? vchTrue : vchFalse"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CheckSig",
          "args": [
            "vchSig",
            "vchPubKey",
            "scriptCode",
            "txTo",
            "nIn",
            "nHashType"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "CheckSig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "1254-1282",
          "snippet": "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n              const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    static CSignatureCache signatureCache;\n\n    // Hash type is one byte tacked on to the end of the signature\n    if (vchSig.empty())\n        return false;\n    if (nHashType == 0)\n        nHashType = vchSig.back();\n    else if (nHashType != vchSig.back())\n        return false;\n    vchSig.pop_back();\n\n    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n\n    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n        return true;\n\n    CKey key;\n    if (!key.SetPubKey(vchPubKey))\n        return false;\n\n    if (!key.Verify(sighash, vchSig))\n        return false;\n\n    signatureCache.Set(sighash, vchSig, vchPubKey);\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,\n              const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    static CSignatureCache signatureCache;\n\n    // Hash type is one byte tacked on to the end of the signature\n    if (vchSig.empty())\n        return false;\n    if (nHashType == 0)\n        nHashType = vchSig.back();\n    else if (nHashType != vchSig.back())\n        return false;\n    vchSig.pop_back();\n\n    uint256 sighash = SignatureHash(scriptCode, txTo, nIn, nHashType);\n\n    if (signatureCache.Get(sighash, vchSig, vchPubKey))\n        return true;\n\n    CKey key;\n    if (!key.SetPubKey(vchPubKey))\n        return false;\n\n    if (!key.Verify(sighash, vchSig))\n        return false;\n\n    signatureCache.Set(sighash, vchSig, vchPubKey);\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCanonicalPubKey",
          "args": [
            "vchPubKey"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "IsCanonicalPubKey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "255-268",
          "snippet": "static bool IsCanonicalPubKey(const valtype &vchPubKey) {\n    if (vchPubKey.size() < 33)\n        return error(\"Non-canonical public key: too short\");\n    if (vchPubKey[0] == 0x04) {\n        if (vchPubKey.size() != 65)\n            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n        if (vchPubKey.size() != 33)\n            return error(\"Non-canonical public key: invalid length for compressed key\");\n    } else {\n        return error(\"Non-canonical public key: compressed nor uncompressed\");\n    }\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic bool IsCanonicalPubKey(const valtype &vchPubKey) {\n    if (vchPubKey.size() < 33)\n        return error(\"Non-canonical public key: too short\");\n    if (vchPubKey[0] == 0x04) {\n        if (vchPubKey.size() != 65)\n            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n        if (vchPubKey.size() != 33)\n            return error(\"Non-canonical public key: invalid length for compressed key\");\n    } else {\n        return error(\"Non-canonical public key: compressed nor uncompressed\");\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IsCanonicalSignature",
          "args": [
            "vchSig"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "IsCanonicalSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "270-321",
          "snippet": "static bool IsCanonicalSignature(const valtype &vchSig) {\n    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n    // Where R and S are not negative (their first byte has its highest bit not set), and not\n    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n    // in which case a single 0 byte is necessary and even required).\n    if (vchSig.size() < 9)\n        return error(\"Non-canonical signature: too short\");\n    if (vchSig.size() > 73)\n        return error(\"Non-canonical signature: too long\");\n    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n        return error(\"Non-canonical signature: unknown hashtype byte\");\n    if (vchSig[0] != 0x30)\n        return error(\"Non-canonical signature: wrong type\");\n    if (vchSig[1] != vchSig.size()-3)\n        return error(\"Non-canonical signature: wrong length marker\");\n    unsigned int nLenR = vchSig[3];\n    if (5 + nLenR >= vchSig.size())\n        return error(\"Non-canonical signature: S length misplaced\");\n    unsigned int nLenS = vchSig[5+nLenR];\n    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n        return error(\"Non-canonical signature: R+S length mismatch\");\n\n    const unsigned char *R = &vchSig[4];\n    if (R[-2] != 0x02)\n        return error(\"Non-canonical signature: R value type mismatch\");\n    if (nLenR == 0)\n        return error(\"Non-canonical signature: R length is zero\");\n    if (R[0] & 0x80)\n        return error(\"Non-canonical signature: R value negative\");\n    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n        return error(\"Non-canonical signature: R value excessively padded\");\n\n    const unsigned char *S = &vchSig[6+nLenR];\n    if (S[-2] != 0x02)\n        return error(\"Non-canonical signature: S value type mismatch\");\n    if (nLenS == 0)\n        return error(\"Non-canonical signature: S length is zero\");\n    if (S[0] & 0x80)\n        return error(\"Non-canonical signature: S value negative\");\n    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n        return error(\"Non-canonical signature: S value excessively padded\");\n\n    // If the above rules hold, and the S data is 33 bytes (or more), then\n    // the S value is above 2^255, which isn't necessary (its negative\n    // modulo the order of the curve could have been used).\n    if (nLenS > 32)\n        return error(\"Non-canonical signature: S value is unnecessarily high\");\n\n    return true;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nstatic bool IsCanonicalSignature(const valtype &vchSig) {\n    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n    // Where R and S are not negative (their first byte has its highest bit not set), and not\n    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n    // in which case a single 0 byte is necessary and even required).\n    if (vchSig.size() < 9)\n        return error(\"Non-canonical signature: too short\");\n    if (vchSig.size() > 73)\n        return error(\"Non-canonical signature: too long\");\n    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n        return error(\"Non-canonical signature: unknown hashtype byte\");\n    if (vchSig[0] != 0x30)\n        return error(\"Non-canonical signature: wrong type\");\n    if (vchSig[1] != vchSig.size()-3)\n        return error(\"Non-canonical signature: wrong length marker\");\n    unsigned int nLenR = vchSig[3];\n    if (5 + nLenR >= vchSig.size())\n        return error(\"Non-canonical signature: S length misplaced\");\n    unsigned int nLenS = vchSig[5+nLenR];\n    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n        return error(\"Non-canonical signature: R+S length mismatch\");\n\n    const unsigned char *R = &vchSig[4];\n    if (R[-2] != 0x02)\n        return error(\"Non-canonical signature: R value type mismatch\");\n    if (nLenR == 0)\n        return error(\"Non-canonical signature: R length is zero\");\n    if (R[0] & 0x80)\n        return error(\"Non-canonical signature: R value negative\");\n    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n        return error(\"Non-canonical signature: R value excessively padded\");\n\n    const unsigned char *S = &vchSig[6+nLenR];\n    if (S[-2] != 0x02)\n        return error(\"Non-canonical signature: S value type mismatch\");\n    if (nLenS == 0)\n        return error(\"Non-canonical signature: S length is zero\");\n    if (S[0] & 0x80)\n        return error(\"Non-canonical signature: S value negative\");\n    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n        return error(\"Non-canonical signature: S value excessively padded\");\n\n    // If the above rules hold, and the S data is 33 bytes (or more), then\n    // the S value is above 2^255, which isn't necessary (its negative\n    // modulo the order of the curve could have been used).\n    if (nLenS > 32)\n        return error(\"Non-canonical signature: S value is unnecessarily high\");\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-ikey"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-isig"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scriptCode.FindAndDelete",
          "args": [
            "CScript(vchSig)"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "FindAndDelete",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "487-504",
          "snippet": "int FindAndDelete(const CScript& b)\n    {\n        int nFound = 0;\n        if (b.empty())\n            return nFound;\n        iterator pc = begin();\n        opcodetype opcode;\n        do\n        {\n            while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n            {\n                erase(pc, pc + b.size());\n                ++nFound;\n            }\n        }\n        while (GetOp(pc, opcode));\n        return nFound;\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  int FindAndDelete(const CScript& b)\n      {\n          int nFound = 0;\n          if (b.empty())\n              return nFound;\n          iterator pc = begin();\n          opcodetype opcode;\n          do\n          {\n              while (end() - pc >= (long)b.size() && memcmp(&pc[0], &b[0], b.size()) == 0)\n              {\n                  erase(pc, pc + b.size());\n                  ++nFound;\n              }\n          }\n          while (GetOp(pc, opcode));\n          return nFound;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CScript",
          "args": [
            "vchSig"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "SetDestination",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "2011-2014",
          "snippet": "void CScript::SetDestination(const CTxDestination& dest)\n{\n    boost::apply_visitor(CScriptVisitor(this), dest);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nCScript {\n  void CScript::SetDestination(const CTxDestination& dest)\n  {\n      boost::apply_visitor(CScriptVisitor(this), dest);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-isig-k"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CastToBigNum",
          "args": [],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CastToBigNum",
          "args": [
            "stacktop(-i)"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "CastToBigNum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "33-39",
          "snippet": "CBigNum CastToBigNum(const valtype& vch)\n{\n    if (vch.size() > nMaxNumSize)\n        throw runtime_error(\"CastToBigNum() : overflow\");\n    // Get rid of extra leading zeros\n    return CBigNum(CBigNum(vch).getvch());\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const size_t nMaxNumSize = 4;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic const size_t nMaxNumSize = 4;\n\nCBigNum CastToBigNum(const valtype& vch)\n{\n    if (vch.size() > nMaxNumSize)\n        throw runtime_error(\"CastToBigNum() : overflow\");\n    // Get rid of extra leading zeros\n    return CBigNum(CBigNum(vch).getvch());\n}"
        }
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-i"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CastToBigNum",
          "args": [],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-i"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "fSuccess ? vchTrue : vchFalse"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vchHash"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vchHash[0]",
            "&hash",
            "sizeof(hash)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Hash",
          "args": [
            "vch.begin()",
            "vch.end()"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "Hash",
          "container": "CBloomFilter",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bloom.cpp",
          "lines": "34-38",
          "snippet": "inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n{\n    // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n    return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include \"script.h\"",
            "#include \"main.h\"",
            "#include \"bloom.h\"",
            "#include <stdlib.h>",
            "#include <math.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include \"script.h\"\n#include \"main.h\"\n#include \"bloom.h\"\n#include <stdlib.h>\n#include <math.h>\n\nCBloomFilter {\n  inline unsigned int CBloomFilter::Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const\n  {\n      // 0xFBA4C795 chosen as it guarantees a reasonable bit difference between nHashNum values.\n      return MurmurHash3(nHashNum * 0xFBA4C795 + nTweak, vDataToHash) % (vData.size() * 8);\n  }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vch.end",
          "args": [],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "end",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "30-30",
          "snippet": "const_iterator end() const { return map.end(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator end() const { return map.end(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vch.begin",
          "args": [],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "begin",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "29-29",
          "snippet": "const_iterator begin() const { return map.begin(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  const_iterator begin() const { return map.begin(); }\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&vchHash[0]",
            "&hash160",
            "sizeof(hash160)"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Hash160",
          "args": [
            "vch"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "Hash160",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/util.h",
          "lines": "554-561",
          "snippet": "inline uint160 Hash160(const std::vector<unsigned char>& vch)\n{\n    uint256 hash1;\n    SHA256(&vch[0], vch.size(), (unsigned char*)&hash1);\n    uint160 hash2;\n    RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n    return hash2;\n}",
          "includes": [
            "#include <inttypes.h>",
            "#include <stdint.h>",
            "#include \"netbase.h\" // for AddTimeData",
            "#include <openssl/ripemd.h>",
            "#include <openssl/sha.h>",
            "#include <boost/date_time/posix_time/posix_time_types.hpp>",
            "#include <boost/date_time/gregorian/gregorian_types.hpp>",
            "#include <boost/filesystem/path.hpp>",
            "#include <boost/filesystem.hpp>",
            "#include <boost/thread.hpp>",
            "#include <string>",
            "#include <vector>",
            "#include <map>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/types.h>",
            "#include \"uint256.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <inttypes.h>\n#include <stdint.h>\n#include \"netbase.h\" // for AddTimeData\n#include <openssl/ripemd.h>\n#include <openssl/sha.h>\n#include <boost/date_time/posix_time/posix_time_types.hpp>\n#include <boost/date_time/gregorian/gregorian_types.hpp>\n#include <boost/filesystem/path.hpp>\n#include <boost/filesystem.hpp>\n#include <boost/thread.hpp>\n#include <string>\n#include <vector>\n#include <map>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include \"uint256.h\"\n\ninline uint160 Hash160(const std::vector<unsigned char>& vch)\n{\n    uint256 hash1;\n    SHA256(&vch[0], vch.size(), (unsigned char*)&hash1);\n    uint160 hash2;\n    RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n    return hash2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHA256",
          "args": [
            "&vch[0]",
            "vch.size()",
            "&vchHash[0]"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "HMAC_SHA256_Update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/pbkdf2.cpp",
          "lines": "65-71",
          "snippet": "void\nHMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n\n    /* Feed data to the inner SHA256 operation. */\n    SHA256_Update(&ctx->ictx, in, len);\n}",
          "includes": [
            "#include \"pbkdf2.h\"",
            "#include <string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pbkdf2.h\"\n#include <string.h>\n\nvoid\nHMAC_SHA256_Update(HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n\n    /* Feed data to the inner SHA256 operation. */\n    SHA256_Update(&ctx->ictx, in, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SHA1",
          "args": [
            "&vch[0]",
            "vch.size()",
            "&vchHash[0]"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RIPEMD160",
          "args": [
            "&vch[0]",
            "vch.size()",
            "&vchHash[0]"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "fValue ? vchTrue : vchFalse"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-3"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CastToBool",
          "args": [
            "stacktop(-1)"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "CastToBool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "41-54",
          "snippet": "bool CastToBool(const valtype& vch)\n{\n    for (unsigned int i = 0; i < vch.size(); i++)\n    {\n        if (vch[i] != 0)\n        {\n            // Can be negative zero\n            if (i == vch.size()-1 && vch[i] == 0x80)\n                return false;\n            return true;\n        }\n    }\n    return false;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CastToBool(const valtype& vch)\n{\n    for (unsigned int i = 0; i < vch.size(); i++)\n    {\n        if (vch[i] != 0)\n        {\n            // Can be negative zero\n            if (i == vch.size()-1 && vch[i] == 0x80)\n                return false;\n            return true;\n        }\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "bn.getvch()"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bn.getvch",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "getvch",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "309-319",
          "snippet": "std::vector<unsigned char> getvch() const\n    {\n        unsigned int nSize = BN_bn2mpi(this, NULL);\n        if (nSize <= 4)\n            return std::vector<unsigned char>();\n        std::vector<unsigned char> vch(nSize);\n        BN_bn2mpi(this, &vch[0]);\n        vch.erase(vch.begin(), vch.begin() + 4);\n        reverse(vch.begin(), vch.end());\n        return vch;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  std::vector<unsigned char> getvch() const\n      {\n          unsigned int nSize = BN_bn2mpi(this, NULL);\n          if (nSize <= 4)\n              return std::vector<unsigned char>();\n          std::vector<unsigned char> vch(nSize);\n          BN_bn2mpi(this, &vch[0]);\n          vch.erase(vch.begin(), vch.begin() + 4);\n          reverse(vch.begin(), vch.end());\n          return vch;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!\"invalid opcode\""
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bn2.getulong",
          "args": [],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "getulong",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "146-149",
          "snippet": "unsigned long getulong() const\n    {\n        return BN_get_word(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  unsigned long getulong() const\n      {\n          return BN_get_word(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "2048"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "BN_mod",
          "args": [
            "&bn",
            "&bn1",
            "&bn2",
            "pctx"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_div",
          "args": [
            "&bn",
            "NULL",
            "&bn1",
            "&bn2",
            "pctx"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BN_mul",
          "args": [
            "&bn",
            "&bn1",
            "&bn2",
            "pctx"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "bn.getvch()"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!\"invalid opcode\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "fEqual ? vchTrue : vchFalse"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MakeSameSize",
          "args": [
            "vch1",
            "vch2"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "MakeSameSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
          "lines": "63-80",
          "snippet": "void MakeSameSize(valtype& vch1, valtype& vch2)\n{\n    // Lengthen the shorter one\n    if (vch1.size() < vch2.size())\n        // PATCH:\n        // +unsigned char msb = vch1[vch1.size()-1];\n        // +vch1[vch1.size()-1] &= 0x7f;\n        //  vch1.resize(vch2.size(), 0);\n        // +vch1[vch1.size()-1] = msb;\n        vch1.resize(vch2.size(), 0);\n    if (vch2.size() < vch1.size())\n        // PATCH:\n        // +unsigned char msb = vch2[vch2.size()-1];\n        // +vch2[vch2.size()-1] &= 0x7f;\n        //  vch2.resize(vch1.size(), 0);\n        // +vch2[vch2.size()-1] = msb;\n        vch2.resize(vch1.size(), 0);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"sync.h\"",
            "#include \"main.h\"",
            "#include \"key.h\"",
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include \"script.h\"",
            "#include <boost/tuple/tuple_comparison.hpp>",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/foreach.hpp>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nvoid MakeSameSize(valtype& vch1, valtype& vch2)\n{\n    // Lengthen the shorter one\n    if (vch1.size() < vch2.size())\n        // PATCH:\n        // +unsigned char msb = vch1[vch1.size()-1];\n        // +vch1[vch1.size()-1] &= 0x7f;\n        //  vch1.resize(vch2.size(), 0);\n        // +vch1[vch1.size()-1] = msb;\n        vch1.resize(vch2.size(), 0);\n    if (vch2.size() < vch1.size())\n        // PATCH:\n        // +unsigned char msb = vch2[vch2.size()-1];\n        // +vch2[vch2.size()-1] &= 0x7f;\n        //  vch2.resize(vch1.size(), 0);\n        // +vch2[vch2.size()-1] = msb;\n        vch2.resize(vch1.size(), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "bn.getvch()"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vch.erase",
          "args": [
            "vch.begin()",
            "vch.end() - nSize"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "870-888",
          "snippet": "iterator erase(iterator first, iterator last)\n    {\n        if (first == vch.begin() + nReadPos)\n        {\n            // special case for erasing from the front\n            if (last == vch.end())\n            {\n                nReadPos = 0;\n                return vch.erase(vch.begin(), vch.end());\n            }\n            else\n            {\n                nReadPos = (last - vch.begin());\n                return last;\n            }\n        }\n        else\n            return vch.erase(first, last);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  iterator erase(iterator first, iterator last)\n      {\n          if (first == vch.begin() + nReadPos)\n          {\n              // special case for erasing from the front\n              if (last == vch.end())\n              {\n                  nReadPos = 0;\n                  return vch.erase(vch.begin(), vch.end());\n              }\n              else\n              {\n                  nReadPos = (last - vch.begin());\n                  return last;\n              }\n          }\n          else\n              return vch.erase(first, last);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CastToBigNum",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CastToBigNum",
          "args": [],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CastToBigNum",
          "args": [],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-3"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vch1.insert",
          "args": [
            "vch1.end()",
            "vch2.begin()",
            "vch2.end()"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "insert",
          "container": "CDataStream",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/serialize.h",
          "lines": "839-850",
          "snippet": "void insert(iterator it, const char* first, const char* last)\n    {\n        assert(last - first >= 0);\n        if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n        {\n            // special case for inserting at the front when there's room\n            nReadPos -= (last - first);\n            memcpy(&vch[nReadPos], &first[0], last - first);\n        }\n        else\n            vch.insert(it, first, last);\n    }",
          "includes": [
            "#include \"version.h\"",
            "#include \"allocators.h\"",
            "#include <boost/tuple/tuple.hpp>",
            "#include <boost/type_traits/is_fundamental.hpp>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <stdint.h>",
            "#include <limits>",
            "#include <cassert>",
            "#include <set>",
            "#include <map>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"version.h\"\n#include \"allocators.h\"\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/is_fundamental.hpp>\n#include <cstdio>\n#include <cstring>\n#include <stdint.h>\n#include <limits>\n#include <cassert>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n\nCDataStream {\n  void insert(iterator it, const char* first, const char* last)\n      {\n          assert(last - first >= 0);\n          if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n          {\n              // special case for inserting at the front when there's room\n              nReadPos -= (last - first);\n              memcpy(&vch[nReadPos], &first[0], last - first);\n          }\n          else\n              vch.insert(it, first, last);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.insert",
          "args": [
            "stack.end()-2",
            "vch"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "stacktop(-2)",
            "stacktop(-1)"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "stacktop(-2)",
            "stacktop(-1)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "stacktop(-3)",
            "stacktop(-2)"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-3"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.erase",
          "args": [
            "stack.end()-n-1"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "erase",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "49-65",
          "snippet": "void erase(const key_type& k)\n    {\n        iterator itTarget = map.find(k);\n        if (itTarget == map.end())\n            return;\n        std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n        for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n            if (it->second == itTarget)\n            {\n                rmap.erase(it);\n                map.erase(itTarget);\n                return;\n            }\n        // Shouldn't ever get here\n        assert(0); //TODO remove me\n        map.erase(itTarget);\n    }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  void erase(const key_type& k)\n      {\n          iterator itTarget = map.find(k);\n          if (itTarget == map.end())\n              return;\n          std::pair<rmap_iterator, rmap_iterator> itPair = rmap.equal_range(itTarget->second);\n          for (rmap_iterator it = itPair.first; it != itPair.second; ++it)\n              if (it->second == itTarget)\n              {\n                  rmap.erase(it);\n                  map.erase(itTarget);\n                  return;\n              }\n          // Shouldn't ever get here\n          assert(0); //TODO remove me\n          map.erase(itTarget);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-n-1"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CastToBigNum",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "bn.getvch()"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "stacktop(-3)",
            "stacktop(-1)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-3"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "stacktop(-4)",
            "stacktop(-2)"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-4"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch2"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch1"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-5"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-6"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch2"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch1"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-3"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-4"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch3"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch2"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch1"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-3"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch2"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vch1"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-2"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "altstacktop(-1)"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "altstacktop",
          "args": [
            "-1"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "altstack.push_back",
          "args": [
            "stacktop(-1)"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfExec.pop_back",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfExec.back",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfExec.back",
          "args": [],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfExec.push_back",
          "args": [
            "fValue"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stacktop",
          "args": [
            "-1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "bn.getvch()"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.push_back",
          "args": [
            "vchPushValue"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "script.GetOp",
          "args": [
            "pc",
            "opcode",
            "vchPushValue"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "GetOp",
          "container": "CScript",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.h",
          "lines": "408-411",
          "snippet": "bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n    {\n        return GetOp2(pc, opcodeRet, &vchRet);\n    }",
          "includes": [
            "#include \"bignum.h\"",
            "#include \"keystore.h\"",
            "#include <boost/variant.hpp>",
            "#include <boost/foreach.hpp>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"bignum.h\"\n#include \"keystore.h\"\n#include <boost/variant.hpp>\n#include <boost/foreach.hpp>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nCScript {\n  bool GetOp(const_iterator& pc, opcodetype& opcodeRet, std::vector<unsigned char>& vchRet) const\n      {\n          return GetOp2(pc, opcodeRet, &vchRet);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "count",
          "args": [
            "vfExec.begin()",
            "vfExec.end()",
            "false"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "GetAccountBalance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/rpcwallet.cpp",
          "lines": "528-551",
          "snippet": "int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth)\n{\n    int64_t nBalance = 0;\n\n    // Tally wallet transactions\n    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n    {\n        const CWalletTx& wtx = (*it).second;\n        if (!wtx.IsFinal() || wtx.GetDepthInMainChain() < 0)\n            continue;\n\n        int64_t nReceived, nSent, nFee;\n        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee);\n\n        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth && wtx.GetBlocksToMaturity() == 0)\n            nBalance += nReceived;\n        nBalance -= nSent + nFee;\n    }\n\n    // Tally internal accounting entries\n    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n\n    return nBalance;\n}",
          "includes": [
            "#include \"base58.h\"",
            "#include \"ntp.h\"",
            "#include \"util.h\"",
            "#include \"init.h\"",
            "#include \"bitcoinrpc.h\"",
            "#include \"walletdb.h\"",
            "#include \"wallet.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"base58.h\"\n#include \"ntp.h\"\n#include \"util.h\"\n#include \"init.h\"\n#include \"bitcoinrpc.h\"\n#include \"walletdb.h\"\n#include \"wallet.h\"\n\nint64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth)\n{\n    int64_t nBalance = 0;\n\n    // Tally wallet transactions\n    for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n    {\n        const CWalletTx& wtx = (*it).second;\n        if (!wtx.IsFinal() || wtx.GetDepthInMainChain() < 0)\n            continue;\n\n        int64_t nReceived, nSent, nFee;\n        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee);\n\n        if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth && wtx.GetBlocksToMaturity() == 0)\n            nBalance += nReceived;\n        nBalance -= nSent + nFee;\n    }\n\n    // Tally internal accounting entries\n    nBalance += walletdb.GetAccountCreditDebit(strAccount);\n\n    return nBalance;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\nstatic const valtype vchFalse(0);\nstatic const valtype vchTrue(1, 1);\nstatic const CBigNum bnZero(0);\nstatic const CBigNum bnOne(1);\n\nbool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, const CTransaction& txTo, unsigned int nIn, int nHashType)\n{\n    CAutoBN_CTX pctx;\n    CScript::const_iterator pc = script.begin();\n    CScript::const_iterator pend = script.end();\n    CScript::const_iterator pbegincodehash = script.begin();\n    opcodetype opcode;\n    valtype vchPushValue;\n    vector<bool> vfExec;\n    vector<valtype> altstack;\n    if (script.size() > 10000)\n        return false;\n    int nOpCount = 0;\n\n\n    try\n    {\n        while (pc < pend)\n        {\n            bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n\n            //\n            // Read instruction\n            //\n            if (!script.GetOp(pc, opcode, vchPushValue))\n                return false;\n            if (vchPushValue.size() > 520)\n                return false;\n            if (opcode > OP_16 && ++nOpCount > 201)\n                return false;\n\n            if (opcode == OP_CAT ||\n                opcode == OP_SUBSTR ||\n                opcode == OP_LEFT ||\n                opcode == OP_RIGHT ||\n                opcode == OP_INVERT ||\n                opcode == OP_AND ||\n                opcode == OP_OR ||\n                opcode == OP_XOR ||\n                opcode == OP_2MUL ||\n                opcode == OP_2DIV ||\n                opcode == OP_MUL ||\n                opcode == OP_DIV ||\n                opcode == OP_MOD ||\n                opcode == OP_LSHIFT ||\n                opcode == OP_RSHIFT)\n                return false;\n\n            if (fExec && 0 <= opcode && opcode <= OP_PUSHDATA4)\n                stack.push_back(vchPushValue);\n            else if (fExec || (OP_IF <= opcode && opcode <= OP_ENDIF))\n            switch (opcode)\n            {\n                //\n                // Push value\n                //\n                case OP_1NEGATE:\n                case OP_1:\n                case OP_2:\n                case OP_3:\n                case OP_4:\n                case OP_5:\n                case OP_6:\n                case OP_7:\n                case OP_8:\n                case OP_9:\n                case OP_10:\n                case OP_11:\n                case OP_12:\n                case OP_13:\n                case OP_14:\n                case OP_15:\n                case OP_16:\n                {\n                    // ( -- value)\n                    CBigNum bn((int)opcode - (int)(OP_1 - 1));\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Control\n                //\n                case OP_NOP:\n                case OP_NOP1: case OP_NOP2: case OP_NOP3: case OP_NOP4: case OP_NOP5:\n                case OP_NOP6: case OP_NOP7: case OP_NOP8: case OP_NOP9: case OP_NOP10:\n                break;\n\n                case OP_IF:\n                case OP_NOTIF:\n                {\n                    // <expression> if [statements] [else [statements]] endif\n                    bool fValue = false;\n                    if (fExec)\n                    {\n                        if (stack.size() < 1)\n                            return false;\n                        valtype& vch = stacktop(-1);\n                        fValue = CastToBool(vch);\n                        if (opcode == OP_NOTIF)\n                            fValue = !fValue;\n                        popstack(stack);\n                    }\n                    vfExec.push_back(fValue);\n                }\n                break;\n\n                case OP_ELSE:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.back() = !vfExec.back();\n                }\n                break;\n\n                case OP_ENDIF:\n                {\n                    if (vfExec.empty())\n                        return false;\n                    vfExec.pop_back();\n                }\n                break;\n\n                case OP_VERIFY:\n                {\n                    // (true -- ) or\n                    // (false -- false) and return\n                    if (stack.size() < 1)\n                        return false;\n                    bool fValue = CastToBool(stacktop(-1));\n                    if (fValue)\n                        popstack(stack);\n                    else\n                        return false;\n                }\n                break;\n\n                case OP_RETURN:\n                {\n                    return false;\n                }\n                break;\n\n\n                //\n                // Stack ops\n                //\n                case OP_TOALTSTACK:\n                {\n                    if (stack.size() < 1)\n                        return false;\n                    altstack.push_back(stacktop(-1));\n                    popstack(stack);\n                }\n                break;\n\n                case OP_FROMALTSTACK:\n                {\n                    if (altstack.size() < 1)\n                        return false;\n                    stack.push_back(altstacktop(-1));\n                    popstack(altstack);\n                }\n                break;\n\n                case OP_2DROP:\n                {\n                    // (x1 x2 -- )\n                    if (stack.size() < 2)\n                        return false;\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_2DUP:\n                {\n                    // (x1 x2 -- x1 x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch1 = stacktop(-2);\n                    valtype vch2 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_3DUP:\n                {\n                    // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype vch1 = stacktop(-3);\n                    valtype vch2 = stacktop(-2);\n                    valtype vch3 = stacktop(-1);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                    stack.push_back(vch3);\n                }\n                break;\n\n                case OP_2OVER:\n                {\n                    // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    valtype vch1 = stacktop(-4);\n                    valtype vch2 = stacktop(-3);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2ROT:\n                {\n                    // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n                    if (stack.size() < 6)\n                        return false;\n                    valtype vch1 = stacktop(-6);\n                    valtype vch2 = stacktop(-5);\n                    stack.erase(stack.end()-6, stack.end()-4);\n                    stack.push_back(vch1);\n                    stack.push_back(vch2);\n                }\n                break;\n\n                case OP_2SWAP:\n                {\n                    // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n                    if (stack.size() < 4)\n                        return false;\n                    swap(stacktop(-4), stacktop(-2));\n                    swap(stacktop(-3), stacktop(-1));\n                }\n                break;\n\n                case OP_IFDUP:\n                {\n                    // (x - 0 | x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    if (CastToBool(vch))\n                        stack.push_back(vch);\n                }\n                break;\n\n                case OP_DEPTH:\n                {\n                    // -- stacksize\n                    CBigNum bn(stack.size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_DROP:\n                {\n                    // (x -- )\n                    if (stack.size() < 1)\n                        return false;\n                    popstack(stack);\n                }\n                break;\n\n                case OP_DUP:\n                {\n                    // (x -- x x)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_NIP:\n                {\n                    // (x1 x2 -- x2)\n                    if (stack.size() < 2)\n                        return false;\n                    stack.erase(stack.end() - 2);\n                }\n                break;\n\n                case OP_OVER:\n                {\n                    // (x1 x2 -- x1 x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-2);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_PICK:\n                case OP_ROLL:\n                {\n                    // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n                    // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n                    if (stack.size() < 2)\n                        return false;\n                    int n = CastToBigNum(stacktop(-1)).getint();\n                    popstack(stack);\n                    if (n < 0 || n >= (int)stack.size())\n                        return false;\n                    valtype vch = stacktop(-n-1);\n                    if (opcode == OP_ROLL)\n                        stack.erase(stack.end()-n-1);\n                    stack.push_back(vch);\n                }\n                break;\n\n                case OP_ROT:\n                {\n                    // (x1 x2 x3 -- x2 x3 x1)\n                    //  x2 x1 x3  after first swap\n                    //  x2 x3 x1  after second swap\n                    if (stack.size() < 3)\n                        return false;\n                    swap(stacktop(-3), stacktop(-2));\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_SWAP:\n                {\n                    // (x1 x2 -- x2 x1)\n                    if (stack.size() < 2)\n                        return false;\n                    swap(stacktop(-2), stacktop(-1));\n                }\n                break;\n\n                case OP_TUCK:\n                {\n                    // (x1 x2 -- x2 x1 x2)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype vch = stacktop(-1);\n                    stack.insert(stack.end()-2, vch);\n                }\n                break;\n\n\n                //\n                // Splice ops\n                //\n                case OP_CAT:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    vch1.insert(vch1.end(), vch2.begin(), vch2.end());\n                    popstack(stack);\n                    if (stacktop(-1).size() > 520)\n                        return false;\n                }\n                break;\n\n                case OP_SUBSTR:\n                {\n                    // (in begin size -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    valtype& vch = stacktop(-3);\n                    int nBegin = CastToBigNum(stacktop(-2)).getint();\n                    int nEnd = nBegin + CastToBigNum(stacktop(-1)).getint();\n                    if (nBegin < 0 || nEnd < nBegin)\n                        return false;\n                    if (nBegin > (int)vch.size())\n                        nBegin = vch.size();\n                    if (nEnd > (int)vch.size())\n                        nEnd = vch.size();\n                    vch.erase(vch.begin() + nEnd, vch.end());\n                    vch.erase(vch.begin(), vch.begin() + nBegin);\n                    popstack(stack);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_LEFT:\n                case OP_RIGHT:\n                {\n                    // (in size -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch = stacktop(-2);\n                    int nSize = CastToBigNum(stacktop(-1)).getint();\n                    if (nSize < 0)\n                        return false;\n                    if (nSize > (int)vch.size())\n                        nSize = vch.size();\n                    if (opcode == OP_LEFT)\n                        vch.erase(vch.begin() + nSize, vch.end());\n                    else\n                        vch.erase(vch.begin(), vch.end() - nSize);\n                    popstack(stack);\n                }\n                break;\n\n                case OP_SIZE:\n                {\n                    // (in -- in size)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn(stacktop(-1).size());\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n\n                //\n                // Bitwise logic\n                //\n                case OP_INVERT:\n                {\n                    // (in - out)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    for (unsigned int i = 0; i < vch.size(); i++)\n                        vch[i] = ~vch[i];\n                }\n                break;\n\n                //\n                // WARNING: These disabled opcodes exhibit unexpected behavior\n                // when used on signed integers due to a bug in MakeSameSize()\n                // [see definition of MakeSameSize() above].\n                //\n                case OP_AND:\n                case OP_OR:\n                case OP_XOR:\n                {\n                    // (x1 x2 - out)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    MakeSameSize(vch1, vch2); // <-- NOT SAFE FOR SIGNED VALUES\n                    if (opcode == OP_AND)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] &= vch2[i];\n                    }\n                    else if (opcode == OP_OR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] |= vch2[i];\n                    }\n                    else if (opcode == OP_XOR)\n                    {\n                        for (unsigned int i = 0; i < vch1.size(); i++)\n                            vch1[i] ^= vch2[i];\n                    }\n                    popstack(stack);\n                }\n                break;\n\n                case OP_EQUAL:\n                case OP_EQUALVERIFY:\n                //case OP_NOTEQUAL: // use OP_NUMNOTEQUAL\n                {\n                    // (x1 x2 - bool)\n                    if (stack.size() < 2)\n                        return false;\n                    valtype& vch1 = stacktop(-2);\n                    valtype& vch2 = stacktop(-1);\n                    bool fEqual = (vch1 == vch2);\n                    // OP_NOTEQUAL is disabled because it would be too easy to say\n                    // something like n != 1 and have some wiseguy pass in 1 with extra\n                    // zero bytes after it (numerically, 0x01 == 0x0001 == 0x000001)\n                    //if (opcode == OP_NOTEQUAL)\n                    //    fEqual = !fEqual;\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fEqual ? vchTrue : vchFalse);\n                    if (opcode == OP_EQUALVERIFY)\n                    {\n                        if (fEqual)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n\n                //\n                // Numeric\n                //\n                case OP_1ADD:\n                case OP_1SUB:\n                case OP_2MUL:\n                case OP_2DIV:\n                case OP_NEGATE:\n                case OP_ABS:\n                case OP_NOT:\n                case OP_0NOTEQUAL:\n                {\n                    // (in -- out)\n                    if (stack.size() < 1)\n                        return false;\n                    CBigNum bn = CastToBigNum(stacktop(-1));\n                    switch (opcode)\n                    {\n                    case OP_1ADD:       bn += bnOne; break;\n                    case OP_1SUB:       bn -= bnOne; break;\n                    case OP_2MUL:       bn <<= 1; break;\n                    case OP_2DIV:       bn >>= 1; break;\n                    case OP_NEGATE:     bn = -bn; break;\n                    case OP_ABS:        if (bn < bnZero) bn = -bn; break;\n                    case OP_NOT:        bn = (bn == bnZero); break;\n                    case OP_0NOTEQUAL:  bn = (bn != bnZero); break;\n                    default:            assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n                }\n                break;\n\n                case OP_ADD:\n                case OP_SUB:\n                case OP_MUL:\n                case OP_DIV:\n                case OP_MOD:\n                case OP_LSHIFT:\n                case OP_RSHIFT:\n                case OP_BOOLAND:\n                case OP_BOOLOR:\n                case OP_NUMEQUAL:\n                case OP_NUMEQUALVERIFY:\n                case OP_NUMNOTEQUAL:\n                case OP_LESSTHAN:\n                case OP_GREATERTHAN:\n                case OP_LESSTHANOREQUAL:\n                case OP_GREATERTHANOREQUAL:\n                case OP_MIN:\n                case OP_MAX:\n                {\n                    // (x1 x2 -- out)\n                    if (stack.size() < 2)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-2));\n                    CBigNum bn2 = CastToBigNum(stacktop(-1));\n                    CBigNum bn;\n                    switch (opcode)\n                    {\n                    case OP_ADD:\n                        bn = bn1 + bn2;\n                        break;\n\n                    case OP_SUB:\n                        bn = bn1 - bn2;\n                        break;\n\n                    case OP_MUL:\n                        if (!BN_mul(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_DIV:\n                        if (!BN_div(&bn, NULL, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_MOD:\n                        if (!BN_mod(&bn, &bn1, &bn2, pctx))\n                            return false;\n                        break;\n\n                    case OP_LSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 << bn2.getulong();\n                        break;\n\n                    case OP_RSHIFT:\n                        if (bn2 < bnZero || bn2 > CBigNum(2048))\n                            return false;\n                        bn = bn1 >> bn2.getulong();\n                        break;\n\n                    case OP_BOOLAND:             bn = (bn1 != bnZero && bn2 != bnZero); break;\n                    case OP_BOOLOR:              bn = (bn1 != bnZero || bn2 != bnZero); break;\n                    case OP_NUMEQUAL:            bn = (bn1 == bn2); break;\n                    case OP_NUMEQUALVERIFY:      bn = (bn1 == bn2); break;\n                    case OP_NUMNOTEQUAL:         bn = (bn1 != bn2); break;\n                    case OP_LESSTHAN:            bn = (bn1 < bn2); break;\n                    case OP_GREATERTHAN:         bn = (bn1 > bn2); break;\n                    case OP_LESSTHANOREQUAL:     bn = (bn1 <= bn2); break;\n                    case OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n                    case OP_MIN:                 bn = (bn1 < bn2 ? bn1 : bn2); break;\n                    case OP_MAX:                 bn = (bn1 > bn2 ? bn1 : bn2); break;\n                    default:                     assert(!\"invalid opcode\"); break;\n                    }\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(bn.getvch());\n\n                    if (opcode == OP_NUMEQUALVERIFY)\n                    {\n                        if (CastToBool(stacktop(-1)))\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_WITHIN:\n                {\n                    // (x min max -- out)\n                    if (stack.size() < 3)\n                        return false;\n                    CBigNum bn1 = CastToBigNum(stacktop(-3));\n                    CBigNum bn2 = CastToBigNum(stacktop(-2));\n                    CBigNum bn3 = CastToBigNum(stacktop(-1));\n                    bool fValue = (bn2 <= bn1 && bn1 < bn3);\n                    popstack(stack);\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fValue ? vchTrue : vchFalse);\n                }\n                break;\n\n\n                //\n                // Crypto\n                //\n                case OP_RIPEMD160:\n                case OP_SHA1:\n                case OP_SHA256:\n                case OP_HASH160:\n                case OP_HASH256:\n                {\n                    // (in -- hash)\n                    if (stack.size() < 1)\n                        return false;\n                    valtype& vch = stacktop(-1);\n                    valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                    if (opcode == OP_RIPEMD160)\n                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA1)\n                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_SHA256)\n                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n                    else if (opcode == OP_HASH160)\n                    {\n                        uint160 hash160 = Hash160(vch);\n                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n                    }\n                    else if (opcode == OP_HASH256)\n                    {\n                        uint256 hash = Hash(vch.begin(), vch.end());\n                        memcpy(&vchHash[0], &hash, sizeof(hash));\n                    }\n                    popstack(stack);\n                    stack.push_back(vchHash);\n                }\n                break;\n\n                case OP_CODESEPARATOR:\n                {\n                    // Hash starts after the code separator\n                    pbegincodehash = pc;\n                }\n                break;\n\n                case OP_CHECKSIG:\n                case OP_CHECKSIGVERIFY:\n                {\n                    // (sig pubkey -- bool)\n                    if (stack.size() < 2)\n                        return false;\n\n                    valtype& vchSig    = stacktop(-2);\n                    valtype& vchPubKey = stacktop(-1);\n\n                    ////// debug print\n                    //PrintHex(vchSig.begin(), vchSig.end(), \"sig: %s\\n\");\n                    //PrintHex(vchPubKey.begin(), vchPubKey.end(), \"pubkey: %s\\n\");\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signature, since there's no way for a signature to sign itself\n                    scriptCode.FindAndDelete(CScript(vchSig));\n\n                    bool fSuccess = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                        CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                    popstack(stack);\n                    popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n                    if (opcode == OP_CHECKSIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                case OP_CHECKMULTISIG:\n                case OP_CHECKMULTISIGVERIFY:\n                {\n                    // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n                    int i = 1;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nKeysCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nKeysCount < 0 || nKeysCount > 20)\n                        return false;\n                    nOpCount += nKeysCount;\n                    if (nOpCount > 201)\n                        return false;\n                    int ikey = ++i;\n                    i += nKeysCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    int nSigsCount = CastToBigNum(stacktop(-i)).getint();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount)\n                        return false;\n                    int isig = ++i;\n                    i += nSigsCount;\n                    if ((int)stack.size() < i)\n                        return false;\n\n                    // Subset of script starting at the most recent codeseparator\n                    CScript scriptCode(pbegincodehash, pend);\n\n                    // Drop the signatures, since there's no way for a signature to sign itself\n                    for (int k = 0; k < nSigsCount; k++)\n                    {\n                        valtype& vchSig = stacktop(-isig-k);\n                        scriptCode.FindAndDelete(CScript(vchSig));\n                    }\n\n                    bool fSuccess = true;\n                    while (fSuccess && nSigsCount > 0)\n                    {\n                        valtype& vchSig    = stacktop(-isig);\n                        valtype& vchPubKey = stacktop(-ikey);\n\n                        // Check signature\n                        bool fOk = IsCanonicalSignature(vchSig) && IsCanonicalPubKey(vchPubKey) &&\n                            CheckSig(vchSig, vchPubKey, scriptCode, txTo, nIn, nHashType);\n\n                        if (fOk)\n                        {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n\n                        // If there are more signatures left than keys left,\n                        // then too many signatures have failed\n                        if (nSigsCount > nKeysCount)\n                            fSuccess = false;\n                    }\n\n                    while (i-- > 0)\n                        popstack(stack);\n                    stack.push_back(fSuccess ? vchTrue : vchFalse);\n\n                    if (opcode == OP_CHECKMULTISIGVERIFY)\n                    {\n                        if (fSuccess)\n                            popstack(stack);\n                        else\n                            return false;\n                    }\n                }\n                break;\n\n                default:\n                    return false;\n            }\n\n            // Size limits\n            if (stack.size() + altstack.size() > 1000)\n                return false;\n        }\n    }\n    catch (...)\n    {\n        return false;\n    }\n\n\n    if (!vfExec.empty())\n        return false;\n\n    return true;\n}"
  },
  {
    "function_name": "IsCanonicalSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "270-321",
    "snippet": "static bool IsCanonicalSignature(const valtype &vchSig) {\n    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n    // Where R and S are not negative (their first byte has its highest bit not set), and not\n    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n    // in which case a single 0 byte is necessary and even required).\n    if (vchSig.size() < 9)\n        return error(\"Non-canonical signature: too short\");\n    if (vchSig.size() > 73)\n        return error(\"Non-canonical signature: too long\");\n    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n        return error(\"Non-canonical signature: unknown hashtype byte\");\n    if (vchSig[0] != 0x30)\n        return error(\"Non-canonical signature: wrong type\");\n    if (vchSig[1] != vchSig.size()-3)\n        return error(\"Non-canonical signature: wrong length marker\");\n    unsigned int nLenR = vchSig[3];\n    if (5 + nLenR >= vchSig.size())\n        return error(\"Non-canonical signature: S length misplaced\");\n    unsigned int nLenS = vchSig[5+nLenR];\n    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n        return error(\"Non-canonical signature: R+S length mismatch\");\n\n    const unsigned char *R = &vchSig[4];\n    if (R[-2] != 0x02)\n        return error(\"Non-canonical signature: R value type mismatch\");\n    if (nLenR == 0)\n        return error(\"Non-canonical signature: R length is zero\");\n    if (R[0] & 0x80)\n        return error(\"Non-canonical signature: R value negative\");\n    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n        return error(\"Non-canonical signature: R value excessively padded\");\n\n    const unsigned char *S = &vchSig[6+nLenR];\n    if (S[-2] != 0x02)\n        return error(\"Non-canonical signature: S value type mismatch\");\n    if (nLenS == 0)\n        return error(\"Non-canonical signature: S length is zero\");\n    if (S[0] & 0x80)\n        return error(\"Non-canonical signature: S value negative\");\n    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n        return error(\"Non-canonical signature: S value excessively padded\");\n\n    // If the above rules hold, and the S data is 33 bytes (or more), then\n    // the S value is above 2^255, which isn't necessary (its negative\n    // modulo the order of the curve could have been used).\n    if (nLenS > 32)\n        return error(\"Non-canonical signature: S value is unnecessarily high\");\n\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Non-canonical signature: S value is unnecessarily high\""
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchSig.size",
          "args": [],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType);\n\nstatic bool IsCanonicalSignature(const valtype &vchSig) {\n    // See https://bitcointalk.org/index.php?topic=8392.msg127623#msg127623\n    // A canonical signature exists of: <30> <total len> <02> <len R> <R> <02> <len S> <S> <hashtype>\n    // Where R and S are not negative (their first byte has its highest bit not set), and not\n    // excessively padded (do not start with a 0 byte, unless an otherwise negative number follows,\n    // in which case a single 0 byte is necessary and even required).\n    if (vchSig.size() < 9)\n        return error(\"Non-canonical signature: too short\");\n    if (vchSig.size() > 73)\n        return error(\"Non-canonical signature: too long\");\n    unsigned char nHashType = vchSig[vchSig.size() - 1] & (~(SIGHASH_ANYONECANPAY));\n    if (nHashType < SIGHASH_ALL || nHashType > SIGHASH_SINGLE)\n        return error(\"Non-canonical signature: unknown hashtype byte\");\n    if (vchSig[0] != 0x30)\n        return error(\"Non-canonical signature: wrong type\");\n    if (vchSig[1] != vchSig.size()-3)\n        return error(\"Non-canonical signature: wrong length marker\");\n    unsigned int nLenR = vchSig[3];\n    if (5 + nLenR >= vchSig.size())\n        return error(\"Non-canonical signature: S length misplaced\");\n    unsigned int nLenS = vchSig[5+nLenR];\n    if ((unsigned long)(nLenR+nLenS+7) != vchSig.size())\n        return error(\"Non-canonical signature: R+S length mismatch\");\n\n    const unsigned char *R = &vchSig[4];\n    if (R[-2] != 0x02)\n        return error(\"Non-canonical signature: R value type mismatch\");\n    if (nLenR == 0)\n        return error(\"Non-canonical signature: R length is zero\");\n    if (R[0] & 0x80)\n        return error(\"Non-canonical signature: R value negative\");\n    if (nLenR > 1 && (R[0] == 0x00) && !(R[1] & 0x80))\n        return error(\"Non-canonical signature: R value excessively padded\");\n\n    const unsigned char *S = &vchSig[6+nLenR];\n    if (S[-2] != 0x02)\n        return error(\"Non-canonical signature: S value type mismatch\");\n    if (nLenS == 0)\n        return error(\"Non-canonical signature: S length is zero\");\n    if (S[0] & 0x80)\n        return error(\"Non-canonical signature: S value negative\");\n    if (nLenS > 1 && (S[0] == 0x00) && !(S[1] & 0x80))\n        return error(\"Non-canonical signature: S value excessively padded\");\n\n    // If the above rules hold, and the S data is 33 bytes (or more), then\n    // the S value is above 2^255, which isn't necessary (its negative\n    // modulo the order of the curve could have been used).\n    if (nLenS > 32)\n        return error(\"Non-canonical signature: S value is unnecessarily high\");\n\n    return true;\n}"
  },
  {
    "function_name": "IsCanonicalPubKey",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "255-268",
    "snippet": "static bool IsCanonicalPubKey(const valtype &vchPubKey) {\n    if (vchPubKey.size() < 33)\n        return error(\"Non-canonical public key: too short\");\n    if (vchPubKey[0] == 0x04) {\n        if (vchPubKey.size() != 65)\n            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n        if (vchPubKey.size() != 33)\n            return error(\"Non-canonical public key: invalid length for compressed key\");\n    } else {\n        return error(\"Non-canonical public key: compressed nor uncompressed\");\n    }\n    return true;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Non-canonical public key: compressed nor uncompressed\""
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "key_error",
          "container": "key_error",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/key.h",
          "lines": "44-44",
          "snippet": "explicit key_error(const std::string& str) : std::runtime_error(str) {}",
          "includes": [
            "#include <openssl/ec.h> // for EC_KEY definition",
            "#include \"util.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\"",
            "#include \"allocators.h\"",
            "#include <vector>",
            "#include <stdexcept>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <openssl/ec.h> // for EC_KEY definition\n#include \"util.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n#include \"allocators.h\"\n#include <vector>\n#include <stdexcept>\n\nkey_error {\n  explicit key_error(const std::string& str) : std::runtime_error(str) {}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vchPubKey.size",
          "args": [],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic bool IsCanonicalPubKey(const valtype &vchPubKey) {\n    if (vchPubKey.size() < 33)\n        return error(\"Non-canonical public key: too short\");\n    if (vchPubKey[0] == 0x04) {\n        if (vchPubKey.size() != 65)\n            return error(\"Non-canonical public key: invalid length for uncompressed key\");\n    } else if (vchPubKey[0] == 0x02 || vchPubKey[0] == 0x03) {\n        if (vchPubKey.size() != 33)\n            return error(\"Non-canonical public key: invalid length for compressed key\");\n    } else {\n        return error(\"Non-canonical public key: compressed nor uncompressed\");\n    }\n    return true;\n}"
  },
  {
    "function_name": "popstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "90-95",
    "snippet": "static inline void popstack(vector<valtype>& stack)\n{\n    if (stack.empty())\n        throw runtime_error(\"popstack() : stack empty\");\n    stack.pop_back();\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stack.pop_back",
          "args": [],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"popstack() : stack empty\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stack.empty",
          "args": [],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "empty",
          "container": "limitedmap",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/limitedmap.h",
          "lines": "32-32",
          "snippet": "bool empty() const { return map.empty(); }",
          "includes": [
            "#include <deque>",
            "#include <map>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <deque>\n#include <map>\n\nlimitedmap {\n  bool empty() const { return map.empty(); }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic inline void popstack(vector<valtype>& stack)\n{\n    if (stack.empty())\n        throw runtime_error(\"popstack() : stack empty\");\n    stack.pop_back();\n}"
  },
  {
    "function_name": "MakeSameSize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "63-80",
    "snippet": "void MakeSameSize(valtype& vch1, valtype& vch2)\n{\n    // Lengthen the shorter one\n    if (vch1.size() < vch2.size())\n        // PATCH:\n        // +unsigned char msb = vch1[vch1.size()-1];\n        // +vch1[vch1.size()-1] &= 0x7f;\n        //  vch1.resize(vch2.size(), 0);\n        // +vch1[vch1.size()-1] = msb;\n        vch1.resize(vch2.size(), 0);\n    if (vch2.size() < vch1.size())\n        // PATCH:\n        // +unsigned char msb = vch2[vch2.size()-1];\n        // +vch2[vch2.size()-1] &= 0x7f;\n        //  vch2.resize(vch1.size(), 0);\n        // +vch2[vch2.size()-1] = msb;\n        vch2.resize(vch1.size(), 0);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vch2.resize",
          "args": [
            "vch1.size()",
            "0"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vch1.size",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "vch1.resize",
          "args": [
            "vch2.size()",
            "0"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nvoid MakeSameSize(valtype& vch1, valtype& vch2)\n{\n    // Lengthen the shorter one\n    if (vch1.size() < vch2.size())\n        // PATCH:\n        // +unsigned char msb = vch1[vch1.size()-1];\n        // +vch1[vch1.size()-1] &= 0x7f;\n        //  vch1.resize(vch2.size(), 0);\n        // +vch1[vch1.size()-1] = msb;\n        vch1.resize(vch2.size(), 0);\n    if (vch2.size() < vch1.size())\n        // PATCH:\n        // +unsigned char msb = vch2[vch2.size()-1];\n        // +vch2[vch2.size()-1] &= 0x7f;\n        //  vch2.resize(vch1.size(), 0);\n        // +vch2[vch2.size()-1] = msb;\n        vch2.resize(vch1.size(), 0);\n}"
  },
  {
    "function_name": "CastToBool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "41-54",
    "snippet": "bool CastToBool(const valtype& vch)\n{\n    for (unsigned int i = 0; i < vch.size(); i++)\n    {\n        if (vch[i] != 0)\n        {\n            // Can be negative zero\n            if (i == vch.size()-1 && vch[i] == 0x80)\n                return false;\n            return true;\n        }\n    }\n    return false;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vch.size",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nbool CastToBool(const valtype& vch)\n{\n    for (unsigned int i = 0; i < vch.size(); i++)\n    {\n        if (vch[i] != 0)\n        {\n            // Can be negative zero\n            if (i == vch.size()-1 && vch[i] == 0x80)\n                return false;\n            return true;\n        }\n    }\n    return false;\n}"
  },
  {
    "function_name": "CastToBigNum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/script.cpp",
    "lines": "33-39",
    "snippet": "CBigNum CastToBigNum(const valtype& vch)\n{\n    if (vch.size() > nMaxNumSize)\n        throw runtime_error(\"CastToBigNum() : overflow\");\n    // Get rid of extra leading zeros\n    return CBigNum(CBigNum(vch).getvch());\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"sync.h\"",
      "#include \"main.h\"",
      "#include \"key.h\"",
      "#include \"bignum.h\"",
      "#include \"keystore.h\"",
      "#include \"script.h\"",
      "#include <boost/tuple/tuple_comparison.hpp>",
      "#include <boost/tuple/tuple.hpp>",
      "#include <boost/foreach.hpp>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const size_t nMaxNumSize = 4;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [
            "CBigNum(vch).getvch()"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "gcd",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "515-521",
          "snippet": "CBigNum gcd( const CBigNum& b) const{\n        CAutoBN_CTX pctx;\n        CBigNum ret;\n        if (!BN_gcd(&ret, this, &b, pctx))\n            throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n        return ret;\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  CBigNum gcd( const CBigNum& b) const{\n          CAutoBN_CTX pctx;\n          CBigNum ret;\n          if (!BN_gcd(&ret, this, &b, pctx))\n              throw bignum_error(\"CBigNum::gcd*= :BN_gcd\");\n          return ret;\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "CBigNum",
          "args": [],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "isOne",
          "container": "CBigNum",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/bignum.h",
          "lines": "538-540",
          "snippet": "bool isOne() const {\n        return BN_is_one(this);\n    }",
          "includes": [
            "#include <stdint.h>",
            "#include <vector>",
            "#include <stdexcept>",
            "#include <openssl/bn.h>",
            "#include \"version.h\"",
            "#include \"uint256.h\"",
            "#include \"serialize.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdint.h>\n#include <vector>\n#include <stdexcept>\n#include <openssl/bn.h>\n#include \"version.h\"\n#include \"uint256.h\"\n#include \"serialize.h\"\n\nCBigNum {\n  bool isOne() const {\n          return BN_is_one(this);\n      }\n}"
        }
      },
      {
        "call_info": {
          "callee": "runtime_error",
          "args": [
            "\"CastToBigNum() : overflow\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vch.size",
          "args": [],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "size",
          "container": "base_uint",
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2021-4300/repo/src/uint256.h",
          "lines": "354-357",
          "snippet": "unsigned int size()\n    {\n        return sizeof(pn);\n    }",
          "includes": [
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <vector>",
            "#include <string>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <vector>\n#include <string>\n\nbase_uint {\n  unsigned int size()\n      {\n          return sizeof(pn);\n      }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"sync.h\"\n#include \"main.h\"\n#include \"key.h\"\n#include \"bignum.h\"\n#include \"keystore.h\"\n#include \"script.h\"\n#include <boost/tuple/tuple_comparison.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/foreach.hpp>\n\nstatic const size_t nMaxNumSize = 4;\n\nCBigNum CastToBigNum(const valtype& vch)\n{\n    if (vch.size() > nMaxNumSize)\n        throw runtime_error(\"CastToBigNum() : overflow\");\n    // Get rid of extra leading zeros\n    return CBigNum(CBigNum(vch).getvch());\n}"
  }
]